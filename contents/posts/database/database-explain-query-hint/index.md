---
title: "실행 계획과 쿼리 최적화"
date: 2025-01-16 18:00:00
tags: 
  - Database
  - Index
---

## 랜덤 I/O와 순차 I/O
- 랜덤 I/O는 임의의 위치에 있는 데이터를 읽거나 쓰는 입출력 작업이다.
- 순차 I/O는 연속적인 순서대로 데이터를 읽거나 쓰는 입출력 작업이다.

HDD에서 랜덤 I/O는 순차 I/O에 비해 헤더의 움직임이 많기 때문에 느립니다. 이는 SSD에서도 마찬가지입니다.

## 인덱스
- 인덱스는 컬럼의 값과 레코드의 주소를 Key-Value 삼아놓은 정보이다.
- 데이터베이스는 인덱스를 통해 빠르게 레코드를 조회할 수 있다. 
- 빠른 조회를 위해 인덱스는 항상 정렬되어 있다는 특징이 있는데, 이 때문에 레코드의 삽입/수정/삭제 성능이 희생된다는 단점이 있다.

## 인덱스의 동작 방식
B Tree 인덱스 기준으로 설명 드리겠습니다.
사용자 요청으로 들어온 select 쿼리의 where에 인덱스가 걸린 컬럼이 조건으로 들어있다면,
컬럼 값에 해당하는 레코드를 찾기위해 B Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 해당하는 리프 노드를 찾습니다.
그 다음 리프 노드에 있는 레코드의 실제 주소값을 따라 데이터 파일에서 레코드를 조회해옵니다. 
어떤 기준으로 인덱스를 설정해야할까요?
검색 조건에 주로 사용되고 카디널리티가 높은 컬럼을 인덱스로 설정하면 좋습니다.
카디널리티는 인덱스에 해당하는 컬럼 기준으로 테이블에서 유일한 레코드 개수를 의미합니다.
카디널리티가 높을 컬럼에 인덱스를 걸면 그만큼 검색 대상이 줄어들기 때문에 빠르게 레코드에 접근할 수 있습니다.

## 테이블에 인덱스를 많이 설정하면 좋을까?

  **인덱스를 많이 설정하면 좋지 않습니다.**

  **인덱스 자체를 저장하는 공간이 필요하기도 하고,**

  **인덱스는 빠른 검색을 위해 항상 정렬된 상태를 유지해야하므로,**

  **인덱스가 많아진다면 데이터 삽입, 수정, 삭제 성능이 저하될 우려가 있습니다.**

  **따라서 인덱스를 추가할때는 데이터의 삽입,수정,삭제 성능을 얼마나 희생하고,**

  **읽기 성능은 얼마나 빠르게 해야할지 고민하고 결정해야합니다.**

- 커버링 인덱스(Covering index)

  **쿼리 조회 결과가 인덱스에 해당하는 컬럼 값으로만 이루어진 것을 커버링 인덱스라고 합니다.**

  **커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 그만큼 랜덤 엑세스가 줄어들고 성능은 빨라집니다.**

- 다중 컬럼 인덱스(Multi-column index, 복합 인덱스)

  **다중 컬럼 인덱스는 2개 이상의 컬럼으로 이루어진 인덱스입니다.**

  **2개의 컬럼으로 이루어진 인덱스가 있을때,**

  **인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다는 특징이 있다는 것을 고려해서 사용해야합니다.**

- B-Tree 인덱스와 B+Tree 인덱스

  **B-Tree와 B+Tree는 둘다 Balanced Tree 자료구조로 구현된 인덱스 저장 방식입니다.**

  **B-Tree와 달리 B+Tree는 리프 노드에만 값을 담아 놓는다는 특징이 있습니다.**

- Hash 인덱스

  **Hash 인덱스는 컬럼의 값으로 해시값을 계산해서 인덱스로 사용하는 알고리즘 입니다.**
  **매우 빠른 검색을 지원하지만 값을 변형해서 인덱스로 사용하므로 prefix 일치 검색 또는 범위 검색에서는 사용될 수 없다는 단점이 있습니다.**

- 클러스터링 인덱스

  **클러스터링 인덱스 기본키가 비슷한 레코드끼리 묶어서 인접한 물리적 위치에 저장하는 것을 뜻합니다.**
  **주로 비슷한 값들을 동시에 조회하는 경우가 많은데, 이에 착안해서 생긴 레코드 저장 방식입니다.**
  **클러스터링 인덱스로 저장되는 테이블은 기본키 기반 검색이 매우 빠릅니다.**
  **MySQL의 innoDB 엔진은 기본적으로 클러스터링 인덱스로 저장됩니다.**

- 인덱스 스캔 방식

  **B Tree 기준으로 인덱스 레인지 스캔과 인덱스 풀 스캔에 대해 설명해주세요.**
  **인덱스 레인지 스캔은 검색 해야할 인덱스의 범위가 결정 됐을때 사용하는 방식입니다.**
  **루트 노드, 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾고,**
  **리프 노드간의 링크를 통해 검색 종료점 리프 노드까지 스캔하면서 레코드를 랜덤 엑세스로 읽어 들입니다.**
  **인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 스캔하는 방식입니다.**
  **예를들어 a,b,c 컬럼에 복합 인덱스가 걸려있고 쿼리의 조건절에는 b 또는 c 컬럼이 들어가 있을 경우 인덱스 풀 스캔이 발생합니다. 테이블 풀 스캔보다는 효율적입니다.**

- 쿼리 실행 계획에 대해서 설명해주세요. 실행 계획을 확인해본적이 있나요?

  **실행 계획은 옵티마이저가 SQL을 어떻게 실행할지에 대한 계획입니다.**
  **옵티마이저는 SQL을 효율적으로 실행하기 위해,**
  **SQL의 비용을 고려하거나 규칙 기반으로 실행계획을 생성하여 SQL을 실행 시킵니다.**
  **EXPLAIN 키워드를 통해 사용자가 직접 쿼리에 대한 실행 계획을 확인할 수 있습니다.**

- 쿼리 힌트

  **쿼리 힌트(Query Hint)는 데이터베이스 옵티마이저에게 특정 실행 계획을 사용하도록 지시하는 역할을 합니다. 힌트를 사용하여 옵티마이저가 쿼리를 처리하는 방식을 직접 제어할 수 있습니다. 힌트는 주로 성능 최적화나 예상치 못한 실행 계획을 수정하고자 할 때 사용됩니다.**

- 인덱스가 잘 동작하고 있는지 어떻게 확인하는 방법

  **쿼리에 대한 실행 계획을 보면서 인덱스가 어떻게 걸리는지 확인하고 실제로 쿼리를 날려봐서 조회 속도를 측정해 봅니다.**
  **또는 select * from sys.schema_unused_indexes 쿼리를 날려서 사용되지 않는 인덱스가 있는지 확인합니다.**

- 인덱스 사용시 주의해야할 점

  **인덱스 키 값이 너무 길어지게 하지 않습니다.**
  **인덱스 키 값이 길어지면 인덱스 정보들을 담고 있는 페이지 개수가 많아집니다.**
  **이는 디스크로부터 페이지를 읽어야 하는 횟수가 늘어나는 걸 뜻하고,**
  **랜덤 엑세스 횟수가 증가하는 것을 뜻하기 때문에 조회 속도가 느려지는 결과를 가져올 수 있습니다.**

- GROUP BY 사용시 인덱스가 걸리는 조건

  **GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 같아야한다.**
  **예를들어 복합 인덱스 (a,b,c)는 group by (a,b,c) 했을때 걸립니다.**
  **또는 group by (a) 또는 group by (a,b) 했을때 걸립니다.**