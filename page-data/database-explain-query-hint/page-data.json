{"componentChunkName":"component---src-templates-post-jsx","path":"/database-explain-query-hint/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","excerpt":"데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다.\n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다. 인덱스 스캔 방식 인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은…","html":"<p>데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다.\n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다.</p>\n<h3 id=\"인덱스-스캔-방식\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"인덱스 스캔 방식 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 스캔 방식</h3>\n<p>인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은 MySQL을 기준으로 설명하였다).</p>\n<h4 id=\"인덱스-레인지-스캔Index-Range-Scan\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%A0%88%EC%9D%B8%EC%A7%80-%EC%8A%A4%EC%BA%94Index-Range-Scan\" aria-label=\"인덱스 레인지 스캔Index Range Scan permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 레인지 스캔(Index Range Scan)</h4>\n<p>인덱스 레인지 스캔은 특정 범위 내의 데이터를 검색할 때 사용된다.\n이는 일반적으로 <code class=\"language-text\">WHERE</code> 절에 <code class=\"language-text\">BETWEEN</code>, <code class=\"language-text\">IN</code>, <code class=\"language-text\">></code>, <code class=\"language-text\">&lt;</code> 등의 연산자가 사용될 때 발생한다.\nMySQL은 루트 노드에서 시작하여 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾은 후,\n리프 노드 간의 링크를 따라 검색 종료점 리프 노드 까지 데이터를 스캔한다.\n이때 레코드를 랜덤 엑세스로 읽어 들이게 된다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 레인지 스캔이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> age <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">20</span> <span class=\"token operator\">AND</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 쿼리는 <code class=\"language-text\">users</code> 테이블에서 <code class=\"language-text\">age</code> 컬럼에 인덱스가 걸려 있다면, 해당 범위 내의 데이터를 효율적으로 검색할 수 있다.</p>\n<h4 id=\"인덱스-풀-스캔Index-Full-Scan\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%92%80-%EC%8A%A4%EC%BA%94Index-Full-Scan\" aria-label=\"인덱스 풀 스캔Index Full Scan permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 풀 스캔(Index Full Scan)</h4>\n<p>인덱스 풀 스캔은 인덱스의 처음부터 끝까지 전체를 스캔하는 방식이다.\n이는 <code class=\"language-text\">WHERE</code> 절에 조건에서 인덱스의 특정 순서를 활용할 필요가 없거나, 범위가 명확하지 않은 조건에서 발생한다.\n인덱스 풀 스캔은 레인지 스캔에 비해 더 많은 블록을 읽어야 하기 때문에, 레인지 스캔보다 느릴 수 있다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 풀 스캔이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'developer'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">users</code> 테이블에서 <code class=\"language-text\">job</code> 컬럼에 인덱스가 존재하지만, 검색 조건이 인덱스의 순서를 활용하지 못하는 경우, 인덱스 풀 스캔이 발생한다.</p>\n<h2 id=\"인덱스-설계\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%84%A4%EA%B3%84\" aria-label=\"인덱스 설계 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 설계</h2>\n<p>인덱스의 스캔 방식과에 대해 알아봤다면, 이젠 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.</p>\n<h3 id=\"효율적인-인덱스-설계\" style=\"position:relative;\"><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%84%A4%EA%B3%84\" aria-label=\"효율적인 인덱스 설계 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>효율적인 인덱스 설계</h3>\n<p>다음은 효율적인 인덱스 설계를 위한 몇 가지 팁이다.</p>\n<ul>\n<li><code class=\"language-text\">WHERE</code> 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.</li>\n<li><code class=\"language-text\">SELECT</code> 절에 자주 사용되는 컬럼들을 조합해서 인덱스로 만들어 커버링 인덱스를 사용하는 것이 좋다.</li>\n<li><code class=\"language-text\">JOIN</code> 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.</li>\n<li><code class=\"language-text\">ORDER</code> BY 절에 자주 사용되는 컬럼에 클러스터형 인덱스를 사용하는 것이 좋다.</li>\n</ul>\n<h3 id=\"지양해야할-인덱스-설계\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%96%91%ED%95%B4%EC%95%BC%ED%95%A0-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%84%A4%EA%B3%84\" aria-label=\"지양해야할 인덱스 설계 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>지양해야할 인덱스 설계</h3>\n<p>다음은 지양해야할 인덱스 설계를 위한 몇 가지 팁이다.</p>\n<ul>\n<li>대용량 데이터가 자주 입력되는 경우 클러스터형 인덱스의 페이징이 빈번하게 발생해 시스템에 부하가 걸릴 수 있다. 때문에 클러스터 대신 세컨더리 인덱스를 사용하는 것이 좋을 수 있다.</li>\n<li>데이터 중복도가 높은 컬럼에 인덱싱을 하는 것은 효율적이지 않다. 중복도가 높은 컬럼에 인덱싱을 하게 되면 인덱스의 크기가 커지고, 인덱스를 탐색하는데 시간이 오래걸릴 수 있다.</li>\n<li>인덱스를 많이 사용하게 되면 인덱스를 관리하는데 시간이 오래걸리게 되고, 인덱스의 크기가 커지게 된다. 때문에 인덱스를 많이 사용하는 것은 지양해야한다.</li>\n<li>자주 사용되지 않는 컬럼에 인덱싱을 하는 것은 효율적이지 않다.</li>\n</ul>\n<h2 id=\"인덱스-스캔-방식-1\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94-%EB%B0%A9%EC%8B%9D-1\" aria-label=\"인덱스 스캔 방식 1 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 스캔 방식</h2>\n<p>인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다. 인덱스 스캔 방식에는 여러가지가 있는데, 그 중에서 대표적인 방식은 다음과 같다.\nB Tree 기준으로 설명하자면, 인덱스 레인지 스캔은 검색 해야할 인덱스의 범위가 결정 됐을때 사용하는 방식이다.\n루트 노드, 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾고,\n리프 노드간의 링크를 통해 검색 종료점 리프 노드까지 스캔하면서 레코드를 랜덤 엑세스로 읽어 들인다.\n인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 스캔하는 방식이다.\n예를들어 a,b,c 컬럼에 복합 인덱스가 걸려있고 쿼리의 조건절에는 b 또는 c 컬럼이 들어가 있을 경우 인덱스 풀 스캔이 발생한다.\n테이블 풀 스캔보다는 효율적이다.</p>\n<h2 id=\"쿼리-실행-계획\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D\" aria-label=\"쿼리 실행 계획 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>쿼리 실행 계획</h2>\n<p>쿼리 실행 계획(Query Plan)은 데이터베이스 관리 시스템(DBMS)이 SQL 쿼리를 처리하기 위해 사용하는 실행 계획이다.\n이것은 DBMS에서 쿼리를 처리할 때 데이터베이스에서 데이터를 검색하고 가져오는 방법을 결정하는데 사용된다.\n쿼리 실행에 필요한 단계를 보여주며, 각 단계에서 DBMS가 사용하는 액세스 경로를 보여주고, 쿼리 실행에 필요한 리소스 및 비용 정보를 제공한다.\n즉, SQL을 실행하는데 있어 사용되는 cost와 어떠한 방식이 가장 적절한지 판단하고, 올바른 플랜 중 평가하여 어떠한 순서와 방식으로 처리할 것인지 계획을 세우고 필요에 따라 변경하여 성능을 개선하는데 사용된다.\n이를 통해 DBMS는 쿼리 실행에 필요한 최소한의 리소스를 사용하면서 최적의 성능을 제공할 수 있다.</p>\n<h3 id=\"쿼리-실행-계획-확인-방법\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D-%ED%99%95%EC%9D%B8-%EB%B0%A9%EB%B2%95\" aria-label=\"쿼리 실행 계획 확인 방법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>쿼리 실행 계획 확인 방법</h3>\n<p>쿼리 실행 계획을 확인하는 방법은 DBMS마다 다르지만, 대부분의 DBMS에서는 <code class=\"language-text\">EXPLAIN</code> 명령어를 사용하여 확인할 수 있다.\n<code class=\"language-text\">EXPLAIN</code> 명령어는 쿼리 실행 계획을 확인하는 명령어로, 쿼리를 실행하기 전에 어떠한 방식으로 실행할지에 대한 정보를 제공한다.\n예를 들어, MySQL에서는 다음과 같이 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> age <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">20</span> <span class=\"token operator\">AND</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 쿼리를 실행하면, 해당 쿼리의 실행 계획을 확인할 수 있다.</p>\n<h3 id=\"쿼리-실행-계획-확인-방법-1\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D-%ED%99%95%EC%9D%B8-%EB%B0%A9%EB%B2%95-1\" aria-label=\"쿼리 실행 계획 확인 방법 1 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>쿼리 실행 계획 확인 방법</h3>\n<p>이러한 쿼리 실행 계획은 옵티마이저가 사용하게 되는데 이때 예상치 못한 문제가 발생할 수 있다.\n이러한 문제를 해결하기 위해 쿼리 힌트를 사용할 수 있다.\n쿼리 힌트는 옵티마이저가 쿼리를 처리하는 방식을 제어하는 방법으로, 쿼리에 힌트를 추가하여 옵티마이저가 쿼리를 처리하는 방식을 변경할 수 있다.</p>\n<h2 id=\"인덱스-동작-확인-방법\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%8F%99%EC%9E%91-%ED%99%95%EC%9D%B8-%EB%B0%A9%EB%B2%95\" aria-label=\"인덱스 동작 확인 방법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 동작 확인 방법</h2>\n<p>인덱스 동작을 확인하는 방법은 쿼리에 대한 실행 계획을 보면서 인덱스가 어떻게 걸리는지 확인하여 실제 조회 시 속도와 성능을 확인할 수 있다.\n하지만 가끔씩 인덱스가 제대로 동작하지 않는 경우가 있을 수 있다.\n이런 경우에는 <code class=\"language-text\">sys.shema_unused_indexes</code>를 사용해 인덱스 동작 여부를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>  <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> sys<span class=\"token punctuation\">.</span>shema_unused_indexes<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 사용되지 않는 인덱스를 확인하고, 필요한 인덱스를 추가하거나 사용되지 않는 인덱스를 삭제하여 성능을 향상시킬 수 있다.</p>\n<h2 id=\"ORDER-BY-와-GROUP-BY에-대한-인덱스\" style=\"position:relative;\"><a href=\"#ORDER-BY-%EC%99%80-GROUP-BY%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"ORDER BY 와 GROUP BY에 대한 인덱스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>ORDER BY 와 GROUP BY에 대한 인덱스</h2>\n<p>인덱스는 WHERE 절에 사용되는 컬럼에 대해서만 동작하는 것이 아니라, ORDER BY와 GROUP BY에도 영향을 줄 수 있다.\n하지만 조건이 있는데 GROUP BY 기준으로 예를 들자면, 복합인덱스를 사용한다고 가정했을 때 GROUP BY (복합인덱스 컬럼들)로 사용해야 인덱스가 동작한다.\nORDER BY의 경우에는 인덱스의 정렬 방식과 일치해야 인덱스가 동작한다.</p>\n<blockquote>\n<p>커버링 인덱스 : 쿼리 조회 결과가 인덱스에 해당하는 컬럼 값으로만 이루어진 것을 커버링 인덱스라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 그만큼 랜덤 엑세스가 줄어들고 성능은 빨라진다.<br>\n다중 컬럼 인덱스 : 다중 컬럼 인덱스는 2개 이상의 컬럼으로 이루어진 인덱스다. 2개의 컬럼으로 이루어진 인덱스가 있을때, 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다는 특징이 있다는 것을 고려해서 사용해야한다.</p>\n</blockquote>","frontmatter":{"title":"실행 계획과 쿼리 최적화","date":"January 16, 2025","update":null,"tags":["Database","Index"],"series":null},"fields":{"slug":"/database-explain-query-hint/","readingTime":{"minutes":12.035}}},"seriesList":{"edges":[{"node":{"id":"af6c0192-819a-5110-957c-643bdd4721be","fields":{"slug":"/nginx-config/"},"frontmatter":{"title":"Nginx 설정하기 전에 보면 좋은 글"}}},{"node":{"id":"07aa966e-666d-563f-85c8-b3b4ad26865d","fields":{"slug":"/git-conventions/"},"frontmatter":{"title":"협업을 위한 Git 컨벤션"}}},{"node":{"id":"e4531ca2-2ac9-531b-9164-8b64c75e5a19","fields":{"slug":"/interview/"},"frontmatter":{"title":"면접관 사로잡기"}}},{"node":{"id":"61bcd7ea-d1d1-5f31-918d-791f3c09c94f","fields":{"slug":"/linking-pr-to-issue/"},"frontmatter":{"title":"Nginx 설정하기 전에 보면 좋은 글"}}},{"node":{"id":"cb4fcc1e-9deb-586d-8c9a-6d51d726aa2e","fields":{"slug":"/spring-data-jpa-paging/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"7fed17e5-3250-5f81-b864-7f719203a651","fields":{"slug":"/database-ssd-faster-than-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"97279d93-b018-5291-a7f8-154ab9af9e06","fields":{"slug":"/database-transaction/"},"frontmatter":{"title":"DBMS는 트랜잭션을 어떻게 관리할까?"}}},{"node":{"id":"556e4443-760f-5c0e-9d3f-56bce92db6bf","fields":{"slug":"/database-isolation-level/"},"frontmatter":{"title":"트랜잭션의 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"6bb66c2b-026f-566d-84fb-df3ce4dbec95","fields":{"slug":"/boj-17825/"},"frontmatter":{"title":"17825 주사위 윳놀이"}}},{"node":{"id":"0e31350d-6754-56b2-85a5-d739d57c38af","fields":{"slug":"/jscode-study-memoir/"},"frontmatter":{"title":"JSCODE 스터디 되돌아보기"}}},{"node":{"id":"a69e3d86-fa3b-5b23-a46b-27ca07dc31cc","fields":{"slug":"/boj-1325/"},"frontmatter":{"title":"1325 효율적인 해킹"}}},{"node":{"id":"07d0b3a0-20f5-5418-87e3-6e5eff4cbd0a","fields":{"slug":"/boj-1018/"},"frontmatter":{"title":"1018 체스판 다시 칠하기"}}},{"node":{"id":"9dde491d-5904-5c61-84e7-7943094943bd","fields":{"slug":"/boj-1051/"},"frontmatter":{"title":"1051 숫자 정사각형"}}},{"node":{"id":"a563c631-3d22-5595-9063-749fc5553ad3","fields":{"slug":"/boj-2529/"},"frontmatter":{"title":"2529 부등호"}}},{"node":{"id":"b9ebae0f-eb1d-5b1e-890b-1af660585100","fields":{"slug":"/boj-2615/"},"frontmatter":{"title":"2615 오목"}}},{"node":{"id":"c91b8fbb-756d-569e-867a-b441a01f7af8","fields":{"slug":"/boj-15686/"},"frontmatter":{"title":"15686 치킨 배달"}}},{"node":{"id":"c8a562b7-c6eb-5d5f-a167-29ea98d2d2c7","fields":{"slug":"/boj-9663/"},"frontmatter":{"title":"9663 N-Queen"}}},{"node":{"id":"b7249a5d-d62e-511f-a47b-4cae4c5d4a76","fields":{"slug":"/boj-27961/"},"frontmatter":{"title":"27961 고양이는 많을수록 좋다"}}},{"node":{"id":"830ecb3c-ea0c-5b32-932c-b78dea1fd7e6","fields":{"slug":"/prog-42839/"},"frontmatter":{"title":"42839 소수찾기"}}},{"node":{"id":"c14454eb-539e-5270-b82d-a5e74d5846e3","fields":{"slug":"/boj-11399/"},"frontmatter":{"title":"17503 맥주 축제"}}},{"node":{"id":"db022464-1f93-5ca3-b1ef-3ef7a0e53568","fields":{"slug":"/boj-1946/"},"frontmatter":{"title":"1946 신입 사원"}}},{"node":{"id":"442747fb-c36d-5ebf-b571-fc25a484ea56","fields":{"slug":"/boj-19598/"},"frontmatter":{"title":"19598 최소 회의실 개수"}}},{"node":{"id":"d1de5bbb-2949-5108-a4e8-29b57fb29120","fields":{"slug":"/boj-1003/"},"frontmatter":{"title":"1003 피보나치 함수"}}},{"node":{"id":"f66f88d3-87df-5f27-aa94-26a50d7330e8","fields":{"slug":"/boj-2212/"},"frontmatter":{"title":"2212 센서"}}},{"node":{"id":"bdb20dae-34ac-5a09-893c-74ae7b30c8fc","fields":{"slug":"/boj-11053/"},"frontmatter":{"title":"11053 가장 긴 증가하는 부분 수열"}}},{"node":{"id":"0e7377eb-09a1-531d-a44f-08c0014c411f","fields":{"slug":"/boj-9251/"},"frontmatter":{"title":"9251 LCS"}}},{"node":{"id":"9df5e584-f2a1-52e7-99a1-54cfcf2b8d98","fields":{"slug":"/boj-2225/"},"frontmatter":{"title":"2225 합분해"}}},{"node":{"id":"5ed27546-4130-51d0-a15c-fd9346bc5a0a","fields":{"slug":"/boj-1351/"},"frontmatter":{"title":"1351 무한 수열"}}},{"node":{"id":"63ced38b-1e3d-57de-b03b-906629d93cf3","fields":{"slug":"/enablewebmvc-jackson/"},"frontmatter":{"title":"@EnableWebMvc 사용해도 될까?"}}},{"node":{"id":"fe87df1d-0330-5345-8fc9-6fe633d3dee1","fields":{"slug":"/annotation-modifying-with-transactional/"},"frontmatter":{"title":"@Query와 @Modifying만 사용하면 될까?"}}},{"node":{"id":"5204b390-54c4-5a3d-898b-8dbe85eeec62","fields":{"slug":"/static-resources-attack/"},"frontmatter":{"title":"디렉토리 스캔 공격은 어떻게 대응해야 할까?"}}},{"node":{"id":"f4903cfa-9ebd-5f61-8c70-9f15d1fd5e15","fields":{"slug":"/ec2-cron-alert/"},"frontmatter":{"title":"서버 장애를 미리 예측할 수 있을까?"}}},{"node":{"id":"187c27c2-6ef1-560d-8127-7173cc083d5c","fields":{"slug":"/fail2ban-alert/"},"frontmatter":{"title":"Fail2Ban이 일 잘하고 있는 걸까?"}}},{"node":{"id":"a6191ffd-2529-5df8-984b-8fda6c70c299","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"서버 모니터링"}}},{"node":{"id":"ebf552bc-59ea-5969-b86b-bad95404ee87","fields":{"slug":"/ssl-protocol/"},"frontmatter":{"title":"Nginx 설정하기 전에 보면 좋은 글"}}},{"node":{"id":"4a640eb1-312c-5046-a330-010c52c6c644","fields":{"slug":"/bastion-host/"},"frontmatter":{"title":"서버 장애를 미리 예측할 수 있을까?"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"focus and hustle"}}}]},"previous":{"fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}},"next":{"fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},"pageContext":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","series":null,"previousPostId":"c553b71b-99ee-54e4-99c1-28158b54878a","nextPostId":"879a45c4-b438-5e30-b986-6a4fbcf179c3"}},"staticQueryHashes":[],"slicesMap":{}}