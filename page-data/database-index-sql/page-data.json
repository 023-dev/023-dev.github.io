{"componentChunkName":"component---src-templates-post-jsx","path":"/database-index-sql/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","excerpt":"DBMS에는 저장되어 있는 데이터를 효율적으로 검색할 수 있게 해주는 인덱스가 있다.\n우리가 보통 애플리케이션의 백엔드 성능을 높이려고 종종 실행하는 SQL 튜닝은 이 인덱스를 SQL이 DBMS에서 최대한 활용할 수 있도록 SQL을 수정하는 것이라고 할 수 있다.\n그러니 인덱스에 대해 잘 이해하고 있다면 더 효율적인 SQL을 작성할 수 있을 것이고, 훨씬…","html":"<p>DBMS에는 저장되어 있는 데이터를 효율적으로 검색할 수 있게 해주는 인덱스가 있다.\n우리가 보통 애플리케이션의 백엔드 성능을 높이려고 종종 실행하는 SQL 튜닝은 이 인덱스를 SQL이 DBMS에서 최대한 활용할 수 있도록 SQL을 수정하는 것이라고 할 수 있다.\n그러니 인덱스에 대해 잘 이해하고 있다면 더 효율적인 SQL을 작성할 수 있을 것이고, 훨씬 더 성능 좋은 애플리케이션을 만들 수 있을 것이다.\n그래서 이 글에서는 MySQL 8.0에 적용된 인덱스 기법을 중심으로 인덱스 구조와 인덱스 활용 기법을 살펴보겠다.</p>\n<h2 id=\"인덱스-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스 구조 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 구조</h2>\n<p>MySQL 뿐만 아니라 거의 모든 DBMS는 B-Tree 계열 인덱스를 사용한다.\n인덱스 종류에 대한 특별한 언급이 없다면 아마도 B-Tree 계열 인덱스를 의미하는 것으로 봐도 무방할 정도이다.\nB-tree에서 변형된 B+-Tree도 있는데, 일반적인 B-Tree와 달리 데이터 포인터를 리프(Leaf) 노드에만 저장한다.\n리프 노드의 상위 레벨인 비리프(Non-Leaf) 노드는 전형적인 B-Tree 로 구성되며 리프 노드를 빠르게 찾는 인덱스 역할을 한다. 리\n프 노드에는 키와 키에 대응하는 데이터의 포인터가 저장되어 있다. 다음 그림은 전형적인 B+-Tree 모습이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/a3bdb6bc62745f77b1716eae485c0f9e/3643c/img_11.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVR42nWTia6CQAxF+f8fRNEoihugAi4ooPblNLkEl9ekmaHT3ra3JXg8HlbXtT2fT5Ocz2fb7/eW57mfWZZZURS22+16++FwMGI/Jbherzafz41TUlWVpWlqm83GkiRxBWgymbjver12cABfr9c7oP0QsgNAEqonARVeLhe38Q1g0zTfFdJq27aeDWeACCQzb+jtdvOKEVVFzPF49ERd17nyFigjPNES7eFUlqVzyblcLm2xWLjP6XTyDnjjezweewwY+AZUwyN8EcSpzNhxhDeCaFMD46Rq7MT1gJRJS3BFG9xRtXG/392Ococ37JyKwU4Mtp9DUYDAuA9P2T8n7EOhZfaKbBJK32633hrKHR/o0DdK4i9AskEywENA+IEXhgAYvALGN8OAz+HP8O8ekpVgSFfbbAJJ1S6Kz/Bn6AHFg5xGo5GDISKeCuM4Nm2EEq9Wq96uantA2mD8+n8JBHw2m1kYhjadTnteeYuiyPeWHdVyvwFqvwCGO0QD01DgFX4RKpc/nanCP/IyNUwQztsQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='B tree and B+ tree in DB' title='' src='/static/a3bdb6bc62745f77b1716eae485c0f9e/ca1dc/img_11.png' srcset='/static/a3bdb6bc62745f77b1716eae485c0f9e/e7570/img_11.png 170w,\n/static/a3bdb6bc62745f77b1716eae485c0f9e/f46e7/img_11.png 340w,\n/static/a3bdb6bc62745f77b1716eae485c0f9e/ca1dc/img_11.png 680w,\n/static/a3bdb6bc62745f77b1716eae485c0f9e/02d09/img_11.png 1020w,\n/static/a3bdb6bc62745f77b1716eae485c0f9e/9d567/img_11.png 1360w,\n/static/a3bdb6bc62745f77b1716eae485c0f9e/3643c/img_11.png 1400w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>B tree and B+ tree in DB</figcaption>\n  </figure></p>\n<h2 id=\"인덱스-스캔\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94\" aria-label=\"인덱스 스캔 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 스캔</h2>\n<p>B+-Tree의 리프 노드는 링크드 리스트(linked list)로 서로 연결되어 있고, 저장된 키는 정렬되어 있어서 순차 처리가 용이하다.\n그렇기 때문에 범위를 검색하는 데 유리하다.\n테이블에서는 처음부터 끝까지 모든 레코드를 읽어야 완전한 결과 집합을 얻을 수 있지만, 인덱스는 키-칼럼 순으로 정렬되어 있기 때문에 특정 위치에서 검색을 시작해서 검색 조건이 일치하지 않는 값을 만나는 순간 검색을 멈출 수 있다.\n이것을 인덱스 범위 스캔(Index Range Scan)이라고 한다.\nMySQL(InnoDB)는 범위 스캔을 B+-Tree 검색의 기본 연산으로 제공하고 있다. 범위 스캔에는 두 개의 키가 필요한데, 범위의 양 끝을 표현하는 하위 키(Lower Key)와 상위 키(Upper Key)가 그것이다.\n인덱스 범위 스캔은 다음 그림과 같이 두 단계로 진행된다.\n첫 번째 단계에서는 루트에서부터 트리를 순회하여 리프 노드에서 하위 키를 찾는다. 두 번째 단계에서는 첫 번째 단계에서 찾은 키에서부터 상위 키까지 순차적으로 레코드를 읽어 처리한다.\n상위 키가 현재 노드에서 발견되지 않으면 다음 노드를 읽어 상위 키를 가진 노드까지 검색을 계속해 나간다. 상위 키까지 순차 검색이 끝나면 전체 범위 검색이 완료된다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 509px; '>\n      <a class='gatsby-resp-image-link' href='/static/eb68eaefaad43393ec0f5f21c0941fad/98235/img_7.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 26.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSklEQVR42m2OwUvCcBTHZ3XJOkT/UfRvdJN2EDqMnTrETp1C6jo6SCNEJHJucyOnze3HxnQRVLqfznRbhEhkRadK2K/fDCWoB4/3fbzv+7xHEL8CIZQoFNBiXOOeYdnkCW9sC7myKxku5CSTpOmDlZlX07QlLBPEn8BDbJiDSIZNckU9VbLuoQkgAg0/At57ZHbekAC8TgxOp5nV/54gGIZZmDUURS1nS1aKNyDU8XJFb0dVpTFRb58m6vXjpILTaI8jAF9/wCVAbtH0/OOYNYUeZotrObmxI5o93wk+keN/RPWbEapXHKS7L0hrj6dVxyDNxbr1jJrYcxV+IcnqhaeyQ2UyhfUpbHf/aJMTLYk3OqOy7Qci8CBv+13lON+v5eVBTbsbiGfVUFXs8PLCeVDPa0MBdHv4uCtZ/VbZDnzB9IY5xRH2MuzGN3Km71ohueZ8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='인덱스 범위 스캔' title='' src='/static/eb68eaefaad43393ec0f5f21c0941fad/98235/img_7.png' srcset='/static/eb68eaefaad43393ec0f5f21c0941fad/e7570/img_7.png 170w,\n/static/eb68eaefaad43393ec0f5f21c0941fad/f46e7/img_7.png 340w,\n/static/eb68eaefaad43393ec0f5f21c0941fad/98235/img_7.png 509w' sizes='(max-width: 509px) 100vw, 509px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>인덱스 범위 스캔</figcaption>\n  </figure></p>\n<p>두 번째 단계에서 상위 키까지 찾아가는 과정은 레코드에서 키를 읽어와 상위 키와 비교하는 과정의 연속이다.\n상위 키가 최대 키이면 현재 노드의 키부터 마지막 노드까지 모두 검색 결과에 포함되기 때문에 비교 연산을 할 필요가 없어져서 검색의 성능이 좋아진다.\n검색 성능을 위해 옵티마이저는 입력된 쿼리를 재작성(rewrite)하며, MySQL은 특정 키를 찾는 검색도 범위 검색으로 변환하여 수행한다.\n특정 키를 찾는 검색을 범위 검색으로 변환할 때에는 하위 키와 상위 키 모두를 찾으려는 키로 동일하게 설정한다.</p>\n<h2 id=\"인덱스-스캔을-이용한-질의-처리-과정\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A7%88%EC%9D%98-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95\" aria-label=\"인덱스 스캔을 이용한 질의 처리 과정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 스캔을 이용한 질의 처리 과정</h2>\n<p>다음 그림은 MySQL에서 아래의 SQL 질의로 테이블과 인덱스를 생성하고 데이터를 입력했을 때 인덱스 리프 노드와 테이블 데이터의 관계를 나타낸 그림이다. 왼쪽 인덱스 리프 노드에는 인덱스 키와 키에 대응되는 OID(레코드의 물리적 주소 값)가 저장되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> tbl  \n<span class=\"token punctuation\">(</span>a <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\nb STRING<span class=\"token punctuation\">,</span>  \nc <span class=\"token keyword\">BIGINT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx <span class=\"token keyword\">ON</span> tbl  \n<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> tbl <span class=\"token keyword\">VALUES</span>  \n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'ZZZ'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">123456</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'BBB'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">123456789</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'AAA'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">123</span>'<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n…\n<span class=\"token punctuation\">(</span>이하 생략<span class=\"token punctuation\">)</span></code></pre></div>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; '>\n      <a class='gatsby-resp-image-link' href='/static/d508cf181fc4ccff83f1503f7e9f0a91/99c16/img_6.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 131.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAF40lEQVR42n1VaW8TVxSdP1UVWtGqFLH8gfYPQAVFlLAVBVFB1aoUqlIobVmKaFPKKkIgOHviOImTONs4Tjy2Zx/b4/F4Hdvx7iSnd1740A9Vn3L1ZibJffe8c869XKlYhhozYKdy0GQdUiyKuK5he3sb7nq7sbW1tQ36garpiEZjkGUF4bCASCQKTTfY33CD/H3cmTiH+97z6Bm/gZcjPJ4PBGBlnJ2ELOlO1nK5DCMWQnjFj7WFacRWAwjO+8DP+ZAUQ8iZGrhfvJ/jvOd9dD17F9++OYLHnlX88TIA2bBRqzewUWtgc3OLJTTiSQRnRyEsTlB4Ia5MQeSnsTIztPMcnAN3338Ol4YP4kLfPvw02oWXo2E8HVimhGmWpNFsoViqwMoWoGhx8P5xRJd8WJ0bQ3R5CjGKCL2HF+gQqpz7feYsS3h55CB+HOnC08Ew/nq9jLAYR73RpHvbglPeQL3ZRlRUIa/OISEQglU/lNVZxIUFOAkB1ZQIS1kDd2v8GM707cYXj9/BN68P41E/j3tPfQiGVVZd0sqhs7mJVmcTCTNF8EYRIbgCq8qLtcA4qzQt8VDWF8FlSybMgoJkVoKZ0VCubNDlE8RMnqKAPKnATVylu0xZGaiiACsuw9QlJDQRKUOGndSQNXXYpgFOsoIIGpPgNS9W1QDCUgqCnIKWsJGyc4zlNCW2MkVERIXuboJVxPvHqDov1NA80nKQVagJy+B+myGWh97Dl/27cG38KB4NCHjoCUHU0sjmi0hni6xS9wAzZaNSLqHTaaPTbqNeq6HZqKPdapESOijk8+DueE/j4pv9uPByH668Oo6nnhX82euHGrcZu5m8g1Klio1qAyuhKGLCOhkgCkWMQIkJO7sUYbsUFXZk8/XYIVweOoAblLxvXMSTwSAMM48m3Z2ZzrHE2UIZiWQKofkJ8KS7wKTnLSkTWPANYIHe+XkvuJtjR4nlXTjd6wr7MHr6VnD7MYlUs1Cp1mg3kSKC7JyDolNCoVgkeJsEu4MaQW40GuzZlVfehczr4/CJT1gE5BGoRgaiajIi6lRhinZeIM9KcZJNmmBGENdkFroiwlAltid1BQZ948obReRLNnJOmtyQImgEL18m2zWhxC0iw0JEjqO8USdS0ozldYLpshwhtoVFH8EfIOtNw4jwdIez5JSRA7g0uB83fafxfDiCh/3LDHKWCJG0FMEtMnEbSYtBdiG2iFkGuV5nrG923rL868RJdL/ei/MvPsJ3r4+RU1aYU9aiOv1TG6adpyrTLGE4psKg1mankkhTGLoKRZGhqi5cFRo9c/emz+Ly6CFc7N+P66On8GoiRlWGMM9LcMg1brdJWlkm7JLjIMb7oa/PUwSghOYgBWeoQUyjYKzDlEJU4eRxdA/uwdne3bgyeJTa1zoe9C2SW0xitUx3V0PBqUBPknMsG7adRq1KB1UqcBw6pOSgulFhInd/x/Ut3cLdqVP4bfwk/p65Dt98FMM+numuQd1G1JJM2PFUFjHZ7dQCNJVgKhJkKQZFFmkXoWsKe+c6beokzQ7Zp0Mn1dhlu4J2e7UrmbBksCrb1GTjCZP5VyaYUtCPGDHrBu8fgRldQiJGLD9fvIZbU5/hZ+8R9Mx+j35vFL2jQQjUD13JbNMQcSts0cGWnaVO5NChTTq0waC64TLdajaRy2bB3Z46gQtDH6L7zR5cHT6GZ0MCel4tYHlNYSPAXU1iu0I6TJIOxWgECWJXJ2Z1gu6yG9d3wr0G7t7UGVz07Ed378e46jmBZ4MhPHjhx6qg4d/LrTBJDXaN/Lo+P4YVgul62Z0tS9NDWJ4aQGjBRxX6utDt2YtzLz7A1aHjVOE6Dak5LIVk1MktTrnKPN3pbEFS40hbFhq1KmoEtVwqYoPaGYNN3zIuyw8Dl3DN+yl+mPwEd6e/gscXw4uRIAl6Z4xu0Qhttzs0X1rI5ArIZHJsnJZK1CgKRYoCe3a/5XI5cJUadZFKBgWKvGNTVXVmKdde/7XcGf1/8Q939ROmWjZq3AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='인덱스 리프 노드와 테이블 데이터의 관계' title='' src='/static/d508cf181fc4ccff83f1503f7e9f0a91/99c16/img_6.png' srcset='/static/d508cf181fc4ccff83f1503f7e9f0a91/e7570/img_6.png 170w,\n/static/d508cf181fc4ccff83f1503f7e9f0a91/f46e7/img_6.png 340w,\n/static/d508cf181fc4ccff83f1503f7e9f0a91/99c16/img_6.png 451w' sizes='(max-width: 451px) 100vw, 451px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>인덱스 리프 노드와 테이블 데이터의 관계</figcaption>\n  </figure></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tbl  \n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">AND</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span>  \n<span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>  \n<span class=\"token operator\">AND</span> c <span class=\"token operator\">></span> <span class=\"token number\">10000</span>  \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> b<span class=\"token punctuation\">;</span>  </code></pre></div>\n<p>위와 같은 SELECT 질의에서 WHERE 절에 있는 검색 조건은 다음과 같이 3가지로 나눌 수 있다.</p>\n<ul>\n<li>Key Range: 인덱스 스캔 범위로 활용하는 조건이다(a > 1 AND a &#x3C; 5).</li>\n<li>Key Filter: Key Range에 포함할 수 없지만 인덱스 키로 처리 가능한 조건이다(b &#x3C; 'K').</li>\n<li>Data Filter: 인덱스를 사용할 수 없는 조건이다. 테이블에서 레코드를 읽어야만 처리 가능한 조건이다(c > 10000).</li>\n</ul>\n<p>MySQL의 질의 처리 과정은 다음과 같다.\n인덱스 스캔인 경우 먼저 Key Range와 Key Filter를 적용하여 조건에 부합하는 OID 리스트를 만든다. 이 과정은 Key Range의 시작부터 끝까지 계속된다.\nOID를 이용해 데이터 페이지에서 해당 레코드를 읽어 Data Filter를 적용하거나 SELECT 리스트에 기술된 칼럼 값을 읽어와 결과를 저장하는 임시 페이지에 기록한다.\nORDER BY 절이나 GROUP BY 절이 있으면 임시 페이지에 저장된 레코드를 정렬하여 최종 결과를 생성한다.\n다음 그림은 위의 SELECT 질의가 처리되는 과정이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 545px; '>\n      <a class='gatsby-resp-image-link' href='/static/259165101295fdf07ef625485d5eea7a/f2ede/img_9.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+0lEQVR42n2UbW/bVBTH/aH2HiHxdgxpr/gCiI8AGxNIIPECgRBvEAgkVA2JPbGuSztGYU2alKVpugYnjpPY8UP8EDtJ3ZE4aZPG+XHrjololCsdHUs+9+dz7v9/LY2PY7KVVXKVdbaLFYJexNlaLBZpHsdD6tUD9KaSZsfQSJI5Fy0pikM+2bzMx5m3WXn4FM3upy+S5Bzo2ToHO49pHuRRSlnKu5t4fX/po0vAwdDn2sZr3Mi8yff3C6h6sAQ09UYKVMpZzFoRU90l6If4ns9oNHoFLMWTIdut22Tr95AbJofRkBdVJCJ1LINqOU9LLmHU9wlMhSiKGBxGzKbTf/W2SENqGw3W5K9YffY1WyUVNzgSrER0mHAyO8WyLfxOG69jcNTzOBLjhr0ek8nxf59hYfUm79+9xPXMFb65u80vuTrDvyIUtUU4iPDcDpoqY7TqtJs1tEaVvgDGsQAmpAKlwamIOVI5c5vP19/ii613+WnjKT+ulmhYAb/v7GN7PaLDPq4tOnRMuq6FY7UZDAYYho7e2Kcka+xVdYqlInKthqTnngghRAT76HaXetNhGI8pVepYbohlmejqn9i6iik6bLQqWKGLUmtTyO1hdyPCKEY70LDFXqmZe8Sn9y/z2eY7rDzIU9hr8Xw0plxR0EyHXhgSdl0CzyH0XXy/IwQ55PR0vqTuP8+SsvWQ925d4traFb69k2PlXhHVcFn7NU+tadEPfIymjKUpmFqNQPiyF/ZJXgDOQOeRGgNJ297kVv46d559ydZuncdPKsxmU9GdS19YyHNdcW66MLiRhiFc4Ybdi42tZX+jULnJjr5BRbWRlTZBcL5hKsbyPQH2TQZdm4Fv4/ltovHzi4Guo/LB2ut8mLnKdz+fjekyGY/S4rm4LWe20RtyahmjpaQWOp6M/+fqjbrcePQGH61f5YcHf9BoB0vFnufR9WwhSkeI0hEGNwVw8vI2vQI8mU6oejmqTgHTCRjFx0u1J9MZ87mw7Xz+MieL5MK/zd+OX0RVIdNZ7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='인덱스 스캔을 통한 질의 처리 과정' title='' src='/static/259165101295fdf07ef625485d5eea7a/f2ede/img_9.png' srcset='/static/259165101295fdf07ef625485d5eea7a/e7570/img_9.png 170w,\n/static/259165101295fdf07ef625485d5eea7a/f46e7/img_9.png 340w,\n/static/259165101295fdf07ef625485d5eea7a/f2ede/img_9.png 545w' sizes='(max-width: 545px) 100vw, 545px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>인덱스 스캔을 통한 질의 처리 과정</figcaption>\n  </figure></p>\n<h2 id=\"인덱스-사용하기\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"인덱스 사용하기 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 사용하기</h2>\n<p>옵티마이저가 인덱스를 사용하게 하려면 WHERE 절에 범위(Range) 조건이 있어야 한다. 범위 조건은 값의 비교 조건, 즉 크다, 작다, 크거나 같다, 작거나 같다, 같다와 같은 비교문으로 기술한다. 만약 범위 조건이 없다면 옵티마이저는 테이블 순차 스캔을 시도할 것이다.</p>\n<p>두 개 이상의 칼럼을 묶어서 인덱스를 만들 때는 칼럼의 순서가 매우 중요하다. 이런 인덱스를 다중 칼럼 인덱스(Multi-Column Index) 또는 복합 인덱스라고 한다. 복합 인덱스에서는 WHERE 절에 인덱스 키의 첫 번째 칼럼을 사용해야 인덱스 스캔을 수행한다. 인덱스가 여러 칼럼으로 조합되어 있을 때 칼럼 가운데 한 가지 칼럼만 사용해도 무방하다고 알려져 있는데, 잘못 알려진 것이라고 할 수 있다. 첫 번째 칼럼이 없는 상태에서는 두 번째 칼럼이 정렬된 상태라고 할 수 없기 때문에 범위를 정의할 수 없다. 따라서 반드시 첫 번째 칼럼이 조건에 있어야 하며, 첫 번째 이후의 칼럼은 조건에 없어도 상관없다.</p>\n<p>인덱스는 값의 대소 비교를 토대로 트리를 구성한다 따라서 값의 대소 비교가 아닌 조건은 B+-Tree를 사용해서 값을 찾을 수 없다. &#x3C;>, != 와 같이 부정형 조건이나 NULL 비교는 인덱스를 사용할 수 없다. 인덱스의 칼럼을 조건절에서 가공할 때도 인덱스를 사용할 수 없다. 다음은 인덱스를 사용하지 못하는 쿼리와 튜닝 후 인덱스를 사용하도록 수정한 쿼리의 예이다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">튜닝 전</th>\n<th align=\"left\">튜닝 후</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">SELECT * FROM student WHERE grade &#x3C;> 'A';</td>\n<td align=\"left\">SELECT * FROM student WHERE grade > 'A';</td>\n</tr>\n<tr>\n<td align=\"left\">SELECT name, email_addr FROM student WHERE email_addr IS NULL;</td>\n<td align=\"left\">SELECT name,email_addr FROM student WHERE email_addr = '';</td>\n</tr>\n<tr>\n<td align=\"left\">SELECT student_id FROM record WHERE substring(yymm, 1, 4) = '1997';</td>\n<td align=\"left\">SELECT student_id FROM record WHERE yymm BETWEEN '199701' AND '199712';</td>\n</tr>\n<tr>\n<td align=\"left\">SELECT * FROM employee WHERE salary * 12 &#x3C; 10000;</td>\n<td align=\"left\">SELECT * FROM employee WHERE salary &#x3C; 10000 / 12;</td>\n</tr>\n</tbody>\n</table>\n<p>작성한 SQL 질의가 DBMS에서 실행될 때 인덱스 스캔을 이용하는지 확인하려면 질의 실행 계획을 출력해 봐야 한다. 질의 실행 계획에서는 테이블 스캔(sscan)이나 인덱스 스캔(iscan) 여부, 예상되는 CPU 및 I/O 비용, 예상 결과 집합의 레코드 개수, 예상 페이지 접근 개수 등을 볼 수 있다.</p>\n<h2 id=\"인덱스-활용-최적화\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%99%9C%EC%9A%A9-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"인덱스 활용 최적화 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 활용 최적화</h2>\n<p>B+-Tree는 특성상 어떤 리프 페이지에 접근하든 거의 동일한 비용이 든다. B+-Tree를 사용할 때 가장 큰 비용이 드는 부분은 Key Range의 시작부터 끝까지 인덱스 리프 노드를 따라 진행하는 스캔과 여기에 대응하는 테이블 데이터의 스캔이다.</p>\n<p>대부분의 DBMS가 페이지(또는 블록) 단위로 I/O를 수행하며 MySQL도 예외는 아니다. 즉, 하나의 레코드에서 하나의 칼럼만 읽으려 해도 레코드가 속한 페이지 전체를 디스크로부터 읽어온다. 따라서 질의 성능을 좌우하는 가장 중요한 성능 지표는 I/O를 수행하는 페이지 개수이며, 이 개수는 옵티마이저의 판단에 가장 큰 영향을 미친다. 옵티마이저가 인덱스를 읽을지, 테이블을 읽을지 결정하는데 있어 가장 중요한 판단 기준은 읽어야 할 레코드가 아니라 읽어야 할 페이지 개수인 것이다.</p>\n<p>디스크 I/O는 메모리 액세스에 비해 비용이 아주 크다. 질의 수행에 필요한 모든 데이터 페이지와 인덱스 페이지를 데이터베이스 버퍼에 로드해서 처리할 수 있다면 좋지만 그러기에는 한계가 있다. 결국 디스크 I/O를 최소화하고 대부분의 연산을 데이터베이스 버퍼에서 처리할 수 있도록 질의 처리 과정에서 액세스하는 페이지 수를 최소화하는 것이 튜닝의 핵심이다. 액세스하는 페이지 수가 적으면 자연스럽게 물리적으로 디스크에서 읽어야 할 페이지 수도 줄기 때문에 데이터베이스 버퍼 히트율(DB buffer hit ratio)이 높아져서 데이터베이스의 전체적인 성능이 높아진다. 그러면 지금부터 인덱스 스캔 과정에서 액세스해야 할 페이지 수를 줄일 수 있는 기법을 알아보자.</p>\n<h2 id=\"Key-Filter-활용\" style=\"position:relative;\"><a href=\"#Key-Filter-%ED%99%9C%EC%9A%A9\" aria-label=\"Key Filter 활용 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Key Filter 활용</h2>\n<p>앞서 설명한 바와 같이 Key Filter는 Key Range에는 포함되지 않지만 인덱스 키로 처리할 수 있는 조건이다. 이러한 Key Filter가 WHERE 조건절에 포함되면 데이터 페이지에 접근하는 횟수를 줄일 수 있다. 데이터 페이지는 랜덤 액세스로 읽기 때문에 인덱스 페이지 스캔보다 많은 비용이 든다. 따라서 WHERE절에 Key Filter를 포함하면 성능 향상에 유리하다.</p>\n<p>또한 Data Filter가 Key Filter로 적용될 수 있도록 인덱스에 칼럼을 추가하는 것도 방법이 될 수 있다. 예를 들어 user 테이블에 (groupid, name)으로 구성된 인덱스 idx_1이 있는 상태에서 아래 질의를 수행한다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">WHERE</span> groupid <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n  <span class=\"token operator\">AND</span> age <span class=\"token operator\">></span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>groupid=10인 조건을 만족하는 레코드가 100건이고 그 중 age > 40인 레코드가 10건이라고 하면, 인덱스 스캔으로 100건의 OID를 가져온 후, 최악의 경우 데이터 페이지로 100회의 액세스를 수행할 것이다. 그러나, idx_1 인덱스에 age 칼럼을 추가하여 (groupid, name, age)로 만들면 age > 40 조건이 Key Filter 조건으로 처리되어 인덱스 스캔으로 10건의 OID만 추출할 수 있다.</p>\n<h2 id=\"커버링-인덱스\" style=\"position:relative;\"><a href=\"#%EC%BB%A4%EB%B2%84%EB%A7%81-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"커버링 인덱스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>커버링 인덱스</h2>\n<p>만약 사용하는 인덱스로 SELECT 질의에 대한 결과를 모두 얻을 수 있는 상황이라면, 데이터 페이지에 저장되어 있는 레코드를 읽어오지 않아도 인덱스 키의 값만으로도 결과를 얻을 수 있다. 이와 같이 인덱스가 하나의 질의를 모두 '커버'한 경우를 '커버링 인덱스(Covering Index)'라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> a<span class=\"token punctuation\">,</span> b <span class=\"token keyword\">FROM</span> tbl  \n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">AND</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span>  \n<span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>  \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> b<span class=\"token punctuation\">;</span> </code></pre></div>\n<p>위의 SQL 질의에서 커버링 인덱스를 적용할 수 있다. 질의에 사용한 칼럼은 a, b 뿐이고 모두 인덱스 칼럼이기 때문이다. 질의에 커버링 인덱스가 활용되는지 확인하려면 다음 그림과 같이 질의 실행 계획에 covers라는 표시가 있는지 보면 된다.</p>\n<p>커버링 인덱스는 데이터 페이지를 읽지 않는다는 점, 그리고 해당 질의를 자주 사용하면 인덱스가 데이터베이스 버퍼에 캐시되어 있을 가능성이 높다는 점에서 디스크 I/O를 줄이는 데 큰 역할을 한다. 따라서 레코드 크기에 비해 인덱스 키의 크기가 작고, 커버링 인덱스를 이용하는 질의가 자주 수행되는 것이 확실하다면, 커버링 인덱스를 사용하여 SELECT 질의 성능을 크게 향상시킬 수 있다.</p>\n<h2 id=\"정렬-연산-대체\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC-%EC%97%B0%EC%82%B0-%EB%8C%80%EC%B2%B4\" aria-label=\"정렬 연산 대체 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>정렬 연산 대체</h2>\n<p>인덱스 스캔으로 생성한 결과 집합은 인덱스 칼럼 순으로 정렬된 상태이므로 ORDER BY 절이나 GROUP BY 절에 의한 정렬 연산을 생략하도록 질의를 작성할 수 있다.</p>\n<p>정렬 연산을 생략하려면 인덱스 칼럼의 순서대로 ORDER BY 절이나 GROUP BY 절에 칼럼이 지정되어야 한다. 단 인덱스 칼럼이 조건절에서 '=' 연산자로 동등 비교되는 경우에는 해당 칼럼이 ORDER BY나 GROUP BY 절에서 중간에 생략되어도 된다. 예를 들어, 인덱스 키가 (a, b)로 되어 있다면 \"ORDER BY a\" 또는 \"ORDER BY a, b\"처럼 정렬할 컬럼이 명시되어야 한다. \"ORDER BY b\" 는 정렬 연산을 대체할 수 없다. 인덱스 (a, b)에서 b는 a가 같은 값일 때 만 정렬된 상태가 보장되기 때문이다. 하지만, \"a = 2\"와 같은 조건이 WHERE 절에 있다면 \"ORDER BY b\"도 정렬 연산을 대체할 수 있다.</p>\n<p>아래 질의는 정렬 연산 없이 인덱스 스캔만으로 정렬된 결과를 만들어 내는 예이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> b<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">AND</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span>\n  <span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>\n  <span class=\"token operator\">AND</span> c <span class=\"token operator\">></span> <span class=\"token number\">10000</span>\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> a</code></pre></div>\n<p>정렬 연산이 인덱스 스캔으로 대체되는지 확인하려면 다음 그림과 같이 질의 실행 계획에 skip ORDER BY 또는 skip GROUP BY가 표시되는지 확인하면 된다.</p>\n<p>앞에서 인덱스 스캔을 하려면 조건절에 인덱스의 첫 번째 칼럼이 명시돼야 한다고 설명했다. 하지만 인덱스 칼럼에 NOT NULL 제약 조건이 설정돼 있다면, 옵티마이저는 조건절에 인덱스 첫 번째 칼럼이 없더라도 최소 키 값과 최대 키 값으로 Key Range를 자동으로 추가하여 인덱스 스캔을 할 수 있게 최적화한다. 즉, 인덱스 리프 노드의 처음부터 끝까지 스캔하는데, 이를 오라클에서는 인덱스 전체 범위 스캔(Index Full Range Scan)이라고 한다</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tbl  \n<span class=\"token keyword\">WHERE</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>  \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> a<span class=\"token punctuation\">;</span>  </code></pre></div>\n<p>위 SQL 질의는 옵티마이저에 의해 인덱스 전체 범위 스캔이 수행되는 예다. 위 질의문의 실행 계획을 확인하면, 다음 그림처럼 Key Range가 자동으로 추가되어 ORDER BY 정렬 연산이 생략되는 것을 알 수 있다.</p>\n<h2 id=\"LIMIT-최적화\" style=\"position:relative;\"><a href=\"#LIMIT-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"LIMIT 최적화 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>LIMIT 최적화</h2>\n<p>LIMIT 절은 질의의 최종 결과 개수를 제한한다. MySQL 2008 R4.0에서는 Data Filter가 없는 질의에 LIMIT 절이 있으면 Key Range에 해당하는 키 값 전부를 스캔할 필요 없이 LIMIT 절에 기술된 개수만큼의 결과를 확보했을 때 바로 스캔을 중단할 수 있다. 이렇게 하면 범위의 끝까지 스캔하고 나서 결국 버리게 되는 페이지를 액세스하지 않기 때문에 불필요한 I/O를 줄일 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> b\n    <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 SQL 질의는 LIMIT 최적화로 필요한 결과를 얻은 후 인덱스 스캔이 중단되는 예다. 만약 a = 2인 인덱스 키가 10페이지에 걸쳐 저장돼 있더라도 LIMIT 절에 명시한 3개의 키 값만 스캔하므로 1개의 페이지만 읽게 된다.</p>\n<p>IN 절을 사용한 질의에도 LIMIT 최적화를 적용할 수 있다. MySQL은 인덱스 칼럼이 IN 절에 사용되면 Key Range를 IN 절에 사용된 개수만큼 생성하고, 각 Key Range에 대해 인덱스 스캔을 수행한다. 다만, 아래 질의처럼 LIMIT 절에 결과 개수가 명시되면 3번의 인덱스 스캔에 대해 각각 3건의 결과만 구하고 인덱스 스캔을 중단한다. 즉, 각 인덱스 스캔에 대해서 LIMIT 최적화가 적용되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">AND</span> b <span class=\"token operator\">&lt;</span> <span class=\"token string\">'K'</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> b\n    <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>ORDER BY 절은 전체 결과에 대한 정렬을 의미하기 때문에 Key Range가 여러 개이면 각 인덱스 스캔 결과를 모아서 다시 정렬해야 한다. 하지만 인덱스 스캔의 결과로 정렬을 대체할 수 있을 때에는 스캔 과정에서 바로 병합(merge)할 수 있다. MySQL은 이 과정을 'In-Place Sorting'이라고 부른다.</p>\n<p>다음 그림을 보면서 자세히 설명하면, 먼저 첫 번째 범위(a = 2 AND b &#x3C; 'K')를 스캔하여 3건의 OID를 확보한다. 그 다음 두 번째 범위(a = 4 AND b &#x3C; 'K')에 대한 스캔을 시도하는데, 이 범위의 첫 번째 키(4, 'DAA')는 첫 번째 범위의 마지막 스캔 키(2, 'CCC')보다 b 칼럼의 값이 크기 때문에 바로 스캔을 중단한다. 마찬가지로 다음 세 번째 범위인 a = 5 AND b &#x3C; 'K'에 대한 스캔에서도 두 번째 키를 읽은 후 바로 스캔을 중단한다. 이처럼 In-Place Sorting 기법은 인덱스 스캔 범위를 더욱 축소하고, 최종 결과에 대한 별도의 정렬을 수행하지 않기 때문에 성능 향상에 많은 도움을 준다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 567px; '>\n      <a class='gatsby-resp-image-link' href='/static/dc1b34c323618e8e6e2137a7820fd30d/b546d/img_10.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 82.3529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAADI0lEQVR42m2UWW8bZRSG/ZOQUAkXReKGX8E1F9wgNfyEXCBVKihNaSraO4RIoOCEpAkVaRw7JVs93sbreJnd24xtJcEex9vD52ndxJCRPp3Rp6NnzjnveyYwnowJyb/xh7TK3tkBx1KJ0WjEzWcymfjxvOOSTUYpZhPkZIls4ozztjuXGxiNR6zsf8li8A6Ptp4S/KvI1aB/K1ArZTna2yB1vEfmzQHRyC5aMTOX4wO/2/uCxc0PWdn6gee7OfpX3q1AUy0gHe4in+5TTh1RLUSpG6VZ1jVwP/0zv7y5Tyh2QEw2GA4HtwJto0LyLEwucUwhdYqalWja+jxwOsO4vk+4uEZUSZKvuG9nKCAz0CzZtgysSp6qpuBWVS6aJvWqyXg88fOnJ6DEY3zz7DO+3l5gOfiYX3dy9Lze+8pm0MFwjKHrGGoJQyv7UVeLGIZOr391LYqWiLP07QKLOx/zcOMxP22maDgOXu+SXvcS07LJFxSabpuqqZOOnZBPSyiZOLJ41wX4n16fmq3RadUJ1CoVdl4+YDOzQiR5SCprE5UV1rYjvDzKUjIaHMcztDqX2LZF1dJpiDZrtuGfltPA7VwQCr8iGj15N0MjxGFpnWghSVnvcJwq8+zPAk9e5DnLaPwtZbjoejh1m2Iu6VtFVTJUCjKuuOt5A/KiEFNrEUgehFj6/lPubX3kz3BtS8aqN5jJ0fOu/HZ7/QEt16EmKmzWLOqiuimsLe6mLb/34XnL5f7m53z1/AOWN1ZZf5Gl1nR80abqzRI9AazZpl+dKZTWilnfg3Vx1xUfnQkoWp4Qyf3ORmyZ18nXSCkNp92Z89+03OFojC5U1ssF0VoJraxgVBRMXRObNZxfvZj6irCyhlRMIskW7n+B75yoCgGrRpm6qWLrJWFqES2Tyc1dzoTDLD36hHvbd4RtVvkxGMdpteeAs2gJ2+TluLCMWIB0nIR0gqaW53e5fHrC0sO7QpQFAXwiREmLmXRv7Md1stOo0bBUmlUdp2bQEGvXFML8728Tyq0TTD4gkjokXaiLeQ257fH6nlC9759uz8MTcXpuAv8FYhyHxuC0TYcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='In-Place Sorting 기법에 의해 최적화된 질의 처리 과정' title='' src='/static/dc1b34c323618e8e6e2137a7820fd30d/b546d/img_10.png' srcset='/static/dc1b34c323618e8e6e2137a7820fd30d/e7570/img_10.png 170w,\n/static/dc1b34c323618e8e6e2137a7820fd30d/f46e7/img_10.png 340w,\n/static/dc1b34c323618e8e6e2137a7820fd30d/b546d/img_10.png 567w' sizes='(max-width: 567px) 100vw, 567px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>In-Place Sorting 기법에 의해 최적화된 질의 처리 과정</figcaption>\n  </figure></p>\n<h2 id=\"은-총알은-없다No-Silver-Bullet\" style=\"position:relative;\"><a href=\"#%EC%9D%80-%EC%B4%9D%EC%95%8C%EC%9D%80-%EC%97%86%EB%8B%A4No-Silver-Bullet\" aria-label=\"은 총알은 없다No Silver Bullet permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>은 총알은 없다(No Silver Bullet)</h2>\n<p>인덱스가 좋다고 인덱스를 많이 만드는 것은 능사가 아니다. 오히려 인덱스 관리 비용이 증가하고 INSERT, UPDATE, DELETE의 성능 저하의 원인이 될 수 있다. 인덱스 사용 시 다음 내용을 고려하자.</p>\n<ul>\n<li>인덱스 키의 크기는 되도록 작게 설계해야 성능에 유리하다.</li>\n<li>분포도가 좋은 칼럼(좁은 범위), 기본 키, 조인의 연결 고리가 되는 칼럼을 인덱스로 구성한다.</li>\n<li>단일 인덱스 여러 개보다 다중 칼럼 인덱스의 생성을 고려한다.</li>\n<li>업데이트가 빈번하지 않은 칼럼으로 인덱스를 구성한다.</li>\n<li>JOIN 시 자주 사용하는 칼럼은 인덱스로 등록한다.</li>\n<li>되도록 동등 비교(=)를 사용한다.</li>\n<li>WHERE 절에서 자주 사용하는 칼럼에는 인덱스 추가를 고려한다.</li>\n<li>인덱스를 많이 생성하는 것은 INSERT/UPDATE/DELETE의 성능 저하의 원인이 될 수 있다.</li>\n<li>인덱스 스캔이 테이블 순차 스캔보다 항상 빠르지는 않다. 보통 선택도(selectivity)가 5~10% 이내인 경우에 인덱스 스캔이 우수하다.</li>\n</ul>\n<p>정리하면, 데이터베이스 튜닝의 핵심은 적절한 수의 인덱스를 생성하고 질의가 이 인덱스를 활용할 수 있도록 질의를 최적화하는 것이다. 이를 위해서는 DBMS에 구현된 인덱스 구조와 다양한 활용 기법을 이해하고, 질의 패턴과 사용 빈도, I/O 비용, 저장 공간에 대한 비용을 전체적으로 고려해야 한다.</p>","frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?","date":"January 27, 2025","update":null,"tags":["Database"],"series":null},"fields":{"slug":"/database-index-sql/","readingTime":{"minutes":26.705}}},"seriesList":{"edges":[{"node":{"id":"ebf552bc-59ea-5969-b86b-bad95404ee87","fields":{"slug":"/ssl-protocol/"},"frontmatter":{"title":"SSL Protocol"}}},{"node":{"id":"af6c0192-819a-5110-957c-643bdd4721be","fields":{"slug":"/nginx-config/"},"frontmatter":{"title":"Nginx 설정하기"}}},{"node":{"id":"07aa966e-666d-563f-85c8-b3b4ad26865d","fields":{"slug":"/git-conventions/"},"frontmatter":{"title":"협업을 위한 Git 컨벤션"}}},{"node":{"id":"e4531ca2-2ac9-531b-9164-8b64c75e5a19","fields":{"slug":"/interview/"},"frontmatter":{"title":"면접관 사로잡기"}}},{"node":{"id":"9b20fef2-3067-501e-bf1c-8496cd150398","fields":{"slug":"/spring-data-jpa-paging/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"7fed17e5-3250-5f81-b864-7f719203a651","fields":{"slug":"/database-ssd-faster-than-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"97279d93-b018-5291-a7f8-154ab9af9e06","fields":{"slug":"/database-transaction/"},"frontmatter":{"title":"DBMS는 트랜잭션을 어떻게 관리할까?"}}},{"node":{"id":"556e4443-760f-5c0e-9d3f-56bce92db6bf","fields":{"slug":"/database-isolation-level/"},"frontmatter":{"title":"트랜잭션의 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"6bb66c2b-026f-566d-84fb-df3ce4dbec95","fields":{"slug":"/boj-17825/"},"frontmatter":{"title":"17825 주사위 윳놀이"}}},{"node":{"id":"0e31350d-6754-56b2-85a5-d739d57c38af","fields":{"slug":"/jscode-study-memoir/"},"frontmatter":{"title":"JSCODE 스터디 되돌아보기"}}},{"node":{"id":"a69e3d86-fa3b-5b23-a46b-27ca07dc31cc","fields":{"slug":"/boj-1325/"},"frontmatter":{"title":"1325 효율적인 해킹"}}},{"node":{"id":"07d0b3a0-20f5-5418-87e3-6e5eff4cbd0a","fields":{"slug":"/boj-1018/"},"frontmatter":{"title":"1018 체스판 다시 칠하기"}}},{"node":{"id":"9dde491d-5904-5c61-84e7-7943094943bd","fields":{"slug":"/boj-1051/"},"frontmatter":{"title":"1051 숫자 정사각형"}}},{"node":{"id":"a563c631-3d22-5595-9063-749fc5553ad3","fields":{"slug":"/boj-2529/"},"frontmatter":{"title":"2529 부등호"}}},{"node":{"id":"b9ebae0f-eb1d-5b1e-890b-1af660585100","fields":{"slug":"/boj-2615/"},"frontmatter":{"title":"2615 오목"}}},{"node":{"id":"c91b8fbb-756d-569e-867a-b441a01f7af8","fields":{"slug":"/boj-15686/"},"frontmatter":{"title":"15686 치킨 배달"}}},{"node":{"id":"c8a562b7-c6eb-5d5f-a167-29ea98d2d2c7","fields":{"slug":"/boj-9663/"},"frontmatter":{"title":"9663 N-Queen"}}},{"node":{"id":"b7249a5d-d62e-511f-a47b-4cae4c5d4a76","fields":{"slug":"/boj-27961/"},"frontmatter":{"title":"27961 고양이는 많을수록 좋다"}}},{"node":{"id":"830ecb3c-ea0c-5b32-932c-b78dea1fd7e6","fields":{"slug":"/prog-42839/"},"frontmatter":{"title":"42839 소수찾기"}}},{"node":{"id":"c14454eb-539e-5270-b82d-a5e74d5846e3","fields":{"slug":"/boj-11399/"},"frontmatter":{"title":"17503 맥주 축제"}}},{"node":{"id":"db022464-1f93-5ca3-b1ef-3ef7a0e53568","fields":{"slug":"/boj-1946/"},"frontmatter":{"title":"1946 신입 사원"}}},{"node":{"id":"442747fb-c36d-5ebf-b571-fc25a484ea56","fields":{"slug":"/boj-19598/"},"frontmatter":{"title":"19598 최소 회의실 개수"}}},{"node":{"id":"d1de5bbb-2949-5108-a4e8-29b57fb29120","fields":{"slug":"/boj-1003/"},"frontmatter":{"title":"1003 피보나치 함수"}}},{"node":{"id":"f66f88d3-87df-5f27-aa94-26a50d7330e8","fields":{"slug":"/boj-2212/"},"frontmatter":{"title":"2212 센서"}}},{"node":{"id":"bdb20dae-34ac-5a09-893c-74ae7b30c8fc","fields":{"slug":"/boj-11053/"},"frontmatter":{"title":"11053 가장 긴 증가하는 부분 수열"}}},{"node":{"id":"0e7377eb-09a1-531d-a44f-08c0014c411f","fields":{"slug":"/boj-9251/"},"frontmatter":{"title":"9251 LCS"}}},{"node":{"id":"9df5e584-f2a1-52e7-99a1-54cfcf2b8d98","fields":{"slug":"/boj-2225/"},"frontmatter":{"title":"2225 합분해"}}},{"node":{"id":"5ed27546-4130-51d0-a15c-fd9346bc5a0a","fields":{"slug":"/boj-1351/"},"frontmatter":{"title":"1351 무한 수열"}}},{"node":{"id":"202eda44-2909-5595-bd82-cb82f45a0ff6","fields":{"slug":"/enablewebmvc-jackson/"},"frontmatter":{"title":"@EnableWebMvc 사용해도 될까?"}}},{"node":{"id":"6d0a4c84-fa22-5a93-956d-8925e17b886f","fields":{"slug":"/annotation-modifying-with-transactional/"},"frontmatter":{"title":"@Query와 @Modifying만 사용하면 될까?"}}},{"node":{"id":"5204b390-54c4-5a3d-898b-8dbe85eeec62","fields":{"slug":"/static-resources-attack/"},"frontmatter":{"title":"디렉토리 스캔 공격은 어떻게 대응해야 할까?"}}},{"node":{"id":"2f361a7b-f132-50c6-a31d-1fb6f6cb18ba","fields":{"slug":"/method-naming/"},"frontmatter":{"title":"Java Method Naming Conventions"}}},{"node":{"id":"f4903cfa-9ebd-5f61-8c70-9f15d1fd5e15","fields":{"slug":"/ec2-cron-alert/"},"frontmatter":{"title":"서버 장애를 대비해 서버 리소스에 대한 Slack Webhook 처리하기"}}},{"node":{"id":"187c27c2-6ef1-560d-8127-7173cc083d5c","fields":{"slug":"/fail2ban-alert/"},"frontmatter":{"title":"Fail2Ban의 상태를 Slack Webhhook 처리하기"}}},{"node":{"id":"9bb120aa-03ff-507f-a287-b07192513173","fields":{"slug":"/2/"},"frontmatter":{"title":"No 'Access-Control-Allow-Origin' header is present on the requested resource"}}},{"node":{"id":"fe089a8a-241a-50b4-a390-8106ba05f4db","fields":{"slug":"/3/"},"frontmatter":{"title":"JSON serialization with Jackson don’t work properly."}}},{"node":{"id":"a6191ffd-2529-5df8-984b-8fda6c70c299","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"서버 모니터링에 대한 생각"}}},{"node":{"id":"4a640eb1-312c-5046-a330-010c52c6c644","fields":{"slug":"/bastion-host/"},"frontmatter":{"title":"AWS Bastion Host"}}},{"node":{"id":"96f7894e-d4a9-5bf7-9bb8-830a528eb6ef","fields":{"slug":"/gitactions-connect-private-instance/"},"frontmatter":{"title":"GitHub Actions에서 SSH로 Private 인스턴스에 접근하기"}}},{"node":{"id":"20d53e3c-f47c-5a86-a5ab-6f6b58f0d20d","fields":{"slug":"/gitactions-aws-add-inbound-rule/"},"frontmatter":{"title":"AWS Security Group의 Inbound Rule에 GitHub Actions의 Public IP 추가하기"}}},{"node":{"id":"1c1b69df-adb9-53bc-bc0a-8606822aa0b2","fields":{"slug":"/1/"},"frontmatter":{"title":"301 Moved Permanently"}}},{"node":{"id":"575ef349-72c5-5c06-8530-e2ae7a85f6dc","fields":{"slug":"/1/"},"frontmatter":{"title":"Utility Class에서 생성자를 private으로 선언해야 하는 이유"}}},{"node":{"id":"f7cc2668-fdd8-5081-8d46-4112cbde352b","fields":{"slug":"/id-generator/"},"frontmatter":{"title":"ID를 만드는 방법들"}}},{"node":{"id":"81aed75e-a872-5984-9ec0-e86b482eb8c7","fields":{"slug":"/4/"},"frontmatter":{"title":"Spring에서 Object를 Bean으로 관리하는 이유는 뭘까?"}}},{"node":{"id":"32a2cb86-8f1e-5c8f-9f56-bef33a14fb49","fields":{"slug":"/cookie-session/"},"frontmatter":{"title":"쿠키(Cookie)와 세션(Session)의 차이"}}},{"node":{"id":"7d4b9ff6-50df-50b9-9ffa-626cf0f444df","fields":{"slug":"/uri-url-urn/"},"frontmatter":{"title":"URI, URL, URN의 차이"}}},{"node":{"id":"0b358ad3-9f0a-53d4-9fa7-bfbe38edf138","fields":{"slug":"/not-in-query/"},"frontmatter":{"title":"NOT IN 쿼리를 사용할 때 발생할 수 있는 문제"}}},{"node":{"id":"2a8b8bcd-f005-5fd1-a25c-396b86696c56","fields":{"slug":"/http-https/"},"frontmatter":{"title":"HTTP와 HTTPS의 차이"}}},{"node":{"id":"363816c7-cc18-5b57-acb6-2bf5a9d47d1e","fields":{"slug":"/singleton-pattern/"},"frontmatter":{"title":"싱글턴 패턴(Singleton Pattern)"}}},{"node":{"id":"c5c31b8d-b95d-585a-b7cc-eb943e19a565","fields":{"slug":"/gc-algothms/"},"frontmatter":{"title":"GC 알고리즘(Garbage Collection Algorithms)"}}},{"node":{"id":"fe479149-14a0-5758-ad7d-8ee66f29fa81","fields":{"slug":"/web-socket/"},"frontmatter":{"title":"웹 소켓(Web socket)"}}},{"node":{"id":"1414b62f-0f58-51f0-ae3b-fc32861f1db8","fields":{"slug":"/stomp/"},"frontmatter":{"title":"STOMP"}}},{"node":{"id":"6cb5e327-ee97-5527-b3b3-46ee00cbe484","fields":{"slug":"/smart-convention/"},"frontmatter":{"title":"좋은 이름의 기준"}}},{"node":{"id":"f9a398a1-11e3-5923-8ccd-62c07bc7cd45","fields":{"slug":"/4/"},"frontmatter":{"title":"쓰레드 "}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"focus and hustle"}}}]},"previous":{"fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}},"next":{"fields":{"slug":"/item-34/"},"frontmatter":{"title":"int 상수 대신 열거 타입을 사용하라"}}},"pageContext":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","series":null,"previousPostId":"7d0e1c93-56d9-556d-8ed7-7920e7470762","nextPostId":"7062e173-15fc-579c-9637-8d4985247b51"}},"staticQueryHashes":[],"slicesMap":{}}