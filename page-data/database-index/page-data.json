{"componentChunkName":"component---src-templates-post-jsx","path":"/database-index/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"287deadf-40de-5a3a-9545-342fd478f804","excerpt":"인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다. 물론 인덱스가 없는 데이터…","html":"<p>인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다.</p>\n<p>물론 인덱스가 없는 데이터베이스에서도 데이터를 조회할 수 있지만, 데이터베이스의 크기가 크면 클수록 인덱스가 필요해진다.\n인덱스는 데이터베이스의 크기가 커져도 빠르게 데이터를 조회할 수 있도록 도와준다.</p>\n<blockquote>\n<p>그럼 모든 컬럼에 인덱스를 걸면 좋을까? 아니다.\n인덱스를 효율적으로 사용한다면 매우 빠른 데이터 조회가 가능하고, 쿼리의 부하가 줄어들어 데이터베이스의 성능을 향상시킬 수 있지만,\n인덱스 역시 하나의 데이터 덩어리이기 때문에 적절한 인덱스를 사용하지 않으면 오히려 데이터베이스의 성능을 저하시킬 수 있다.</p>\n</blockquote>\n<blockquote>\n<p>그럼 어떤 기준으로 인덱스를 설정해야할까?\n검색 조건에 주로 사용되고 카디널리티가 높은 컬럼을 인덱스로 설정하면 좋다.\n카디널리티는 인덱스에 해당하는 컬럼 기준으로 테이블에서 유일한 레코드 개수를 의미한다.\n카디널리티가 높을 컬럼에 인덱스를 걸면 그만큼 검색 대상이 줄어들기 때문에 빠르게 레코드에 접근할 수 있다.</p>\n</blockquote>\n<p>때문에 인덱스를 효율적으로 사용하기 위해서는 인덱스의 동작 방식과 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.</p>\n<h2 id=\"인덱스-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"인덱스 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 알고리즘</h2>\n<p>인덱스 알고리즘은 B-Tree와 Hash Index으로 분류하여 구분할 수 있다.\n이 중에서도 B-Tree 알고리즘은 Balanced Tree 알고리즘으로, 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.\n인덱스는 이러한 B-Tree 알고리즘을 사용하며 데이터가 정렬된 상태를 유지한다.\n때문에 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다.</p>\n<blockquote>\n<p>트리의 높이가 다른 경우 차이가 발생할 수 있지만, 일반적으로 B-Tree는 O(logN)의 시간복잡도를 가진다.</p>\n</blockquote>\n<h3 id=\"B-Tree\" style=\"position:relative;\"><a href=\"#B-Tree\" aria-label=\"B Tree permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>B-Tree</h3>\n<p>MySQL에서 사용하는 인덱스 알고리즘으로, 별다른 데이터의 변형을 가하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.\nB-Tree는 최상위에 하나의 루트 노드가 있고, 그 아래에 여러 개의 브랜치 노드가 있으며, 가장 하위에는 리프 노드가 있는 형태이다.</p>\n<p>해당 알고리즘의 장점은 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다는 것이다.\n하지만 어떤 데이터를 조회를 하더라도 루트 노드부터 리프 노드까지 탐색해야하기 때문에,\n데이터가 적은 테이블의 경우에는 인덱스를 사용하지 않는 것이 더 빠를 수 있다.</p>\n<h3 id=\"BTree\" style=\"position:relative;\"><a href=\"#BTree\" aria-label=\"BTree permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>B+Tree</h3>\n<p>B+Tree는 B-Tree의 변형 알고리즘으로, B-Tree와 달리 리프 노드가 연결 리스트로 연결되어 있다.\n또한 리프 노드에만 데이터가 저장되어 있고, 브랜치 노드에는 데이터가 저장되어 있지 않다.\n이러한 구조로 인해 범위 검색에 특화되어 있으며, 데이터베이스에서 범위 검색이 많은 경우에 사용된다.</p>\n<p>해당 알고리즘의 장점으로는 범위 검색에 특화되어 있어, 범위 검색이 많은 데이터베이스에서 빠른 검색 속도를 가진다.\n또한 리프 노드가 연결 리스트로 연결되어 있기 때문에 범위 검색을 할 때, 리프 노드를 순회하면 되기 때문에 빠른 검색 속도를 가진다.\n그러나 B-Tree에 비해 높이가 더 높아져서, B-Tree보다 더 많은 블록을 읽어야 한다.\n또한, 리프 노드가 연결 리스트로 연결되어 있기 때문에, 범위 검색이 아닌 동등 비교 검색에는 B-Tree보다 느릴 수 있다.</p>\n<h3 id=\"Hash-Index\" style=\"position:relative;\"><a href=\"#Hash-Index\" aria-label=\"Hash Index permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Hash Index</h3>\n<p>Hash Index 알고리즘은 데이터를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하는 알고리즘이으로, 특히 동등 비교 검색에 특화되어 있다.\n하지만 값을 해시값으로 변환하기 때문에 범위 검색이나 정렬된 데이터를 조회하는데는 적합하지 않다.\n주로 인메모리 데이터베이스에서 사용되는 인덱스 알고리즘이다.</p>\n<blockquote>\n<p>인메모리 데이터베이스는 데이터를 메모리에 저장하고, 디스크에 저장하지 않는 데이터베이스이다. 예를 들어 Redis가 있다.</p>\n</blockquote>\n<p>이러한 해시 인덱스의 장점으로는 실제 키 값과는 관계없이 해시값을 통해 데이터를 저장하기 때문에 데이터의 길이에 상관없이 일정한 시간복잡도를 가진다.\n그래서 타 인덱싱 알고리즘에 비해 빠른 검색 속도를 가진다.\n그러나 해시 인덱스는 각 해쉬값에 주소값을 지정하는 인덱스의 특성상, 범위로 조회하는 쿼리에는 적합하지 않다.\n또한 데이터베이스의 크기가 커질수록 충돌이 발생할 확률이 높아지기 때문에, 충돌을 해결하는 방법이 필요하다.</p>\n<h2 id=\"인덱스-타입\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%83%80%EC%9E%85\" aria-label=\"인덱스 타입 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인덱스 타입</h2>\n<p>인덱스의 타입은 크게 클러스터 인덱스와 세컨더리 인덱스로 나눌 수 있다.\n클러스터 인덱스는 처음부터 정렬된 상태로 데이터가 저장되는 인덱스이며, 세컨더리 인덱스는 정렬되지 않은 상태로 데이터가 저장되는 인덱스이다.\n영어사전을 예로 들면, 영어사전의 알파벳 순으로 정렬된 상태를 클러스터 인덱스라고 할 수 있고,\n영어사전의 단어가 추가되는 순서대로 저장된 상태를 세컨더리 인덱스라고 할 수 있다.</p>\n<p>각 인덱스의 특징에 따라 사용하는 경우가 다르다.</p>\n<h3 id=\"클러스터-인덱스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"클러스터 인덱스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>클러스터 인덱스</h3>\n<p>MySQL의 InnoDB 엔진은 기본적으로 클러스터 인덱스로 저장되는데,\n클러스터 인덱스는 기본키가 비슷한 레코드끼리 묶어서 인접한 물리적 위치에 저장하는 것을 뜻한다.\n그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬되어 저장되기 때문에, 기본키 기반 검색이 매우 빠르다.\n하지만, 이러한 정렬 방식 때문에 이미 대용량의 데이터가 저장된 상태라면 인덱스 생성은 시스템 부하를 일으킬 수 있다.</p>\n<p>클러스터 인덱스는 한 개의 테이블에 하나만 생성할 수 있으며, 기본키에 대해서만 생성할 수 있다.</p>\n<blockquote>\n<p>MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로,\n없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지않는 컬럼을 만들어 Clustered Index로 지정한다.</p>\n</blockquote>\n<h3 id=\"세컨더리-인덱스\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%BB%A8%EB%8D%94%EB%A6%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"세컨더리 인덱스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>세컨더리 인덱스</h3>\n<p>세컨더리 인덱스는 논 클러스터 인덱스(Non-Clustered Index)라고도 불린다.\n클러스터 인덱스와는 다르게 후보키 기반으로 생성되는 인덱스로, 기본키와는 별개로 생성된다.\n세컨더리 인덱스 생성 시에는 데이터 페이지는 정렬되지 않은 상태에서 별도의 인덱스 페이지에 인덱스가 생성된다.\n별도의 인덱스 페이지에 인덱스가 생성하여 구성하기 때문에 클러스터와는 달리 자동 정렬을 하지 않는다.\n때문에 클러스터형 보다 느리게 검색되지만, 데이터 삽입, 수정, 삭제에 대한 부하가 적다.</p>\n<blockquote>\n<p>세컨더리 인덱스는 여러 개 생성할 수 있으나, 이를 남용할 경우 오히려 성능이 저하될 수 있다.</p>\n</blockquote>\n<h3 id=\"클러스터--세컨더리-인덱스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0--%EC%84%B8%EC%BB%A8%EB%8D%94%EB%A6%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"클러스터  세컨더리 인덱스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>클러스터 + 세컨더리 인덱스</h3>\n<p>클러스터 인덱스와 세컨더리 인덱스를 함께 사용하는 방법도 있다.\n클러스터 인덱스는 기본키 기반 검색에 특화되어 있고, 세컨더리 인덱스는 범위 검색에 특화되어 있기 때문에,\n클러스터 인덱스와 세컨더리 인덱스를 함께 사용하면 더 빠른 검색 속도를 가질 수 있다.</p>\n<blockquote>\n<p>클러스터 인덱스와 세컨더리 인덱스를 함께 사용할 경우, 세컨더리 인덱스는 클러스터 인덱스를 참조하는 형태로 사용된다.</p>\n</blockquote>","frontmatter":{"title":"인덱스(Index)","date":"January 16, 2025","update":null,"tags":["Database","Index"],"series":null},"fields":{"slug":"/database-index/","readingTime":{"minutes":12.085}}},"seriesList":{"edges":[{"node":{"id":"ebf552bc-59ea-5969-b86b-bad95404ee87","fields":{"slug":"/ssl-protocol/"},"frontmatter":{"title":"SSL Protocol"}}},{"node":{"id":"af6c0192-819a-5110-957c-643bdd4721be","fields":{"slug":"/nginx-config/"},"frontmatter":{"title":"Nginx 설정하기"}}},{"node":{"id":"07aa966e-666d-563f-85c8-b3b4ad26865d","fields":{"slug":"/git-conventions/"},"frontmatter":{"title":"협업을 위한 Git 컨벤션"}}},{"node":{"id":"e4531ca2-2ac9-531b-9164-8b64c75e5a19","fields":{"slug":"/interview/"},"frontmatter":{"title":"면접관 사로잡기"}}},{"node":{"id":"9b20fef2-3067-501e-bf1c-8496cd150398","fields":{"slug":"/spring-data-jpa-paging/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"7fed17e5-3250-5f81-b864-7f719203a651","fields":{"slug":"/database-ssd-faster-than-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"97279d93-b018-5291-a7f8-154ab9af9e06","fields":{"slug":"/database-transaction/"},"frontmatter":{"title":"DBMS는 트랜잭션을 어떻게 관리할까?"}}},{"node":{"id":"556e4443-760f-5c0e-9d3f-56bce92db6bf","fields":{"slug":"/database-isolation-level/"},"frontmatter":{"title":"트랜잭션의 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"6bb66c2b-026f-566d-84fb-df3ce4dbec95","fields":{"slug":"/boj-17825/"},"frontmatter":{"title":"17825 주사위 윳놀이"}}},{"node":{"id":"0e31350d-6754-56b2-85a5-d739d57c38af","fields":{"slug":"/jscode-study-memoir/"},"frontmatter":{"title":"JSCODE 스터디 되돌아보기"}}},{"node":{"id":"a69e3d86-fa3b-5b23-a46b-27ca07dc31cc","fields":{"slug":"/boj-1325/"},"frontmatter":{"title":"1325 효율적인 해킹"}}},{"node":{"id":"07d0b3a0-20f5-5418-87e3-6e5eff4cbd0a","fields":{"slug":"/boj-1018/"},"frontmatter":{"title":"1018 체스판 다시 칠하기"}}},{"node":{"id":"9dde491d-5904-5c61-84e7-7943094943bd","fields":{"slug":"/boj-1051/"},"frontmatter":{"title":"1051 숫자 정사각형"}}},{"node":{"id":"a563c631-3d22-5595-9063-749fc5553ad3","fields":{"slug":"/boj-2529/"},"frontmatter":{"title":"2529 부등호"}}},{"node":{"id":"b9ebae0f-eb1d-5b1e-890b-1af660585100","fields":{"slug":"/boj-2615/"},"frontmatter":{"title":"2615 오목"}}},{"node":{"id":"c91b8fbb-756d-569e-867a-b441a01f7af8","fields":{"slug":"/boj-15686/"},"frontmatter":{"title":"15686 치킨 배달"}}},{"node":{"id":"c8a562b7-c6eb-5d5f-a167-29ea98d2d2c7","fields":{"slug":"/boj-9663/"},"frontmatter":{"title":"9663 N-Queen"}}},{"node":{"id":"b7249a5d-d62e-511f-a47b-4cae4c5d4a76","fields":{"slug":"/boj-27961/"},"frontmatter":{"title":"27961 고양이는 많을수록 좋다"}}},{"node":{"id":"830ecb3c-ea0c-5b32-932c-b78dea1fd7e6","fields":{"slug":"/prog-42839/"},"frontmatter":{"title":"42839 소수찾기"}}},{"node":{"id":"c14454eb-539e-5270-b82d-a5e74d5846e3","fields":{"slug":"/boj-11399/"},"frontmatter":{"title":"17503 맥주 축제"}}},{"node":{"id":"db022464-1f93-5ca3-b1ef-3ef7a0e53568","fields":{"slug":"/boj-1946/"},"frontmatter":{"title":"1946 신입 사원"}}},{"node":{"id":"442747fb-c36d-5ebf-b571-fc25a484ea56","fields":{"slug":"/boj-19598/"},"frontmatter":{"title":"19598 최소 회의실 개수"}}},{"node":{"id":"d1de5bbb-2949-5108-a4e8-29b57fb29120","fields":{"slug":"/boj-1003/"},"frontmatter":{"title":"1003 피보나치 함수"}}},{"node":{"id":"f66f88d3-87df-5f27-aa94-26a50d7330e8","fields":{"slug":"/boj-2212/"},"frontmatter":{"title":"2212 센서"}}},{"node":{"id":"bdb20dae-34ac-5a09-893c-74ae7b30c8fc","fields":{"slug":"/boj-11053/"},"frontmatter":{"title":"11053 가장 긴 증가하는 부분 수열"}}},{"node":{"id":"0e7377eb-09a1-531d-a44f-08c0014c411f","fields":{"slug":"/boj-9251/"},"frontmatter":{"title":"9251 LCS"}}},{"node":{"id":"9df5e584-f2a1-52e7-99a1-54cfcf2b8d98","fields":{"slug":"/boj-2225/"},"frontmatter":{"title":"2225 합분해"}}},{"node":{"id":"5ed27546-4130-51d0-a15c-fd9346bc5a0a","fields":{"slug":"/boj-1351/"},"frontmatter":{"title":"1351 무한 수열"}}},{"node":{"id":"202eda44-2909-5595-bd82-cb82f45a0ff6","fields":{"slug":"/enablewebmvc-jackson/"},"frontmatter":{"title":"@EnableWebMvc 사용해도 될까?"}}},{"node":{"id":"6d0a4c84-fa22-5a93-956d-8925e17b886f","fields":{"slug":"/annotation-modifying-with-transactional/"},"frontmatter":{"title":"@Query와 @Modifying만 사용하면 될까?"}}},{"node":{"id":"5204b390-54c4-5a3d-898b-8dbe85eeec62","fields":{"slug":"/static-resources-attack/"},"frontmatter":{"title":"디렉토리 스캔 공격은 어떻게 대응해야 할까?"}}},{"node":{"id":"2f361a7b-f132-50c6-a31d-1fb6f6cb18ba","fields":{"slug":"/method-naming/"},"frontmatter":{"title":"Java Method Naming Conventions"}}},{"node":{"id":"f4903cfa-9ebd-5f61-8c70-9f15d1fd5e15","fields":{"slug":"/ec2-cron-alert/"},"frontmatter":{"title":"서버 장애를 대비해 서버 리소스에 대한 Slack Webhook 처리하기"}}},{"node":{"id":"187c27c2-6ef1-560d-8127-7173cc083d5c","fields":{"slug":"/fail2ban-alert/"},"frontmatter":{"title":"Fail2Ban의 상태를 Slack Webhhook 처리하기"}}},{"node":{"id":"9bb120aa-03ff-507f-a287-b07192513173","fields":{"slug":"/2/"},"frontmatter":{"title":"No 'Access-Control-Allow-Origin' header is present on the requested resource"}}},{"node":{"id":"fe089a8a-241a-50b4-a390-8106ba05f4db","fields":{"slug":"/3/"},"frontmatter":{"title":"JSON serialization with Jackson don’t work properly."}}},{"node":{"id":"a6191ffd-2529-5df8-984b-8fda6c70c299","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"서버 모니터링에 대한 생각"}}},{"node":{"id":"4a640eb1-312c-5046-a330-010c52c6c644","fields":{"slug":"/bastion-host/"},"frontmatter":{"title":"AWS Bastion Host"}}},{"node":{"id":"96f7894e-d4a9-5bf7-9bb8-830a528eb6ef","fields":{"slug":"/gitactions-connect-private-instance/"},"frontmatter":{"title":"GitHub Actions에서 SSH로 Private 인스턴스에 접근하기"}}},{"node":{"id":"20d53e3c-f47c-5a86-a5ab-6f6b58f0d20d","fields":{"slug":"/gitactions-aws-add-inbound-rule/"},"frontmatter":{"title":"AWS Security Group의 Inbound Rule에 GitHub Actions의 Public IP 추가하기"}}},{"node":{"id":"1c1b69df-adb9-53bc-bc0a-8606822aa0b2","fields":{"slug":"/1/"},"frontmatter":{"title":"301 Moved Permanently"}}},{"node":{"id":"575ef349-72c5-5c06-8530-e2ae7a85f6dc","fields":{"slug":"/1/"},"frontmatter":{"title":"Utility Class에서 생성자를 private으로 선언해야 하는 이유"}}},{"node":{"id":"f7cc2668-fdd8-5081-8d46-4112cbde352b","fields":{"slug":"/id-generator/"},"frontmatter":{"title":"ID를 만드는 방법들"}}},{"node":{"id":"81aed75e-a872-5984-9ec0-e86b482eb8c7","fields":{"slug":"/4/"},"frontmatter":{"title":"Spring에서 Object를 Bean으로 관리하는 이유는 뭘까?"}}},{"node":{"id":"32a2cb86-8f1e-5c8f-9f56-bef33a14fb49","fields":{"slug":"/cookie-session/"},"frontmatter":{"title":"쿠키(Cookie)와 세션(Session)의 차이"}}},{"node":{"id":"7d4b9ff6-50df-50b9-9ffa-626cf0f444df","fields":{"slug":"/uri-url-urn/"},"frontmatter":{"title":"URI, URL, URN의 차이"}}},{"node":{"id":"0b358ad3-9f0a-53d4-9fa7-bfbe38edf138","fields":{"slug":"/not-in-query/"},"frontmatter":{"title":"NOT IN 쿼리를 사용할 때 발생할 수 있는 문제"}}},{"node":{"id":"2a8b8bcd-f005-5fd1-a25c-396b86696c56","fields":{"slug":"/http-https/"},"frontmatter":{"title":"HTTP와 HTTPS의 차이"}}},{"node":{"id":"363816c7-cc18-5b57-acb6-2bf5a9d47d1e","fields":{"slug":"/singleton-pattern/"},"frontmatter":{"title":"싱글턴 패턴(Singleton Pattern)"}}},{"node":{"id":"c5c31b8d-b95d-585a-b7cc-eb943e19a565","fields":{"slug":"/gc-algothms/"},"frontmatter":{"title":"GC 알고리즘(Garbage Collection Algorithms)"}}},{"node":{"id":"fe479149-14a0-5758-ad7d-8ee66f29fa81","fields":{"slug":"/web-socket/"},"frontmatter":{"title":"웹 소켓(Web socket)"}}},{"node":{"id":"1414b62f-0f58-51f0-ae3b-fc32861f1db8","fields":{"slug":"/stomp/"},"frontmatter":{"title":"STOMP"}}},{"node":{"id":"f6fbda6b-f55a-5f6e-bf3f-aa185355d924","fields":{"slug":"/1/"},"frontmatter":{"title":"운영체제의 개념과 구조"}}},{"node":{"id":"db774082-a0a9-59dd-a0bc-c521f2f961e1","fields":{"slug":"/2/"},"frontmatter":{"title":"커널의 작동 방식"}}},{"node":{"id":"6cb5e327-ee97-5527-b3b3-46ee00cbe484","fields":{"slug":"/smart-convention/"},"frontmatter":{"title":"좋은 이름의 기준"}}},{"node":{"id":"f9a398a1-11e3-5923-8ccd-62c07bc7cd45","fields":{"slug":"/4/"},"frontmatter":{"title":"쓰레드 "}}},{"node":{"id":"f91ab77f-dfa8-5f3d-b879-49faf8c5a077","fields":{"slug":"/3/"},"frontmatter":{"title":"프로세스"}}},{"node":{"id":"e5492bb1-3397-5615-89ac-c6b85f49a613","fields":{"slug":"/5/"},"frontmatter":{"title":"CPU 스케줄링"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"focus and hustle"}}}]},"previous":{"fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}},"next":{"fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},"pageContext":{"id":"287deadf-40de-5a3a-9545-342fd478f804","series":null,"previousPostId":"c553b71b-99ee-54e4-99c1-28158b54878a","nextPostId":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff"}},"staticQueryHashes":[],"slicesMap":{}}