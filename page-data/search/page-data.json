{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"보통 안전을 위해 AWS에서 배포 중인 인스턴스의 인바운드 규칙에서 SSH에 대한 접근 허용을 개인 아이피에 대해 설정할 것이다.\n이렇게 하면 CI/CD로 사용 중인 GitHub Actions이 연결도 당연히 차단될 것이다.\nGitHub Actions의 Public IP는 유동적이기 때문에 인바운드 규칙에 추가하는 방식을 고민할 것이다. Metadata …","fields":{"slug":"/gitactions-aws-add-inbound-rule/"},"frontmatter":{"date":"March 21, 2025","title":"AWS Security Group의 Inbound Rule에 GitHub Actions의 Public IP 추가하기","tags":["DevOps"]},"rawMarkdownBody":"\n보통 안전을 위해 AWS에서 배포 중인 인스턴스의 인바운드 규칙에서 SSH에 대한 접근 허용을 개인 아이피에 대해 설정할 것이다.\n이렇게 하면 CI/CD로 사용 중인 GitHub Actions이 연결도 당연히 차단될 것이다.\nGitHub Actions의 Public IP는 유동적이기 때문에 인바운드 규칙에 추가하는 방식을 고민할 것이다.\n\n[Metadata syntax for GitHub Actions](https://api.github.com/meta)\n\n물론 위에서 GibHub Actions의 Public IP의 범위를 공개해주기에 그렇게만 추가하는 방식도 있다.\n하지만 이 방법은 위험하고, 너무 많은 IP를 추가하고 관리해야 하기 떄문에 비효율적이다.\n그래서 매번 변경될 때마다 인바운드 규칙을 수정해야 한다고 생각했다.\n\n찾아보니 이미 GitHub Actions에서 제공하는 액션이 존재했다.\n이 글에서는 이러한 액션을 활용해 GitHub Actions에서 Security Group에 Inbound Rule 추가하는 방법을 설명하겠다.\n\n## GitHub Actions에서 할당받은 Public IP 확인하기\n\n먼저, `haythem/public-ip@v1.2` 액션을 사용하여 GitHub Actions에서 할당받은 Public IP를 확인하고 변수 선언 및 할당을 해준다.\n\n```yaml\n- name: Get GitHub Actions Public IP\n  id: ip\n  uses: haythem/public-ip@v1.2\n```\n\n## GitHub Actions에서 AWS 연결하기\n\n이제 아이피를 얻었으니 인바운드 규칙을 추가해야 한다.\n추가하기 전에 먼저 `aws-actions/configure-aws-credentials@v1` AWS에 연결해야 한다.\n\n```yaml\n- name: Configure AWS Credentials\n  uses: aws-actions/configure-aws-credentials@v1\n  with:\n    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n    aws-region: ${{ secrets.AWS_REGION }}\n```\n\n## Security Group에 Inbound Rule 추가하기\n\n이제 AWS에 연결했으니, `mnavarrocarter/aws-security-group-inbound-rule-action@v1.0.0` 액션을 사용하여 Security Group에 Inbound Rule을 추가하면 된다.\n\n- `SECURITY_GROUP_ID` : 설정할 Security Group의 ID\n- `SSH_PROTOCOL` : SSH 프로토콜\n- `SSH_PORT` : SSH 포트\n\n```yaml\n - name: Add GitHub Actions IP to Security Group\n   run: |\n      aws ec2 authorize-security-group-ingress \\\n        --group-id ${{ secrets.SECURITY_GROUP_ID }} \\\n        --protocol ${{ secrets.SSH_PROTOCOL }} \\\n        --port ${{ secrets.SSH_PORT }} \\\n        --cidr ${{ steps.ip.outputs.ipv4 }}/32\n```\n\n## Security Group에 추가한 Inbound Rule 삭제하기\n\n이제 인바운드 규칙을 추가했으니, 배포가 끝나면 안전상 삭제해야 한다.\n\n```yaml\n- name: Remove GitHub Actions IP from Security Group\n  if: always()\n  run: |\n    aws ec2 revoke-security-group-ingress \\\n      --group-id ${{ secrets.SECURITY_GROUP_ID }} \\\n      --protocol ${{ secrets.SSH_PROTOCOL }} \\\n      --port ${{ secrets.SSH_PORT }} \\\n      --cidr ${{ steps.ip.outputs.ipv4 }}/32\n```\n\n## 참고\n\n[About YAML syntax for GitHub Actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions)\n\n[appleboy, SSH for GitHub Actions](https://github.com/marketplace/actions/ssh-remote-commands)\n\n[mnavarrocarter, AWS Security Group Inbound Rule Action](https://github.com/marketplace/actions/aws-security-group-inbound-rule-action)\n\n[chaudharykiran, dial tcp ***:22: i/o timeout](https://github.com/appleboy/ssh-action/issues/78)\n\n[stack overflow, How can I find the right inbound rule for my Github action to deploy on my AWS EC2 server?](https://stackoverflow.com/questions/63642807/how-can-i-find-the-right-inbound-rule-for-my-github-action-to-deploy-on-my-aws-e)"},{"excerpt":"진행하고 있는 프로젝트에서 보안 이슈가 빈번히 발생했고, 이를 해결하기 위한 방안 중 하나로 인스턴스들을 Private Subnet으로 숨길 필요성이 생겼다.\n그래서 모든 인스턴스들을 Private Instance로 변경하고, SSH 접근을 하기 위해 Bastion Host를 구축했다.\n이에 따라 CI/CD 파이프라인에서 접속 방법에 대한 수정이 필요했다…","fields":{"slug":"/gitactions-connect-private-instance/"},"frontmatter":{"date":"March 20, 2025","title":"GitHub Actions에서 SSH로 Private 인스턴스에 접근하기","tags":["DevOps"]},"rawMarkdownBody":"\n진행하고 있는 프로젝트에서 보안 이슈가 빈번히 발생했고, 이를 해결하기 위한 방안 중 하나로 인스턴스들을 Private Subnet으로 숨길 필요성이 생겼다.\n그래서 모든 인스턴스들을 Private Instance로 변경하고, SSH 접근을 하기 위해 Bastion Host를 구축했다.\n이에 따라 CI/CD 파이프라인에서 접속 방법에 대한 수정이 필요했다.\n이 글에서는 GitHub Actions에서 SSH로 Proxy Host를 통해 Private 인스턴스에 배포하는 방법을 설명하겠다.\n\n## Login to AWS ECR\n\n먼저 AWS ECR에 빌드된 이미지를 올리기 위해 인증과정을 거쳐야 한다.\n스크립트는 다음과 같이 만들 수 있을 것 같다.\n\n```yaml\n - name: Login to AWS ECR\n  env:\n    AWS_REGION: \"${{ secrets.AWS_REGION }}\"\n    AWS_ACCOUNT_ID: \"${{ secrets.AWS_ACCOUNT_ID }}\"\n    AWS_ACCESS_KEY_ID: \"${{ secrets.AWS_ACCESS_KEY_ID }}\"\n    AWS_SECRET_ACCESS_KEY: \"${{ secrets.AWS_SECRET_ACCESS_KEY }}\"\n  run: |\n    aws ecr get-login-password --region $AWS_REGION | \\\n    docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com\n```\n\n## Build and Push Docker Image to AWS ECR\n\n이제 AWS ECR에 접근해서 다음과 같은 스크립트를 작성하면 된다.\n이 부분은 AWS ECR 페이지에 배포 방법에 대해 도움말이 있으니 참고하면 된다.\n\n```yaml\n- name: Build & Push Docker Image to AWS ECR\n  env:\n    AWS_REGION: \"${{ secrets.AWS_REGION }}\"\n    AWS_ACCOUNT_ID: \"${{ secrets.AWS_ACCOUNT_ID }}\"\n    ECR_REPO_NAME: \"${{ secrets.AWS_ECR_REPO_NAME }}\"\n  run: |\n    IMAGE_URI=\"$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO_NAME:latest\"\n    docker build -t $IMAGE_URI .\n    docker push $IMAGE_URI\n```\n\n## Deploy to EC2\n\n이제 이번 글의 핵심 이슈인 Private Instance에 배포 과정을 진행해야 한다.\n현재 사용하는 파이프라인 구조는 다음과 같을 것이다.\n\n```yaml\n+--------+       +----------+      +-----------+\n| Laptop | <-->  | Jumphost | <--> | FooServer |\n+--------+       +----------+      +-----------+\n```\n\n접속은 다음처럼 하면 되는데 보통 EC2에 배포할 때 사용하는 appleboy님의 ssh-action을 사용하면 된다.\n차이점은 proxy config 부분인데 현재 Jump Host인 Bastion Host의 정보를 넣으면 된다.\n다른 부분은 기존 ssh-action과 동일하게 하면 된다.\n이렇게 하면 Jump Host를 통해 Private Host로 접근하여 script를 수행하게 될 것이다.\n자세한 내용은 참고 링크를 확인하면 되겠다.\n\n```yaml\n- name: Deploy to EC2\n  uses: appleboy/ssh-action@v1.0.0\n  with:\n    host: ${{ secrets.EC2_HOST }}\n    username: ${{ secrets.EC2_USERNAME }}\n    key: ${{ secrets.EC2_PRIVATE_KEY }}\n    proxy_host: ${{ secrets.PROXY_HOST }}\n    proxy_username: ${{ secrets.PROXY_USERNAME }}\n    proxy_key: ${{ secrets.PROXY_KEY }}\n    script: |\n#      scripts...\n```\n\n## 참고\n\n[appleboy, SSL Action](https://github.com/appleboy/ssh-action)\n"},{"excerpt":"작성 중.. 참고 Bastion Host AWS Bastion Host meta data of GitHub actions ssh cidr range","fields":{"slug":"/bastion-host/"},"frontmatter":{"date":"March 17, 2025","title":"AWS Bastion Host","tags":["Server","AWS"]},"rawMarkdownBody":"\n작성 중..\n\n## 참고\n\n- [Bastion Host](https://rachel0115.tistory.com/entry/AWS-Bastion-Host-%EC%9D%B4%ED%95%B4-%EB%B0%8F-%EA%B5%AC%EC%B6%95)\n- [AWS Bastion Host](https://docs.aws.amazon.com/quickstart/latest/linux-bastion/architecture.html)\n- [meta data of GitHub actions ssh cidr range](https://api.github.com/meta)"},{"excerpt":"방어적 복사를 사용하는 불변 클래스 아이템 50에서는 불변식을 지키고 불변을 유지한 날짜 클래스를 만들기 위해,\n생성자와 접근자(getter)에서 Data 객체를 방어적으로 복사하도록 했다.\n다음이 그 클래스의 모습니다. 이 클래스를 직렬화를 하고자 한다면 물리적 표현과 논리적 표현이 같기 때문에 기본 직렬화 형태를 사용해도 무방할 것 같다.\n따라서 만 …","fields":{"slug":"/item-88/"},"frontmatter":{"date":"March 13, 2025","title":"readObject 메서드는 방어적으로 작성하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 방어적 복사를 사용하는 불변 클래스\n\n[아이템 50](https://023-dev.github.io/item-50/)에서는 불변식을 지키고 불변을 유지한 날짜 클래스를 만들기 위해,\n생성자와 접근자(getter)에서 Data 객체를 방어적으로 복사하도록 했다.\n다음이 그 클래스의 모습니다.\n\n```java\npublic final class Period {\n    private final Date start;\n    private final Date end;\n\n    /**\n     * @param  start 시작 시각\n     * @param  end 종료 시각; 시작 시각보다 뒤여야 한다.\n     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.\n     * @throws NullPointerException start나 end가 null이면 발생한다.\n     */\n    public Period(Date start, Date end) {\n        this.start = new Date(start.getTime()); // 가변인 Date 클래스의 위험을 막기 위해 새로운 객체로 방어적 복사\n        this.end = new Date(end.getTime());\n\n        if (this.start.compareTo(this.end) > 0) {\n            throw new IllegalArgumentException(start + \" after \" + end);\n        }\n    }\n\n    public Date start() { return new Date(start.getTime()); }\n    public Date end() { return new Date(end.getTime()); }\n    public String toString() { return start + \" - \" + end; }\n    // ... 나머지 코드는 생략\n}\n```\n\n이 클래스를 직렬화를 하고자 한다면 물리적 표현과 논리적 표현이 같기 때문에 기본 직렬화 형태를 사용해도 무방할 것 같다.\n따라서 `Serializable`만 구현하면 될 것 같지만, 사실 실제로는 불변식을 보장하지 못하게 된다.\n\n그 이유는 `readObject` 메서드가 실질적으로 또 다른 `public` 생성자이기 때문이다.\n따라서 `readObject` 메서드도 다른 생성자와 똑같은 수준으로 주의를 기울여야 한다. \n\n## readObject 메서드\n\n쉽게 말해, `readObject` 메서드는 매개변수로 바이트 스트림을 받는 생성자라고 할 수 있다.\n보통 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어진다.\n하지만 불변을 깨뜨릴 의도로 만들어진 바이트 스트림을 받으면 문제가 생긴다.\n이는 정상적인 생성자로는 만들어낼 수 없는 객체를 생성하기 때문이다.\n\n단순하게 앞서 살펴본 `Period` 클래스에 `Serializable` 구현을 추가했다고 가정했을 때,\n아래와 같은 코드는 불변식을 깨뜨리는 공격을 할 수 있다.\n\n```java\npublic class BogusPeriod {\n    // 진짜 Period 인스턴스에서는 만들어질 수 없는 바이트 스트림,\n    // 정상적인 Period 인스턴스를 직렬화한 후에 손수 수정한 바이트 스트림이다.\n    private static final byte[] serializedForm = {\n        (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,\n        0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,\n        ... 생략\n    }\n\n    // 상위 비트가 1인 바이트 값들은 byte로 형변환 했는데,\n    // 이유는 자바가 바이트 리터럴을 지원하지 않고 byte 타입은 부호가 있는(signed) 타입이기 때문이다.\n\n    public static void main(String[] args) {\n        Period p = (Period) deserialize(serializedForm);\n        System.out.println(p);\n    }\n\n    // 주어진 직렬화 형태(바이트 스트림)로부터 객체를 만들어 반환한다.\n    static Object deserialize(byte[] sf) {\n        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(sf)) {\n            try (ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream)) {\n                return objectInputStream.readObject();\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}\n```\n\n```java\n# 실행 결과, end가 start 보다 과거다. 즉, Period의 불변식이 깨진다.\nFri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984\n```\n\n이렇게 `Period`를 직혈화 할 수 있도록 선언한 것만으로도 클래스의 불변식을 깨뜨리는 객체를 만들 수 있게 된 것이다.\n\n## 어떻게 방어할 수 있을까?\n\n이 문제를 고치려면 `Period`의 `readObject` 메서드가 `defaultReadObject`를 호출하게 한 후에 역직렬화된 객체가 유효한지 검사해야 한다.\n여기서 유효성 검사에 실패한다면, `InvalidObjectException`을 던지게 해서 잘못된 역직렬화가 일어나는 것을 막을 수 있다.\n\n```java\nprivate void readObject(ObjectInputStream s)\n        throws IOException, ClassNotFoundException {\n\n    // 불변식을 만족하는지 검사한다.\n    if (start.compareTo(end) > 0) {\n        throw new InvalidObjectException(start + \"after\" + end);\n    }\n}\n```\n\n하지만 여기서도 문제가 존재하는데, 정상적인 `Period` 인스턴스에서 시작된 바이트 스트림 끝에 `private Date` 필드 참조를 추가하면 가변적인 인스턴스를 만들어 낼 수 있다.\n이때 공격자가 역직렬화를 통해 바이트 스트림 끝의 추가된 참조 값을 읽으면 `Period`의 내부 정부를 얻을 수 있다.\n이렇게 되면 참조로 얻은 `Date` 인스턴스들을 수정을 할 수 있게 되어, 더는 `Period` 인스턴스가 불변이 아니게 되는 것이다. \n\n```java\npublic class MutablePeriod {\n    // Period 인스턴스\n    public final Period period;\n\n    // 시작 시각 필드 - 외부에서 접근할 수 없어야 한다.\n    public final Date start;\n\n    // 종료 시각 필드 - 외부에서 접근할 수 없어야 한다.\n    public final Date end;\n\n    public MutablePeriod() {\n        try {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(bos);\n\n            // 유효한 Period 인스턴스를 직렬화한다.\n            out.writeObject(new Period(new Date(), new Date()));\n\n            /*\n             * 악의적인 '이전 객체 참조', 즉 내부 Date 필드로의 참조를 추가한다.\n             * 상세 내용은 자바 객체 직렬화 명세의 6.4절 참조.\n             */\n            byte[] ref = { 0x71, 0, 0x7e, 0, 5 }; // 참조 #5\n            bos.write(ref); // 시작(start) 필드\n            ref[4] = 4; // 참조 #4\n            bos.write(ref); // 종료(end) 필드\n\n            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\n            period = (Period) in.readObject();\n            start = (Date) in.readObject();\n            end = (Date) in.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        MutablePeriod mp = new MutablePeriod();\n        Period p = mp.period;\n        Date pEnd = mp.end;\n\n        // 시간을 되돌린다.\n        pEnd.setYear(78);\n        System.out.println(p);\n\n        // 60년대로 돌아간다.\n        pEnd.setYear(69);\n        System.out.println(p);\n    }\n}\n```\n\n```java\nWed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978\nWed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969\n```\n\n이 문제의 원인은 `Period`의 `readObject` 메서드가 방어적 복사를 하지 않음에 있다. \n역직렬화를 할 때는 클라이언트가 접근해서는 안 되는 객체 참조를 갖는 필드는 모두 방어적으로 복사를 해야 한다.\n\n## 방어적 복사와 유효성 검사를 모두 수행해야 한다.\n\nPeriod를 공격으로부터 보호하기 위해 방어적 복사를 유효성 검사보다 먼저 수행해야 한다. \n또한 Date의 clone 메서드는 사용되지 않았다.\n\n```java\nprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // 가변 요소들을 방어적으로 복사한다.\n    start = new Date(start.getTime());\n    end = new Date(end.getTime());\n\n    // 불변식을 만족하는지 검사한다.\n    if (start.compareto(end) > 0) {\n        throw new InvalidObjectException(start + \" after \" + end);\n    }\n}\n```\n\n```java\n# MutablePeriod의 main 메서드 출력 결과. \nFri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019\nFri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019\n```\n\n해당 작업에 있어서 `final` 필드는 방어적 복사가 불가능하다.\n그래서 이 `readObject` 메서드를 사용하려면 `start`와 `end` 필드에서 `final` 한정자를 제거해야 한다.\n이 부분에 대해서 다른 보안적인 이슈와 트레이드 오프가 있겠지만, 앞서 살펴본 공격 위험에 노출되는 것보다 나은 방향이다.\n\n## 그럼 언제 기본 readObject를 사용해야 할까?\n\ntransient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사를 없이도 필드에 대입하는 public 생성자를 추가해도 괜찮다고 판단되면 기본 readObject 메서드를 사용해도 된다. \n아닌 경우 직접 readObject 메서드를 정의하여 생성자에서 수행했어야 할 모든 유효성 검사와 방어적 복사를 수행해야 한다. \n가장 추천되는 것은 직렬화 프록시 패턴을 사용하는 것이다. \n역직렬화를 안전하게 만드는 데 필요한 노력을 줄여준다.\n\nfinal이 아닌 직렬화 가능한 클래스라면 생성자처럼 readObject 메서드도 재정의(overriding) 가능한 메서드를 호출해서는 안 된다. \n하위 클래스의 상태가 완전히 역직렬회되기 전에 하위 클래스에서 재정의된 메서드가 실행되기 때문이다.\n\n## 정리\n\n`readObject` 메서드를 작성할 때는 언제나 `public` 생성자를 작성하는 자세로 임해야 한다.\n`readObject`는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 한다.\n이 바이트 스트림이 항상 진짜 직렬화된 인스턴스라고 가정해서는 안 된다.\n\n해당 아이템에서는 기본 직렬화 형태를 사용해 예를 들었지만 커스텀 직렬화 또한 모든 문제가 그대로 발생할 수 있다.\n그래서 다음과 같은 지침을 따르는 것을 권장한다.\n\n- `private`이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라. 불변 클래스 내의 가변 요소가 여기 속한다.\n- 모든 불변식을 검사하여 어긋나는 게 발견되면 `InvalidObjectException`을 던져라. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.\n- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 `ObjectInputValidation` 인터페이스를 사용하라.\n- 직접적이든 간접적이든, 재정의할 수 있는 메서드는 호출하지 말자."},{"excerpt":"이번 글에서는 서버 모니터링에 대해 다루어 보려고 한다. Concept 서버 공격으로 인한 서버 다운이 흔하게 발생 → 모니터링의 필요성 CloudWatch → 트래픽에 따른 비용 증가, 구축 편이 Promethus + Grafana(추후 Loki) → 오픈 소스, 상대적으로 구축이 복잡 결론은  Promethus + Grafana → 구축 경험이 있고,…","fields":{"slug":"/server-monitoring/"},"frontmatter":{"date":"March 10, 2025","title":"서버 모니터링에 대한 생각","tags":["Server","Grafana","Prometheus","Alertmanager","Nginx"]},"rawMarkdownBody":"\n이번 글에서는 서버 모니터링에 대해 다루어 보려고 한다.\n\n## Concept\n\n- 서버 공격으로 인한 서버 다운이 흔하게 발생 → 모니터링의 필요성\n- CloudWatch → 트래픽에 따른 비용 증가, 구축 편이\n- Promethus + Grafana(추후 Loki) → 오픈 소스, 상대적으로 구축이 복잡\n- 결론은  Promethus + Grafana → 구축 경험이 있고, 오픈 소스\n- 모니터링 소스 → Nginx Log 및 Docker Logs\n- cAdvisor + Prometheus → 컨테이너 리소스 사용량 모니터링 (CPU, RAM, Disk, 네트워크)\n- Docker Daemon Logs + Loki + Grafana → 컨테이너 로그 분석\n- Nginx VTS (Virtual Host Traffic Status) + Prometheus Exporter → 실시간 트래픽 모니터링\n- Nginx Access/Error 로그 분석 → 로그 기반 분석\n\n## Workflow\n\n- Prometheus 설치\n\n    ```bash\n    # Ubuntu로 수정 필요\n    # Prometheus 사용자 생성\n    sudo useradd -M -r -s /bin/false prometheus\n    \n    # 설정 디렉토리 및 데이터 디렉토리 생성\n    sudo mkdir /etc/prometheus /var/lib/prometheus\n    \n    # Prometheus 다운로드\n    cd /tmp\n    curl -LO https://github.com/prometheus/prometheus/releases/download/v2.41.0/prometheus-2.41.0.linux-amd64.tar.gz\n    tar xvf prometheus-2.41.0.linux-amd64.tar.gz\n    \n    # 바이너리 이동\n    sudo mv prometheus-2.41.0.linux-amd64/prometheus /usr/local/bin/\n    sudo mv prometheus-2.41.0.linux-amd64/promtool /usr/local/bin/\n    ```\n\n- Prometheus 설정\n    - /etc/prometheus/prometheus.yml\n\n        ```bash\n        global:\n          scrape_interval: 15s\n        \n        scrape_configs:\n          - job_name: 'nginx'\n            static_configs:\n              - targets: ['localhost:9113']  # Nginx Exporter\n        \n          - job_name: 'docker'\n            static_configs:\n              - targets: ['localhost:9323']  # cAdvisor (Docker 컨테이너 모니터링)\n        ```\n\n- Prometheus 실행\n\n    ```bash\n    # Prometheus 실행\n    sudo systemctl enable prometheus\n    sudo systemctl start prometheus\n    ```\n\n- Nginx 설정\n    - /etc/nginx/nginx.conf\n\n    ```bash\n    server {\n        listen 80;\n        server_name localhost;\n    \n        location /nginx_status {\n            stub_status;\n            allow 127.0.0.1;\n            deny all;\n        }\n    }\n    ```\n\n    - `sudo systemctl restart nginx`로 설정 반영\n- Nginx Exporter 설치\n\n    ```bash\n    # Nginx Exporter 다운로드\n    wget https://github.com/nginxinc/nginx-prometheus-exporter/releases/download/v0.10.0/nginx-prometheus-exporter-0.10.0-linux-amd64.tar.gz\n    tar xvf nginx-prometheus-exporter-0.10.0-linux-amd64.tar.gz\n    sudo mv nginx-prometheus-exporter /usr/local/bin/\n    \n    # Nginx Exporter 실행\n    /usr/local/bin/nginx-prometheus-exporter -nginx.scrape-uri=http://localhost/nginx_status &\n    ```\n\n    - 실행 확인\n\n    ```bash\n    curl http://localhost:9113/metrics\n    ```\n\n- Docker Container Advisor 실행\n\n    ```bash\n    docker run -d \\\n      --name=cadvisor \\\n      --restart=always \\\n      -p 9323:8080 \\\n      --privileged \\\n      --volume=/var/run:/var/run:rw \\\n      --volume=/sys:/sys:ro \\\n      --volume=/var/lib/docker/:/var/lib/docker:ro \\\n      google/cadvisor:latest\n    ```\n\n    - 실행 확인\n\n    ```bash\n    curl http://localhost:9323/metrics\n    ```\n\n- Grafana 설치\n\n    ```bash\n    sudo apt-get install -y adduser libfontconfig1\n    wget https://dl.grafana.com/oss/release/grafana_9.3.2_amd64.deb\n    sudo dpkg -i grafana_9.3.2_amd64.deb\n    \n    # Grafana 실행\n    sudo systemctl enable grafana-server\n    sudo systemctl start grafana-server\n    ```\n\n    - 브라우저에서 http://<EC2_IP>:3000 접속 → 기본 로그인 ID/PW: **admin / admin**\n    - Prometheus 데이터 소스 추가 → Configuration > Data Sources > Add Data Source, **Type:** Prometheus, URL: [http://localhost:909](http://localhost:909/)0\n- Grafana 설정\n    - Nginx Dashboard\n        - Import → Load Dashboard ID: 2949 → Prometheus로 Import\n    - Docker Dashboard\n        - Import → Load Dashboard ID: 193 → Prometheus로 Import\n- Slack 알림 설정 (AlertManager)\n    - AlertManager 설정 (/etc/prometheus/alertmanager.yml)\n\n        ```bash\n        global:\n          resolve_timeout: 5m\n        \n        route:\n          receiver: 'slack'\n        \n        receivers:\n          - name: 'slack'\n            slack_configs:\n              - send_resolved: true\n                channel: '#alerts'\n                api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'\n        ```\n\n    - 설정 반영 -> `sudo systemctl restart alertmanager`\n\n---\n\n## 참고\n\n- [Nihisil, Send notifications to the Slack from fail2ban](https://gist.github.com/Nihisil/29fd2971c9dd109ae245)"},{"excerpt":"이번 아이템에서는 동기화를 과도하게 했을 때의 피해에 대해 알아본다. 외계인 메서드 동기화된 영역 안에서는 재정의할 수 있는 메서드를 호출하거나 클라이언트가 넘겨준 함수 객체를 호출하는 경우,\n클래스 관점에서는 이런 메서드는 모두 바깥 세상에서 온 외계인 메서드로 그 메서드가 무슨 일을 할 지 알지 못하며 통제할 수 없게 된다. 이러한 외계인 메서드가 하…","fields":{"slug":"/item-79/"},"frontmatter":{"date":"March 06, 2025","title":"과도한 동기화는 피하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n이번 아이템에서는 동기화를 과도하게 했을 때의 피해에 대해 알아본다.\n\n## 외계인 메서드\n\n동기화된 영역 안에서는 재정의할 수 있는 메서드를 호출하거나 클라이언트가 넘겨준 함수 객체를 호출하는 경우,\n클래스 관점에서는 이런 메서드는 모두 바깥 세상에서 온 외계인 메서드로 그 메서드가 무슨 일을 할 지 알지 못하며 통제할 수 없게 된다.\n\n이러한 외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착상태에 빠지거나, 데이터를 훼손할 수도 있다.\n\n다음을 예로 들면, 어떤 집합(Set)을 감싼 래퍼 클래스이고,\n이 클래스의 클라이언트는 집합에 원소가 추가되면 알림을 받을 수 있다.\n\n```java\n@FunctionalInterface\npublic interface SetObserver<E> {\n    // ObservableSet에 원소가 추가되면 호출된다.\n    void added(ObservableSet<E> set, E element);\n}\n```\n\n```java\n public class ObservableSet<E> extends ForwardingSet<E> {\n    public ObservableSet(Set<E> set) {\n        super(set);\n    }\n\n    private final List<SetObserver<E>> observers \n            = new ArrayList<>();\n\n    public void addObserver(SetObserver<E> observer) {\n        synchronized(observers) {\n            observers.add(observer);\n        }\n    }\n\n    public boolean removeObserver(SetObserver<E> observer) {\n        synchronized(observers) {\n            return observers.remove(observer);\n        }\n    }\n\n    private void notifyElementAdded(E element) {\n        synchronized(observers) {\n            for (SetObserver<E> observer : observers)\n                observer.added(this, element);\n        }\n    }\n\n    @Override\n    public boolean add(E element) {\n        boolean added = super.add(element);\n\n        if (added)\n            notifyElementAdded(element);\n        \n        return added;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        boolean result = false;\n\n        for (E element : c)\n            result |= add(element);\n\n        return result;\n    }\n}\n```\n\n## 외계인 메서드 예외 발생\n\n위의 예시는 눈으로 보기에 잘 작동할 것 같다.\n그럼 한 번 테스트를 해보도록 하자.\n\n```java\npublic static void main(String[] args) {\n    ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>());\n\n    set.addObserver(new SetObserver<>() {\n        public void added(ObservableSet<Integer> s, Integer e) {\n            System.out.println(e);\n            \n            if (e == 23)\n                s.removeObserver(this);\n        }\n    });\n\n    for (int i=0; i<100; i++)\n        set.add(i);\n}\n```\n\n0 부터 99까지의 수를 집합에 추가하면서 출력하다가, 그 값이 23이면 자기 자신을 제거하는 관찰자에 대한 코드이다.\n예상대로라면 0부터 23까지 출력한 후 관찰자 자신을 구독해지한 다음 프로그램이 종료되어야 한다.\n하지만 이 프로그램은 23까지 출력한 다음 `ConcurrentModificationException`을 던지며 종료된다.\n\n그 이유는 `added` 메서드가 `ObservableSet`의 `removeObserve` 메서드를 호출하고,\n이 메서드는 다시 `observers.remove` 메서드를 호출하는데,\n`notifyElementAdded`가 관찰자들의 리스트를 순회하는 도중이기 때문이다.\n\n즉, 리스트에서 원소를 제거하려는데 현재 이 리스트를 순회하고 있어 허용되지 않은 동작이므로 예외가 발생한 것이다.\n\n## 외계인 메서드 교착상태 발생\n\n이번에는 구독해지를 하는 관찰자를 작성하는데 `removeOberserver`를 직접 호출하지 않고,\n실행자 서비스(`ExecutorService`)를 이용하여 다른 스레드한테 위임하여 호출할 것이다.\n\n```java\nset.addObserver(new SetObserver<>() {\n    public void added(ObservableSet<Integer> s, Integer e) {\n        System.out.println(e);\n\n        if (e == 23) {\n            ExecutorService exec = Executors.newSingleThreadExecutor();\n\n            try {\n                exec.submit(() -> s.removeObserver(this)).get(); // Deadlock 발생\n            } catch (ExecutionException | InterruptedException ex) {\n                throw new AssertionError(ex);\n            } finally {\n                exec.shutdown();\n            }\n        }\n    }\n})\n```\n\n이 프로그램을 실행하면 예외는 나지 않지만 교착상태에 빠진다.\n\n이유는 백그라운드 스레드가 `s.removeObserver`를 호출하면 `synchronized` 키워드에 의해 관찰자를 잠그려 시도하지만,\n이미 메인 스레드가 락을 쥐고 있기 때문에 락을 얻을 수 없다.\n\n그와 동시에 메인 스레드는 `get()`으로 백그라운드 스레드가 관찰자를 제거하지만을 기다리는 중이다.\n\n따라서 해당 부분에서 프로그램은 교착상태(Deadlock)이 발생하게 된다.\n\n## 예외 발생과 교착상태 해결\n\n그럼 어떻게 이러한 문제를 해결할 수 있을까?\n위의 두 예시에서 발생한 예외와 교착 상태를 해결하기 위해서는 외계인 메서드 호출을 동기화 블록 바깥은 옮기면 된다.\n\n```java\nprivate void notifyElementAdded(E element) {\n    List<SetObserver<E>> snapshot = null;\n    synchronized(observers) {\n        snapshot = new ArrayList<>(observers);\n    }\n    for (SetObserver<E> observer : snapshot)\n        observer.added(this, element);\n}\n```\n\n외계인 메서드는 얼마나 오래 실행할 지 알 수가 없는데,\n거기에 동기화 영역 안에서 호출된다면 다른 스레드는 자원을 사용하지 못하고 대기해야 한다.\n\n하지만 위와 같이 동기화 영역 밖에서 호출하는 방식을 통해 동시성 효율을 크게 개선할 수 있다.\n\n이러한 방식을 열린 호출이라고 한다.\n\n그리고 이것보다 더 나은 방법도 존재한다.\n자바의 동시정 컬렉션 라이브러리인 `CopyOnWriteArrayList`를 사용하는 것이다.\n이름이 말해주듯 `ArrayList`를 구현한 클래스로, 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행하도록 구현했다.\n이러한 이유로 다른 용도로 쓰인다면 끔찍이 느리겠지만, 수정한 일은 드물고 순회만 빈번히 일어나는 관찰자 리스트 용도로는 최적이다.\n\n`ObservableSet`을 `CopyOnWriteArrayList`를 사용해 다시 구현하면 다음과 같이 바꿀 수 있다.\n\n```java\nprivate final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();\n\npublic void addObserver(SetObserver<E> observer) {\n    observers.add(observer);\n}\n\npublic boolean removeObserver(SetObserver) {\n    return observers.remove(observer);\n}\n\nprivate void notifyElementAdded(E element) {\n    for (SetObserver<E> observer : observers)\n        observer.added(this, element);\n}\n```\n\n## 성능 측면에서의 동기화 문제점\n\n자바의 동기화 비용은 빠르게 낮아져 왔지만, 과도한 동기화를 피하는 일은 오히려 과거 어느 때보다 중요해졌다.\n\n과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니다.\n경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 일고 모든 코어가 메모리를 일관되게 보기 위한 지연 시간이 진짜 비용이다.\n\n또한, 가상머신의 코드 최적화를 제한한다는 점도 과도한 동기화의 또 다른 숨은 비용이다.\n\n## 가변 클래스를 작성하는 방법\n\n가변 클래스를 작성하기 위해서는 다음 두 선택지 중 하나를 따른다.\n\n첫 번째, 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.\n- ex. java.util (Vector, Hashtable 제외), StringBuilder\n\n두 번째, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.\n- ex. java.util.concurrent, StringBuffer\n  이 경우처럼 클래스를 내부에서 동기화하기로 했다면,\n  락 분할(lock splitting), 락 스트라이핑(lock striping), 비차단 동시성 제어(nonblocking concurrency control) 등 다양한 기법을 동원해 동시성을 높여줄 수 있다.\n\n여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화해야 한다.\n\n이 정적필드가 `private`이라도 서로 관련 없는 스레드들이 동시에 읽고 수정할 수 있게 된다.\n\n사실상 전역 변수와 같아진다.\n전에 예로 들었던 `generateSerialNumber` 메서드에서 쓰인 `nextSerialNumber` 필드가 바로 이러한 예시이다.\n\n```java\nprivate static int nextSerialNumber = 0;\n\npublic static synchronized int generateSerialNumber() {\n     return nextSerialNumber++; \n}\n```\n\n## 정리\n\n교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.\n일반화해 이야기하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자.\n또한 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자.\n멀티코어 세상인 지금은 과도한 동기화를 피하는 게 과거 어느 때보다 중요하다.\n합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자."},{"excerpt":"저번에 서버에 대한 악성 공격으로 인한 대응 처리를 했다.\nFail2Ban을 통해 악성 공격을 차단하는 방법을 사용했는데 사실 이게 잘 작동하는지 확인하려면 로그를 계속 확인해야 했다.\n그래서 이번에는 Fail2Ban이 잘 동작하고 있는지, 그리고 서버에 대한 상태를 체크하고 알림을 받아 미리 대응할 수 있도록 해보려고 한다.\n이 글에서는 이러한 알림 서…","fields":{"slug":"/fail2ban-alert/"},"frontmatter":{"date":"March 04, 2025","title":"Fail2Ban의 상태를 Slack Webhhook 처리하기","tags":["Server","AWS"]},"rawMarkdownBody":"\n저번에 서버에 대한 악성 공격으로 인한 대응 처리를 했다.\nFail2Ban을 통해 악성 공격을 차단하는 방법을 사용했는데 사실 이게 잘 작동하는지 확인하려면 로그를 계속 확인해야 했다.\n그래서 이번에는 Fail2Ban이 잘 동작하고 있는지, 그리고 서버에 대한 상태를 체크하고 알림을 받아 미리 대응할 수 있도록 해보려고 한다.\n이 글에서는 이러한 알림 서비스를 만들어서 서버에 대한 상태를 체크하는 방법에 대해 기록하고 유사한 상황에 놓인 다른 개발자들에게 도움을 드리고자 정리한다.\n\n## 슬랙 웹훅 생성\n\n먼저 Slack에서 알림을 받을 채널을 생성한 후, Webhook URL을 발급받아야 한다.\n\n1. Slack Webhook에서 Incoming Webhooks 추가\n2. Webhook을 설정한 채널 선택 후, Webhook URL을 생성\n3. 생성된 URL을 복사하여 사용한다. \n\nURL은 `https://hooks.slack.com/services/~` 이런 형식이다.\n\n### 스크립트 작성\n\n이제 알림을 받을 곳을 설정했으니, 알림을 보낼 스크립트를 작성해야 한다.\nFail2Ban이 특정 IP를 차단할 때 Slack으로 알림을 보내도록 설정하려면,\nFail2Ban의 action.d 디렉터리에 새로운 액션을 추가해야 한다.\n경로는 `/etc/fail2ban/action.d/`이다.\n\n```shell\n[Definition]\n# Option:  actionstart\n# Notes.:  command executed once at the start of Fail2Ban.\n# Values:  CMD\n#\nactionstart = curl -s -o /dev/null -X POST --data-urlencode \"payload={\\\"text\\\": \\\"Fail2Ban (<name>) jail has started\\\", \\\"channel\\\": \\\"#<slack_channel>\\\" }\" <slack_webhook_url>\n\n# Option:  actionstop\n# Notes.:  command executed once at the end of Fail2Ban\n# Values:  CMD\n#\nactionstop = curl -s -o /dev/null -X POST --data-urlencode \"payload={\\\"text\\\": \\\"Fail2Ban (<name>) jail has stopped\\\", \\\"channel\\\": \\\"#<slack_channel>\\\" }\" <slack_webhook_url>\n\n# Option:  actioncheck\n# Notes.:  command executed once before each actionban command\n# Values:  CMD\n#\nactioncheck =\n\n# Option:  actionban\n# Notes.:  command executed when banning an IP. Take care that the\n#          command is executed with Fail2Ban user rights.\n# Tags:    <ip>  IP address\n#          <failures>  number of failures\n#          <time>  unix timestamp of the ban time\n# Values:  CMD\n#\nactionban = curl -s -o /dev/null -X POST --data-urlencode \"payload={\\\"text\\\": \\\"Fail2Ban Alert(<name>)\\n Banned IP: *<ip>*\\n Failures: <failures> failure(s)\\n Timestap: <time>\\\"}\" <slack_webhook_url>\n\n# Option:  actionunban\n# Notes.:  command executed when unbanning an IP. Take care that the\n#          command is executed with Fail2Ban user rights.\n# Tags:    <ip>  IP address\n#          <failures>  number of failures\n#          <time>  unix timestamp of the ban time\n# Values:  CMD\n#\nactionunban = curl -s -o /dev/null -X POST --data-urlencode \"payload={\\\"text\\\": \\\"Fail2Ban Alert(<name>)\\n Unbanned IP: *<ip>*\\\"}\" <slack_webhook_url>\n\n[Init]\n\ninit = 'Sending notification to Slack'\n\n# Put the values here without quotation marks\n# The channel name should be without the leading # too!\nslack_webhook_url = \"https://hooks.slack.com/services/~\"\n```\n\n위 스크립트의 구성을 간단히 설명하면 다음과 같다. \n\n- `actionstart`: Fail2Ban이 시작될 때 알림을 보낸다.\n- `actionstop`: Fail2Ban이 종료될 때 알림을 보낸다.\n- `actionban`: IP가 차단될 때 알림을 보낸다.\n- `actionunban`: IP가 차단 해제될 때 알림을 보낸다.\n- `slack_webhook_url`: Slack Webhook URL을 설정한다.\n\n이제 행위를 정의했으니, 이제 Fail2Ban 설정 파일에 이를 적용해야 한다.\n\n## Fail2Ban 설정\n\nFail2Ban 설정 파일은 `/etc/fail2ban/jail.local`에 위치해 있다.\n이 파일을 열어서 다음과 같이 설정을 추가한다.\n\n```shell\n[nginx-bad-request]\nenabled = true\nfilter = nginx-bad-request\nlogpath = /var/log/nginx/access.log\nmaxretry = 10\nfindtime = 1m\nbantime = 10m\naction = slack-notify\n```\n\n위 설정을 간단히 설명하자면 다음과 같다.\n\n- `enabled`: 해당 설정을 사용할지 여부를 나타낸다.\n- `filter`: 사용할 필터를 지정한다.\n- `logpath`: 필터링할 로그 파일을 지정한다.\n- `maxretry`: 허용할 최대 실패 횟수를 의미한다.\n- `findtime`: 실패 횟수를 체크할 시간을 의미한다.\n- `bantime`: 차단 시간을 의미한다.\n- `action`: 사용할 액션을 지정한다.\n- `slack-notify`: 액션을 사용할 때 설정한 이름이다.\n\n이렇게 설정을 했으면 이제 Fail2Ban을 재시작하면 된다.\n\n```shell\nsudo systemctl restart fail2ban\n```\n\n이제 Nginx에서 400, 403과 같은 비정상적인 요청을 감지하면 Slack으로 알림이 전송된다.\n\n그리고 혹시 테스트를 해보고 싶으면 다음과 같이하면 된다.\n\n```shell\nsudo fail2ban-client set nginx-bad-request banip 1.2.3.4\n```\n\n위 명령어를 실행하면 해당 IP가 차단되고, Slack으로 알림이 전송될 것이다.\n\n```shell\nFail2Ban Alert(nginx-bad-request)\nUnbanned IP: 1.2.3.4\n```\n\n## 참고\n\n- [Reddit, This is how we are using fail2ban notifications and Slack](https://www.reddit.com/r/linuxadmin/comments/3xslx0/this_is_how_we_are_using_fail2ban_notifications/)\n- [Nihisil, Send notifications to the Slack from fail2ban](https://gist.github.com/Nihisil/29fd2971c9dd109ae245)\n- [Cole Turner, fail2ban-slack-action](https://github.com/coleturner/fail2ban-slack-action)"},{"excerpt":"왜 알림이 필요할까? 저번에 서버에 대한 악성 공격으로 인해 스프링 애플리케이션을 올려놓은 컨테이너의 리소스 사용량이 급격히 증가하다가 결국 OOM(Out Of Memory) 이슈로 서버가 다운되었던 경험이 있었다.\n그래서 Nginx 단에서 필터링을 적용하고, Fail2Ban을 통해 악성 공격을차단하는 방법을 사용했다\n하지만 이건 악성 공격에 대한 대응이…","fields":{"slug":"/ec2-cron-alert/"},"frontmatter":{"date":"March 03, 2025","title":"서버 장애를 대비해 서버 리소스에 대한 Slack Webhook 처리하기","tags":["Server","AWS"]},"rawMarkdownBody":"\n## 왜 알림이 필요할까?\n\n저번에 서버에 대한 악성 공격으로 인해 스프링 애플리케이션을 올려놓은 컨테이너의 리소스 사용량이 급격히 증가하다가 결국 OOM(Out Of Memory) 이슈로 서버가 다운되었던 경험이 있었다.\n그래서 Nginx 단에서 필터링을 적용하고, Fail2Ban을 통해 악성 공격을차단하는 방법을 사용했다\n하지만 이건 악성 공격에 대한 대응이었고, 서버에 대한 상태를 체크하고 알림을 받아 미리 대응할 수 있도록 해야 한다고 생각했다.\n\n## 어떤 알림이 필요할까?\n\n먼저 서버 리소스에 대한 알림이 필수적으로 필요하다고 생각했다.\n그래서 생각한 알림은 다음과 같다.\n\n- CPU 사용률이 임계치를 초과했을 때\n- 메모리 사용량이 급증하여 OOM 발생 가능성이 높을 때\n- 디스크 사용량이 일정 임계치를 초과했을 때\n\n그리고 컨테이너 자체에 대한 알림도 필요하다고 생각했다.\n컨테이너가 중지되거나 컨테이너의 CPU 및 메모리 사용량이 비정상적으로 증가했을 때 알림을 받기로 했다.\n\n이제 어떤 알림을 받을지 결정했고, 그럼 어떻게 알림 서비를 만들어야 할까를 생각을 봐야한다.\n필자는 앞선 글에서 Slack을 사용하여 알림을 받았기 때문에 이번에도 Slack을 사용하여 알림을 받기로 했다.\n이후에 Prometheus + Grafana로 확장할 예정이며, AWS CloudWatch도 고려할 수도 있을 것 같다.\n\n## 슬랙 웹훅 생성\n\nSlack 채널에서 Webhook을 생성한 후, 해당 URL을 사용하여 슬랙 알림을 받을 수 있다.\n방법은 다음과 같다.\n\n1. Slack 앱에서 Incoming Webhooks 추가\n2. Webhook을 설정한 채널 선택 후, Webhook URL을 생성\n\n여기서 생성되는 URL의 예시는 `https://hooks.slack.com/services/~` 이런 형식이다. \n참고하길 바란다.\n\n### 스크립트 작성\n\n이제 알림을 받을 곳을 설정했으니, 알림을 보낼 스크립트를 작성해야 한다.\n\n먼저 서버 리소스 모니터링 스크립트이다.\n앞서 언급한 대로 서버의 CPU, 메모리, 디스크 사용량을 모니터링하고, 임계치를 초과했을 때 슬랙 알림을 받을 수 있도록 작성했다.\n\n\n\n```shell\n#!/bin/bash\n\n# Slack Webhook URL (수정 필요)\nWEBHOOK_URL=\"https://hooks.slack.com/services/~\"\n\n# Server Information\nHOSTNAME=$(hostname)\nTIMESTAMP=$(date \"+%Y-%m-%d %H:%M:%S\")\n\n# System Metrics\nCPU_USAGE=$(top -bn1 | grep \"Cpu(s)\" | awk '{print $2 + $4}')\nMEMORY_USAGE=$(free -m | awk '/Mem/{printf \"%.2f\", $3/$2 * 100}')\nDISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')\nLOAD_AVG=$(uptime | awk -F'load average:' '{print $2}' | xargs)\nUPTIME=$(uptime -p)\nACTIVE_PROCESSES=$(ps aux | wc -l)\n\n# Thresholds\nCPU_THRESHOLD=80\nMEMORY_THRESHOLD=90\nDISK_THRESHOLD=90\n\n# Slack Notification Function\nsend_slack_notification() {\n    MESSAGE=$1\n    PAYLOAD=\"{\\\"text\\\": \\\"[Server Alert] \\n${MESSAGE}\\\"}\"\n    curl -X POST --data-urlencode \"payload=${PAYLOAD}\" \"$WEBHOOK_URL\"\n}\n\n# CPU Usage Check\nif (( $(echo \"$CPU_USAGE > $CPU_THRESHOLD\" | bc -l) )); then\n    send_slack_notification \"High CPU Usage Detected: ${CPU_USAGE}%\\nLoad Average: ${LOAD_AVG}\"\nfi\n\n# Memory Usage Check\nif (( $(echo \"$MEMORY_USAGE > $MEMORY_THRESHOLD\" | bc -l) )); then\n    send_slack_notification \"High Memory Usage Detected: ${MEMORY_USAGE}%\\nActive Processes: ${ACTIVE_PROCESSES}\"\nfi\n\n# Disk Usage Check\nif (( DISK_USAGE > DISK_THRESHOLD )); then\n    send_slack_notification \"High Disk Usage Detected: ${DISK_USAGE}%\\nSystem Uptime: ${UPTIME}\"\nfi\n```\n\n위의 스크립트는 다음과 같은 내용을 포함하고 있다.\n\n- `WEBHOOK_URL=\"https://hooks.slack.com/services/~\"`: 슬랙 웹훅 URL을 설정하는 부분이다.\n- `HOSTNAME=$(hostname)`, `TIMESTAMP=$(date \"+%Y-%m-%d %H:%M:%S\")`: 서버 정보를 가져오는 부분이다. 여기서 호스트 이름과 타임스탬프를 가져와 포맷팅을 한다.\n- `CPU_USAGE=$(top -bn1 | grep \"Cpu(s)\" | awk '{print $2 + $4}')`: CPU 사용량을 가져오는 부분이다. `top` 명령어를 사용하여 CPU 사용량을 가져온다.\n- `MEMORY_USAGE=$(free -m | awk '/Mem/{printf \"%.2f\", $3/$2 * 100}')`: 메모리 사용량을 가져오는 부분이다. `free` 명령어를 사용하여 메모리 사용량을 가져온다.\n- `DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')`: 디스크 사용량을 가져오는 부분이다. `df` 명령어를 사용하여 디스크 사용량을 가져온다.\n- `LOAD_AVG=$(uptime | awk -F'load average:' '{print $2}' | xargs)`: 시스템 부하를 가져오는 부분이다. `uptime` 명령어를 사용하여 시스템 부하를 가져온다.\n- `UPTIME=$(uptime -p)`: 시스템 업타임을 가져오는 부분이다. `uptime` 명령어를 사용하여 시스템 업타임을 가져온다.\n- `ACTIVE_PROCESSES=$(ps aux | wc -l)`: 활성 프로세스 수를 가져오는 부분이다. `ps` 명령어를 사용하여 활성 프로세스 수를 가져온다.\n- `CPU_THRESHOLD=80`, `MEMORY_THRESHOLD=90`, `DISK_THRESHOLD=90`: CPU, 메모리, 디스크 사용률의 임계치를 설정한다.\n- `send_slack_notification()`: 실질적으로 슬랙 알림을 보내는 함수이다.\n- `if (( $(echo \"$CPU_USAGE > $CPU_THRESHOLD\" | bc -l) )); then`: CPU 사용량이 설정한 임계치를 초과했을 때 감지하는 부분이다.\n- `send_slack_notification \"High CPU Usage Detected: ${CPU_USAGE}%\\nLoad Average: ${LOAD_AVG}\"`: 그리고 이 부분이 진짜 슬랙 알림을 보내는 부분이다.\n\n```shell\n#!/bin/bash\n\n# Slack Webhook URL\nWEBHOOK_URL=\"https://hooks.slack.com/services/~\"\n\n# Thresholds\nCPU_THRESHOLD=80\nMEMORY_THRESHOLD=90\n\n# Function to send Slack notifications\nsend_slack_notification() {\n    MESSAGE=$1\n    PAYLOAD=\"{\\\"text\\\": \\\"[Docker Alert] \\n${MESSAGE}\\\"}\"\n    curl -X POST --data-urlencode \"payload=${PAYLOAD}\" \"$WEBHOOK_URL\"\n}\n\n# Get running containers\nCONTAINERS=$(docker ps --format \"{{.Names}}\")\n\n# Check container statuses\nfor CONTAINER in $CONTAINERS; do\n    STATUS=$(docker inspect --format '{{.State.Status}}' \"$CONTAINER\")\n\n    # Send alert if container is not running\n    if [ \"$STATUS\" != \"running\" ]; then\n        send_slack_notification \"Container stopped: $CONTAINER (Status: $STATUS)\"\n    fi\n\n    # Get CPU and memory usage\n    STATS=$(docker stats --no-stream --format \"{{.CPUPerc}} {{.MemPerc}}\" \"$CONTAINER\")\n    CPU_USAGE=$(echo \"$STATS\" | awk '{print $1}' | sed 's/%//')\n    MEMORY_USAGE=$(echo \"$STATS\" | awk '{print $2}' | sed 's/%//')\n\n    # Send alert if CPU usage exceeds threshold\n    if (( $(echo \"$CPU_USAGE > $CPU_THRESHOLD\" | bc -l) )); then\n        send_slack_notification \"High CPU usage detected: $CONTAINER - ${CPU_USAGE}%\"\n    fi\n\n    # Send alert if memory usage exceeds threshold\n    if (( $(echo \"$MEMORY_USAGE > $MEMORY_THRESHOLD\" | bc -l) )); then\n        send_slack_notification \"High memory usage detected: $CONTAINER - ${MEMORY_USAGE}%\"\n    fi\ndone\n```\n\n위의 스크립트도 앞서 작성한 스크립트와 유사한 부분이 많다.\n이 부분에 대해서 위에서 설명한 내용과 중복되는 부분도 있지만, 그래도 포함해서 간단하게 설명하면 다음과 같다.\n\n- `WEBHOOK_URL=\"https://hooks.slack.com/services/~\"`: 슬랙 웹훅 URL을 설정하는 부분이다.\n- `CPU_THRESHOLD=80`, `MEMORY_THRESHOLD=90`: CPU, 메모리 사용률의 임계치를 설정한다.\n- `send_slack_notification()`: 실질적으로 슬랙 알림을 보내는 함수이다.\n- `CONTAINERS=$(docker ps --format \"{{.Names}}\")`: 실행 중인 컨테이너 목록을 가져오는 부분이다.\n- `STATUS=$(docker inspect --format '{{.State.Status}}' \"$CONTAINER\")`: 컨테이너 상태를 가져오는 부분이다.\n- `STATS=$(docker stats --no-stream --format \"{{.CPUPerc}} {{.MemPerc}}\" \"$CONTAINER\")`: 컨테이너의 CPU 및 메모리 사용량을 가져오는 부분이다.\n- `CPU_USAGE=$(echo \"$STATS\" | awk '{print $1}' | sed 's/%//')`: 컨테이너의 CPU 사용량을 가져오는 부분이다.\n- `MEMORY_USAGE=$(echo \"$STATS\" | awk '{print $2}' | sed 's/%//')`: 컨테이너의 메모리 사용량을 가져오는 부분이다.\n- `if (( $(echo \"$CPU_USAGE > $CPU_THRESHOLD\" | bc -l) )); then`: CPU 사용량이 설정한 임계치를 초과했을 때 감지하는 부분이다.\n- `send_slack_notification \"High CPU usage detected: $CONTAINER - ${CPU_USAGE}%\"`: 그리고 이 부분이 진짜 슬랙 알림을 보내는 부분이다.\n\n자 이제, 스크립트를 작성을 마쳤다.\n그럼 이 스크립트들을 스케줄링을 통해 주기적으로 실행하도록 하기 위한 크론탭을 만들어 보겠다.\n아 그 전에 자신이 사용하는 Slack Webhook URL이 올바르게 동작하는지 별도로 테스트를 하고 싶으면 아래 명령어처럼 사용하면 된다.\n\n```shell\ncurl -X POST --data-urlencode \"payload={\\\"text\\\": \\\"Test Alert from Server\\\"}\" \"https://hooks.slack.com/services/~\"\n```\n\n### 크론탭 설정\n\n먼저 크론탭에 대해서 간단히 설명하자면, 리눅스 시스템에서 주기적으로 실행되는 작업을 설정할 수 있는 스케줄러이다.\n본격적으로 크론탭을 편집하기 위해 다음 명령어를 실행한다.\n\n```shell\ncrontab -e\n```\n\n이렇게 하면 기본 편집기가 열리는데, 여기에 아래 스크립트를 추가하면 된다.\n\n```shell\n*/10 * * * * /usr/local/bin/docker-monitor.sh >> /var/log/docker-monitor.log 2>&1\n*/10 * * * * /usr/local/bin/server-monitor.sh >> /var/log/server-monitor.log 2>&1\n``` \n\n위의 스크립트도 간단히 설명하자면, \n\n- `*/10 * * * *`: 10분마다 실행하도록 설정한 부분이다.\n- `/usr/local/bin/docker-monitor.sh >> /var/log/docker-monitor.log 2>&1`: 스크립트 실행 결과를 `/var/log/docker-monitor.log` 파일에 저장한다.\n\n필자는 위 내용처럼 10분마다 스크립트를 실행하도록 설정했다.\n\n이 부분에서 주의해야 할 점은, 크론탭을 설정할 때 크론식도 잘 설정했고, 스크립트도 잘 작성했는데,\n실행하지 못하고 있을 수도 있다.\n이때는 꼭 `ls -al`로 스크립트와 실행 권한이 있는지 확인해 보길 바란다.\n\n```shell\n-rwxr-xr-x  1 root root 1719 Mar 10 05:51 docker-monitor.sh\n-rwxr-xr-x  1 root root 1326 Mar 10 07:36 server-monitor.sh\n```\n\n위와 같이 파일에 x가 있어야 실행 권한이 있는 것이다.\n왜 이렇게 하는지 모르겠다면, 개발자의 기본 교양인 리눅스 기본 명령어를 공부해야 할 필요가 있다.\n\n아무튼 다시 돌아와서 만약에 없다면, 다음과 같이 실행 권한을 추가하면 된다.\n\n```shell\nsudo chmod +x /usr/local/bin/docker-monitor.sh\nsudo chmod +x /usr/local/bin/server-monitor.sh\n```\n\n이렇게 하면 실행 권한이 추가되어 크론탭이 정상적으로 실행될 것이다.\n\n만약 컨테이너 중지가 감지되면, 다음과 같은 메시지를 설정한 슬랙 채널로 받게 될 것이다.\n\n```less\n[Docker Alert]\nContainer stopped: jovial_mestorf\nStatus: exited\nExit Code: 137\nError: No specific error message\n```\n\n## 참고\n\n- [Slack Incoming Webhooks](https://api.slack.com/messaging/webhooks)\n- [Slack Webhook API](https://jojoldu.tistory.com/552)\n- [Cron Tab](https://crontab.guru/)"},{"excerpt":"최근 개발 중인 서버에 무수히 많은 에러 로그와 트래픽이 발생하는 이슈가 발생했다.\n이는 찾아보니 디렉토리 스캔 공격이었고,\n이 글에서는 이러한 이슈를 어떻게 대응했는지에 대해 기록하고자 한다.\n그리고 이를 통해 다른 개발자들이 비슷한 이슈에 대해 대응하는데 도움이 되길 바란다. 어떤 로그가 있었나? CI/CD 파이프 라인을 구축하고 개발 서버 로그를 확…","fields":{"slug":"/static-resources-attack/"},"frontmatter":{"date":"February 28, 2025","title":"디렉토리 스캔 공격은 어떻게 대응해야 할까?","tags":["Server","Nginx","Fail2Ban","TroubleShooting"]},"rawMarkdownBody":"\n최근 개발 중인 서버에 무수히 많은 에러 로그와 트래픽이 발생하는 이슈가 발생했다.\n이는 찾아보니 디렉토리 스캔 공격이었고,\n이 글에서는 이러한 이슈를 어떻게 대응했는지에 대해 기록하고자 한다.\n그리고 이를 통해 다른 개발자들이 비슷한 이슈에 대해 대응하는데 도움이 되길 바란다.\n\n## 어떤 로그가 있었나?\n\nCI/CD 파이프 라인을 구축하고 개발 서버 로그를 확인하던 중, 다음과 같은 로그를 발견했다.\n\n```bash\n193.41.206.72 - - [28/Feb/2025:11:59:01 +0000] \"GET /.env HTTP/1.1\" 301 178 \"-\" \"-\" \"-\"\"0.000\"\n193.41.206.72 - - [28/Feb/2025:11:59:02 +0000] \"GET .env HTTP/1.1\" 400 166 \"-\" \"-\" \"-\"\"0.249\"\n193.41.206.72 - - [28/Feb/2025:11:59:03 +0000] \"GET /vendor/.env HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.008\"\n193.41.206.72 - - [28/Feb/2025:11:59:03 +0000] \"GET /prod/.env.bak HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.011\"\n193.41.206.72 - - [28/Feb/2025:11:59:03 +0000] \"GET /prod/config.env HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.006\"\n193.41.206.72 - - [28/Feb/2025:11:59:03 +0000] \"GET /prod/.env.dist HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.004\"\n193.41.206.72 - - [28/Feb/2025:11:59:04 +0000] \"GET /prod/.env.dev HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.006\"\n193.41.206.72 - - [28/Feb/2025:11:59:04 +0000] \"GET /product/.env.bak HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.005\"\n193.41.206.72 - - [28/Feb/2025:11:59:04 +0000] \"GET /product/config.env HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.011\"\n193.41.206.72 - - [28/Feb/2025:11:59:04 +0000] \"GET /product/.env.dist HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.005\"\n193.41.206.72 - - [28/Feb/2025:11:59:05 +0000] \"GET /product/.env.dev HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.006\"\n193.41.206.72 - - [28/Feb/2025:11:59:05 +0000] \"GET /production/.env.bak HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.007\"\n193.41.206.72 - - [28/Feb/2025:11:59:05 +0000] \"GET /production/config.env HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.008\"\n193.41.206.72 - - [28/Feb/2025:11:59:05 +0000] \"GET /production/.env.dist HTTP/1.1\" 400 102 \"-\" \"-\" \"-\"\"0.006\"\n```\n\n현재 프로젝트와 전혀 무관한 정적 리소스 파일 경로였고, 비정상 적이게 많은 요청이 발생했다.\n위에 로그는 5초 동안의 로그이며, 1분간 계속해서 이러한 로그가 발생했다.\n특히, .env 같은 민감한 정보의 파일을 요청하는 로그가 많았다.\n만약 해당 파일이 노출된다면, 데이터베이스 접속 정보나 API 키 등이 유출될 수 있어 보안에 치명적인 문제가 될 수 있다.\n그래서 정황상 봇(bot)으로 자동화된 스캔 공격 시도로 판단하고, 이에 대한 대응을 진행하기로 했다.\n\n## 그래서 어떻게 대응했나?\n\n먼저 요청이 들어오는 입구를 도메인을 통한 요청으로만 중앙화하고,\n중앙화된 요청을 필터링을 통하여 관리하기로 했다.\n그래서 제일 먼저 AWS 보안 그룹 설정을 변경했다.\nHTTPS 전환 전까지 사용했던 HTTP(80) 포트를 삭제하고, HTTPS(443)만 허용하도록 변경했다.\n그리고 8080 포트를 VPC 내부에서만 접근 가능하도록 수정했고, 모든 트래픽 허용 규칙도 삭제했다.\n이들은 모두 앞서 진행했던 인프라 작업 후 불필요하게 열려있던 포트들이었다.\n설정을 마친 후 테스트도 진행했다.\n\n```bash\ncurl -I http://dev.unretired.co.kr  # 접속 제한\n```\n\nAWS Layer에서는 우선 이렇게 처리하고, 본격적으로 Nginx에서 보안 설정을 하고자했다.\n하지만, 혹시 모를 경우에 대비하여 근본적으로 현재 실행 중인 애플리케이션인 Spring Boot의 application.yml 설정을 변경하여 정적 리소스 서빙을 비활성화했다.\n\n```yaml\nspring.web.resources.add-mappings: false\n```\n\n이제 Nginx만 설정하면 당장 대응이 가능할 것으로 판단했다.\n위의 로그들을 보고 공격을 감행하던 경로를 패턴으로 설정하고, 해당 경로로 요청이 들어오면 403 Forbidden을 반환하도록 설정했다.\n\n```nginx\nlocation ~* \\.(env|config\\.env|aws/credentials|git|bak|old|dist|dev|local)$ {\n    deny all;\n    return 403;\n}\n```\n\n이렇게 설정을 마치고, curl 테스트를 진행했다.\n\n```bash\nHTTP/1.1 403 Forbidden\nServer: nginx/1.24.0 (Ubuntu)\nDate: Fri, 28 Feb 2025 14:11:51 GMT\nContent-Type: text/html\nContent-Length: 162\nConnection: keep-alive\n```\n\n이제 Nginx 설정은 잘 작동하는 것 같다.\n\n## 아직 끝이 아니다\n\n현재까지는 확인된 공격에 한해서만 대응한 것이었다.\n설정을 마친 후, 얼마 안가 Nginx 로그를 확인하니 다른 공격 시도가 있었다.\n그래서 이를 방지하기 위해 고민을 했고, 이렇게만 대응하면 안될 것 같아 찾아보았다.\n\n두 가지 방법을 찾았는데, AWS WAF(AWS Web Application Firewall)와 Fail2Ban이었다.\nAWS WAF는 악성 트래픽을 차단하는 AWS의 서비스로, 적용하는 방법도 간단했다.\n하지만 이렇게 설정하면 당연하게도 비용이 발생하고, 현재 상황에서는 이 정도의 대응이 필요한지 판단이 어려웠다.\n\n그래서 비정상적인 요청을 필터링 기능과 금전적인 자원이 들지 않는 선에서 다른 방법을 고민하게 되었고, Fail2Ban을 적용하기로 했다.\nFail2Ban은 로그를 모니터링하고, 설정한 패턴에 맞는 IP를 자동으로 차단하는 오픈소스 프로그램으로\n이를 통해 공격 시도를 차단할 수 있을 것으로 판단했다.\n\n## Fail2Ban 설정\n\nFail2Ban 구조에 대해 간단히 설명하자면 클라이언트와 서버로 이루어져 있다.\n여기서 서버는 멀티스레드이며 소켓을 받아 명령을 실행한다.\n그리고 클라이언트는 서버 구성 및 동작을 하기 위한 명령어들을 보낸다.\n그렇기에 이를 통해서 Fail2Ban의 기능들을 설정할 수 있다.\n\n실제로 차단(Ban)하는 방법에 대한 정책 규정은 `jail.local` 파일에 설정할 수 있다.\n사용자가 지정한 로그 파일들을 대상으로 필터링을 해서 규칙에 맞는 로그가 발생하면 해당 IP를 차단한다.\n기본적으로 많은 정책들이 있고, 이를 통해 다양한 공격 시도에 대응할 수 있다.\n추가로 감지 횟수와 차단 시간을 설정할 수 있어서, 이를 통해 더욱 세밀한 대응이 가능하다.\n이후 커스텀 액션이라는 개념이 존재해 정책에 맞는 작업을 수행하고 이메일 전송 같은 작업도 가능하게 되어있다.\n\n이제 설정해보자. 먼저 Fail2Ban을 설치하겠다.\n\n```bash\nsudo apt-get install fail2ban\n```\n\n그리고 필터링 설정 파일을 수정해야 한다.\n파일들은 기본적으로 `/etc/fail2ban/filter.d/`에 위치해있다.\n지금은 Nginx에 들어오는 로그를 필터링하고 차단하는 설정을 해야한다.\n이러한 설정은 `nginx-bad-request.conf`에서 기본 설정을 제공해주고 있다.\n400 Bad Request와 403 Forbidden 로그를 필터링해야 하기에 다음과 같이 설정했다.\n\n```ini\n[Definition]\nfailregex = ^<HOST> .* \"(GET|POST|HEAD|OPTIONS|PUT|DELETE|PATCH).*\" 400\n            ^<HOST> .* \"(GET|POST|HEAD|OPTIONS|PUT|DELETE|PATCH).*\" 403\nignoreregex =\n```\n\n설명하자면 `failregex`는 필터링할 로그의 패턴을 정의하는 부분이다.\n`<HOST>`는 IP를 의미하며, `400`과 `403`은 HTTP 상태 코드를 의미한다.\n이렇게 설정하면 400 Bad Request와 403 Forbidden 로그를 필터링할 수 있다.\n\n이제 설정 파일을 만들어야 한다.\n`/etc/fail2ban/jail.local` 파일을 만들어서 설정을 추가하자.\njail.local 파일은 jail.conf 파일을 오버라이드하는 설정 파일이다.\n이 파일에 설정을 추가하면 jail.conf 파일에 있는 설정을 덮어쓰게 된다.\n고로 jail.local 파일에 설정을 추가하자.\n\n```ini\n[nginx-bad-request]\nenabled = true\nfilter = nginx-bad-request\nlogpath = /var/log/nginx/access.log\nmaxretry = 10\nfindtime = 1m\nbantime = 10m\n```\n\n이 부분도 간단히 설명하자면 `enabled`는 해당 설정을 사용할지 여부를 나타내며, `filter`는 사용할 필터를 지정한다.\n`logpath`는 필터링할 로그 파일을 지정하고, `maxretry`는 허용할 최대 실패 횟수를 의미한다.\n`findtime`은 `maxretry`를 적용할 시간을 의미하며, `bantime`은 차단할 시간을 의미한다.\n여기서 설정 내용은 1분 동안 10번 이상의 400 Bad Request와 403 Forbidden 로그가 발생하면 해당 IP를 10분 동안 차단한다는 의미이다.\n왜 1분 동안 10번 이상으로 했냐하면 개발 서버이기에 프론트 서버 응답에 대한 테스트를 진행하고 있기 때문이다.\n배포였다면 좀 더 타이트하게 잡았을 것 같다.\n\n이렇게 해서 설정을 마치고, 적용하겠다.\n\n```bash\nsystemctl restart fail2ban\nfail2ban-client add nginx-bad-request\nfail2ban-client status nginx-bad-request\n```\n\n잘 돌아가는 지 상태 로그를 확인해보자.\n\n```bash\nStatus for the jail: nginx-bad-request\n|- Filter\n|  |- Currently failed:\t0\n|  |- Total failed:\t26\n|  `- File list: nginx-bad-request\n`- Actions\n   |- Currently banned:\t3\n   |- Total banned:\t5\n   `- Banned IP list:\n```\n\n이렇게 뜨면 설정이 잘 적용된 것이다.\n이제 이를 통해 공격 시도를 차단할 수 있을 것으로 기대한다.\n물론 근본적인 해결책은 아니기에 적용 후에도 문제가 된다면 WAF 등을 도입해볼 계획이다.\n\n## 참고\n\n- [How to define a location regex matching block in nginx.conf](https://stackoverflow.com/questions/65650622/how-to-define-a-location-regex-matching-block-in-nginx-conf)\n- [Nginx Security Best Practices](https://stackoverflow.com/questions/65650622/how-to-define-a-location-regex-matching-block-in-nginx-conf)\n- [AWS WAF Official Docs](https://docs.aws.amazon.com/waf/latest/developerguide/)\n- [Fail2Ban GitHub](https://github.com/fail2ban/fail2ban)\n- [Fail2Ban Official Docs](https://www.fail2ban.org/wiki/index.php/Main_Page)\n- [Sharing of fail2ban banned IPs](https://serverfault.com/questions/625656/sharing-of-fail2ban-banned-ips)\n"},{"excerpt":"자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공하고 있다.\n이 글에서는 이러한 검사 예외, 런타임 예외, 에러가 무엇이고 언제 사용해야 하는지 알아본다. 검사 예외 (Checked Exception) 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용해야 한다.\n검사 예외는 예외를…","fields":{"slug":"/item-70/"},"frontmatter":{"date":"February 27, 2025","title":"복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공하고 있다.\n이 글에서는 이러한 검사 예외, 런타임 예외, 에러가 무엇이고 언제 사용해야 하는지 알아본다.\n\n## 검사 예외 (Checked Exception)\n\n호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용해야 한다.\n검사 예외는 예외를 던지면 호출자가 그 예외를 `catch`로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.\n이러한 검사 예외는 메서드를 호출하는 쪽에서 회복하리라 여겨지는 상황에서 사용해야 하는데\n달리 말하면, API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구하는 것이다.\n\n## 비검사 예외 (Unchecked Exception)\n\n비검사 예외는 `RuntimeException`를 상속 받은 클래스로서, 런타임 시 프로그래밍 오류를 나타낼 때 사용한다.\n이런 `throwable`을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.\n런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.\n전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다.\n그 예로 배열 인덱스를 벗어나는 경우가 이에 해당한다.\n배열의 인덱스는 0에서 배열 크기 -1 사이여야 한다.\n`ArrayIndexOutOfBoundsException`이 발생했다는 건 이 전제 조건이 지켜지지 않았다는 뜻이다.\n\n## 에러 (Error)\n\n에러는 `Error`를 상속 받은 클래스로 보통 JVM이 자원부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.\n여기서 주의할 점은 Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하지 말아야 한다.\n다시 말해 우리가 구현하는 비검사 `throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다는 뜻이다..\n`Error`는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.(단, `AssertionError`는 예외이다.)\n\n## 검사 예외와 비검사 예외\n\n그럼 언제 검사 예외를 사용해야 하고, 언제 비검사 예외를 사용해야 할까?\n해당 고민은 API 설계자의 판단에 달려있는데 복구 가능하다고 생각하면 검사 예외를, 불가능하다면 비검사 예외를 사용해야 한다.\n만일 확신하기 어렵다면 비검사 예외를 사용하는 것이 좋다.(아이템 71)\n\n## 정리\n\n복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.\n확실하지 않다면 비검사 예외를 던지자.\n검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자.\n검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자."},{"excerpt":"테스트 진행 중, 프론트에서 로그아웃 API를 호출했을 때 에러가 발생하는 것을 발견했다.\n로그를 확인해보니 다음과 같은 오류가 나타났다. 해당 오류가 발생하는 이유와 해결 방법에 대해 알아보기 위해 찾아보았다.\n근데 찾아보니까 Spring Data JPA에서  메서드에서 와 가 사용하면 이 반드시 필요하다는 점을 알게 되었고, 현재 코드에는 가 없다는 …","fields":{"slug":"/annotation-modifying-with-transactional/"},"frontmatter":{"date":"February 25, 2025","title":"@Query와 @Modifying만 사용하면 될까?","tags":["Java","Spring","Troubleshooting"]},"rawMarkdownBody":"\n테스트 진행 중, 프론트에서 로그아웃 API를 호출했을 때 에러가 발생하는 것을 발견했다.\n로그를 확인해보니 다음과 같은 오류가 나타났다.\n\n```java\norg.springframework.dao.InvalidDataAccessApiUsageException: Executing an update/delete query;\nnested exception is javax.persistence.TransactionRequiredException: Executing an update/delete query\n``` \n\n해당 오류가 발생하는 이유와 해결 방법에 대해 알아보기 위해 찾아보았다.\n근데 찾아보니까 Spring Data JPA에서 `delete` 메서드에서 `@Query`와 `@Modifying`가 사용하면 `@Transactional`이 반드시 필요하다는 점을 알게 되었고, 현재 코드에는 `@Transactional`가 없다는 것을 알게 되었다.\n그렇다면 `@Modifying`을 사용할 때 `@Transactional`이 반드시 필요한 이유는 무엇일까? \n이를 이해하려면, 먼저 JPQL이 트랜잭션을 처리하는 방식을 알아야 한다. \n하지만 그 전에, Spring Data JPA의 기본 구현체인 `SimpleJpaRepository`가 트랜잭션을 어떻게 관리하는지 먼저 알아볼 필요가 있다.\n\n## SimpleJpaRepository는 어떻게 트랜잭션을 처리할까?\n\n일반적으로 `Repository` 클래스를 만들 때 `JpaRepository`를 확장해서 사용한다.\n그리고 이러한 Custom Repository를 사용한 곳에서 디버그를 진행하면 `SimpleJpaRepository` 클래스가 `Proxy` 형태로 주입 되어 있는 것을 확인할 수 있다.\n그렇다면 `SimpleJpaRepository`에서는 트랜잭션이 어떻게 처리될까?\n해당 클래스의 내부를 보면 `@Transactional`을 이용하는 것을 알 수 있다.\n전역적으로 `@Transactional(readOnly = true)`이 걸려 있었고, `save()`, `delete()` 같은 메서드들은 별도로 `@Transactional`이 적용되어 있었다.\n\n```java\n@Repository\n@Transactional(readOnly = true)\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> {\n\n    @Override\n    @Transactional\n    @SuppressWarnings(\"unchecked\")\n    public void delete(T entity) { \n        ... \n    }\n\n    @Override\n    public Optional<T> findById(ID id) { \n        ... \n    }\n}\n```\n\n그래서 `SimpleJpaRepository`의 `save()`나 `delete()` 같은 메서드는 트랜잭션이 자동으로 적용되므로 별도의 `@Transactional` 설정 없이도 정상적으로 동작하는 것이다.\n\n## 그렇다면 JPQL을 이용한 메서드는?\n\n`SimpleJpaRepository`에 원하는 메서드가 지원되지 않는 경우,\n이때 JPQL로 작성하게 되는데 이때 **_Annotation to declare finder queries directly on repository query methods._**하기 위해 `@Query`를 사용한다.\n\n즉, `@Query` 어노테이션은 Spring Data JPA를 사용하여 DML을 수행하기 위해 쿼리를 직접 작성할 때 사용한다는 것이다.\nSpring Data JPA에서 `@Query`는 기본적으로 읽기 전용 트랜잭션을 사용한다.\n\n그래서 SELECT 쿼리를 실행할 때는 `@Transactional(readOnly = true)`가 필요 없다.\n하지만 `@Query`를 사용하여 `update`나 `delete` 같은 데이터의 상태를 변경하고자 쿼리를 실행할 때는 `@Modifying`을 명시적으로 추가해서 사용해야 한다.\n그렇지 않으면 런타임 시점에 에러가 발생한다.\n\n그럼 `@Modifying`만 사용하면 `update`나 `delete`가 될까?\n먼저, 공식 문서에서는 `@Modifying` 어노테이션에 대해 \n`Indicates a query method should be considered as modifying query as that changes the way it needs to be executed. This annotation is only considered if used on query methods defined through a Query annotation.`라고 설명하고 있다.\n\n즉, `@Query`로 작성된 쿼리가 직접 `update`나 `delete` 같은 데이터 변경 작업을 수행하는 메서드를 정의할 때 \n`@Modifying`을 추가하여 Spring Data JPA에 이 쿼리가 데이터베이스의 상태를 변경할 것임을 명시해야 한다는 것이다.\n더 자세히 보면, `@Modifying`은 `flushAutomatically`와 `clearAutomatically` 두 가지 설정을 제공하고 있다.\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n@Documented\npublic @interface Modifying {\n\n    /**\n     * Defines whether we should flush the underlying persistence context before executing the modifying query.\n     *\n     * @return\n     */\n    boolean flushAutomatically() default false;\n\n    /**\n     * Defines whether we should clear the underlying persistence context after executing the modifying query.\n     *\n     * @return\n     */\n    boolean clearAutomatically() default false;\n}\n```\n\n여기서 `flushAutomatically`는 `@Modifying` 쿼리 실헹 직전에 영속성 컨텍스트의 변경 내용을 자동으로 `flush`를 할지 결정한다.\n즉, 영속성 컨텍스트 내의 변경 사항을 데이터베이스에 자동으로 반영하는지 여부를 결정하는 작업이라고 보면 된다.\n이렇게 함으로써 쿼리 실행 전에 변경사항이 누락되지 않도록 할 수 있다.\n\n그리고 `clearAutomatically`는 `@Modifying` 쿼리 실행 후 영속성 컨텍스트를 자동으로 `clear`할지 결정한다.\n영속성 컨텍스트를 `clear`하는 것은 영속성 컨텍스트 내에서 관리하는 데이터를 초기화해서 이후의 데이터 조회 시 최신 상태를 반영하는 작업이라고 보면 된다.\n이를 통해 연산 후 발생할 수 있는 영속성 컨텍스트와 데이터베이스 간의 불일치를 방지할 수 있다.\n\n다시 돌아와서 왜 이런 설명을 했냐면 위의 설정을 보고 유추할 수 있는 것은\n기본적으로 `@Modifying`이 적용된 JPQL 쿼리는 실행될 때 영속성 컨텍스트의 변경 사항이 자동으로 데이터베이스에 반영되지 않는다는 것이다. \n즉, `flushAutomatically`와 같은 설정을 명시적으로 사용하지 않으면, JPQL을 통해 데이터가 변경되더라도 영속성 컨텍스트는 여전히 기존 데이터를 유지할 수 있다.\n즉, 기본 값으로만 설정을 한다면 데이터베이스와 영속성 컨텍스트의 정합성이 깨질 수 있다는 것이다.\n\n그래서 다음과 같이 `@Modifying`만 사용하고 별다른 설정없이 `update`나 `delete` 쿼리를 실행하면 \n처음에 언급한 `javax.persistence.TransactionRequiredException: Executing an update/delete query` 에러가 발생한다.\n즉, `update`나 `delete`를 수행하기 위해서는 트랜잭션이 필수적으로 존재해야하는데, 트랜잭션이 존재하지 않아서 발생하는 것이다.\n\n```java\npublic interface MemberTokenRepository extends JpaRepository<MemberToken, Long> {\n    @Modifying\n    @Query(\"delete from MemberToken m where m.member.id = :memberId and m.id = :tokenId\")\n    void deleteBy(\n            @Param(\"memberId\") Long memberId,\n            @Param(\"tokenId\") Long tokenId\n    );\n}\n```\n\n## 그렇다면 어떻게 해야할까?\n\n방법은 간단하다. `@Transactional`을 추가하면 된다.\n`@Transactional`을 추가하면 `@Modifying`이 있는 메서드에서도 트랜잭션이 적용되어 `update`나 `delete` 쿼리를 실행할 수 있다.\n\n```java\npublic interface MemberTokenRepository extends JpaRepository<MemberToken, Long> {\n    @Modifying\n    @Transactional\n    @Query(\"delete from MemberToken m where m.member.id = :memberId and m.id = :tokenId\")\n    void deleteBy(\n            @Param(\"memberId\") Long memberId,\n            @Param(\"tokenId\") Long tokenId\n    );\n}\n```\n\n그렇다면 꼭 `Repository`에 `@Transactional`을 추가해야 할까? \n사실 `@Transactional`의 기본 전파 속성이 `REQUIRED`이므로, \n`Service`에서 이미 트랜잭션이 시작된 경우 이를 그대로 사용할 수 있고,\n`Repository`에도 `@Transactional` 적용하면 트랜잭션 전파(Propagation) 설정이 복잡해질 수 있다.\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@Reflective\npublic @interface Transactional {\n    /**\n     * The transaction propagation type.\n     * <p>Defaults to {@link Propagation#REQUIRED}.\n     * @see org.springframework.transaction.interceptor.TransactionAttribute#getPropagationBehavior()\n     */\n    Propagation propagation() default Propagation.REQUIRED;\n}\n```\n  \n 그래서 개인적으로 일반적인 경우에는 `@Transactional`은 비즈니스 로직이나 서비스 계층에서 사용하는 것이 좋은 것 같다고 생각한다.\n\n> 만일 서비스 레이어에서 메서드 로직 중간에서 에러가 발생하면 `Rollback` 해야한다면, 서비스 레이어의 메서드에 `@Transactional`을 적용하면 된다.\n> 하지만 서비스 로직 중간에 에러가 발생해도 실행된 쿼리 단위로 `Rollback` 처리가 필요하다면, 서비스 레이어의 메서드에 `@Transactional(readOnly = true)`을 적용하고, `Repository`의 메서드에 `@Transactional`을 적용하면 된다.\n\n\n## 참고\n\n- [stackoverflow - Spring Data JPA Modifying annotation usage with transactional](https://stackoverflow.com/questions/69942873/spring-data-jpa-modifying-annotation-usage-with-transactional)\n- [stackoverflow - Do we need both Transactional and Modifying annotation in spring](https://stackoverflow.com/questions/48314475/do-we-need-both-transactional-and-modifying-annotation-in-spring)\n- [spring docs - Transactionality](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html)\n- [spring docs - Annotation Interface Query](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html)\n- [spring docs - Annotation Interface Modifying](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Modifying.html)"},{"excerpt":"@EnableWebMvc의 함정 CORS를 설정을 하면서 공식 문서에 샘플이 있길래 골자를 따와 안에 값만 수정해서 배포를 진행했다.\n하지만 프론트 쪽에서 응답 값의 직렬화가 작동하지 않는다는 이슈를 접하게 되었다.\n조금의 삽질을 하면서 가 문제라는 것을 알게 되었다. 그럼 @EnableWebMvc를 사용하면 어떻게 될까? 처음에는 를 본 지 하도 오래되…","fields":{"slug":"/enablewebmvc-jackson/"},"frontmatter":{"date":"February 24, 2025","title":"@EnableWebMvc 사용해도 될까?","tags":["Java","Spring","Troubleshooting"]},"rawMarkdownBody":"\n## @EnableWebMvc의 함정\n\nCORS를 설정을 하면서 공식 문서에 샘플이 있길래 골자를 따와 안에 값만 수정해서 배포를 진행했다.\n하지만 프론트 쪽에서 응답 값의 직렬화가 작동하지 않는다는 이슈를 접하게 되었다.\n조금의 삽질을 하면서 `@EnableWebMvc`가 문제라는 것을 알게 되었다.\n\n## 그럼 @EnableWebMvc를 사용하면 어떻게 될까?\n\n처음에는 `@EnableWebMvc`를 본 지 하도 오래되어서 왜 문제가 됐지 했다.\n이게 왜 문제인지 알기 전에 먼저 Spring Boot의 자동 구성 기능 알아야 한다.\nSpring Boot는 빠르게 개발할 수 있도록 자동 구성 기능 같은 많은 편의성을 제공한다.\n그 중 하나가 Spring MVC에 대한 자동 구성이고, Spring MVC의 기본값 외에도 자동 설정은 다양한 설정을 제공한다.\n\n- Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n- Support for serving static resources, including support for WebJars (covered later in this document).\n- Automatic registration of Converter, GenericConverter, and Formatter beans.\n- Support for HttpMessageConverters (covered later in this document).\n- Automatic registration of MessageCodesResolver (covered later in this document).\n- Static index.html support.\n- Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).\n\n> 자세한 내용은 [Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration)와 [WebMvcAutoConfiguration](https://docs.spring.io/spring-boot/api/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.html)를 참고하면 된다.\n\n아무튼 여기서 중요한 건 Spring MVC에 대한 자동 구성을 한다는 것이다.\n이러한 자동 구성 환경에서 `@EnableWebMvc`는 재앙이다.\nSpring Boot가 제공하는 자동 설정을 무시하게 만들기 때문이다.\n그니까 정리하자면,  `@EnableWebMvc`란 Spring Boot가 제공하는 자동 구성 기능을 비활성화하고,\n개발자가 수종적으로 Spring MVC 설정을 정의할 수 있는 어노테이션이다.\n즉, Spring Boot 내에서 담당했던 모든 설정을 개발자가 직접 해야 한다는 것이다.\n\n여기까지 읽어도 아직 왜 문제가 됐는지 모르겠다면, 자동 설정 기능에 대해 알아보길 권한다.\n다시 돌아와서 설명하자면, `@EnableWebMvc`를 사용하면 Spring Boot가 제공하는 자동 설정을 무시하게 되는데 \n이때 Spring Boot 내에서 사용 중인 Jackson 설정도 무시하게 된다.\n그래서 `application.yml`에 설정한 Jackson 설정조차 무시하게 되어서 프론트 쪽에서 응답 값의 직렬화가 작동하지 않는 것이다.\n\n내가 담당하던 클래스는 대충 아래랑 비슷한 코드였다.\n클래스에 `@EnableWebMvc`가 붙어 있었는데, 이래서 당연하게도 Jackson 설정이 비활성화 되어서 적용이 안되었던 것이다.\n\n```java\n@ControllerAdvice\n@EnableWebMvc\n@Profile(\"dev\")\npublic class DevCorsConfig extends WebMvcConfigurerAdapter {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n                .allowedOrigins(\"*\")\n                .allowedMethods(\"*\")\n                .allowedHeaders(\"Content-Type\", \"Authorization\")\n                .allowCredentials(true)\n                .maxAge(3600L);\n    }\n}\n```\n\n그래서 만일, `application.yml` 설정을 했는데도 직렬화가 안되는 경우가 생겼다면 `@EnableWebMvc` 설정이 되어 있는지를 확인해보자."},{"excerpt":"문자열(String)은 텍스트를 표현하도록 설계되었다. 자바에서 문자열은 텍스트를 표현하도록 설계되었지만,\n원래 의도하지 않은 용도로도 쓰이는 경향이 있다.\n이번 주제에서는 문자열을 쓰지 않아야 할 사례를 다룬다. 문자열은 다른 값 타입을 대신하기에 적합하지 않다. 많은 개발자들은 다양한 타입의 데이터를 받을 때 주로 문자열을 사용한다.\n하지만, 진짜 문…","fields":{"slug":"/item-62/"},"frontmatter":{"date":"February 23, 2025","title":"다른 타입이 적절하다면 문자열 사용을 피하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n\n## 문자열(String)은 텍스트를 표현하도록 설계되었다.\n\n자바에서 문자열은 텍스트를 표현하도록 설계되었지만,\n원래 의도하지 않은 용도로도 쓰이는 경향이 있다.\n이번 주제에서는 문자열을 쓰지 않아야 할 사례를 다룬다.\n\n## 문자열은 다른 값 타입을 대신하기에 적합하지 않다.\n\n많은 개발자들은 다양한 타입의 데이터를 받을 때 주로 문자열을 사용한다.\n하지만, 진짜 문자열일 때만 사용하는 것이 좋다.\n받은 데이터가 수치형이라면 int, float, BigInteger 등 적당한 타입을 사용해야 하고,\n예/아니오와 같은 질문의 답이라면 boolean을 사용해야 한다.\n즉, 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 만들어 사용하는 것이 좋다.\n\n## 문자열은 열거 타입을 대신하기에 적합하지 않다.\n\n아이템 34에서 다뤘듯이, 상수를 열거할 때는 문자열보다는 열거 타입이 월등히 낫다.\n열거 타입은 상수 데이터를 컴파일 타임에 알 수 있고, 타입 안전성을 제공하며, 이름을 프로그램 요소로 활용할 수 있다.\n하지만 상수를 문자열로 작성하는 경우 다음과 같이 예상치 못한 결과가 발생할 수 있다.\n\n```java\npublic String getFileExtension(String fileName) {\n    switch (fileName) {\n        case \"png\":\n            return \"PNG\";\n        ...\n        default:\n            return \"UNKNOWN\";\n    }\n}\n\ngetFileExtension(\"PNG\"); // UNKNOWN\ngetFileExtension(\"Png\"); // UNKNOWN\n```\n\n따라서 이런 상황에서는 문자열 대신 열거 타입을 정의해서 사용하는 것이 좋다.\n\n```java\npublic enum FileType {\n    PNG, JPG, GIF, UNKNOWN;\n}\n\npublic FileType getFileExtension(FileType fileType) {\n    switch (fileType) {\n        case PNG:\n            return FileType.PNG;\n        ...\n        default:\n            return FileType.UNKNOWN;\n    }\n}\n\ngetFileExtension(png); // 컴파일 에러 발생\n```\n\n## 문자열은 혼합 타입을 대신하기에 적합하지 않다.\n\n여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 경우도 있다.\n```java\nString compoundKey = className + \"#\" + i.next();\n```\n이런 경우에는 각 요소를 개별로 접근할 수 없고, 문자열을 파싱해야 한다.\n이때 파싱 과정에서 느리고, 귀찮고, 오류 가능성도 커진다.\n그리고 `equals`, `toString`, `compareTo` 같은 메서드를 제공할 수 없고, `String`이 제공하는 기능에만 의존해야 한다.\n그래서 차라리 [아이템 24](https://github.com/effective-java-3e-study/effective-java/blob/main/4%EC%9E%A5_%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/%EC%95%84%EC%9D%B4%ED%85%9C_24/%EB%A9%A4%EB%B2%84_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94_%EB%90%98%EB%8F%84%EB%A1%9D_static%EC%9C%BC%EB%A1%9C_%EB%A7%8C%EB%93%A4%EB%9D%BC.md)에서 언급했듯이, `private` 정적 멤버 클래스로 만드는 것이 좋다.\n\n## 문자열은 권한을 표현하기에 적합하지 않다.\n\n권한(capacity)을 문자열로 표현하는 경우가 있다.\n여기 `ThreadLocal` 클래스에서 문자열을 사용했다고 가정해본다.\n\n```java\npublic class ThreadLocal {\n    private ThreadLoacl() {} // 객체 생성 불가\n    \n    // 현 스레드의 값을 키로 구분해 저장한다.\n    public static void set(String key, Object value);\n    \n    // (키가 가리키는) 현 스레드의 값을 반환한다.\n    public static Object get(String key);\n}\n```\n\n이 방식의 문제는 스레드 구분용 키가 전역 이름공간에서 공유 된다는 점이다.\n만약, 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.\n만일 상대가 악의적인 클라이언트라면 의도적으로 같은 키를 사용하여 다른 클라이언트 값을 가져올 수도 있다.\n따라서 문자열 대신 위조할 수 없는 키를 사용해야 한다.\n\n```java\npublic class ThreadLocal {\n    private ThreadLocal() { } // 객체 생성 불가\n    \n    public static class key { // ((권한)\n        Key() { }\n    }\n    \n    // 위조 불가능한 고유 키를 생성한다.\n    public static Key getKey() {\n        return new Key();\n    }\n    \n    public static void set(Key key, Object value);\n    public static Object get(Key key);\n}\n```\n\n여기서 `set`과 `get`은 이제 정적 메서드일 이유가 없으므로 `Key` 클래스의 인스턴스 메서드로 바꿀 수 있다.\n이렇게 하면 `Key`는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 스레드 지역변수가 된다.\n\n```java\npublic final class ThreadLocal<T> {\n    public ThreadLocal();\n    public void set(T value);\n    public T get();\n}\n```\n\n## 정리\n\n“만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다.”\n그냥 문자열을 쓰면 그때는 편할 수 있다. 하지만, 그것이 미래에 수고롭게 만들 수 있다.\n만일 더 나은 데이터 타입이 있거나 새로 만들 수 있다면, 그것을 사용하고 만들어야 한다.\n문자열은 잘못 사용하면 위에서 봤듯이 문제를 일으킬 수 있으므로, 주의해서 사용해야 한다.\n\n"},{"excerpt":"대부분 소수점을 표현하고자 할 때는 int나 long을 사용한다.\nfloat와 double 타입은 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계되었다.\n따라서 float와 double 타입은 특히 금융 관련 계산과 같은 정확한 결과가 필요할 때는 사용하면 안 된다. float와 double을 피하라 예를 들어 주머니에는 1달러가 있…","fields":{"slug":"/item-60/"},"frontmatter":{"date":"February 22, 2025","title":"정확한 답이 필요하다면 float와 double은 피하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n\n대부분 소수점을 표현하고자 할 때는 int나 long을 사용한다.\nfloat와 double 타입은 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계되었다.\n따라서 float와 double 타입은 특히 금융 관련 계산과 같은 정확한 결과가 필요할 때는 사용하면 안 된다.\n\n## float와 double을 피하라\n\n예를 들어 주머니에는 1달러가 있고, 선반에 10센트, 20센트, 30센트, ... 1달러까지의 맛있는 사탕이 놓여 있다고 가정해보자.\n10센트짜리 사탕부터 하나씩 차례대로 구입한다고 가정 했을 때, 사탕을 몇 개나 살 수 있고, 잔돈은 얼마나 남을까?\n\n```JAVA\npublic static void main(String[] args) {\n    double funds = 1.00;\n    int itemsBought = 0;\n    for (double price = 0.10; funds >= price; price += 0.10) {\n        funds -= price;\n        itemsBought++;\n    }\n    System.out.println(itemsBought + \"개 구입\");\n    System.out.println(\"잔돈(달러): \" + funds);\n}\n```\n\n위의 예시에서 사탕 3개를 구입한 후에 예상 잔돈은 0.4달러이다.\n하지만 프로그램을 실행해보면 사탕 3개를 구입한 후 잔돈은 0.3999999999999999달러가 남았음을 알게 된다.\n이 문제를 올바로 해결하려면 어떻게 해야 할까?\n\n## BigDecimal, int 혹은 long을 사용하자\n\n앞서 발생한 문제는 BigDecimal, int 혹은 long을 사용하면 해결할 수 있다.\n우선 BigDecimal을 사용하면 다음과 같이 코드를 구현할 수 있다.\n\n```JAVA\npublic static void main(String[] args) {\n    final BigDecimal TEN_CENTS = new BigDecimal(\".10\");\n\n    int itemsBought = 0;\n    BigDecimal funds = new BigDecimal(\"1.00\");\n    for (BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = price.add(TEN_CENTS)) {\n        funds = funds.subtract(price);\n        itemBought++;\n    }\n\n    System.out.println(itemBought + \"개 구입\");\n    System.out.println(\"잔돈(달러): \" + funds);\n}\n```\n\n이 프로그램을 실행하면 사탕 4개를 구입한 후, 0달러가 남았음을 알 수 있다.\n올바른 답이 나왔지만 BigDecimal은 두 가지 단점이 존재한다.\n기본 타입보다 쓰기가 훨씬 느리고, 훨씬 불편하다.\n단발성 계산이라면 느리다는 문제는 무시할 수 있지만, 쓰기 불편하다는 점은 무시할 수 없을 것이다.\n\n이런 BigDecimal대안으로 숫자가 너무 크지 않다면 int나 long을 사용하면 된다.\n다음은 정수 타입을 사용해 구현한 코드다.\n\n```JAVA\npublic static void main(String[] args) {\n    int itemsBought = 0;\n    int funds = 100;\n    for (int price = 10; funds >= price; price += 10) {\n        funds -= price;\n        itemsBought++;\n    }\n\n    System.out.println(itemBought + \"개 구입\");\n    System.out.println(\"잔돈(달러): \" + funds);\n}\n```\n\n## 정리\n\n정확한 답이 필요한 계산에는 float와 double을 피하자.\n소수점 추적은 BigDecimal을 사용하거나, 정수 타입을 사용하자."},{"excerpt":"라이브러리에 익숙치 않으면 발생할 수 있는 문제 아래는 무작위 수를 백만 개를 생성한 다음, 그중 중간 값보다 작은 게 몇 개인지를 출력하는 코드다. 괜찮은 듯 보여도 적지않은 문제를 내포하고 있다. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다. n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다. n 값…","fields":{"slug":"/item-59/"},"frontmatter":{"date":"February 21, 2025","title":"라이브러리를 익히고 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 라이브러리에 익숙치 않으면 발생할 수 있는 문제\n\n아래는 무작위 수를 백만 개를 생성한 다음, 그중 중간 값보다 작은 게 몇 개인지를 출력하는 코드다.\n\n```java\nstatic Random rnd = new Random();\n\nstatic int random(int n) {\n    return Math.abs(rnd.nextInt()) % n;\n}\n\npublic static void main(String[] args) {\n    int n = 2 * (Integer.MAX_VALUE / 3);\n    int low = 0;\n    for (int i = 0; i < 1000000; i++) {\n        if (random(n) < n/2) {\n            low++;\n        }\n    }\n    System.out.println(low);\n}\n```\n\n괜찮은 듯 보여도 적지않은 문제를 내포하고 있다.\n\n- n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.\n- n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다. n 값이 클수록 이 현상은 더 두드러진다.\n    - 무작위 수를 백만개를 선택한 다음, 그중 중간 값보다 작은 게 몇개인지 출력하는 테스트를 진행했다.  \n      random 메서드가 이상적으로 동작한다면, 약 50만 개가 출력돼야 하지만, 실제로 돌려보면 무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로 쏠려 666,666에 가까운 값을 얻는다.\n- 지정한 범위 '바깥'의 수가 종종 튀어나올 수 있다.\n    - `rnd.nextInt()`가 반환한 값을 `Math.abs`를 이용해 음수가 아닌 정수로 매핑하기 때문에 지정한 범위의 바깥 수가 반환될 수 있다. `nextInt()`가 `Integer.MIN_VALUE`를 반환하면, `Math.abs`도 `Integer.MIN_VALUE`를 반환하고, 나머지 연산자(%)는 음수를 반환해버린다.\n\n그럼 이 문제들을 어떻게 해결해야 할까?\n\n## 표준 라이브러리의 이점\n\n위 결함들을 해결하려면 의사난수 생성기, 정수론, 2의 보수 계산 등에 조예가 깊어야 한다.\n하지만, 이미 `Random.nextInt(int)` 메서드가 이런 문제를 해결해주고 있기 때문에 우리가 직접 해결할 필요는 없다.\n\n### 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.\n\n이것이 가능한 이유는 이 알고리즘에 능통한 개발자 및 전문가 들이 설계부터 검증까지 해놓았기 때문이다.\n그리고 혹시 버그가 발겨노디더라도 다음 릴리스에서 수정될 것이다.\n이처럼 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.\n\n### 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다는 것이다.\n\n프로그래머들은 하부 공사를 하기보다는 애플리케이션 기능 개발에 집중하고 싶어한다.\n\n### 따로 노력하지 않아도 성능이 지속해서 개선된다.\n\n사용자가 많고, 업계 표준 벤치마크를 사용해 성능을 확인했기 때문에 표준 라이브러리 제작자들은 더 나은 방법을 꾸준히 모색할 수 밖에 없을 것이다.\n이런 환경에서 자바 플랫폼 라이브러리의 많은 부분이 수 년에 걸쳐 지속해서 다시 작성되고, 성능이 극적으로 개선되기도 한다.\n\n### 기능이 점점 많아진다.\n\n라이브러리에 부족한 부분이 있다면 해당 라이브러리를 사용하는 개발자들의 커뮤니티에서 이야기가 나올 것이고, 그 부분에서 논의된 후 다음 릴리스에 해당 기능이 추가되기도 한다.\n\n### 내가 작성한 코드가 많은 사람에게 낯익은 코드가 된다.\n\n표준 라이브러리를 사용하게 되면 자연스럽게 다른 개발자들이 더 읽기 좋아지고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 될 것이다.\n\n## 그럼에도 불구하고 직접 구현하는 이유\n\n이렇게 많은 이점을 가진 표준 라이브러리가가 있지만, 실상은 많은 프로그래머가 직접 구현해 쓰고 있다.\n왜 그럴까?\n대부분 이유는 라이브러리에 그런 기능이 있는지 모르기 때문이다.\n메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가되고 있다.\n이렇게 라이브러리가 너무 방대하면 모든 API 문서를 공부하기는 벅찰 수 있다.\n그럼 어느 정도까지 알아야 할까?\n책에서는 자바 프로그래머라면 적어도 `java.lang`, `java.util`, `java.io`와 그 하위 패키지는 알아두길 권장하고 있다.\n이후, 다른 라이브러리들을 필요할 때마다 익히는 것을 함께 권장하고 있다.\n\n## 라이브러리가 필요한 기능을 충분히 제공하지 못하는 경우\n\n때때로 라이브러리가 필요한 기능을 충분히 제공하지 못할 수 있다.\n더 전문적인 기능을 요구할수록 이러한 현상은 더 자주 발생할 것이다.\n이때는 우선은 라이브러리를 사용하려고 시도해보고, 해당 라이브러리가 원하는 기능이 아니라 판단되면 그때 대안을 사용하도록 하는 것이 좋다.\n어떤 라이브러리든 제공하는 깅은 유한하다.\n이땐 항상 구멍이 존재하기에 자바 표준 라이브러리 또한 원하는 기능이 없을 수 있다.\n그럼 그다음 선택지는 고글의 구아바 라이브러리 같은 고품질의 서드파티 라이브러리에서 대안을 찾아보도록 하자.\n\n## 정리\n\n바퀴를 다시 발명하지 말자.\n나만의 특별한 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다.\n이러한 라이브러리 코드는 일반적으로 우리가 작성한 코드보다 품질이 좋고, 개선의 가능성 또한 크기에 바퀴를 다시 발명하기 전에 있는 지 먼저 찾아보도록 하자.\n"},{"excerpt":"무한 수열 백준 1351번 무한 수열 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 14823 5677 4656 37.554% 문제 무한 수열 A는 다음과 같다.   , 와 가 주어질 때, 을 구하는 프로그램을 작성하시오. 입력 첫째 줄에 3개의 정수 가 주어진다. 출력 첫째 줄에 을 출력한다. 제한   풀이 이 문제를 풀 때…","fields":{"slug":"/boj-1351/"},"frontmatter":{"date":"February 21, 2025","title":"1351 무한 수열","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 무한 수열\n\n[백준 1351번 무한 수열](https://www.acmicpc.net/problem/1351)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 14823 | 5677 | 4656 | 37.554% |\n\n### 문제\n\n무한 수열 A는 다음과 같다.\n\n- $A_{0} = 1$\n- $A_{i} = A_{⌊i/P⌋} + A_{⌊i/Q⌋} (i ≥ 1)$\n\n$N$, $P$와 $Q$가 주어질 때, $A_{N}$을 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 3개의 정수 $N, P, Q$가 주어진다.\n\n### 출력\n\n첫째 줄에 $A_{N}$을 출력한다.\n\n### 제한\n\n- $0 ≤ N ≤ 10^{12}$\n- $2 ≤ P, Q ≤ 10^{9}$\n\n---\n\n## 풀이\n\n이 문제를 풀 때 먼저 주어진 점화식을 그대로 재귀로 구현하면 N이 매우 커질 경우 중복 연산이 많아져 비효율적이라는 점을 깨달았다. 따라서 메모이제이션을 활용한 동적 계획법(DP) 을 적용하여 이미 계산된 값은 저장하고 재사용하는 방식으로 접근했다. 하지만 N이 10¹²까지 가능하므로 배열 대신 해시맵(HashMap) 을 사용해야 했고, 결과적으로 기존 구현보다 약 2~3배 빠르게 실행되어 최적화 효과를 확실히 볼 수 있었다.\n\n```java\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    static HashMap<Long, Long> memozation = new HashMap<>();\n    public static long getA(long n, long p, long q) {\n        if (n == 0) return 1;\n        if (memozation.containsKey(n)) return memozation.get(n);\n        long result = getA(n / p, p, q) + getA(n / q, p, q);\n        memozation.put(n, result);\n        return result;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long N = scanner.nextLong();\n        long P = scanner.nextLong();\n        long Q = scanner.nextLong();\n        scanner.close();\n\n        System.out.println(getA(N, P, Q));\n    }\n}\n```"},{"excerpt":"합분해 백준 2225번 합분해 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 51202 23406 17432 44.397% 문제 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오. 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를…","fields":{"slug":"/boj-2225/"},"frontmatter":{"date":"February 20, 2025","title":"2225 합분해","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 합분해\n\n[백준 2225번 합분해](https://www.acmicpc.net/problem/2225)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 51202 | 23406 | 17432 | 44.397% |\n\n### 문제\n\n0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.\n\n덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.\n\n### 입력\n\n첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.\n\n### 출력\n\n첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.\n\n---\n\n## 풀이\n\n이 문제를 풀면서 처음에는 단순한 재귀로 접근하려 했지만, 중복 계산이 많아 비효율적이라는 걸 깨달았다. \n그래서 동적 계획법(DP)으로 접근하여 `dp[k][n]`을 \"K개의 정수를 사용하여 합이 N이 되는 경우의 수\"로 정의했다. \n점화식은 `dp[k][n] = dp[k-1][n] + dp[k][n-1]`을 활용하여 누적 합 방식으로 최적화할 수 있었고, \n이를 통해 O(K * N)의 시간 복잡도를 갖는 효율적인 풀이가 가능했다.\n\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_000;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());\n        int K = Integer.parseInt(tokenizer.nextToken());\n\n        int[][] dp = new int[K + 1][N + 1];\n\n        for (int i = 0; i <= N; i++) {\n            dp[1][i] = 1;\n        }\n\n        for (int k = 2; k <= K; k++) {\n            for (int n = 0; n <= N; n++) {\n                dp[k][n] = dp[k - 1][n];\n                if (n > 0) dp[k][n] = (dp[k][n] + dp[k][n - 1]) % MOD;\n            }\n        }\n\n        writer.write(dp[K][N] + \"\\n\");\n        writer.flush();\n        reader.close();\n        writer.close();\n    }\n}\n\n```"},{"excerpt":"LCS 백준 9251번 LCS 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 0.1 초 256 MB 100941 42608 31180 41.497% 문제 LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACA…","fields":{"slug":"/boj-9251/"},"frontmatter":{"date":"February 19, 2025","title":"9251 LCS","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## LCS\n\n[백준 9251번 LCS](https://www.acmicpc.net/problem/9251)\n\n| 시간 제한 | 메모리 제한 | 제출    | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:------|:------|:------|:--------|\n| 0.1 초 | 256 MB | 100941 | 42608 | 31180 | 41.497% |\n\n### 문제\n\nLCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.\n\n예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.\n\n### 입력\n\n첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.\n\n### 출력\n\n첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.\n\n---\n\n## 풀이\n\nLCS(Longest Common Subsequence) 문제를 해결하기 위해 처음에는 전통적인 **2차원 DP 테이블**을 사용했지만, 메모리 사용량이 너무 커지는 문제가 있었다. \n그래서 **1차원 DP 배열**을 활용하는 방식으로 최적화하여 공간 복잡도를 `O(N*M)`에서 `O(N)`으로 줄였다. \n`prev[]`와 `current[]` 두 개의 배열을 사용해 이전 행과 현재 행만 유지하도록 했으며, 이를 **스왑 방식**으로 구현해 메모리 사용량을 절반으로 줄였다. \nLCS 길이 계산에서는 기존의 `dp[i][j]` 값을 갱신하는 방식에서 `Math.max()`를 활용해 불필요한 조건문을 줄이며 연산량을 최적화했다. \n결국, 공간 복잡도를 줄이면서도 시간 복잡도 `O(N*M)`을 유지한 채 더 빠른 실행 속도로 구현할 수 있었다.\n\n```java\nimport java.nio.Buffer;\n\nclass NQueenSolver {\n    private final int N;\n    private int count;\n    private final int[] board;\n\n    public NQueenSolver(int n) {\n        this.N = n;\n        this.board = new int[N];\n        this.count = 0;\n    }\n\n    public void solve() {\n        int half = (N % 2 == 0) ? (N / 2) : (N / 2 + 1);\n        for (int col = 0; col < half; col++) {\n            board[0] = col;\n            placeQueen(1);\n        }\n        count *= 2;  // 대칭 적용\n        if (N % 2 != 0)\n            count -= removeDuplicatedCases();\n    }\n\n    private void placeQueen(int row) {\n        if (row == N) {\n            count++;\n            return;\n        }\n        for (int col = 0; col < N; col++) {\n            if (isSafe(row, col)) {\n                board[row] = col;\n                placeQueen(row + 1);\n            }\n        }\n    }\n\n    private boolean isSafe(int row, int col) {\n        for (int prevRow = 0; prevRow < row; prevRow++) {\n            int prevCol = board[prevRow];\n            if (prevCol == col || Math.abs(prevCol - col) == Math.abs(prevRow - row)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int removeDuplicatedCases() {\n        int centerCol = N / 2;\n        board[0] = centerCol;\n        count = 0;\n        placeQueen(1);\n        return count;\n    }\n\n    public int getSolutionCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(reader.readLine());\n        NQueenSolver solver = new NQueenSolver(N);\n        solver.solve();\n        System.out.println(solver.getSolutionCount());\n    }\n}\n\n```"},{"excerpt":"가장 긴 증가하는 부분 수열 11053번: 가장 긴 증가하는 부분 수열 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 187720 76040 50446 38.364% 문제 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} …","fields":{"slug":"/boj-11053/"},"frontmatter":{"date":"February 18, 2025","title":"11053 가장 긴 증가하는 부분 수열","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 가장 긴 증가하는 부분 수열\n\n[11053번: 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)\n\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 187720 | 76040 | 50446 | 38.364% |\n\n### 문제\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.\n\n### 입력\n\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)\n\n### 출력\n\n첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.\n\n---\n\n## 풀이\n\n가장 긴 증가하는 부분 수열을 구하는 문제이다.\n접근 방식은 다음과 같다.\n먼저 입력 데이터 개수를 보고, 시간 복잡도를 생각해봤다.\nN은 최대 1,000이고, 수열 A의 크기 N이므로, O(N^2)의 시간 복잡도로 풀면 시간 초과가 날 것이다.\n그래서 O(NlogN)의 시간 복잡도로 풀어야 한다.\n자료형 또한 최대 1,000이므로 int형으로 충분하다.\n다시 문제로 돌아와서 요구사항을 보면 수열 A를 입력받아 가장 긴 증가하는 부분 수열의 길이를 출력하면 된다.\n시간 복잡도를 고려해 봤을 때 이 문제는 이진 탐색을 사용하여 풀 수 있다.\n이진 탐색을 사용하여 풀기 위해서는 다음과 같은 방법을 사용한다.\n수열 A의 각 원소를 순회하면서, 현재 원소보다 작은 원소가 있으면 그 원소의 값에 1을 더한 값으로 현재 원소의 값을 갱신해준다.\n이렇게 하면 수열 A의 각 원소를 순회하면서 가장 긴 증가하는 부분 수열의 길이를 구할 수 있다.\n\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(reader.readLine());\n        int[] numbers = new int[n];\n\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i < N; i++) {\n            numbers[i] = Integer.parseInt(tokenizer.nextToken());\n        }\n\n        ArrayList<Integer> list = new ArrayList<>();\n\n        for (int number : numbers) {\n            if (list.isEmpty() || list.get(lis.size() - 1) < number) {\n                list.add(number);\n            } else {\n                int pos = Collections.binarySearch(list, num);\n                if (pos < 0) pos = -(pos + 1);\n                lis.set(pos, number);\n            }\n        }\n        writer.write(lis.size() + \"\\n\");\n            \n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"센서 2212번: 센서 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 19143 9890 8069 50.921% 문제 한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K…","fields":{"slug":"/boj-2212/"},"frontmatter":{"date":"February 17, 2025","title":"2212 센서","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 센서\n\n[2212번: 센서](https://www.acmicpc.net/problem/2212)\n\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 19143 | 9890 | 8069 | 50.921% |\n\n### 문제\n\n한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.\n\n각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.\n\n편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.\n\n### 입력\n\n첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.\n\n### 출력\n\n첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.\n\n---\n\n## 풀이\n\n우선 입력 데이터 개수를 보고, 시간 복잡도를 생각해봤다.\nN은 최대 10,000이고, K는 최대 1000이다.\nN이 10,000이고, K가 1000이므로, O(N^2)의 시간 복잡도로 풀면 시간 초과가 날 것이다.\n그래서 O(NlogN)의 시간 복잡도로 풀어야 한다.\n자료형 또한 최대 1,000,000이므로 int형으로 충분하다.\n즉, 문제는 센서의 좌표를 입력받아 정렬하고, 각 센서 사이의 거리를 구한 뒤, 가장 큰 거리부터 K-1개를 제외한 나머지 거리를 더하면 된다.\n하지만 주의 해야할 부분이 있는데, K가 N보다 크거나 같을 경우에는 0을 출력하면 된다.\n\n\n```java\npackage test.code;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(reader.readLine()); // 센서의 갯수\n        int k = Integer.parseInt(reader.readLine()); // 집중국의 갯수\n        //if k >= n then print 0 and exit.\n        if(k >= n) {\n            System.out.println(0);\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int[] sensors = new int[n];\n        for(int i = 0; i < n; i++) {\n            sensors[i] = Integer.parseInt(tokenizer.nextToken());\n        }\n        Arrays.sort(sensors);\n\n        Integer[] distances = new Integer[n-1];\n        for(int i = 0; i < n-1; i++)\n            distances[i] = sensors[i+1] - sensors[i];\n\n        Arrays.sort(distances, Collections.reverseOrder());\n\n        int result = 0;\n        for(int i = k-1; i < n-1; i++) {\n            result += distances[i];\n        }\n\n\n        writer.write(result + \"\\n\");\n\n        writer.flush();\n        writer.close();\n        reader.close();\n    }\n}\n```"},{"excerpt":"피보나치 함수 1003번: 피보나치 함수 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 141306 71100 56615 50.245% 문제 다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다. fibonacci(3)을 호출하면 다음과 같은 일이 일어난다. fibonacci(3)은 fibonacci(2)와 fibonacc…","fields":{"slug":"/boj-1003/"},"frontmatter":{"date":"February 17, 2025","title":"1003 피보나치 함수","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 피보나치 함수\n\n[1003번: 피보나치 함수](https://www.acmicpc.net/problem/1003)\n\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 141306 | 71100 | 56615 | 50.245% |\n\n### 문제\n\n다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\n\n```cpp\nint fibonacci(int n) {\n    if (n == 0) {\n        printf(\"0\");\n        return 0;\n    } else if (n == 1) {\n        printf(\"1\");\n        return 1;\n    } else {\n        return fibonacci(n‐1) + fibonacci(n‐2);\n    }\n}\n```\n\nfibonacci(3)을 호출하면 다음과 같은 일이 일어난다.\n\n- fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다. \n- fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다. \n- 두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다. \n- fibonacci(0)은 0을 출력하고, 0을 리턴한다. \n- fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다. \n- 첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다. \n- fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.\n\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.\n\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.\n\n### 출력\n\n각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 피보나치 수열을 재귀로 구현했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 문제이다.\n예전에 했던 방법이 떠올라서 바로 풀었다.\n재귀를 안 쓰는 방식이라 복합적으로 복잡도의 계수가 줄어들 수 있다.\n코드를 보면 무슨 의미인지 알기에 따로 풀이에 대한 설명은 필요 없을 것 같다.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int T = Integer.parseInt(reader.readLine());\n\n        int[] countZero = new int[41];\n        int[] countOne = new int[41];\n\n        countZero[0] = 1;\n        countOne[0] = 0;\n        countZero[1] = 0;\n        countOne[1] = 1;\n\n        for (int i = 2; i <= 40; i++) {\n            countZero[i] = countZero[i - 1] + countZero[i - 2];\n            countOne[i] = countOne[i - 1] + countOne[i - 2];\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (int t = 0; t < T; t++) {\n            int N = Integer.parseInt(reader.readLine());\n            result.append(countZero[N]).append(\" \").append(countOne[N]).append(\"\\n\");\n        }\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result + \"\\n\");\n\n        writer.flush();\n        writer.close();\n        reader.close();\n    }\n}\n```"},{"excerpt":"최소 회의실 개수 백준 19598번 최소 회의실 개수 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 9412 4203 3245 44.698% 문제 서준이는 아빠로부터 N개의 회의를 모두 진행할 수 있는 최소 회의실 개수를 구하라는 미션을 받았다. 각 회의는 시작 시간과 끝나는 시간이 주어지고 한 회의실에서 동시에 두 개 이상의…","fields":{"slug":"/boj-19598/"},"frontmatter":{"date":"February 15, 2025","title":"19598 최소 회의실 개수","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 최소 회의실 개수\n\n[백준 19598번 최소 회의실 개수](https://www.acmicpc.net/problem/19598)\n\n| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-----|:-----|:------|:--------|\n| 2 초   | 256 MB | 9412 | 4203 | 3245  | 44.698% |\n\n### 문제\n\n서준이는 아빠로부터 N개의 회의를 모두 진행할 수 있는 최소 회의실 개수를 구하라는 미션을 받았다. 각 회의는 시작 시간과 끝나는 시간이 주어지고 한 회의실에서 동시에 두 개 이상의 회의가 진행될 수 없다. 단, 회의는 한번 시작되면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작 시간은 끝나는 시간보다 항상 작다. N이 너무 커서 괴로워 하는 우리 서준이를 도와주자.\n\n### 입력\n\n첫째 줄에 배열의 크기 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231−1보다 작거나 같은 자연수 또는 0이다.\n\n### 출력\n\n첫째 줄에 최소 회의실 개수를 출력한다.\n\n---\n\n## 풀이\n\n\n```java\npackage test.code;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int N;\n    static PriorityQueue<Time> pq;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        pq = new PriorityQueue<>();\n\n        for (int i = 0; i < N; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            pq.add(new Time(Integer.parseInt(st.nextToken()), true)); // 시작시간\n            pq.add(new Time(Integer.parseInt(st.nextToken()), false)); // 종료시간\n        }\n\n        int cnt = 0; // 회의실 개수\n        int answer = 0; // 최대값\n\n        while (!pq.isEmpty()) {\n            Time t = pq.poll();\n\n            if (t.isStart) {\n                cnt++;\n                answer = Math.max(cnt, answer);\n            }\n            else {\n                cnt--;\n            }\n        }\n\n        System.out.println(answer);\n    }\n\n    static class Time implements Comparable<Time>{\n        int time;\n        boolean isStart;\n\n        public Time(int time, boolean isStart) {\n            this.time = time;\n            this.isStart = isStart;\n        }\n\n        @Override\n        public int compareTo(Time o) {\n            return this.time - o.time;\n        }\n    }\n}\n```"},{"excerpt":"자바는 안전한 언어다 자바는 네이티브 메서드를 사용하지 않기 때문에 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 비교적 안전하다.\n또한 자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 기본적으로 불변성을 유지할 수 있도록 설계되었지만, 모든 경우에 자동으로 보호되는 것은 아니다. 왜 방어적으로 프로그래밍 해야할까? …","fields":{"slug":"/item-50/"},"frontmatter":{"date":"February 13, 2025","title":"적시에 방어적 복사본을 만들라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 자바는 안전한 언어다\n\n자바는 네이티브 메서드를 사용하지 않기 때문에 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 비교적 안전하다.\n또한 자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 기본적으로 불변성을 유지할 수 있도록 설계되었지만, 모든 경우에 자동으로 보호되는 것은 아니다.\n\n## 왜 방어적으로 프로그래밍 해야할까?\n\n하지만 책에서는 자바가 안전한 언어라고 해도 방어적으로 프로그래밍을 해야한다고 강조하고 있다.\n아무리 자바라고 해도 다른 클래스로부터의 침범을 아무런 노력없이 막을 수 있는 것은 아니다.\n실제로도 악의적인 의도를 가진 사람들이 시스템의 보안을 뚫으려는 시도가 늘고 있다.\n심지어 평범한 프로그래머도 순전히 실수로 클래스를 오작동하게 만들 수 있다.\n그래서 책에서는 **클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야한다**고 말하고 있다.\n\n## 객체가 자기도 모르게 내부를 수정하도록 허락하는 경우\n\n어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하지만, 간혹 실수를 하여 자기도 모르게 수정하도록 허락하는 경우가 생긴다.\n\n### 생성자를 이용한 방어 파훼\n\n'시작 시각이 종료 시각보다 늦을 수 없다는 불변식'이 있는 다음과 같은 클래스가 있다고 하자.\n\n```JAVA\npublic final class Period {\n\tprivate final Date start;\n\tprivate final Date end;\n\n    /**\n     * @param start 시작 시각\n     * @param end 종료 시각; 시작 시각보다 뒤여야 하낟.\n     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.\n     * @throws NullPointerException start나 end가 null이면 발생한다.\n     */\n    public Period(Date start, Date end) {\n        if(start.compareTo(end) > 0)\n            throw new IllegalArgumentException(\n                    start + \"가 \" + end + \"보다 늦다.\");\n        this.start = start;\n        this.end = end;\n    }\n    \n\tpublic Period(Date start, Date end) {\n\t\tif (start.compareTo(end) > 0) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\tstart + \"가 \" + end + \"보다 늦다.\"\n\t\t\t);\n\t\t}\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\tpublic Date start() {\n\t\treturn start;\n\t}\n\n\tpublic Date end() {\n\t\treturn end;\n\t}\n}\n```\n\n얼핏보면 이 클래스는 불변처럼 보이지만, `Date`가 가변이라는 사실을 이용하면 어렵지 않게 불변식을 깰 수 있다.\n\n```JAVA\nDate start = new Date();\nDate end = new Date();\nPeriod p = new Period(start, end);\nend.setYear(78); // p의 내부를 수정했다!!\n```\n\n자바 8 이후로는 `Date` 대신 `LocalDateTime` 또는 `ZonedDateTime` 같은 불변인 `Instant`를 사용해서 쉽게 해결할 수 있지만,\n앞으로 쓰지 않는다고 이 문제에서 해방되는 건 아니다.\n\n실전에서는 `Date` 같은 낡은 API를 새로운 코드를 작성할 떄는 더 이상 사용하면 안되지만,\n`Date` 처럼 가변인 낡은 값 타입을 사용하던 시절이 길었던 탓에 여전히 많은 API와 내부 구현에 그 잔재가 남아 있다.\n\n이 부분은 이러한 낡은 코드들을 대처하기 위한 것이다.\n\n다시 돌아가서 외부 공격으로부터 `Period` 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.\n\n```java\npublic Period(Date start, Date end) {\n    this.start = new Date(start.getTime());\n    this.end = new Date(end.getTime());\n\n    if(this.start.compareTo(this.end) > 0)\n        throw new IllegalArgumentException(\n                this.start + \"가 \" + this.end + \"보다 늦다.\");\n}\n```\n\n그런 다음 `Period` 인스턴스 안에서는 원본이 아닌 복사본을 사용하면 된다.\n\n이때, 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목해보면, 순서가 부자연스러워 보이겠지만 반드시 이렇게 작성해야 한다.\n멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.\n\n하나 더 주의할 점이 있는데 방어적 복사에 `Date`의 `clone` 메서드를 사용하지 않은 점이다.\n`Date`는 `final`이 아니므로 `clone`이 `Date`가 정의한 게 아닐 수 있다.\n즉, `clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있기 때문이다.\n\n이러한 공격을 막기 위해서는 **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안된다**는 것이다.\n\n### 접근자를 이용한 방어 파훼\n\n이렇게 하면 앞서의 공격을 막아낼 수 있지만, 아직 안전하지 않다.\n접근자 메서드가 내부의 가변 정보를 직접 드러내서 `Period` 인스턴스 변경이 가능하기 때문이다.\n\n```java\nDate start = new Date();\nDate end = new Date();\nPeriod period = new Period(start, end);\nperiod.end().setYear(78); // p의 내부를 변경했다!\n```\n\n이를 막아내려면 단순히 접근자가 가변 필드의 방어적 복사복을 반환하면 된다.\n\n```java\npublic Date start() {\n    return new Date(start.getTime());\n}\n\npublic Date end() {\n    return new Date(end.getTime());\n}\n```\n\n이렇게 새로운 접근자까지 갖추면 `Period`는 자신 말고는 가변 필드에 접근할 방법이 없고,\n모든 필드가 객체 안에 완벽히 캡슐화된 완벽한 불변이 된다.\n이때, `Period`가 가지고 있는 Date 객체가 `java.util.Date` 임이 확실하기 때문에,\n생성자와 달리 접근자 메서드에서는 방어적 복사에 `clone`을 사용해도 된다.\n그렇지만 아이템 13에서 설명했듯이, 인스턴스 복사에는 이러한 방법보다는 일반적으로 생성자나 정적 팩터리를 쓰는 게 좋다.\n\n## 어떻게 사용해야 할까?\n\n앞서 살펴본 내용을 통해 방어적 복사본을 생성자와 접근자를 처리할 때만 만든다고 생각하지 않았으면 한다.\n메서드든 상성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.\n내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 이유도 마찬가지로\n클래스가 불변이든 가변이든, 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다.\n\n하지만 방어적 복사에는 성능 저하가 따르고, 또 항사 쓸 수 있는 것은 아니다.\n같은 패키지에 속하는 등의 이유로 호출자가 컴포넌트 내부를 수정ㅇ하지 않으리라 확신하면 방어적 복사를 생략할 수 있지만,\n이 경우 호출자에서 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.\n또한 다른 패키지에서 사용한다고 해서 넘겨 받은 매개변수를 항상 방어적으로 복사해 저장해야한 것도 아니다.\n이 경우에 대해서도 마찬가지로 문서화를 통해 사용자에게 알려주는 것이 좋다.\n\n## 정리\n\n클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.\n복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없을을 신뢰한다면,\n방어적 복사를 수행하는 대신 해당 구성 요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자."},{"excerpt":"신입 사원 백준 1946번 신입 사원 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 69548 24748 17972 33.933% 문제 언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들…","fields":{"slug":"/boj-1946/"},"frontmatter":{"date":"February 13, 2025","title":"1946 신입 사원","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 신입 사원\n\n[백준 1946번 신입 사원](https://www.acmicpc.net/problem/1946)\n\n\n\n| 시간 제한 | 메모리 제한 | 제출    | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:------|:------|:------|:--------|\n| 2 초   | 256 MB | 69548 | 24748 | 17972 | 33.933% |\n\n### 문제\n\n언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.\n\n그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.\n\n이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.\n\n### 출력\n\n각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.\n\n---\n\n## 풀이\n\n서류심사를 기준으로 정렬하여 문제 접근을 했다.\n\n1등은 무조건 뽑힌다.\n\n2등부터는 자신보다 앞선 서류심사 등수 인원 모두보다 면접시험 등수가 높으면 뽑힌다.\n\nmin변수를 유지해서, 모두와 비교하지 않고 등수가 가장 높은 사람과만 비교하면 된다.\n\n```java\nimport java.nio.Buffer;\n\nclass NQueenSolver {\n    private final int N;\n    private int count;\n    private final int[] board;\n\n    public NQueenSolver(int n) {\n        this.N = n;\n        this.board = new int[N];\n        this.count = 0;\n    }\n\n    public void solve() {\n        int half = (N % 2 == 0) ? (N / 2) : (N / 2 + 1);\n        for (int col = 0; col < half; col++) {\n            board[0] = col;\n            placeQueen(1);\n        }\n        count *= 2;  // 대칭 적용\n        if (N % 2 != 0)\n            count -= removeDuplicatedCases();\n    }\n\n    private void placeQueen(int row) {\n        if (row == N) {\n            count++;\n            return;\n        }\n        for (int col = 0; col < N; col++) {\n            if (isSafe(row, col)) {\n                board[row] = col;\n                placeQueen(row + 1);\n            }\n        }\n    }\n\n    private boolean isSafe(int row, int col) {\n        for (int prevRow = 0; prevRow < row; prevRow++) {\n            int prevCol = board[prevRow];\n            if (prevCol == col || Math.abs(prevCol - col) == Math.abs(prevRow - row)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int removeDuplicatedCases() {\n        int centerCol = N / 2;\n        board[0] = centerCol;\n        count = 0;\n        placeQueen(1);\n        return count;\n    }\n\n    public int getSolutionCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(reader.readLine());\n        NQueenSolver solver = new NQueenSolver(N);\n        solver.solve();\n        System.out.println(solver.getSolutionCount());\n    }\n}\n\n```"},{"excerpt":"맥주 축제 백준 17503번 맥주 축제 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 4455 1392 1014 30.053% 문제 내일부터 N일 동안 대구광역시에서 맥주 축제가 열립니다! 이 축제에서는 무려 K종류의 맥주를 무료로 제공합니다. 축제 주최자는 축제에서 더 많은 참가자들이 다양한 종류의 맥주를 즐겼으면 합니다. …","fields":{"slug":"/boj-11399/"},"frontmatter":{"date":"February 12, 2025","title":"17503 맥주 축제","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 맥주 축제\n\n[백준 17503번 맥주 축제](https://www.acmicpc.net/problem/17503)\n\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 4455 | 1392 | 1014 | 30.053% |\n\n### 문제\n\n내일부터 N일 동안 대구광역시에서 맥주 축제가 열립니다!\n\n이 축제에서는 무려 K종류의 맥주를 무료로 제공합니다.\n\n축제 주최자는 축제에서 더 많은 참가자들이 다양한 종류의 맥주를 즐겼으면 합니다. 그래서 축제에서 참가자들은 하루에 맥주 1병만 받을 수 있고, 이전에 받았던 종류의 맥주는 다시 받을 수 없습니다.\n\n맥주를 정말로 사랑하는 대학생 전씨는 무료 맥주 소식에 신이 났습니다. 전씨는 이 맥주 축제에 참가해 총 N일 동안 맥주 N병을 마시려 합니다.\n\n하지만 전씨에게는 큰 고민이 있었습니다. 전씨는 맥주를 사랑하지만, 도수가 높은 맥주를 마시면 기절하는 맥주병이 있습니다. 전씨는 맥주를 마시다 기절하면 늦잠을 자 다음 날 1교시 수업에 결석해 F를 받게 될 수도 있습니다.\n\n전씨는 고민을 해결하기 위해 천재석사 현씨과 천재박사 승씨에게 자신의 간을 강력하게 만들어달라고 부탁했습니다. 하지만 간을 강력하게 만드는 비용이 너무 비싸서, 전씨는 간을 가능한 한 조금만 강화할 계획을 세웠습니다.\n\n우선, K종류의 맥주에 각각 '선호도'와 '도수 레벨'을 매겼습니다. 선호도는 전씨가 해당 맥주를 얼마나 좋아하는지를 나타내는 수치이고, 도수 레벨은 해당 맥주의 도수가 얼마나 강한지를 나타내는 수치입니다. 편의상 전씨는 선호도와 도수 레벨을 정수로 매겼습니다.\n\n만약, 마시는 맥주의 도수 레벨이 전씨의 간 레벨보다 높으면 맥주병이 발병해 기절해버리고 맙니다.\n\n또한, 전씨는 맥주병에 걸리지 않으면서도 자신이 좋아하는 맥주를 많이 마시고 싶어합니다. 따라서, 마시는 맥주 N개의 선호도 합이 M이상이 되게 하려 합니다.\n\n거창한 계획을 세운 전, 현, 승 세 사람은 서로 머리를 맞대고 고민하다가, 스트레스를 받아 연구를 집어치고 맥주를 마시러 떠나버렸습니다.\n\n이를 본 여러분은 세 사람을 대신해 조건을 만족하는 간 레벨의 최솟값을 출력하는 프로그램을 만들어 주려고 합니다.\n\n세 사람을 도와주세요!\n\n### 입력\n\n첫 번째 줄에 축제가 열리는 기간 $N (1 ≤ N ≤ 200,000)$ 과, 채워야 하는 선호도의 합 $M (1 ≤ M < 2^{31})$ 과, 마실 수 있는 맥주 종류의 수 $K (N ≤ K ≤ 200,000)$ 가 주어집니다.\n\n다음 K개의 줄에는 1번부터 K번 맥주의 선호도 $v_i (0 ≤ vi ≤ 10,000)$ 와 도수 레벨 $c_i (1 ≤ ci < 231)$ (vi, ci는 정수) 이 공백을 사이에 두고 주어집니다.\n\n1번부터 K번 맥주의 종류는 모두 다릅니다.\n\n### 출력\n\n첫 번째 줄에 주어진 선호도의 합 M을 채우면서 N개의 맥주를 모두 마실 수 있는 간 레벨의 최솟값을 출력합니다.\n\n만약 아무리 레벨을 올려도 조건을 만족시킬 수 없으면 첫 번째 줄에 \"-1\" 하나만 출력하고 더 이상 아무것도 출력하지 않아야 합니다.\n\n---\n\n## 풀이\n\n이 문제는 이진 탐색 없이 정렬과 우선순위 큐(PriorityQueue)를 활용하여 최소한의 간 레벨을 찾는 방식으로 접근했다. \n먼저, Beer 클래스를 정의하고, 각 맥주의 선호도와 도수 레벨을 저장할 수 있도록 했다. \n이후 입력받은 맥주 목록을 도수 레벨 기준으로 오름차순 정렬한 뒤, 작은 도수부터 하나씩 선택하면서 우선순위 큐에 추가하며 선호도의 합을 관리했다. \n큐의 크기가 n을 초과하면 가장 선호도가 낮은 맥주를 제거하여 최적의 맥주 조합을 유지했다. 만약 n개의 맥주를 선택한 상태에서 선호도 합이 m 이상이면, 해당 맥주의 도수 레벨을 정답으로 설정하고 탐색을 종료하게 구현했다.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\nclass Beer implements Comparable<Beer> {\n    private int preference; //맥주의 선호도(0 ≤ v ≤ 10,000)\n    private int alcohol; //도수 레벨(1 ≤ c < 231)\n\n    private Beer(int preference, int alcohol){\n        this.preference = preference;\n        this.alcohol = alcohol;\n    }\n\n    public static Beer from(String input){\n        StringTokenizer tokenizer = new StringTokenizer(input);\n        int v = Integer.parseInt(tokenizer.nextToken());\n        int c = Integer.parseInt(tokenizer.nextToken());\n        return new Beer(v, c);\n    }\n\n    @Override\n    public int compareTo(Beer other) {\n        return this.alcohol - other.alcohol;\n    }\n\n    public int getPreference() {\n        return preference;\n    }\n\n    public int getAlcohol() {\n        return alcohol;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        long m = Long.parseLong(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        Beer[] beers = new Beer[k];\n        for (int i = 0; i < k; i++) {\n            beers[i] = Beer.from(reader.readLine());\n        }\n\n        Arrays.sort(beers);\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n\n        long total = 0;\n        int result = 0;\n        for (int i = 0; i < beers.length; i++) {\n\n            priorityQueue.offer(beers[i].getPreference());\n            total += beers[i].getPreference();\n\n            if (priorityQueue.size() > n) {\n                total -= priorityQueue.poll();\n            }\n\n            if (priorityQueue.size() == n && total >= m) {\n                result = beers[i].getAlcohol();\n                break;\n            }\n        }\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        if (result == 0) {\n            writer.write(-1 + \"\\n\");\n        } else {\n            writer.write(result + \"\\n\");\n        }\n\n        writer.flush();\n        writer.close();\n        reader.close();\n    }\n}\n```"},{"excerpt":"입국심사 프로그래머스 입국심사 문제 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는…","fields":{"slug":"/prog-42839/"},"frontmatter":{"date":"February 11, 2025","title":"42839 소수찾기","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 입국심사\n\n[프로그래머스 입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/42839?language=java)\n\n### 문제\n\n한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.<br>\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.\n\n### 제한사항\n\n- numbers는 길이 1 이상 7 이하인 문자열입니다. \n- numbers는 0~9까지 숫자만으로 이루어져 있습니다.\n- \"013\"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.\n\n### 입출력 예\n\n| numbers\t | return |\n|:---------|:-------|\n| \"17\"\t    | 3      |\n| \"011\"\t   | 2      |\n\n### 입출력 예 설명\n\n예제 #1<br>\n[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.<br>\n\n예제 #2<br>\n[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.\n\n- 11과 011은 같은 숫자로 취급합니다.\n\n---\n\n## 풀이\n\n순열 + dfS 문제로, 주어진 숫자로 만들 수 있는 모든 숫자를 구한 뒤 소수인지 판별하는 문제이다. 숫자의 길이가 최대 7이므로, 순열을 이용해 모든 경우의 수를 구할 수 있다. 이후 소수인지 판별하여 카운트하면 된다.\n\n\n```java\nimport java.util.*;\n\nclass Solution {\n    static Set<Integer> set;\n    static boolean[] visited = new boolean[7]; // numbers는 길이 1 이상 7 이하\n\n    public int solution(String numbers) {\n        int answer = 0;\n        set = new HashSet<>();\n        dfs(numbers, \"\", 0);\n\n        for (Integer num : set) {\n            if (isPrime(num)) {\n                answer++;\n            }\n        }\n        return answer;\n    }\n\n    public static void dfs(String numbers, String s, int depth) {\n        if (depth > numbers.length()) {\n            return;\n        }\n\n        for (int i = 0; i < numbers.length(); i++) {\n            if(!visited[i]) {\n                visited[i] = true;\n                set.add(Integer.parseInt(s + numbers.charAt(i)));\n                dfs(numbers ,s + numbers.charAt(i), depth + 1);\n                visited[i] = false;\n            }\n        }\n    }\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"},{"excerpt":"고양이는 많을수록 좋다 백준 27961번 고양이는 많을수록 좋다 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 1024 MB 3728 1468 1258 39.685% 문제 마법소녀인 마도카는 너무나도 고양이를 좋아하는 나머지 마법을 이용하여 고양이 마리를 집에서 키우기로 결심했다! 마도카는 한 번의 행동에서 다음 가지 마법 중 하나를 선택…","fields":{"slug":"/boj-27961/"},"frontmatter":{"date":"February 11, 2025","title":"27961 고양이는 많을수록 좋다","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 고양이는 많을수록 좋다\n\n[백준 27961번 고양이는 많을수록 좋다](https://www.acmicpc.net/problem/27961)\n\n| 시간 제한 | 메모리 제한  | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:--------|:-------|:------|:------|:--------|\n| 1 초   | 1024 MB | 3728 | 1468 | 1258 | 39.685% |\n\n### 문제\n\n마법소녀인 마도카는 너무나도 고양이를 좋아하는 나머지 마법을 이용하여 고양이 $N$마리를 집에서 키우기로 결심했다!\n\n마도카는 한 번의 행동에서 다음 $2$가지 마법 중 하나를 선택하여 사용한다. 처음에는 마도카의 집에 고양이가 존재하지 않는다.\n\n- 생성 마법: 고양이 $1$마리를 마도카의 집에 생성한다.\n- 복제 마법: 마도카의 집에 있는 고양이 일부 또는 전부를 대상으로 하여 복제한다. 즉, 만약 현재 마도카의 집에 고양이가 $k$마리 존재한다면, $0$마리 이상 $k$마리 이하의 고양이를 마도카의 집에 추가할 수 있다.\n\n마도카는 위의 $2$가지 마법을 적절히 사용하여, 최소의 행동 횟수로 마도카의 집에 정확히 $N$마리의 고양이가 있도록 만들고 싶다. 계산을 어려워하는 마도카를 위해 최소의 행동 횟수를 계산해주자!\n\n### 입력\n\n첫 번째 줄에 키우기를 원하는 고양이의 수 $N(0\\leq N\\leq 10^{12})$이 정수로 주어진다.\n\n### 출력\n\n첫 번째 줄에 정확히 $N$마리의 고양이를 마도카의 집에 들일 수 있는 최소의 행동 횟수를 출력한다.\n\n---\n\n## 풀이\n\n문제를 해결할 때 가장 중요한 부분은 복제 마법을 어떻게 활용할 것인가였다. 문제에서 0마리 이상 k마리 이하를 복제할 수 있다고 했지만, 최적의 전략을 생각해 보면 현재 있는 고양이를 전부 복제하는 것이 항상 유리하다. 왜냐하면 한 번의 복제로 가장 빠르게 고양이 수를 증가시킬 수 있기 때문이다. 결국 이 문제는 고양이를 1마리씩 늘리거나, 현재 있는 수를 2배로 늘릴 수 있을 때, 최소한의 행동으로 N마리를 만드는 문제라고 볼 수 있다.\n\n처음엔 0마리에서 시작해 N마리로 맞춰가는 방식으로 접근했지만, 반대로 N에서 0으로 내려오는 방식이 더 직관적이고 편리했다. 2배로 나누면서 내려오고, 만약 나눈 값이 홀수라면 1번 더 증가하는 식으로 처리했다. 이렇게 하면 항상 최소 연산으로 도달할 수 있다. 특히 3마리 이하에서는 남은 마리 수만큼 행동해야 하므로, 이 부분을 별도로 처리하여 최적화했다.\n\n```java\npackage test.code;\n\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        long n = Long.parseLong(reader.readLine());\n        int cnt = 0;\n        while (n > 3) {\n            cnt++;\n            n = n/2 + (n%2==1?1:0);\n        }\n        System.out.println(cnt + n);\n    }\n}\n\n```"},{"excerpt":"N-Queen 백준 9663번 N-Queen 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 10 초 128 MB 131775 63781 40975 46.740% 문제 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오. 입력 …","fields":{"slug":"/boj-9663/"},"frontmatter":{"date":"February 10, 2025","title":"9663 N-Queen","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## N-Queen\n\n[백준 9663번 N-Queen](https://www.acmicpc.net/problem/9663)\n\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 10 초  | 128 MB | 131775 | 63781 | 40975 | 46.740% |\n\n### 문제\n\nN-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.\n\nN이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 N이 주어진다. (1 ≤ N < 15)\n\n### 출력\n\n첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.\n\n---\n\n## 풀이\n\nN-Queen 문제를 해결하는 과정에서 여러 가지 접근 방식을 고민해봤다. 처음에는 가장 직관적인 **백트래킹(Backtracking)** 알고리즘을 떠올렸고, 이를 기반으로 기본적인 풀이를 구현했다. 퀸을 하나씩 배치하면서 매번 유효한 위치인지 검사하고, 유효하면 다음 행으로 이동하는 방식이다. 기본적인 방식이지만 `O(N!)`의 시간 복잡도를 가지므로, `N`이 커질수록 성능이 급격히 저하될 가능성이 있었다.\n\n이후 성능을 개선할 방법을 찾던 중, **대칭성을 활용하는 최적화 기법**이 눈에 들어왔다. 체스판에서 퀸의 배치는 좌우 대칭이 존재하므로, 첫 번째 행에서 절반만 탐색한 뒤 결과를 두 배로 계산하는 방식이었다. 하지만 이를 적용하려면 `N`이 짝수인지, 홀수인지에 따라 보정이 필요했다. `N`이 홀수일 경우 중앙열에 위치한 경우를 따로 계산해야 했고, 단순히 `* 4` 하는 방식은 오답을 유발할 수 있었다. 즉, 모든 경우가 완벽하게 4배 비율로 대칭을 이루는 것이 아니라는 점이 문제였다.\n\n결국 최적화 방법을 적용하되, 문제에서 `N`이 입력으로 고정된다는 점을 고려하여 **가장 일반적인 백트래킹 방식을 유지하는 것이 최선**이라는 결론을 내렸다. 기본적인 백트래킹을 적용하되, 객체지향적 설계를 활용하여 `NQueenSolver` 클래스를 만들어 문제 해결과 실행을 분리했다. 이렇게 하면 코드의 구조가 명확해지고 유지보수도 쉬워진다. 최적화가 필요한 경우에는 `isSafe()` 체크를 개선하거나 비트마스크를 활용하는 방식으로 추가적인 최적화를 고려할 수 있다.\n\n이번 문제를 풀면서, 단순히 정답을 찾는 것뿐만 아니라 **성능을 고려한 최적화**와 **객체지향적인 코드 구조**에 대한 고민을 많이 하게 되었다. 단순한 문제라도, 다양한 방식으로 접근해보는 것이 중요하다는 점을 다시 한번 느꼈다.\n\n```java\nimport java.nio.Buffer;\n\nclass NQueenSolver {\n    private final int N;\n    private int count;\n    private final int[] board;\n\n    public NQueenSolver(int n) {\n        this.N = n;\n        this.board = new int[N];\n        this.count = 0;\n    }\n\n    public void solve() {\n        int half = (N % 2 == 0) ? (N / 2) : (N / 2 + 1);\n        for (int col = 0; col < half; col++) {\n            board[0] = col;\n            placeQueen(1);\n        }\n        count *= 2;  // 대칭 적용\n        if (N % 2 != 0)\n            count -= removeDuplicatedCases();\n    }\n\n    private void placeQueen(int row) {\n        if (row == N) {\n            count++;\n            return;\n        }\n        for (int col = 0; col < N; col++) {\n            if (isSafe(row, col)) {\n                board[row] = col;\n                placeQueen(row + 1);\n            }\n        }\n    }\n\n    private boolean isSafe(int row, int col) {\n        for (int prevRow = 0; prevRow < row; prevRow++) {\n            int prevCol = board[prevRow];\n            if (prevCol == col || Math.abs(prevCol - col) == Math.abs(prevRow - row)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int removeDuplicatedCases() {\n        int centerCol = N / 2;\n        board[0] = centerCol;\n        count = 0;\n        placeQueen(1);\n        return count;\n    }\n\n    public int getSolutionCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(reader.readLine());\n        NQueenSolver solver = new NQueenSolver(N);\n        solver.solve();\n        System.out.println(solver.getSolutionCount());\n    }\n}\n\n```"},{"excerpt":"치킨 배달 백준 15686번 치킨 배달 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 512 MB 102036 50626 30573 46.376% 문제 크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또…","fields":{"slug":"/boj-15686/"},"frontmatter":{"date":"February 07, 2025","title":"15686 치킨 배달","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 치킨 배달\n\n[백준 15686번 치킨 배달](https://www.acmicpc.net/problem/15686)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 512 MB | 102036 | 50626 | 30573 | 46.376% |\n\n### 문제\n\n크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.\n\n이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 \"치킨 거리\"라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.\n\n임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.\n\n예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.\n\n```java\n0 2 0 1 0\n1 0 1 0 0\n0 0 0 0 0\n0 0 0 1 1\n0 0 0 1 2\n```\n\n0은 빈 칸, 1은 집, 2는 치킨집이다.\n\n(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.\n\n(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.\n\n이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.\n\n도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.\n        \n### 입력\n\n첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.\n\n둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.\n\n도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.\n\n### 출력\n\n첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 도시의 치킨 거리를 최소화하는 **조합 최적화 문제**로, \nM개의 치킨집을 선택하는 **백트래킹(조합)**을 활용하여 해결했다. \n먼저, 도시의 정보를 객체 지향적으로 모델링하여 `City`, `House`, `ChickenStore` 클래스를 정의하고, \n각각의 역할을 명확히 분리했다. 조합을 활용하여 가능한 모든 치킨집 조합을 생성하고, 선택된 치킨집들에 대해 도시의 치킨 거리를 계산하는 방식으로 진행했다. 거리 계산은 각 집이 가장 가까운 치킨집까지의 맨해튼 거리를 구하여 합산하는 방식이며, 이를 `Stream API`를 활용하여 간결하게 구현했다. 전체적인 시간 복잡도는 \\( C(13, M) \\times O(N^2) \\)로, 최악의 경우에도 치킨집 개수가 13개 이하로 제한되므로 충분히 해결 가능했다. 이를 통해 객체 지향적인 구조를 유지하면서도 효율적인 탐색이 가능하도록 최적화된 풀이를 도출할 수 있었다.\n\n```java\npackage test.code;\n\nimport java.util.*;\n\nclass City {\n    private final int size;\n    private final List<House> houses;\n    private final List<ChickenStore> chickenStores;\n\n    public City(int size) {\n        this.size = size;\n        this.houses = new ArrayList<>();\n        this.chickenStores = new ArrayList<>();\n    }\n\n    public void addHouse(int r, int c) {\n        houses.add(new House(r, c));\n    }\n\n    public void addChickenStore(int r, int c) {\n        chickenStores.add(new ChickenStore(r, c));\n    }\n\n    public int calculateMinChickenDistance(List<ChickenStore> selectedStores) {\n        int totalDistance = 0;\n        for (House house : houses) {\n            totalDistance += house.getMinDistance(selectedStores);\n        }\n        return totalDistance;\n    }\n\n    public List<ChickenStore> getChickenStores() {\n        return chickenStores;\n    }\n}\n\nclass House {\n    private final int row;\n    private final int col;\n\n    public House(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    public int getMinDistance(List<ChickenStore> stores) {\n        return stores.stream()\n                .mapToInt(store -> store.getDistance(this))\n                .min()\n                .orElse(Integer.MAX_VALUE);\n    }\n\n    public int getDistanceTo(House house) {\n        return Math.abs(this.row - house.row) + Math.abs(this.col - house.col);\n    }\n}\n\nclass ChickenStore {\n    private final int row;\n    private final int col;\n\n    public ChickenStore(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    public int getDistance(House otherHouse) {\n        House thisHouse = new House(this.row, this.col);\n        return thisHouse.getDistanceTo(otherHouse);\n    }\n}\n\npublic class Main {\n    private static int N, M;\n    private static City city;\n    private static int minDistance = Integer.MAX_VALUE;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        city = new City(N);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int type = scanner.nextInt();\n                if (type == 1) {\n                    city.addHouse(i, j);\n                } else if (type == 2) {\n                    city.addChickenStore(i, j);\n                }\n            }\n        }\n        scanner.close();\n\n        selectChickenStores(0, new ArrayList<>(), 0);\n        System.out.println(minDistance);\n    }\n\n    private static void selectChickenStores(int start, List<ChickenStore> selected, int count) {\n        if (count == M) {\n            minDistance = Math.min(minDistance, city.calculateMinChickenDistance(selected));\n            return;\n        }\n\n        List<ChickenStore> chickenStores = city.getChickenStores();\n        for (int i = start; i < chickenStores.size(); i++) {\n            selected.add(chickenStores.get(i));\n            selectChickenStores(i + 1, selected, count + 1);\n            selected.remove(selected.size() - 1);\n        }\n    }\n}\n```"},{"excerpt":"오목 백준 2615번 오목 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 44140 8807 6038 19.099% 문제 오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고…","fields":{"slug":"/boj-2615/"},"frontmatter":{"date":"February 06, 2025","title":"2615 오목","tags":["Algorithm"]},"rawMarkdownBody":"\n# 오목\n[백준 2615번 오목](https://www.acmicpc.net/problem/2615)\n\n| 시간 제한 | 메모리 제한 | 제출    | 정답   | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:------|:-----|:------|:--------|\n| 1 초   | 128 MB | 44140 | 8807 | 6038  | 19.099% |\n\n### 문제\n\n오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.\n\n![](img.png)\n\n위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 즉, 위의 그림은 검은색이 이긴 경우이다. 하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.\n\n입력으로 바둑판의 어떤 상태가 주어졌을 때, 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 단, 검은색과 흰색이 동시에 이기거나 검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.\n\n### 입력\n\n19줄에 각 줄마다 19개의 숫자로 표현되는데, 검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시되며, 숫자는 한 칸씩 띄어서 표시된다.\n\n### 출력\n\n첫줄에 검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.\n\n---\n\n## 풀이\n\n처음에는 `char[][]` 배열을 사용하여 입력을 처리했지만, 공백으로 구분된 숫자를 올바르게 읽지 못해 `int[][]` 배열로 변경했다. 또, `isOmok()` 메서드에서 5개의 돌이 연속되는지만 확인하고 **6목(여섯 개 이상 연속되는 경우)을 방지하는 로직이 없어서** 틀린 결과가 나왔다. 이를 해결하기 위해 **앞뒤 돌을 검사하여 6목 여부를 체크**하도록 수정했다. 그리고 승리한 돌의 좌표를 반환할 때, **배열 인덱스(0-based)와 바둑판 좌표(1-based) 차이를 고려하지 않아 잘못된 좌표가 출력되는 문제**도 발견했다. 이를 `(i + 1, j + 1)`로 변환하여 해결했고, 불필요한 `visited` 배열을 제거하여 코드의 복잡성을 줄였다. 결국, 입력 데이터를 정확히 읽고, 6목을 방지하면서, 올바른 승리 좌표를 반환하도록 개선하니 문제를 정확하게 해결할 수 있었다.\n\n```java\nimport java.io.*;\n\nclass Omok {\n    private static final int EMPTY = 0;\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n    private final int[][] board;\n    private final int LINES;\n\n    private Omok(int[][] board) {\n        this.board = board;\n        this.LINES = board.length;\n    }\n\n    static class Winner {\n        private final int winner;\n        private final int x;\n        private final int y;\n\n        private Winner(int winner, int x, int y) {\n            this.winner = winner;\n            this.x = x;\n            this.y = y;\n        }\n\n        public static Winner from(int winner, int x, int y) {\n            return new Winner(winner, x, y);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%d\\n%d %d\", winner, x, y);\n        }\n    }\n\n    public static Omok from(int[][] board) {\n        return new Omok(board);\n    }\n\n    private Winner findWinner() {\n        for (int i = 0; i < LINES; i++) {\n            for (int j = 0; j < LINES; j++) {\n                if (board[i][j] != EMPTY) {\n                    for (int[] direction : DIRECTIONS) {\n                        if (isOmok(i, j, direction[0], direction[1])) {\n                            return Winner.from(board[i][j], i + 1, j + 1);\n                        }\n                    }\n                }\n            }\n        }\n        return Winner.from(0, 0, 0);\n    }\n\n    private boolean isOmok(int x, int y, int dx, int dy) {\n        int color = board[x][y];\n        int count = 1;\n\n        int prevX = x - dx;\n        int prevY = y - dy;\n        if (isValid(prevX, prevY) && board[prevX][prevY] == color) {\n            return false; // 6목 방지: 연속된 돌의 시작점이 아님\n        }\n\n        for (int i = 1; i < 5; i++) {\n            int nx = x + dx * i;\n            int ny = y + dy * i;\n            if (!isValid(nx, ny) || board[nx][ny] != color) {\n                return false;\n            }\n            count++;\n        }\n\n        int nextX = x + dx * 5;\n        int nextY = y + dy * 5;\n        if (isValid(nextX, nextY) && board[nextX][nextY] == color) {\n            return false; // 6목 방지\n        }\n\n        return count == 5;\n    }\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < LINES && y >= 0 && y < LINES;\n    }\n\n    public String getWinner() {\n        Winner winner = findWinner();\n        if (winner.winner == 0) {\n            return \"0\";\n        }\n        return winner.toString();\n    }\n}\n\npublic class Main {\n    public static final int LINES = 19;\n\n    public static void main(String args[]) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int[][] board = new int[LINES][LINES];\n\n        for (int i = 0; i < LINES; i++) {\n            String[] input = reader.readLine().split(\" \");\n            for (int j = 0; j < LINES; j++) {\n                board[i][j] = Integer.parseInt(input[j]);\n            }\n        }\n        reader.close();\n\n        String result = Omok.from(board).getWinner();\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result);\n        writer.newLine();\n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"부등호 백준 2529번 부등호 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 30616 18053 12272 57.980% 문제 두 종류의 부등호 기호 ‘<’와 ‘>’가 k개 나열된 순서열 A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 …","fields":{"slug":"/boj-2529/"},"frontmatter":{"date":"February 05, 2025","title":"2529 부등호","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 부등호\n\n[백준 2529번 부등호](https://www.acmicpc.net/problem/2529)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 30616 | 18053 | 12272 | 57.980% |\n\n### 문제\n\n두 종류의 부등호 기호 ‘<’와 ‘>’가 k개 나열된 순서열 A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자.\n\n$$A ⇒ < < < > < < > < >$$\n\n부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를 만족시키는 한 예이다.\n\n$$3 < 4 < 5 < 6 > 1 < 2 < 8 > 7 < 9 > 0$$\n\n이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다. 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다.\n\n$$5 < 6 < 8 < 9 > 0 < 2 < 3 > 1 < 7 > 4$$\n\n여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다. 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 **선택된 숫자는 모두 달라야 한다.**\n\n### 입력\n\n첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다. 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 $2 ≤ k ≤ 9$ 이다.\n\n### 출력\n\n여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.\n\n---\n\n## 풀이\n\n이 문제를 풀면서 백트래킹(Backtracking)의 강력함을 다시 한번 실감했다. 처음에는 단순한 DFS 탐색 문제처럼 보였지만, 숫자의 중복 방지와 부등호 조건을 충족하는지 검사하는 부분이 핵심이었다. 특히, 탐색 과정에서 visited 배열을 활용하여 불필요한 중복을 막고, 조건을 만족하지 않는 경우 즉시 백트래킹하는 방식이 탐색 공간을 효과적으로 줄이는 데 도움이 되었다. 또한, k가 최대 9로 제한되어 있어 완전 탐색이 가능하다는 점도 문제 해결 전략을 세우는 데 중요한 요소였다. 탐색이 끝난 후 모든 가능한 숫자 조합을 정렬하여 최댓값과 최솟값을 구하는 방식은 직관적이었고, 결과적으로 문제를 깔끔하게 해결할 수 있었다.\n\n```java\nimport java.util.*;\n\nclass InequalityChecker {\n    private final char[] signs;\n\n    public InequalityChecker(char[] signs) {\n        this.signs = signs;\n    }\n\n    public boolean isValid(int left, int right, int index) {\n        if (signs[index] == '<') return left < right;\n        if (signs[index] == '>') return left > right;\n        return false;\n    }\n}\n\nclass NumberGenerator {\n    private final int k;\n    private final InequalityChecker checker;\n    private final List<String> results = new ArrayList<>();\n    private final boolean[] visited = new boolean[10];\n\n    public NumberGenerator(int k, char[] signs) {\n        this.k = k;\n        this.checker = new InequalityChecker(signs);\n    }\n\n    public void generate() {\n        dfs(\"\", 0);\n    }\n\n    private void dfs(String num, int depth) {\n        if (depth == k + 1) {\n            results.add(num);\n            return;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            if (!visited[i]) {\n                if (depth == 0 || checker.isValid(num.charAt(depth - 1) - '0', i, depth - 1)) {\n                    visited[i] = true;\n                    dfs(num + i, depth + 1);\n                    visited[i] = false;\n                }\n            }\n        }\n    }\n\n    public String getMaxNumber() {\n        return Collections.max(results);\n    }\n\n    public String getMinNumber() {\n        return Collections.min(results);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int k = sc.nextInt();\n        char[] signs = new char[k];\n\n        for (int i = 0; i < k; i++) {\n            signs[i] = sc.next().charAt(0);\n        }\n\n        NumberGenerator generator = new NumberGenerator(k, signs);\n        generator.generate();\n\n        System.out.println(generator.getMaxNumber());\n        System.out.println(generator.getMinNumber());\n    }\n}\n```"},{"excerpt":"스트림이란? 스트림 API는 다야의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 Java8부터 추가되었다.\n여기서 이 API가 제공하는 핵심 추상 개념은 다음 두 가지다. 데이터 원소의 유한 혹은 무한 시퀀스를 뜻하는 스트림 원소들로 수행하는 연산 단계를 표현한느 스트림 파이프라인 스트림의 원소들은 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수…","fields":{"slug":"/item-45/"},"frontmatter":{"date":"February 05, 2025","title":"스트림은 주의해서 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 스트림이란?\n\n스트림 API는 다야의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 Java8부터 추가되었다.\n여기서 이 API가 제공하는 핵심 추상 개념은 다음 두 가지다.\n\n- 데이터 원소의 유한 혹은 무한 시퀀스를 뜻하는 스트림\n- 원소들로 수행하는 연산 단계를 표현한느 스트림 파이프라인\n\n스트림의 원소들은 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성기, 혹은 다른 스트림 등 어디로부터든 원소들이 올 수 있다.\n보통 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값인데, 기본 타입 값으로는 int, long, double 이렇게 세 가지를 지원한다.\n\n스트림은 이제 알겠는데 그럼 스트림 파이프라인은 무엇일까?\n스트림 파이프라인은 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 중간 연산이 연결되는데, 이때 각 중간 연산은 변환을 한다.\n그래서 스트림의 원소 타입은 변환 전 스트림의 원소 타입과 같을 수도 있고, 다를 수도 있다.\n\n> 추가 설명을 하자면 중간 연산은 특정 조건을 만족 못하는 원소를 걸러내는 연산인 filter나 map 같은 연산을,\n> 종단 연산은 원소를 정렬해 컬렉션에 담거나 특정 원소 하나를 선택하거나 모든 원소를 출력하는 연산을 의미한다고 보면 된다.\n\n### 스트림 파이프라인은 지연 평가된다.\n\n스트림 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.\n즉, 종단 연산이 없는 파이프 라인은 아무 일도 하지 않는 `no-op`같은 명령어이다.\n그러니, 종단 연산을 빼먹는 일이 절대 없도록 해야한다.\n\n## 스트림 API\n\n스트림 API는 메서드 연쇄를 지원하는 플루언트 API다.\n즉, 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다.\n그래서 파이프라인 여러 개를 갖다가 연결해서 표현식 하나로 만들 수도 있다.\n\n기본적으로 스트림 파이프라인은 순차적으로 수행되는데, 이때 병렬로 실행하려면 파이프라인을 구성하는 스트림 중 하나에서 `parallel`을 호출하면 된다.\n\n```java\nimport java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        Stream.of(1, 2, 3, 4, 5)\n                .parallel()\n                .forEach(System.out::println);\n    }\n}\n```\n\n하지만, 효과를 볼 수 있는 상황은 많지 않다.\n\n스트림 API는 다재다능하여 사실상 어떠한 계산이라도 해낼 수 있다.\n하지만 할 수 있다는 뜻이지, 해야한다는 뜻은 아니다.\n그 이유는 스트림을 제대로만 사용하면 코드가 짧고 깔끔해지지만, 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.\n그리고 이러한 스트림을 언제 써야 하는지를 규정하는 확고부동한 규칙이 없다(그래도 노하우는 있으니 안심하자).\n\n### 왜 주의해야 할까?\n\n책에서는 아나그램 프로그램 코드를 이용해 케이스에 맞게 예시를 보여주며 교훈을 주고 있다..\n\n#### 스트림 없이 구현한 코드\n\n```java\npublic class Anagrams {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFile dictionary = new File(args[0]); // 사전 파일\n\t\tint minGroupSize = Integer.parseInt(args[1]); // 사용자가 지정한 원소 수 문턱값\n\n\t\t// key : 알파벳 순으로 정렬한 값, value : 같은 키를 공유한 단어들을 담은 집합\n\t\tMap<String, Set<String>> groups = new HashMap<>();\n\n\t\ttry (Scanner s = new Scanner(dictionary)) { //사전 파일에서 단어 읽음\n\t\t\twhile (s.hasNext()) {\n\t\t\t\tString word = s.next();\n\t\t\t\tgroups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word);\n\t\t\t}\n\t\t}\n\n\t\t//minGroupSize 보다 원소 수가 많은 아나그램 그룹 출력\n\t\tfor (Set<String> group : groups.values()) {\n\t\t\tif (group.size() >= minGroupSize) {\n\t\t\t\tSystem.out.println(group.size() + \" : \" + group);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 아나그램 그룹의 key를 만들어줌\n\tprivate static String alphabetize(String s) {\n\t\tchar[] a = s.toCharArray();\n\t\tArrays.sort(a);\n\t\treturn new String(a);\n\t}\n}\n```\n\n#### 스트림을 과하게 사용한 코드\n\n```java\npublic class Anagrams {\n\tpublic static void main(String[] args) throws IOException {\n\t\tPath dictionary = Paths.get(args[0]); // 사전 파일 경로\n\t\tint minGroupSize = Integer.parseInt(args[1]); // 사용자가 지정한 원소 수 문턱값\n\n\t\ttry (Stream<String> words = Files.lines(dictionary)) { // try-with-resources 문을 사용해 파일을 닫음\n\t\t\t// 사전을 여는 부분을 제외하고 프로그램 전체가 단 하나의 표현식으로 처리\n\t\t\twords.collect(\n\t\t\t\t\tgroupingBy(word -> word.chars().sorted()\n\t\t\t\t\t\t\t.collect(StringBuilder::new,\n\t\t\t\t\t\t\t\t\t(sb, c) -> sb.append((char) c),\n\t\t\t\t\t\t\t\t\tStringBuilder::append).toString()))\n\t\t\t\t\t.values().stream()\n\t\t\t\t\t.filter(group -> group.size() >= minGroupSize) //\n\t\t\t\t\t.map(group -> group.size() + \" : \" + group)\n\t\t\t\t\t.forEach(System.out::println);\n\t\t}\n\t}\n}\n```\n\n확실히 짧아졌지만, 읽기가 어렵다. 그리고 이는 스트림에 익숙치 않은 프로그래머에게는 더 어려울 것이다.\n\n#### 스트림을 적절히 활용한 코드\n\n```java\npublic class Anagrams {\n\tpublic static void main(String[] args) throws IOException {\n\t\tPath dictionary = Paths.get(args[0]); // 사전 파일 경로\n\t\tint minGroupSize = Integer.parseInt(args[1]); // 사용자가 지정한 원소 수 문턱값\n\n\t\ttry (Stream<String> words = Files.lines(dictionary)) { // try-with-resources 문을 사용해 파일을 닫음\n\t\t\twords.collect(groupingBy(Anagrams::alphabetize)) // alphabetize 메서드로 단어들을 그룹화함\n\t\t\t\t\t.values().stream()\n\t\t\t\t\t.filter(group -> group.size() >= minGroupSize) // 문턱값보다 작은 것을 걸러냄\n\t\t\t\t\t.forEach(g -> System.out.println(g.size() + \" : \" + g)); // 필터링이 끝난 리스트 출력\n\t\t}\n\t}\n\n\t// 아나그램 그룹의 key를 만들어줌\n\tprivate static String alphabetize(String s) {\n\t\tchar[] a = s.toCharArray();\n\t\tArrays.sort(a);\n\t\treturn new String(a);\n\t}\n}\n```\n\n이처럼 스트림을 적절히 활용하면 깔끔하고 명료해진다.\n이때 주의할 점은 람다에서 타입 이름을 자주 생략하기 때문에 네이밍을 잘 해주어야한다.\n위 코드에서 보면 `forEach()` 안에 `g`의 경우, `group`이라고 네이밍해주면 된다.\n이렇게 람다의 매개변수도 네이밍을 적절히 해주면 파이프라인의 가독성이 스트림을 사용해도 떨어지지 않는다.\n\n> 아래 alphabetize 메소드에서는 스트림을 사용하지 않았다. 그 이유는 char의 스트림은 자바는 지원하지 않고 있기 때문이다. 여기서 알 수 있는 것은 char는 스트림을 삼가는 것이 좋다는 것이다.\n\n\n## 리팩토링 관점에서의 스트림\n\n원래 반복문을 사용하고 있는 코드에 대해서는 최대한 스트림으로 리팩토링을 하지만 새로운 스트림 코드가 더 나을때만 진행하는 것이 좋다.\n책에서는 코드 블록과 람다 블록을 비교하며, 코드 블록이 더 나을 때는 스트림을 사용하지 않는 것이 좋다고 한다.\n\n그럼 코드 블록이 나을 때가 언제일까?\n람다에서는 `final`이거나 사실상 `final`인 변수만 읽을 수 있고, 지역 변수를 수정하는 건 불가능하다.\n하지만, 코드블록은 범위 안의 지역 변수를 읽고 수정할 수 있다.\n또 있다.\n코드 블록은 `return`, `break`, `continue` 등을 사용하거나 메서드 선언에 명시된 검사 예외를 던질 수 있지만,\n람다로는 이중 무엇도 할 수가 없다.\n이처럼 람다로는 할 수 없는 것들이 많기 때문에 코드 블록이 더 나을 때는 코드 블록을 사용하는 것이 좋다.\n\n그럼 언제 람다를 사용해야 할까?\n스트림으로 처리하기에 딱인 경우 또한 존재한다.\n다음은 스트림으로 처리하기에 적합한 경우이다.\n\n- 원소들의 시퀀스를 일관되게 변환하는 경우\n- 원소들의 시퀀스를 필터링하는 경우\n- 원소들의 시퀀스를 하나의 연산을 사용해 결합하는 경우\n- 원소들의 시퀀스를 하나의 컬렉션에 모아 넣는 경우\n- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는 경우\n\n한편,스트림으로 처리하기 어려운 경우도 존재한다.\n대표적으로, 한 데이터가 파이프 라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시 접근하기 어렵다.\n이유는 다른 값에 매핑하고 나면 원래의 값은 잃는 구조이기 때문이다.\n원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하는 우회 방법도 있지만, 복잡하기 때문에 사용하지 않는 것이 좋을 것이다.\n\n## 스트림과 반복 중 어느 쪽을 써야 할까?\n\n코딩을 하다보면 스트림과 반복문 중 어느 쪽을 써야 할지 바로 알기 어려운 작업도 많다.\n그럼 어떻게 해야 할까?\n스트림을 사용해야 멋지게 처리할 수 있는 일이 있고, 반복 방식이 더 알맞은 일도 있다.\n그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결된다.\n처음에 말했듯이 어느쪽을 선택하는 확고부동한 규칙은 없지만, 방법은 있다고 했다.\n책에서는 다음과 같은 방법을 제시한다.\n_**스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.**_"},{"excerpt":"숫자 정사각형 백준 1051번 숫자 정사각형 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 25921 11944 10155 46.780% 문제 N×M크기의 직사각형이 있다. 각 칸에는 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형…","fields":{"slug":"/boj-1051/"},"frontmatter":{"date":"February 04, 2025","title":"1051 숫자 정사각형","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 숫자 정사각형\n\n[백준 1051번 숫자 정사각형](https://www.acmicpc.net/problem/1051)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 25921 | 11944 | 10155 | 46.780% |\n\n### 문제\n\nN×M크기의 직사각형이 있다. 각 칸에는 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형은 행 또는 열에 평행해야 한다.\n\n### 입력\n\n첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 주어진다.\n\n### 출력\n\n첫째 줄에 정답 정사각형의 크기를 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 우선 완전 탐색 알고리즘으로 구현에만 집중을 했다. 구현에는 정사각형을 이루는 조건만 검증하면 간단하다. 정사각형을 이루는 조건은 4개의 꼭짓점이 같은 숫자인지 확인하는 것이다. \n이 부분에 대해선 다음과 같이 해결했다.\n\n```java\nfor (int k = 1; k < Math.min(n, m); k++) {\n    if (i+k < n && j+k < m) {\n        if (map[i][j] == map[i][j+k] &&\n            map[i][j+k] == map[i+k][j+k] &&\n            map[i+k][j+k] == map[i+k][j]) {\n                max = (int) Math.max(max, Math.pow(k + 1, 2));\n        }\n    }\n}\n```\n\n잠깐 헤메었던 부분은 평소에 문자열 파싱을 할 때, `StirngTokenizer`을 사용해서 이번에도 사용했지만, 처음엔 에러가 났다.\n디버그 모드로 돌려보니 전혀 tokenization 하지 못하고 있던 것이었다.\n그래서 잘 parameter로 empty를 delimiter로 넘겨주었는데, 이것 또한 안되었다.\n이때 어? 뭐지 하다가 찾아보니 `StringTokenizer`는 delimiter를 최소 길이가 1인 문자열을 넘겨주어야 했다.\n그래서 이 문제는 `StringTokenizer`가 아닌 그냥 `toCharArray`를 이용해 풀었다.\n기존 코드에서 간단히 primitive type value에 대한 비교 였기에 `char`로 type casting을 해도 문제가 없었다.\n이렇게 해서 완성된 코드를 제출하니 성공.. 다음에는 `StringTokenizer`를 사용할 때 delimiter에 대한 주의를 해야겠다.\n\n```java\npackage test.code;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int m = Integer.parseInt(tokenizer.nextToken());\n\n        char[][] map = new char[n][m];\n        for (int i  = 0; i < n; i++) {\n            map[i] = reader.readLine().toCharArray();\n        }\n\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                for (int k = 1; k < Math.min(n, m); k++) {\n                    if (i+k < n && j+k < m) {\n                        if (map[i][j] == map[i][j+k] &&\n                                map[i][j+k] == map[i+k][j+k] &&\n                                map[i+k][j+k] == map[i+k][j]) {\n                            max = (int) Math.max(max, Math.pow(k + 1, 2));\n                        }\n                    }\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(max);\n        System.out.println(sb.toString().trim());\n    }\n}\n```"},{"excerpt":"효율적인 해킹 백준 1325번 효율적인 해킹 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 5 초 256 MB 107393 16523 11108 18.941% 문제 해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨…","fields":{"slug":"/boj-1325/"},"frontmatter":{"date":"February 03, 2025","title":"1325 효율적인 해킹","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 효율적인 해킹\n\n[백준 1325번 효율적인 해킹](https://www.acmicpc.net/problem/1325)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 5 초   | 256 MB | 107393 | 16523 | 11108 | 18.941% |\n\n### 문제\n\n해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.\n\n이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.\n\n이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, \"A가 B를 신뢰한다\"를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다.\n\n### 출력\n\n첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.\n\n---\n\n## 풀이\n\n\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class EfficientHacking {\n    static int N, M;\n    static List<Integer>[] graph;\n    static int[] hackCount; // 각 노드에서 해킹 가능한 개수 저장\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n\n        graph = new ArrayList[N + 1];\n        hackCount = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        // 신뢰 관계 입력 받기\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int A = Integer.parseInt(st.nextToken());\n            int B = Integer.parseInt(st.nextToken());\n            graph[B].add(A); // B를 해킹하면 A도 해킹됨\n        }\n\n        int maxCount = 0;\n        List<Integer> result = new ArrayList<>();\n\n        // 모든 노드에서 BFS 수행\n        for (int i = 1; i <= N; i++) {\n            int count = bfs(i);\n            if (count > maxCount) {\n                maxCount = count;\n                result.clear();\n                result.add(i);\n            } else if (count == maxCount) {\n                result.add(i);\n            }\n        }\n\n        Collections.sort(result);\n        StringBuilder sb = new StringBuilder();\n        for (int num : result) {\n            sb.append(num).append(\" \");\n        }\n\n        System.out.println(sb.toString().trim());\n    }\n\n    // BFS를 이용해 해킹 가능한 컴퓨터 개수 계산\n    static int bfs(int start) {\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[N + 1];\n\n        queue.add(start);\n        visited[start] = true;\n        int count = 1; // 자기 자신 포함\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int next : graph[node]) {\n                if (!visited[next]) {\n                    visited[next] = true;\n                    queue.add(next);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n\n```"},{"excerpt":"체스판 다시 칠하기 백준 1018번 체스판 다시 칠하기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 141306 71100 56615 50.245% 문제 지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지…","fields":{"slug":"/boj-1018/"},"frontmatter":{"date":"February 03, 2025","title":"1018 체스판 다시 칠하기","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 체스판 다시 칠하기\n\n[백준 1018번 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 141306 | 71100 | 56615 | 50.245% |\n\n### 문제\n\n지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.\n\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.\n\n보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.\n\n### 출력\n\n첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.\n\n---\n\n## 풀이\n\n체스판 다시 칠하기 문제를 풀면서 가장 먼저 떠올린 방법은 8×8 크기의 체스판을 만들 수 있는 모든 경우를 탐색하는 것이었다. 보드에서 가능한 모든 8×8 영역을 잘라낸 후, 각 영역을 두 가지 체스판 패턴(왼쪽 위가 W 또는 B)과 비교하여 다시 칠해야 하는 개수를 구했다. 처음에는 직접 체스판 패턴을 리스트로 만들어 비교하려고 했는데, `(i + j) % 2` 규칙을 활용하면 불필요한 비교 연산을 줄일 수 있다는 점을 깨달았다. 이렇게 하면 현재 좌표가 W여야 하는지 B여야 하는지를 쉽게 판별할 수 있었고, 두 패턴과의 차이를 계산해 최소 변경 횟수를 구할 수 있었다. 이 방식을 적용해서 `(N-7) × (M-7)` 개의 8×8 영역을 검사하고, 각 영역에서 필요한 최소 변경 횟수를 구한 후 전체 최솟값을 찾는 방식으로 구현했다. 코드의 시간 복잡도는 `O(NM)`이었고, 입력 크기가 최대 50×50이라 충분히 빠르게 동작했다. 결과적으로 원하는 답을 효율적으로 구할 수 있었고, 최적화도 자연스럽게 이루어졌다.\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static char[][] board; // 입력받을 보드\n    static int N, M; // 보드의 크기\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] size = br.readLine().split(\" \");\n        N = Integer.parseInt(size[0]);\n        M = Integer.parseInt(size[1]);\n        \n        board = new char[N][M];\n        for (int i = 0; i < N; i++) {\n            board[i] = br.readLine().toCharArray();\n        }\n        \n        int minRepaints = Integer.MAX_VALUE; // 최솟값 초기화\n        \n        // 8x8 체스판을 추출할 수 있는 모든 경우 탐색\n        for (int i = 0; i <= N - 8; i++) {\n            for (int j = 0; j <= M - 8; j++) {\n                minRepaints = Math.min(minRepaints, countRepaints(i, j));\n            }\n        }\n        \n        System.out.println(minRepaints);\n    }\n    \n    // (x, y)에서 시작하는 8x8 체스판을 다시 칠하는 최소 비용 계산\n    public static int countRepaints(int x, int y) {\n        int repaintW = 0; // W로 시작하는 체스판과 비교\n        int repaintB = 0; // B로 시작하는 체스판과 비교\n\n        // 8x8 체스판 검사\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                char currentColor = board[x + i][y + j];\n\n                // 기준 체스판 패턴과 비교\n                if ((i + j) % 2 == 0) { // 짝수 위치\n                    if (currentColor != 'W') repaintW++; // 'W'가 아니면 다시 칠하기\n                    if (currentColor != 'B') repaintB++; // 'B'가 아니면 다시 칠하기\n                } else { // 홀수 위치\n                    if (currentColor != 'B') repaintW++; // 'B'가 아니면 다시 칠하기\n                    if (currentColor != 'W') repaintB++; // 'W'가 아니면 다시 칠하기\n                }\n            }\n        }\n        \n        // W로 시작하는 경우와 B로 시작하는 경우 중 최소값 반환\n        return Math.min(repaintW, repaintB);\n    }\n}\n\n```"},{"excerpt":"5주간의 JSCODE 스터디가 끝났다. 짧다면 짧고, 길다면 길었던 이 시간 동안 나는 면접 준비라는 목표를 넘어, 개발자로서 한층 더 성장할 수 있었다.\n처음에는 막연한 두려움과 기대를 안고 시작했지만, 스터디를 통해 스스로의 부족한 점을 파악하고 이를 보완할 기회를 가질 수 있었다.\n이 글을 통해 그 과정과 배운 점을 정리하고자 한다. 스터디를 시작한…","fields":{"slug":"/jscode-study-memoir/"},"frontmatter":{"date":"January 31, 2025","title":"JSCODE 스터디 되돌아보기","tags":["Study"]},"rawMarkdownBody":"    \n5주간의 JSCODE 스터디가 끝났다. 짧다면 짧고, 길다면 길었던 이 시간 동안 나는 면접 준비라는 목표를 넘어, 개발자로서 한층 더 성장할 수 있었다. \n처음에는 막연한 두려움과 기대를 안고 시작했지만, 스터디를 통해 스스로의 부족한 점을 파악하고 이를 보완할 기회를 가질 수 있었다. \n이 글을 통해 그 과정과 배운 점을 정리하고자 한다.\n\n## 스터디를 시작한 이유\n\n이 스터디에 참여한 이유는 단순했다. 면접에 대한 두려움을 극복하고, 실전 경험을 쌓고 싶었다. \n혼자 준비하는 면접과 실제 면접 환경에서 질문을 받고 답변하는 과정은 확연히 달랐다. 따라서, 면접 스터디를 통해 실전과 유사한 환경에서 연습하고, 체계적인 피드백을 받아 나의 약점을 보완하는 것이 필요했다. \n또한, 면접 질문을 단순 암기하는 것이 아니라, 본질적인 개념을 이해하고 논리적으로 설명하는 능력을 기르고 싶었다.\n\n## 스터디에서 얻은 것들\n\n첫 주는 혼란스러웠다. 질문을 받고 답하는 것 자체가 익숙하지 않았고, 어떻게 답변을 구성해야 할지 막막했다. \n하지만 스터디가 진행될수록 면접 질문의 흐름과 구조를 이해하게 되었다. \n무엇보다 '면접자, 관찰자, 면접관' 역할을 번갈아 가며 경험하는 방식이 큰 도움이 되었다.\n\n면접자로서 논리적으로 답변을 정리하는 연습을 했고, 관찰자로서는 다른 사람의 답변을 분석하며 객관적인 시각을 가질 수 있었다. \n또한, 면접관 역할을 수행하면서 질문의 의도를 분석하고 답변을 평가하는 과정을 거쳤다. 이를 통해 ‘좋은 답변’이란 무엇인지 자연스럽게 익힐 수 있었다.\n\n2주 차부터는 좀 더 체계적으로 개념을 정리하고, 질문이 요구하는 핵심 내용을 정리하는 연습을 했다.\n이 과정에서 단순한 암기가 아닌, 개념을 깊이 이해하고 활용하는 능력을 키울 수 있었다. 또한, 질문 하나를 준비하면서 관련된 개념을 자연스럽게 학습하는 효과도 있었다. \n단순히 면접 준비를 위한 공부가 아니라, 개발자로서의 전반적인 역량을 키우는 과정이었다.\n\n이번 스터디에서 가장 크게 얻은 것은 ‘나무가 아닌 숲을 보는 법’이었다.\n면접 질문을 단편적으로 받아들이는 것이 아니라, 전체적인 맥락 속에서 이해하는 것이 중요하다는 점을 깨달았다.\n이를 통해 단순한 정답을 찾는 것이 아니라, 논리적인 흐름을 만들어가는 것이 얼마나 중요한지를 알게 되었다.\n\n## 스터디 이후의 변화\n\n스터디가 끝난 후에도 자연스럽게 학습을 지속하고 싶다는 생각이 들었다. \n이번 경험이 단순히 면접 준비를 넘어서, 개발자로서의 깊이 있는 학습의 계기가 되었기 때문이다. 이를 위해 관련 서적을 구매하고, 스터디에서 다뤘던 내용을 정리하여 블로그나 강의 자료로 남기려 한다. \n또한, 다음 스터디 과정에도 참여해 더욱 실력을 다질 계획이다.\n\n만약 면접을 준비하는 사람이 있다면, 이 스터디를 적극 추천하고 싶다. 단순히 면접 기술을 익히는 것이 아니라, 개념을 정리하고 논리적으로 사고하는 능력을 키울 수 있는 좋은 기회이기 때문이다. \n또한, 면접 경험이 부족한 사람뿐만 아니라, 자신의 생각을 정리하는 것이 어려운 사람에게도 큰 도움이 될 것이다.\n\n이번 경험을 통해 한층 더 성장할 수 있었다. 이제는 배운 것들을 실전에 적용하고, 계속해서 발전해 나갈 차례다. \n이 경험을 기반으로 앞으로 어떤 목표를 세우고 나아갈지 고민하며, 더욱 단단한 개발자가 되기를 기대해본다.\n\n"},{"excerpt":"주사위 윷놀이 백준 17825번 주사위 윷놀이 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 512 MB 15687 7048 4386 41.740% 문제 주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.  처음에는 시작 칸에 말 4개가 있다. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하…","fields":{"slug":"/boj-17825/"},"frontmatter":{"date":"January 31, 2025","title":"17825 주사위 윳놀이","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 주사위 윷놀이\n\n[백준 17825번 주사위 윷놀이](https://www.acmicpc.net/problem/17825)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 512 MB | 15687 | 7048 | 4386 | 41.740% |\n\n### 문제\n\n주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.<br>\n\n![img.png](img.png)\n\n- 처음에는 시작 칸에 말 4개가 있다.\n- 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.\n- 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.\n- 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다.\n- 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.\n\n주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.\n\n### 입력\n\n첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다.\n\n### 출력\n\n얻을 수 있는 점수의 최댓값을 출력한다.\n\n---\n\n## 풀이\n\n주사위 윷놀이는 4개의 말을 주어진 경로를 따라 이동시키면서 최대 점수를 얻는 조합을 찾는 문제이다. \n매 턴마다 주사위를 굴려 나온 수만큼 말을 이동시키며, 도착 칸에 도달하면 이동을 종료하고 해당 칸의 점수를 합산해야 한다. \n이 과정에서 같은 칸에 두 개의 말이 존재할 수 없으며, 파란색 칸에서는 특정 경로로 분기해야 하는 제약이 존재한다. \n이를 해결하기 위해 완전 탐색과 백트래킹을 활용하여 모든 이동 조합을 탐색하고 최적의 점수를 찾는 방식으로 접근한다. \n먼저, 10번의 주사위 값에 대해 이동할 말을 선택하는 순열을 생성하고, 이를 바탕으로 게임을 시뮬레이션하면서 점수를 계산한다. \n이동한 칸에 이미 다른 말이 존재하면 해당 조합을 무효화하고, 도착 칸에 도달한 말은 이후 이동에서 제외한다.\n또한, 현재까지 얻은 점수가 최고 점수보다 낮다면 더 이상 진행할 필요가 없으므로 가지치기를 수행하여 탐색 시간을 단축한다. \n게임판은 배열과 해시맵을 활용하여 이동 경로와 점수를 빠르게 참조할 수 있도록 구성하며, 각 말의 상태를 관리하여 이동 가능 여부를 판단한다.\n\n```java\npackage test.code;\n\nimport java.util.*;\n\npublic class Yutnori {\n\n    private static final int[] PATH = {\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28\n    };\n\n    private static final Map<Integer, Integer> SHORTCUT = new HashMap<>() {{\n        put(5, 22);\n        put(10, 25);\n        put(15, 27);\n    }};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        StringBuilder result = new StringBuilder();\n\n        for (int t = 1; t <= T; t++) {\n            int U = sc.nextInt();\n            int N = sc.nextInt();\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n\n            String[] throwsList = new String[N];\n            for (int i = 0; i < N; i++) {\n                throwsList[i] = sc.next();\n            }\n\n            int[] aPositions = new int[A];\n            for (int i = 0; i < A; i++) {\n                aPositions[i] = sc.nextInt();\n            }\n\n            int[] bPositions = new int[B];\n            for (int i = 0; i < B; i++) {\n                bPositions[i] = sc.nextInt();\n            }\n\n            String simulationResult = simulate(U, throwsList, aPositions, bPositions) ? \"YES\" : \"NO\";\n            result.append(\"Case #\").append(t).append(\": \").append(simulationResult).append(\"\\n\");\n        }\n\n        System.out.print(result);\n        sc.close();\n    }\n\n    private static boolean simulate(int U, String[] throwsList, int[] aPositions, int[] bPositions) {\n        int[] aTeam = new int[U];\n        int[] bTeam = new int[U];\n\n        boolean[] aFinished = new boolean[U];\n        boolean[] bFinished = new boolean[U];\n\n        int currentPlayer = 0; // 0 for A, 1 for B\n\n        for (String yut : throwsList) {\n            int move = getMoveDistance(yut);\n            if (currentPlayer == 0) {\n                if (!moveTeam(aTeam, bTeam, aFinished, bFinished, move)) {\n                    return false;\n                }\n                currentPlayer = 1;\n            } else {\n                if (!moveTeam(bTeam, aTeam, bFinished, aFinished, move)) {\n                    return false;\n                }\n                currentPlayer = 0;\n            }\n        }\n\n        return compareFinalPositions(aTeam, bTeam, aPositions, bPositions);\n    }\n\n    private static boolean moveTeam(int[] team, int[] opponent, boolean[] teamFinished, boolean[] opponentFinished, int move) {\n        for (int i = 0; i < team.length; i++) {\n            if (!teamFinished[i] && team[i] >= 0) {\n                team[i] = movePiece(team[i], move);\n                if (team[i] > 28) {\n                    teamFinished[i] = true;\n                } else {\n                    checkAndCapture(team, opponent, teamFinished, opponentFinished, i);\n                    handleStacking(team, i);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int getMoveDistance(String yut) {\n        switch (yut) {\n            case \"Do\": return 1;\n            case \"Gae\": return 2;\n            case \"Gul\": return 3;\n            case \"Yut\": return 4;\n            case \"Mo\": return 5;\n            default: return 0;\n        }\n    }\n\n    private static int movePiece(int position, int move) {\n        position += move;\n        if (SHORTCUT.containsKey(position)) {\n            position = SHORTCUT.get(position);\n        }\n        return position;\n    }\n\n    private static void checkAndCapture(int[] team, int[] opponent, boolean[] teamFinished, boolean[] opponentFinished, int idx) {\n        for (int j = 0; j < opponent.length; j++) {\n            if (!opponentFinished[j] && team[idx] == opponent[j]) {\n                opponent[j] = 0;\n            }\n        }\n    }\n\n    private static void handleStacking(int[] team, int idx) {\n        for (int j = 0; j < team.length; j++) {\n            if (j != idx && team[j] == team[idx]) {\n                team[j] = team[idx]; // Stack pieces\n            }\n        }\n    }\n\n    private static boolean compareFinalPositions(int[] aTeam, int[] bTeam, int[] aPositions, int[] bPositions) {\n        Set<Integer> aSet = new HashSet<>();\n        Set<Integer> bSet = new HashSet<>();\n\n        for (int pos : aPositions) aSet.add(pos);\n        for (int pos : bPositions) bSet.add(pos);\n\n        for (int pos : aTeam) {\n            if (pos > 0 && !aSet.contains(pos)) return false;\n        }\n        for (int pos : bTeam) {\n            if (pos > 0 && !bSet.contains(pos)) return false;\n        }\n\n        return true;\n    }\n}\n\n```"},{"excerpt":"트랜잭션 격리 수준은 동시에 실행되는 여러 트랜잭션 간의 상호 영향을 제어하는 수준을 말한다.\nANSI 표준에서 트랜잭션 격리 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE으로 총 네 가지로 구분된다.\n레벨이 높아질수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적…","fields":{"slug":"/database-isolation-level/"},"frontmatter":{"date":"January 31, 2025","title":"트랜잭션의 격리 수준(Transaction Isolation Level)","tags":["Database"]},"rawMarkdownBody":"\n트랜잭션 격리 수준은 동시에 실행되는 여러 트랜잭션 간의 상호 영향을 제어하는 수준을 말한다.\nANSI 표준에서 트랜잭션 격리 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE으로 총 네 가지로 구분된다.\n레벨이 높아질수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.\n그래서 일반적인 서비스에서는 READ COMMITTED나 REPEATABLE READ 중 하나의 레벨을 사용하는 것이 일반적이다.\n실제로 MySQL에서는 REPEATABLE READ가 기본 격리 수준으로 설정되어 있다.\n\n### SERIALIZABLE\n\nSERIALIZABLE은 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다. \nSERIALIZABLE에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다. \n하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어진다.\nMySQL에서 SELECT FOR SHARE/UPDATE는 대상 레코드에 각각 읽기/쓰기 잠금을 거는 것이다. \n하지만 순수한 SELECT 작업은 아무런 레코드 잠금 없이 실행되는데, 잠금 없는 일관된 읽기(Non-locking consistent read)란 순수한 SELECT 문을 통한 잠금 없는 읽기를 의미하는 것이다.\n하지만 SERIALIZABLE 격리 수준에서는 순수한 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락, Shared Lock)으로 건다. \n따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다. \nSERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다.\n\n\n### REPEATABLE READ\n\n일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둔다.\n그러면 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여 이를 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부른다. \nMVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다. \n각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장한다. \n그리고 해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 백그라운드 쓰레드를 통해 삭제한다.\n\nREPEATABLE READ는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있다.\n이를 Phantom Read라고 하는데, 이는 한 트랜잭션에서 동일한 쿼리를 두 번 실행했을 때, 두 번째 실행에서는 새로 추가된 레코드가 조회되는 현상을 말한다.\n\nMySQL에서 그러나 MySQL에서는 갭 락(Gap Lock)과 넥스트 키 락(Next-Key Lock)을 사용하여 유령 읽기 문제를 방지 하므로,\n실제로 MySQL에서는 REPEATABLE READ에서도 Phantom Read가 발생하지 않는다.\n\n### READ COMMITTED\n\nREAD COMMITTED 격리 수준은 커밋한 데이터만 조회할 수 있는 격리 수준이다.\nREAD COMMITTED에서 발생하는 트랜잭션 수행중에 다른 트랜잭션이 변경하고 커밋한 데이터를 조회할 수 있는데,\n\n**반복적으로 같은 데이터를 읽을 수 없는 NON-REPEATABLE READ 현상이 발생합니다**\n\n### READ UNCOMMITTED\n\nREAD UNCOMMITTED 격리 수준은 가장 낮은 수준의 격리 수준으로 커밋하지 않은 변경 데이터에 접근할 수 있는 격리 수준이다.\n다른 트랜잭션으 작업이 커밋 또는 롤백되지 않아도 조회할 수 있게 된다.\n이렇게 어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 Dirty Read 라고 한다.\nDirty Read는 데이터가 조회되었다가 사라지는 현상을 초래하므로 시스템에 상당한 혼란을 주게 된다.\n그래서 READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.\n따라서 MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용해야 한다.\n\n## 참고\n\n[1] [MangKyu Blog](https://mangkyu.tistory.com/17)\n    [+](https://mangkyu.tistory.com/300)\n[2] [hudi.blog](https://hudi.blog/transaction-isolation-level/)"},{"excerpt":"마커 인터페이스 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 표시해주는 인터페이스를 마커 인터페이스(marker interface)라고 한다.  인터페이스가 대표적인 마커 인터페이스이다. 이 인터페이스를 구현한 클래스는 직렬화할 수 있다는 것을 나타낸다. 실제로  인터페이스는 아무 메서드도 담고 있지 않다. 단지 클래스가 이…","fields":{"slug":"/item-41/"},"frontmatter":{"date":"January 30, 2025","title":"정의하려는 것이 타입이라면 마커 인터페이스를 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 마커 인터페이스\n\n아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 표시해주는 인터페이스를 마커 인터페이스(marker interface)라고 한다.\n\n`Serializable` 인터페이스가 대표적인 마커 인터페이스이다. 이 인터페이스를 구현한 클래스는 직렬화할 수 있다는 것을 나타낸다.\n\n```java\npublic interface Serializable {\n}\n```\n\n실제로 `Serializable` 인터페이스는 아무 메서드도 담고 있지 않다. 단지 클래스가 이 인터페이스를 구현하면 직렬화할 수 있다는 것을 나타낸다.\n\n## 마커 애너테이션의 오해\n\n마커 애서테이션이 등장하면서 마커 인퍼페이스는 구식이라는 이야기가 있다. 하지만 이는 사실이 아니다. 오히려 마커 인터페이스가 더 나은 선택일 수 있다.\n마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 클래스들을 구분하는 타입으로 쓸 수 있으나, 마커 애너테이션은 그렇지 않다.\n그래서 마커 인터페이스도 어엿한 타입이므로, 런타임에야 발견될 오류를 컴파일타임에 잡을 수 있지만, 애너테이션은 런타임에야 문제를 확인할 수 있다.\n마커 인터페이스가 나은 두 번째 이유는 적용 대상을 더 정밀하게 지정할 수 있다는 것이다. \n특정 인터페이스를 구현한 클래스에만 적용할 수 있게 하고 마킹을 해서 지정할 수 있다. \n> `@Target(ElementType.TYPE)`을 사용하여 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거 타입)에 적용할 수 있다.\n\n### Set 인터페이스도 일종의 마커 인터페이스\n`Set` 인터페이스는 마커 인터페이스의 전형적인 예이다.\n`Set` 인터페이스는 `Collection` 인터페이스를 확장하여 하위 타입에만 적용할 수 있고, `Collection` 인터페이스에 없는 기능을 제공하지 않는다.\n\n```java\npublic interface Set<E> extends Collection<E> {\n}\n```\n\n## 마커 애너테이션이 필요한 경우\n\n여태까지 설명에 따르면 마커 인터페이스가 더 나은 선택일 수 있지만, 절대는 아니다.\n마커 애너테이션은 거대한 애너테이션 시스템의 지원을 받는다.\n따라서 애너테이션을 적극 활용하는 프레임워크에서는 애너테이션을 사용해서 일관성을 지킬 수 있게 된다.\n\n## 마커 인터페이스를 사용해야 할 때\n\n그럼 언제 마커 인터페이스를 사용해야 할까?\n책에서는 클래스와 인터페이스 외의 프로그램 요소들 모듈이나, 패키지, 필드, 지역변수 등에 마킹해야 할 때 사용하라고 한다.\n그러면서, 책에서는 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을 때는 인터페이스를, \n마커 인터페이스를 메서드의 매개변수 타입으로 사용하여 컴파일에 오류를 잡을 수 있으면 애너테이션을 사용하라고 한다.\n\n> 애너테이션을 활발히 활용하는 프레임워크에서 사용하려는 마커라면 애너테이션을 사용하는 편이 좋다.\n\n## 정리\n\n새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를,\n클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용하는 프레임워크의 일부로 그 마커를 편입시키고자 한다면 마커 애너테이션을 사용하라.\n\n적용 대상이 `ElementType.TYPE`인 마커 애너테이션을 작성하고 있다면, 정말 애너테이션으로 구현하는 게 옳은지 생각을 해봐라."},{"excerpt":"열거 타입: 일정 개수의 상수 값을 정의한 다음, 그외의 값은 허용하지 않는 타입 정수 열거 패턴의 단점 기존 정수 열거 패턴(int enum pattern)은 타입 안전을 보장할 방법이 없고 표현력이 좋지 않다는 단점이 존재한다.\n위 코드에서 에서 를 동등 비교()를 해도 컴파일러의 경고 메시지가 없다. 자바에서는 정수 열거 패턴을 위한 별도 이름 공간…","fields":{"slug":"/item-34/"},"frontmatter":{"date":"January 29, 2025","title":"int 상수 대신 열거 타입을 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n> 열거 타입: 일정 개수의 상수 값을 정의한 다음, 그외의 값은 허용하지 않는 타입\n\n## 정수 열거 패턴의 단점\n\n```java\npublic static final int APPLE_FUJI = 0;\npublic static final int APPLE_PIPPIN = 1;\npublic static final int APPLE_GRANNY_SMITH = 2;\n\npublic static final int ORANGE_NAVEL = 0;\npublic static final int ORANGE_TEMPLE = 1;\npublic static final int ORANGE_BLOOD = 2;\n```\n\n기존 정수 열거 패턴(int enum pattern)은 **타입 안전을 보장할 방법이 없고 표현력이 좋지 않다**는 단점이 존재한다.\n위 코드에서 `APPLE`에서 `ORANGE`를 동등 비교(`==`)를 해도 컴파일러의 경고 메시지가 없다.\n\n```java\nint i = (APPLE_FUJI - ORANGE_NAVEL) / APPLE_PIPPIN;\n```\n\n**자바에서는 정수 열거 패턴을 위한 별도 이름 공간(namespace)을 지원하지 않아** 접두어를 사용해 이름 충돌을 방지하는 방법을 사용한다.\n\n이렇게 정수 열거 패턴을 사용한 프로그램은 그냥 상수 나열이라, 컴파일 하면 그 값이 클라이언트 쪽에 그대로 새겨지기 때문에 **프로그램이 깨지기 쉽다.**\n\n정수 열거 그룹에 속한 모든 상수를 한 바퀴 **순회하는 방법도 마땅치 않고**, 상수가 몇 개인지도 알 수 없다.\n\n## 문자열 열거 패턴\n\n문자열 열거 패턴(string enum pattern)은 상수의 의미를 출력할 수 있지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만들어야 한다.\n이 부분에서 오타가 있어도 컴파일러가 확인할 방법이 없으니 자연스럽게 런타임 버그가 생기게 된다.\n또한 문자열 비교에 따른 성능 저하도 있어 지금까지의 단점들을 조합해보면 정수 열거 패턴보다 더 나쁜 걸 볼 수 있다.\n\n## 열거 타입\n\n자바의 열거 타입(enum type)은 이러한 기존 열거 패턴의 단점을 모두 해결해준다.\n\n```java\npublic enum Apple { FUJI, PIPPIN, GRANNY_SMITH }\npublic enum Orange { NAVEL, TEMPLE, BLOOD }\n```\n\n모습은 이렇다. 완전한 형태의 클래스라서 단순히 정수값 뿐인 다른 언어의 열거 타입보다 훨씬 강력하다.\n\n### 열거 타입의 아이디어\n\n자바 열거 타입을 뒷받침하는 아이디어는 단순하다.\n열거 타입 자체는 클래스로 하고, 상수 하나당 자신의 인스턴스를 하나씩 만들어 `public static final` 필드로 공개해둔다.\n그럼 외부에서 접근할 수 있다는 것인가? 라고 생각할 수 있다.\n하지만, 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 `final`이라고 해도 무방하다.\n따라서 열거 타입 선은으로 만들어진 인스턴스는 하나씩만 존재하다는 것을 보장할 수 있게 된다.(인스턴스 통제)\n\n이러한 특징으로 책에서는 다음과 같이 열거 타입을 **싱글턴 패턴의 일종**이라고 설명한다.\n> 열거 타입은 싱글턴을 일반화한 형태라고 할 수 있고, 싱글턴은 원소가 하나뿐인 열거 타입이라고 볼 수 있다.\n\n## 열거 타입의 장점\n\n열거 타입은 컴파일 타입 안정성을 제공한다.\n전 예제처럼 `APPLE` 열거 타입 인수에 `ORANGE`를 넘기려 하면 컴파일 오류를 일으킨다.\n\n그리고 이름 같은 상수 공간이 공존하여 열거 타입이 수정되어도 문제가 되지 않는다.\n공개 되는 것이 필드의 이름이라 정수 열거 패턴과 달리 상수 값이 클라이언트로 컴파일되어 각인되지 않는다.\n\n여기서 끝이 아니다. 열거 타입에는 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수 있다.\n\n## 데이터와 메서드를 갖는 열거 타입\n\n각 상수와 연관된 데이터를 해당 상수 내에 내재 시킬 수 있다.\n이렇게 하면 고차원의 추상 개념 하나를 표현하게 된다.\n\n```java\npublic enum Planet {\n    MERCURY(3.302e+23, 2.439e6),\n    VENUS  (4.869e+24, 6.052e6),\n    EARTH  (5.975e+24, 6.378e6),\n    MARS   (6.419e+23, 3.393e6),\n    JUPITER(1.899e+27, 7.149e7),\n    SATURN (5.685e+26, 6.027e7),\n    URANUS (8.683e+25, 2.556e7),\n    NEPTUNE(1.024e+26, 2.477e7);\n\n    private final double mass;           // 질량(단위: 킬로그램)\n    private final double radius;         // 반지름(단위: 미터)\n    private final double surfaceGravity; // 표면중력(단위: m / s^2)\n\n    // 중력상수(단위: m^3 / kg s^2)\n    private static final double G = 6.67300E-11;\n\n    // 생성자\n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n        surfaceGravity = G * mass / (radius * radius);\n    }\n\n    public double mass()           { return mass; }\n    public double radius()         { return radius; }\n    public double surfaceGravity() { return surfaceGravity; }\n\n    public double surfaceWeight(double mass) {\n        return mass * surfaceGravity;  // F = ma\n    }\n}\n```\n\n열거 타입 상수 각각을 특정 데이터와 연결 지을 때는 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.\n\n인지할 점은 열거 타입은 불변이라 모든 필드는 `final`로 선언되어야 하고,\n필드를 `private`으로 선언하고 `public` 접근자 메서드를 제공해야 한다.\n\n## 열거 타입의 배열\n\n```java\npublic class WeightTable {\n   public static void main(String[] args) {\n      double earthWeight = Double.parseDouble(args[0]);\n      double mass = earthWeight / Planet.EARTH.surfaceGravity();\n      for (Planet p : Planet.values())\n         System.out.printf(\"%s에서의 무게는 %f이다.%n\",\n                           p, p.surfaceWeight(mass));\n   }\n}\n```\n\n열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 정적 메서드인 `values`를 제공한다.\n\n> 값들은 서언된 순서로 저장된다.\n\n심지어 각 열거 타입의 값의 `toString` 메서드는 상수 이름을 문자열로 반환해 `print`로 출력하기 딱 좋다.\n\n## 열거 타입을 올바르게 사용하는 예\n\n일반 클래스와 마찬가지로 기능을 클라이언트에게 노출해야하 합당한 이유가 없다면 `private`로, 혹은 필요하다면 `package-private`로 선언해야 한다.\n만약 널리 쓰이는 열거 타입인 경우, 톱레벨 클래스로 구현해야 한다. 만일 특정 톱레벨 클래스에서만 사용된다면 해당 클래스의 멤버 클래스로 만들면 된다.\n\n## 상수별 메서드 구현\n\n책에서는 사칙연산 계산기의 연산 종류를ㄹ 열거 타입으로 선언하여 실제 연산을 타입 상수가 맡아 수행하게 `switch`문을 사용하는 방법을 소개한다.\n\n```java\npublic enum Operation {\n    PLUS, MINUS, TIMES, DIVIDE;\n    \n    public double apply(double x, double y) {\n        switch(this) {\n            case PLUS:   return x + y;\n            case MINUS:  return x - y;\n            case TIMES:  return x * y;\n            case DIVIDE: return x / y;\n        }\n        throw new AssertionError(\"알 수 없는 연산: \" + this);\n    }\n}\n```\n\n이렇게 하면 `Operation` 열거 타입을 사용하는 클라이언트 코드는 새로운 연산을 추가하거나 기존 연산을 수정하기 쉬워진다.\n그래서 이런 동작을 필요로 한다면 상수별 메서드 구현을 권장하고 있다.\n즉, 열거 타입에 추상 메서드를 선언하고, 각 상수에서 자신에 맞게 동작을 재구현하는 방법이다.\n이것을 상수별 메서드 구현(`constant-specific method implementation`)이라고 한다.\n\n```java\npublic enum Operation {\n    PLUS   { public double apply(double x, double y) { return x + y; } },\n    MINUS  { public double apply(double x, double y) { return x - y; } },\n    TIMES  { public double apply(double x, double y) { return x * y; } },\n    DIVIDE { public double apply(double x, double y) { return x / y; } };\n\n    public abstract double apply(double x, double y);\n}\n```\n\n이러한 상수별 메서드 구현을 상수별 데이터와 결합할 수 도 있다.\n\n```java\npublic enum Operation {\n    PLUS(\"+\") {\n        public double apply(double x, double y) { return x + y; }\n    },\n    MINUS(\"-\") {\n        public double apply(double x, double y) { return x - y; }\n    },\n    TIMES(\"*\") {\n        public double apply(double x, double y) { return x * y; }\n    },\n    DIVIDE(\"/\") {\n        public double apply(double x, double y) { return x / y; }\n    };\n\n    private final String symbol;\n\n    Operation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    @Override\n    public String toString() {\n        return symbol;\n    }\n    \n    public abstract double apply(double x, double y);\n}\n```\n\n## 열거 타입 반환 메서드\n\n열거 타입 상수를 반환해야 하는 상황이라면\n아래 두 메서드를 사용하면 문자열을 열거 타입 상수로 변환하여 반환하는 로직을 구현할 수 있다.\n- `valueOf(String)`: 지정한 문자열과 일치하는 열거 타입 상수를 반환하는 메서드\n- `fromString(String)`: `valueOf`와 비슷하지만, 문자열과 일치하는 상수가 없을 때 예외를 던지지 않고 `null`을 반환한다.\n\n```java\nprivate static final Map<String, Operation> stringToEnum = \n        Stream.of(values()).collect(\n    toMap(Object::toString, e -> e));\n\npublic static Optional<Operation> fromString(String symbol) {\n    return Optional.ofNullable(stringToEnum.get(symbol));\n}\n```\n\n## 열거 타입 정적 필드의 생성 시점\n\n```java\nprivate static final Map<String, Operation> stringToEnum = \n        Stream.of(values()).collect(\n    toMap(Object::toString, e -> e));\n```\n\n여기서 `Operation` 상수가 `stringToEnum` 맵에 추가되는 시점은 열거 타입 상수 생성 후 정적 필드가 초기화될 때다.\n스트림이 없던 자바 8이전에는 빈 해시맵에 반환된 배열(`values`)을 순회하며 맵을 추가했을 것이다.\n하지만 열거 타입 상수는 생성자에서 자신의 인스턴스틀 맵에 추가할 수 없게 컴파일 오류가 발생한다.\n만약 이 방식이 허용되었다면 런타임에 `NullPointerException`이 발생할 것이다.\n\n그 이유는 열거 타입에 접근 할 수 있는 방법은 상수 뿐인데,\n열거 타입 생성자가 실행되는 시점에는 정적 필드들이 아직 초기화되기 전이라,\n이러한 자기 자신을 추가하지 못하게 하는 제약이 꼭 필요하다.\n\n\n> 열거 타입 생성자에서 같은 열거 타입의 다른 형제 상수에도 접근할 수 없다.\n\n## 전략 열거 타입 패턴\n\n열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하면 된다.\n\n> 그렇지 않은 경우에는 `switch`문을 사용하는 것이 더 나은 선택일 수 있다.\n\n```java\nimport static effectivejava.chapter6.item34.PayrollDay.PayType.*;\n\nenum PayrollDay {\n    MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY),\n    THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),\n    SATURDAY(WEEKEND), SUNDAY(WEEKEND);\n\n    private final PayType payType;\n\n    PayrollDay(PayType payType) { this.payType = payType; }\n\n    int pay(int minutesWorked, int payRate) {\n        return payType.pay(minutesWorked, payRate);\n    }\n\n    enum PayType {\n        WEEKDAY {\n            int overtimePay(int minsWorked, int payRate) {\n                return minsWorked <= MINS_PER_SHIFT ? 0 :\n                        (minsWorked - MINS_PER_SHIFT) * payRate / 2;\n            }\n        },\n        WEEKEND {\n            int overtimePay(int minsWorked, int payRate) {\n                return minsWorked * payRate / 2;\n            }\n        };\n\n        abstract int overtimePay(int mins, int payRate);\n        private static final int MINS_PER_SHIFT = 8 * 60;\n\n        int pay(int minsWorked, int payRate) {\n            int basePay = minsWorked * payRate;\n            return basePay + overtimePay(minsWorked, payRate);\n        }\n    }\n\n    public static void main(String[] args) {\n        for (PayrollDay day : values())\n            System.out.printf(\"%-10s%d%n\", day, day.pay(8 * 60, 1));\n    }\n}\n```\n\n## 열거 타입을 사용 시점\n\n책에서는 열거 타입의 장점을 설명하는 동시에 사용 시점을 제시한다.\n\n- 필요한 원소를 컴파일 타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자(예: 태양계 행성, 한 주의 요일).\n- 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다(예: 연산 코드, 플래그).\n\n## 정리\n\n열거 타입은 확실히 정수 상수 보다 읽기 쉽고, 안전하고, 강력하여 뛰어나다.\n각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하거나, 하나의 메서드가 상부별로 다르게 동작할 때 열거 타입을 상수별 메서드 구현을 하면 된다.\n그리고 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하면 된다."},{"excerpt":"트랜잭션 관리는 DBMS가 제공하는 핵심 기능 중 하나로,\n데이터베이스 시스템에서 신뢰성을 보장하는 필수 요소이다.\nDBMS 사용자들에게는 마치 공기처럼 당연한 존재이지만,\n내부적으로는 매우 정교한 매커니즘이 작동하고 있다.\n이 글에서는 트랜잭션을 커밋하거나 롤백할 때 DBMS 내부에서 어떤일이 발생하는지,\n그리고 시스템이 트랜잭션을 어떻게 복구하는지를 …","fields":{"slug":"/database-transaction/"},"frontmatter":{"date":"January 29, 2025","title":"DBMS는 트랜잭션을 어떻게 관리할까?","tags":["Database"]},"rawMarkdownBody":"\n트랜잭션 관리는 DBMS가 제공하는 핵심 기능 중 하나로, \n데이터베이스 시스템에서 신뢰성을 보장하는 필수 요소이다.\nDBMS 사용자들에게는 마치 공기처럼 당연한 존재이지만,\n내부적으로는 매우 정교한 매커니즘이 작동하고 있다.\n이 글에서는 트랜잭션을 커밋하거나 롤백할 때 DBMS 내부에서 어떤일이 발생하는지,\n그리고 시스템이 트랜잭션을 어떻게 복구하는지를 살펴보면서,\n트랜잭션 관리가 어떤 원리로 동작하는지 구체적으로 알아가보겠다.\n\n## 트랜잭션이란 무엇인가?\n\n잘 알려진 내용이라 진부할 수 있지만, 그래도 트랜잭션의 개념을 한번 짚고 넘어가자.\n트랜잭션은 데이터베이스 시스템에서 하나의 논리적 작업 단위를 구성하는 연산들의 집합이다.\n이는 데이터의 무결성을 보장하고 일관된 상태를 유지하기 위해 필수적인 개념이다.\n가장 흔한 예로 계좌 간 자금 이체가 많이 언급된다.\n한 계좌에서 10만원을 출금하고,\n다른 계좌에 10만원을 입금하는 작업은 반드시 원자적으로 수행되어야 한다.\n즉, 전체 작업이 정상적으로 완료되거나, 그렇지 않다면 아무것도 수행되지 않은 상태로 복구되어야 한다.\n이러한 특성 덕분에 트랜잭션은 데이터베이스에서 여러 다양한 데이터 항목을 읽고 갱신하는 프로그램의 실행 단위가 된다.\n흔히 트랜잭션의 ACID 성질이라고 하는 다음 네 가지 성질로 설명된다.\n\n### 원자성(Atomicity)\n\n트랜잭션은 “모두 수행되거나, 전혀 수행되지 않거나”라는 특성을 가져야 한다. \n즉, 트랜잭션 수행 도중 오류가 발생하면, 해당 트랜잭션이 수행한 모든 변경 사항은 취소되어야 한다. \n예를 들어, 자금 이체 중 한 계좌에서 돈을 출금했지만, 다른 계좌로 입금하기 전에 오류가 발생했다면, 출금된 금액도 원래 상태로 복구되어야 한다. \n원자성은 “All or Nothing” 원칙으로 이해할 수 있다.\n\n### 일관성(Consistency)\n\n트랜잭션이 실행된 후에도 데이터베이스의 무결성이 유지되어야 한다.\n즉, 트랜잭션 수행 전후의 데이터베이스 상태는 각각 정합성을 갖는 상태여야 한다. \n예를 들어, 자금 이체 트랜잭션을 수행했을 때, 두 계좌의 잔고 총합이 변하지 않아야 한다. \n이러한 일관성은 기본 키, 외래 키 제약 조건뿐만 아니라, 도메인 무결성, 애플리케이션 레벨의 비즈니스 규칙 등을 포함한다.\n\n### 독립성(Isolation)\n\n여러 트랜잭션이 동시에 실행되더라도, 각 트랜잭션은 독립적으로 수행되어야 하며, 다른 트랜잭션의 영향을 받아서는 안 된다. \n즉, 하나의 트랜잭션이 완료되기 전까지는 해당 트랜잭션의 중간 결과를 다른 트랜잭션이 볼 수 없어야 한다. \n예를 들어, 사용자가 계좌 잔액을 조회할 때, 동시에 진행 중인 이체 트랜잭션의 영향을 받지 않아야 한다.\n이를 보장할 수 있는 가장 쉬운 방법은 트랜잭션을 순차적으로 실행하는 것이지만, 이는 성능에 큰 영향을 미친다.\n그래서 DBMS에서는 병렬적 수행을 위해 직렬화(Serializable) 수준의 고수준의 트랜잭션 격리 방식을 제공하고 있다.\n\n> 직렬화(Serializable) 수준은 모든 변경 사항을 읽을 수 없는 수준의 격리 수준이다.\n\n### 지속성(Durability)\n\n트랜잭션이 성공적으로 완료되고 커밋되면, 그 결과는 영구적으로 데이터베이스에 반영되어야 한다. \n이후 시스템 장애(전원 장애, 하드웨어 고장 등)가 발생하더라도, 트랜잭션의 결과가 유실되지 않아야 한다. \n이를 위해 DBMS는 로그(Log), 체크포인트(Checkpoint), WAL(Write-Ahead Logging) 기법 등을 활용하여 트랜잭션을 복구할 수 있도록 한다.\n\n### 트랜잭션의 종료 형태\n\n그럼 트랜잭션은 어떻게 종료되는 것일까?\n트랜잭션은 수행 결과에 따라 다음과 같은 세 가지 형태로 종료될 수 있다.\n\n1. 정상 종료(Commit): 모든 작업이 정상적으로 수행되었으며, 변경 사항이 영구적으로 반영된다. \n2. 사용자 철회(Abort by User): 사용자가 트랜잭션 수행 중 취소(rollback)를 요청하여 변경 사항이 반영되지 않는다. \n3. 시스템 강제 철회(Abort by System): 트랜잭션 수행 중 오류(무결성 제약 위반, 교착 상태, 타임아웃 등)가 발생하여 시스템이 자동으로 트랜잭션을 중단하고 롤백한다.\n\n이 외에도 트랜잭션은 각종 시스템 고장으로 인하여 영향을 받아 비정상 종료가 발생할 수 있다. \nDBMS는 이와 같은 상황에서도 트랜잭션을 관리해야 한다.\n\n> 대표적인 복구 기법으로는 로그 기반 복구, 체크포인트 복구, 그림자 페이징(Shadow Paging) 등이 있다.\n\n## 트랜잭션 관리를 위한 DBMS의 전략\n\n트랜잭션 관리를 효과적으로 수행하기 위해서는 DBMS의 개략적인 구조와 버퍼 관리자(Buffer Manager), 그리고 트랜잭션 관리와 연관된 버퍼 관리 정책(Buffer Management Policy) 에 대한 이해가 필요하다.\n\nDBMS는 보통 비휘발성 저장 장치(디스크)에 데이터를 저장하며, 전체 데이터 중 일부를 메인 메모리에 유지하면서 운영된다. \n데이터는 고정 길이의 페이지(Page) 단위로 저장되며, 디스크에서 데이터를 읽거나 쓸 때도 페이지 단위로 입출력이 수행된다. \n페이지 버퍼(Page Buffer) 관리자 또는 버퍼 관리자(Buffer Manager) 는 메인 메모리에 유지하는 페이지들을 관리하는 핵심 모듈로, DBMS의 성능과 트랜잭션 관리에 중요한 역할을 한다.\n\nDBMS의 구조는 제품마다 다소 차이가 있지만, 일반적으로 다음과 같이 질의 처리기(Query Processor) 와 저장 시스템(Storage System) 으로 구분할 수 있다.\n\n> 질의 처리기(Query Processor): 사용자의 SQL 질의를 분석하고 실행하는 역할을 담당한다. <br>\n> 저장 시스템(Storage System): 데이터를 저장하고 관리하는 역할을 수행하며, 내부적으로 페이지 버퍼 관리자를 포함한다.\n\n대표적인 DBMS인 MySQL 은 InnoDB, MyISAM 등 여러 저장 엔진을 선택할 수 있도록 설계되어 있으며, 이러한 구조는 질의 처리기와 저장 시스템 간의 계층(layered) 구조 를 따른다. \n\n![DBMS의 개략적인 구조](img.png)\n\nDBMS의 여러 구성 요소 중에서 버퍼 관리자가 중요한 이유는 버퍼 관리 정책이 트랜잭션 관리에 직접적인 영향을 미치기 때문이다. \n특히, 특정 버퍼 관리 정책에 따라 UNDO(트랜잭션 취소) 및 REDO(트랜잭션 재적용) 복구가 필요할 수도 있고, 필요하지 않을 수도 있다. \n이 부분에 대해서 하나씩 살펴보자.\n\n### UNDO는 왜 필요할까?\n\nDBMS에서 트랜잭션이 수행되는 동안, 수정된 페이지들은 버퍼 관리자의 버퍼 교체 알고리즘(Buffer Replacement Algorithm) 에 따라 디스크로 출력될 수 있다. \n버퍼 교체는 메모리 상태에 따라 결정되며, 일관성 관점에서 보면 임의의 방식으로 이루어진다. \n즉, 아직 커밋되지 않은 트랜잭션이 수정한 페이지도 디스크에 기록될 수 있으며, 만약 해당 트랜잭션이 정상적으로 종료되지 못하면, 변경된 데이터는 원래 상태로 복구되어야 한다. \n이러한 복구 과정을 UNDO(롤백) 라고 한다.\n\n만약 버퍼 관리자가 트랜잭션 종료 전까지 수정된 페이지를 절대로 디스크에 기록하지 않는 정책을 따른다면, UNDO는 단순히 메모리 버퍼 내에서만 이루어지므로 복구 과정이 간단해진다. \n그러나 이러한 방식은 매우 큰 크기의 메모리 버퍼가 필요하다는 문제점이 있다. \n따라서 대부분의 DBMS는 수정된 페이지가 트랜잭션 종료 전에 디스크에 기록될 수도 있도록 허용하는 정책을 채택 한다.\n\n수정된 페이지를 디스크에 쓰는 시점에 따라 다음과 같은 두 가지 정책으로 나누어 볼 수 있다.\n\n- STEAL 정책\n  - 트랜잭션이 종료되기 전이라도 수정된 페이지를 디스크에 기록할 수 있는 방식이다.\n  - 버퍼 관리자가 메모리 공간 확보를 위해 아직 커밋되지 않은 데이터도 디스크에 기록할 수 있다.\n  - 그러나 비정상 종료된 트랜잭션이 이미 디스크에 기록한 데이터를 원상 복구하기 위해 UNDO 작업이 필요하다.\n  - 거의 모든 DBMS가 채택하는 정책으로, 보다 유연한 메모리 관리를 가능하게 한다.\n- NO-STEAL 정책\n  - 트랜잭션이 종료될 때까지 수정된 페이지를 디스크에 기록하지 않는 방식이다.\n  - UNDO 작업이 필요하지 않지만, 모든 수정된 데이터를 버퍼 내에서만 유지해야 하므로 메모리 사용량이 증가한다.\n  - 현실적으로 대용량 데이터를 처리하는 DBMS에서는 사용하기 어려운 방식이다.\n\nSTEAL 정책에서는 수정된 페이지가 언제든지 디스크에 기록될 수 있으므로, 트랜잭션이 비정상적으로 종료되었을 때 데이터를 원상태로 되돌릴 수 있도록 UNDO 로깅 및 복구 과정이 필수적이다.\n\n예를 들어, 어떤 트랜잭션이 디스크에 100만 원을 인출하는 작업을 기록했지만, 이후 과정에서 오류가 발생했다면, DBMS는 해당 트랜잭션이 변경한 데이터를 이전 상태로 되돌려야 한다. \n이를 위해 트랜잭션이 시작되기 전에 변경 이전의 값을 로그에 저장(UNDO Logging) 해두고, 필요할 경우 이를 활용하여 데이터를 복구하는 방식으로 동작한다.\n\nSTEAL 정책은 거의 모든 DBMS에서 사용되고 있고, 효율적인 버퍼 관리와 안정적인 트랜잭션 복구를 위한 핵심적인 설계 요소라고 할 수 있다.\n\n### REDO는 왜 필요할까?\n\n이제는 UNDO 복구의 반대 개념인 REDO 복구에 대해서 알아볼 것인데, 앞서 설명한 바와 같이 거밋된 트랜잭션의 변경 내용은 어떤 경우에도 유지(Durability)되어야 한다.\n만약 시스템 장애가 발생해도, 커밋된 트랜잭션의 결과는 반드시 데이터베이스에 반영되어야 한다.\n이러한 복구 작업을 REDO라고 한다.\nREDO 복구는 UNDO 복구와 마찬가지로 버퍼 관리 정책에 영향을 받으며, 수정된 데이터를 디스크에 기록하는 시점에 따라 정책이 구분된다.\n\n트랜잭션이 커밋될 때, 해당 트랜잭션이 수정한 페이지를 즉시 디스크에 반영할 것인지 여부에 따라 다음과 같은 두 가지 정책으로 나눌 수 있다.\n\n- FORCE 정책\n  - 트랜잭션이 커밋될 때, 수정된 모든 페이지를 즉시 디스크에 반영하는 방식이다.\n  - 따라서 시스템 장애가 발생하더라도, 디스크에는 커밋된 데이터가 남아 있으므로 REDO 복구가 필요하지 않다.\n  - 하지만 트랜잭션 커밋 시점마다 모든 변경 사항을 디스크에 반영해야 하므로, 성능이 저하될 가능성이 크다.\n- NO-FORCE 정책\n  - 트랜잭션이 커밋되더라도, 수정된 페이지를 즉시 디스크에 반영하지 않을 수 있는 방식이다.\n  - 대신 커밋된 트랜잭션이 어떤 작업을 수행했는지에 대한 로그를 기록(WAL, Write-Ahead Logging)한다.\n  - 장애 발생 시, 커밋된 트랜잭션의 변경 사항이 아직 디스크에 반영되지 않을 수 있으므로, REDO 복구가 반드시 필요하다.\n  - 거의 모든 DBMS가 성능 최적화를 위해 NO-FORCE 정책을 채택하고 있다.\n\n여기서 주의 깊게 봐야 할 부분은 NO-FORCE 정책을 따르더라도, 데이터베이스 백업 복구(미디어 복구, Media Recovery) 과정에서는 REDO 복구가 필요할 수 있다는 점이다.\n\nNO-FORCE 정책은 수정된 데이터를 즉시 디스크에 반영하지 않음으로써, 버퍼 관리의 효율성을 높이고 시스템 성능을 개선하는 장점이 있다. \n그러나 이로 인해 장애 발생 시 REDO 복구가 필수적이 된다. \n반면 FORCE 정책을 사용하면 REDO 복구가 필요 없지만, 모든 커밋 시점마다 디스크 I/O가 발생하여 성능이 저하되는 단점이 있다.\n\n사실 FORCE 정책을 따르더라도, 데이터베이스 백업 복구(미디어 복구, media recovery) 과정에서는 REDO 복구가 필요할 수 있다. \n따라서 현실적으로 거의 모든 DBMS는 NO-FORCE(¬FORCE) 정책을 채택 하며, 시스템 장애 발생 시 커밋된 트랜잭션을 복구하기 위해 REDO 작업을 수행 한다.\n\n앞서 살펴본 STEAL 정책과 NO-FORCE 정책을 함께 채택하면, 트랜잭션이 수행되는 동안 변경된 데이터가 언제든지 디스크에 기록될 수도 있고, 반대로 커밋 이후에도 디스크에 기록되지 않았을 수도 있다. \n이로 인해 다음과 같은 복구 작업이 필요해진다.\n\n- UNDO 복구: STEAL 정책을 사용하면 아직 커밋되지 않은 데이터가 디스크에 기록될 수 있으므로, 트랜잭션이 롤백될 경우 변경 내용을 되돌려야 한다.\n- REDO 복구: NO-FORCE 정책을 사용하면 커밋된 트랜잭션의 변경 사항이 디스크에 반영되지 않았을 수 있으므로, 시스템 장애 발생 시 이를 다시 적용해야 한다.\n\n정리해보면 DBMS는 성능과 복구 가능성을 모두 고려하여, STEAL + NO-FORCE 정책을 채택하는 것이 일반적이다.\n이러한 정책 선택으로 인해 UNDO 복구(롤백)와 REDO 복구(재적용)가 모두 필요하게 된다.\n\n## 트랜잭션 관리\n\n지금까지 살펴본 UNDO 복구와 REDO 복구를 수행하기 위해 가장 널리 사용되는 구조는 로그(log)이다.\n일부 데이터베이스 시스템에서는 shadow paging(Nilavalagan, 2009) 과 같은 복구 기법도 존재하지만, 여기서는 가장 일반적인 로그 기반 복구(log-based recovery) 기법에 초점을 맞추어 설명하겠다.\n\n### 로그(Log)란?\n\n로그는 데이터베이스의 모든 갱신 작업을 기록하는 연속적인 로그 레코드(로그 파일의 단위)로 구성된다.\n이론적으로 로그는 안정적 저장 매체(Stable Storage)에 기록된다고 가정한다.\n안정적 저장 매체란 어떠한 경우에도 데이터 손실이 발생하지 않는 이상적인 저장 매체를 의미하지만, 현실적으로 존재하지 않는다.\n\n이를 보완하기 위해 DBMS는 RAID와 같은 하드웨어 보호 기법을 사용하거나, 여러 개의 로그 파일을 유지하여 안정성을 보장하는 방법을 사용한다.\n하지만 성능상의 이유로, 대부분의 DBMS는 하나의 로그 파일만을 유지하는 경우가 많다.\n\n로그는 항상 새로운 내용을 덧붙이는(append) 방식으로 기록되며, 각 로그 레코드는 고유한 식별자를 가진다.\n이 식별자를 LSN(Log Sequence Number) 또는 LSA(Log Sequence Address) 라고 부르며, 로그가 추가될 때마다 단조 증가하는 성질을 갖는다.\n\n로그 데이터는 저장 방식과 기록 방식에 따라서 분류할 수 있다.\n\n|          | State              | Transition       |\n|:---------|:-------------------|:-----------------|\n| Physical | -                  | Action(DML, DDL) |\n| Logical  | 이전 이미지 <br> 이후 이미지 | XOR 차이           |\n\n#### 물리적인 상태 로깅(physical state logging)\n\nDBMS에서 가장 널리 사용되는 로깅 방식으로, 갱신 이전(before-image)과 갱신 이후(after-image)의 물리적인 데이터를 기록한다.\nUNDO 복수 시, 수정 이미지로 데이터를 되돌리고, REDO 복구시, 수정 이후 이미지를 데이터베이스에 반영한다.\n\n```sql\nUPDATE customer SET balance = balance + 100 WHERE id = 1;\n-- UNDO 로그: balance = 기존 값(예: 500)\n-- REDO 로그: balance = 변경된 값(예: 600)\n```\n\n#### 물리적인 전이 로깅(physical transition logging)\nXOR 연산을 사용하여 변경된 부분만 기록하는 방식이다.\n전체 페이지나 레코드의 이미지를 저장하는 대신, 수정된 부분만 XOR 연산을 통해 기록하므로 로그 크기를 줄일 수 있다.\n복구 시, 로그에 기록된 XOR 차이를 적용하여 UNDO 및 REDO를 수행한다.\n\n```sql\nUPDATE customer SET balance = balance + 100 WHERE id = 1;\n-- 로그 데이터: XOR(기존 값, 변경 값)\n```\n\n이 방식은 로그 크기를 줄일 수 있는 장점이 있지만, 복구 과정이 복잡해질 수 있다.\n\n#### 논리적인 전이 로깅(logical transition logging)\n\n오퍼레이션 자체를 기록하는 방식으로, 오퍼레이션 로깅(Operation Logging)이라고도 한다.\n물리적인 로그가 결과값을 저장하는 방식이라면, 논리적인 로그는 실행된 연산 자체를 기록한다.\n복구 시 UNDO와 REDO를 위해 연산을 재수행하거나 역 오퍼레이션을 수행한다.\n\n```sql\nUPDATE customer SET balance = balance + 100 WHERE id = 1;\n-- UNDO 로그: balance = balance - 100\n-- REDO 로그: balance = balance + 100\n```\n\n하지만 더 중요한 점은 물리적으로 복구하기 쉽지 않은 자료 구조에 대한 로깅을 쉽게 해준다는 점이다. \n예를 들어, 인덱스 구조로 많이 사용되는 B+-tree 또는 B-tree 는 split, merge 와 같은 SMO(Structure Modification Operation)를 통해서 레코드의 위치가 계속 변경되기 때문에 \n로깅 시점과 복구 시점의 데이터 물리적 위치가 같다는 점이 보장되지 않기 때문에(페이지 내의 위치가 다를 수도 있고, 심지어 다른 페이지에 위치할 수도 있다), 물리적인 로그를 통해서 복구하기가 쉽지 않지만, 논리적인 로그를 통해서 보다 쉽게 복구할 수 있다. \n즉, 인덱스에 키 값 k와 포인터 p가 저장되었다는 논리 로그에 대한 REDO 복구는 인덱스에 (k, p)를 다시 삽입하는 작업이면 충분하고, UNDO 복구는 (k, p)를 인덱스에서 제거하는 작업을 수행하면 된다.\n\n대부분의 DBMS는 하나의 로깅 방식만 사용하는 것이 아니라, 상황에 따라 여러 가지 방식을 혼용한다. \nMySQL(InnoDB)도 물리적 로깅과 논리적 로깅을 함께 사용하여 복구 성능을 최적화 한다.\n위에서 설명한 3개의 그룹으로 나눠볼 수 있는 로그 레코드가 DBMS 내에 실제로 몇 종류나 필요할까 하는 궁금증이 드는데, \nDBMS마다 다르지만 MySQL(InnoDB)의 경우에는 UNDO 로그, REDO 로그, BINARY 로그(Binlog) 같은 것을 포함하여 약 40여 종류의 로그 레코드가 존재한다.\n또한, DBMS에서 자료 구조마다 복구 연산이 다르기 때문에, 실제로는 로그 레코드보다 훨씬 많은 복구 연산(Recovery Functions)이 필요하다.\nMySQL(InnoDB)의 경우, 약 100여 개의 복구 연산을 가지고 있다.\n\n여기서 한 가지 더 얘기할 사항은 로그를 이용한 UNDO 및 REDO 복구는 반드시 멱등성(Idempotency)을 가져야 한다.\n즉, 같은 연산을 여러 번 수행하더라도 동일한 결과를 유지해야 하는 것을 의미하는데, 물리적인 로그를 통한 복구는 자연스럽게 멱등성이 보장되지만, 논리적인 로그를 통한 복구는 그렇게 간단하지 않다.\n예를 들어, 물리적인 로깅을 사용하면, 같은 데이터를 여러 번 복구해도 동일한 결과를 유지할 수 있다.\n하지만, 논리적인 로깅을 사용할 경우, a++ 연산을 여러 번 반복하면 값이 변하는 문제가 발생할 수 있다.\n이러한 문제를 방지하기 위해, DBMS는 한 번 수행한 복구 연산을 다시 수행하지 않도록 제어하는 추가적인 로직을 적용한다.\n\n### 로그는 어떻게 쓸까?\n\n로그는 로그 타입과 관계없이 다음과 같은 원칙을 준수하여 기록된다.\n\n- 로그는 데이터베이스에 변경 사항이 반영되기 전에 먼저 기록되어야 한다. 이 원칙을 WAL(Write-Ahead Logging)이라고 하며, UNDO 복구를 위해 반드시 필요한 규칙이다. 즉, 어떤 경우에도 트랜잭션이 수정한 데이터가 디스크에 기록 되지 전에, 해당 변경 사항의 UNDO 정보가 로그에 먼저 기록되어야 한다. 이 원칙이 지켜지지 않으면, 트랜잭션이 롤백될 때 변경 사항을 되돌릴 수 없게 된다.\n- 트랜잭션이 정상적으로 종료(Commit)되기 위해서는, REDO 정보가 로그에 기록되어야 한다. 마찬가지로 어떤 경우에도 커밋을 수행하기 전에 반드시 REDO 로그가 기록되어야 하며, 이 원칙이 지켜져야 장애 발생 시 커밋된 데이터를 복구할 수 있다.\n\nDBMS는 성능 최적화를 위해 로그를 즉시 디스크에 기록하지 않고, 로그 버퍼(Log Buffer)라는 메모리 공간에 먼저 저장한다.\n로그 버퍼에 모아둔 로그들은 일정한 조건이 충족되면 블록 단위로 로그 파일에 기록(flush)된다.\n\n로그 버퍼에 저장된 로그 레코드는 다음과 같은 상황에서 로그 파일에 기록된다.\n\n- **트랜잭션이 커밋을 요청한 경우**, 커밋을 요청한 트랜잭션의 모든 레코드가 로그 파일에 기록된 후, 트랜잭션이 완료된다.\n- **WAL 규칙을 준수해야 하는 경우**, 데이터 변경 사항이 디스크에 기록되기 전에, 해당 변경을 되돌릴 수 있도록 UNDO 로그가 반드시 기록되어야 한다.\n- **로그 버퍼가 가득 찬 경우**, 로그 버퍼는 상대적으로 작기 때문에(보통 수 MB에서 수십 MB 수준), 긴(long) 트랜잭션이 수행 중일 경우 버퍼가 소진될 수 있다.\n- **DBMS 내부적으로 로그 기록이 필요한 경우**, 체크포인트(Checkpoint) 연산, 로그 관리 연산 등으로 인해 DBMS가 주기적으로 로그를 기록하는 경우도 있다.\n\n대부분의 경우 트랜잭션 커밋(1) 또는 WAL 규칙 준수(2)로 인해 로그가 기록되며, 로그 버퍼 소진(3)이나 DBMS 내부 처리(3)로 인해 추가적으로 기록될 수도 있다.\n\n어떤 트랜잭션이 커밋을 요청하면, 해당 트랜잭션의 마지막 로그 레코드까지 로그 파일에 기록되어야 한다.\n예를 들어, 트랜잭션 T1이 커밋될 때, LSN3까지의 로그 레코드가 로그 파일에 기록되어야 한다.\n\n```sql\n<LSN1, T1, type, location, before, after>  # 트랜잭션 T1의 첫 번째 로그\n<LSN2, T2, type, location, before, after>  # 트랜잭션 T2의 첫 번째 로그\n<LSN3, T1, commit>                         # T1의 커밋 로그\n```\n\n트랜잭션 T1이 커밋될 경우, LSN3까지의 모든 로그가 디스크에 기록된 후 커밋이 완료된다.\n\n### 로그를 쓰는 일은 왜 느릴까?\n\nDBMS에서 로그(Log) 레코드가 손실되면 데이터베이스를 복구할 수 없기 때문에, 로그를 최대한 안전하게 기록하는 것이 필수적이다.\n이를 위해 DBMS는 로그를 기록할 때 write 함수(또는 writev 함수) 호출뿐만 아니라 fsync 함수(fsync(2) - Linux man page, 2013) 호출도 수행한다.\n\nfsync 함수는 데이터가 디스크에 실제로 기록되는 것을 보장하는 함수이다.\n그러나 리눅스를 포함한 대부분의 운영체제(OS)는 fsync 호출이 반드시 데이터를 디스크에 물리적으로 기록하는 것까지 보장하지는 않는다.\nfyncs 함수 호출은 매우 느린 연산이고, 트랜잭션이 커밋되려면 해당 트랜잭션의 로그가 파일에 완전히 기록되어야 하므로, 커밋을 하려는 트랜잭션은 fsync가 종료되기를 대기해야 한다.\n\n더 자세히 보면, DBMS가 로그 버퍼를 디스크에 기록할 때, 단순히 로그 레코드만 기록하는 것이 아니라, 로그 헤더까지 함께 기록되어야 하는데,\n로그 레코드를 먼저 쓰고 fsync 함수를 실행하고, 로그 헤더를 업데이트한 후에 다시 fsync 함수를 실행해야 한다.\n로그는 파일 끝에 덧붙이는(append) 방식으로 저장되므로, 이러한 단계가 없으면 로그 레코드나 헤더가 불완전한 상태로 기록될 수 있다.\n그러나 fsync 호출 시 어떤 버퍼 프레임부터 디스크에 기록될지는 OS가 결정하기 때문에, DBMS가 원하는 순서대로 기록할 방법이 없다.\n이로 인해 여러 단계의 fsync를 수행하면서 로그를 기록 하게 된다\n\n하지만 DBMS는 보통 한 번에 하나의 로그 페이지(Log Page)만 기록하는 것이 아니라, 여러 개의 로그 페이지를 동시에 기록한다.\n이 경우, 로그 쓰기 작업은 더 복잡해진다.\n예를 들어, 로그 버퍼 Bi부터 Bk까지 출력하는 경우에, 먼저 Bj부터 Bk까지 로그 파일에 쓰고 fsync 함수를 실행하고, 첫 번째 로그 버퍼인 Bi를 쓴 후 다시 fsync 함수를 실행하고 나서, 비로소 로그 헤더를 업데이트하는 절차로 이루어진다.\n\n\n![로그 버퍼를 로그 파일에 쓰는 순서](img_3.png)\n\n대부분의 트랜잭션 커밋 연산에서 가장 많은 시간이 소요되는 부분은 로그 레코들르 로그 파일에 기록하고, fsync를 실행하는 과정이다.\n정확성을 보장하기 위해 fsync는 여러 차례 호출해야 하며, 초당 수천에서 수만 개의 트랜잭션이 커밋 요청을 할 경우 디스크 I/O 부하가 급격히 증가한다.\n\n### 로그 쓰기 작업, 즉 커밋 오퍼레이션의 성능을 높일 방법이 없을까?\n\nDBMS는 이러한 성능을 위한 몇 가지 기법이 있는데, 먼저 그룹 커밋(group commit)부터 알아보자.\n그룹 커밋은 각각의 트랜잭션 커밋 요청을 개별적으로 처리하지 않고, 여러개의 요청을 모아서 한꺼번에 처리하는 방식이다.\n일반적으로 TPS(transaction per second)가 수천 내지는 수만에 이르는 수준의 요청이 있다고 했을 때, 한 트랜잭션이 커밋할 때 잠시만 기다리면 다른 트랜잭션들이 역시 커밋을 요청할 것이고,\n이때 이들의 요청을 모아 한 번에 처리하면, 디스크 출력 횟수를 줄일 수 있어 성능을 높일 수 있게 된다.\n즉, 그룹 커밋은 여전히 정확성을 보장하면서 각 트랜잭션의 응답 시간(response time)은 약간 희생시키는 경우가 발생되더라도 시스템 전체의 처리량(throughput)을 높이자는 의도이다. \n쉽게 생각해서 개별적으로 승용차를 이용하는 방식과 고속 버스를 이용하는 방식을 연상하면 된다. 고속 버스의 경우 정해진 출발 시각까지 대기해야 하지만, 한 번에 이동하는 승객이 많기 때문에 효율은 높다.\n마찬가지로, 그룹 커밋도 개별 트랜잭션을 잠시 대기시키지만, 전체 시스템 성능을 향상시키는 전략이다.\n\n그룹 커밋의 효율성은 동시에 요청되는 커밋의 개수에 따라 달라진다.\n따라서 적절한 그룹 커밋 대기 시간(commit wait time)을 설정하는 것이 매우 중요하다.\n대기시간이 너무 짧으면 개별 커밋과 다를 바 없어 효율성이 떨어지고, 너무 길면 응답 시간이 길어지고 효율은 더 이상 높아지지 못하게 된다.\n이 때문에 최적의 그룹 커밋 대기 시간은 시스템의 워크로드 패턴(workload pattern)에 따라 달라진다.\n일부 시스템에서는 부하 상황에 따라 자동 조정(adaptive commit delay, Helland 외, 1988)되는 방식도 적용된다.\n\n### 성능을 위해서 지속성을 살짝 포기할 수는 없을까?\n\n커밋 성능을 극대화하기 위해 지속성(durability)을 일부 포기하는 방식도 고려할 수 있다.\n일반적으로 DBMS는 매 커밋마다 정확하게 로그를 기록하고, fsync를 실행하여 데이터를 안전하게 보존하는 방식을 사용하지만, 성능을 위해 로그 기록을 느슨하게 처리하는 옵션도 제공한다.\n예를 들어 MySQL(InnoDB)는 innodb_flush_log_at_trx_commit 파라미터(InnoDB Startup Options and System Variables, 2013)의 설정을 통해서 로그를 쓰는 방식을 조정할 수 있다.\n\n또한, 일부 응용 프로그램이나 시스템에서는 비동기 커밋(asynchronous commit) 방식을 사용하기도 하는데, 비동기 커밋은 로그 버퍼에 로그 레코드를 쓰고 곧바로 커밋을 완료하는 방식이다.\n이 방식은 로그 기록을 기다리지 않기 때문에 성능 향상 효과가 크다.\n그러나 트랜잭션이 커밋되었음에도 불구하고, 시스템 장애로 인해 로그가 디스크에 기록되지 않으면 해당 트랜잭션의 변경 사항이 손실될 수 있다.\n비동기 커밋 방식으로 인해 발생할 수 있는 데이터의 손실은 커밋한 트랜잭션이 변경한 데이터의 유실(loss)이며, 이 경우 데이터의 일관성은 보장된다.\n최근의 몇몇 트랜잭션의 커밋 로그가 유실된 것이기 때문에 복구 시점에 DBMS는 마치 해당 트랜잭션이 커밋하지 않은 것으로 간주하여 이를 철회(rollback)시키게 된다.\n철회를 위한 UNDO 로그는 이미 트랜잭션 수행 중에 WAL 원칙에 따라서 트랜잭션 로그에 기록되어 있기 때문에, 커밋되지 않은 데이터가 데이터베이스에 반영되지는 않는다.\n비동기 커밋은 성능 향상 효과가 크기는 하지만, 손실이 발생할 수 있으므로 응용의 성격에 따라서 신중하게 선택해야 할 필요가 있다. \n동시에 커밋 요청이 매우 많이 요구되며 데이터의 일부 유실을 감내할 수 있는 응용 환경에서는 적용을 고려해볼 수 있을 것이다.\nMySQL은 그룹 커밋과 비동기 커밋 방식을 모두 지원하며, 설정을 통해 쉽게 적용할 수 있다.\n\n### 어떻게 로그로 복구가 이루어지나?\n\n이제 그러면 로그를 통해서 복구가 이루어지는지 알아보자.\n복구에는 두 가지 종류가 있는데, 사용자의 요청 또는 오류 발생등으로 인해서 트랜잭션을 철회하는 경우와\n소프트웨어 오류 또는 하드웨어 장애로 인해 DBMS가 비정상적으로 종료되고 재시작할 때 수행하는 복구(restart recovery)하는 경우가 있다.\n\n### 트랜잭션 철회는 어떻게?\n\n트랜잭션을 철회하는 경우는 시스템이 정상적으로 동작하고 있는 상태에서 특정 트랜잭션만 롤백하는 경우인데, 이때 트랜잭션 철회는 다음과 같이 이루어진다.\n먼저 로그를 역방향으로 탐색하면서 해당 트랜잭션의 UNDO 복구가 필요한 로그를 찾아서 이에 해당하는 UNDO 연산을 수행한다. 역방향으로 로그를 탐색하면서 트랜잭션 수행 순서의 역순으로 UNDO를 수행해야 정확하게 UNDO가 이루어질 수 있다.\n\nUNDO 작업을 수행한 후, 해당 UNDO 작업에 대한 보상 로그 레코드(CLR, Compensation Log Record)라고 하는 REDO 전용 로그를 기록하는데, UNDO를 하고 난 이후에 다시 UNDO를 해서 복구가 잘못 이루어지지 않도록 하기 위함이다. \nCLR은 이전 로그 레코드 위치를 UNDO 로그의 이전 로그를 가리키토록 설정되어, 이후 다시 접근하여 불필요한 UNDO 작업이 반복되지 않도록 해준다.\n이전 로그를 계속 탐색하면서 해당 트랜잭션의 시작 로그까지 도달하면 해당 트랜잭션의 철회 복구가 완료된 것이다.\n\n### 장애로 인해 재시작 되면 어떻게 복구가 되나?\n\nDBMS가 장애로 인해 비정상 종료되었다가 다시 시작될 때,\n손상된 데이터를 복구하고 장애 발생 시점의 상태를 재현하는 과정이 필요하다.\n이를 재시작 복구(restart recovery) 라고 하며, 다음 3단계로 이루어진다.\n\n1단계는 로그 분석 단계로, 마지막 체크포인트(checkpoint) 시점부터  최근 로그(EOL, End Of Log)까지 로그를 탐색하면서 어디서부터 시스템이 복구를 시작해야 하는지, 어느 트랜잭션들을 복구해야 하는지 등등을 알아내는 과정이다.\n\n2단계는 REDO 복구 단계로 복구를 시작해야 하는 시점부터 장애 발생 직전 시점까지 REDO가 필요한 모든 로그를 REDO 복구를 하는 단계이다. \n이 단계에서는 심지어 실패한 트랜잭션의 REDO 로그조차도 REDO를 하게 되는데, 언뜻 보면 불필요한 것으로 생각되지만 이렇게 하면 이후의 복구 단계를 매우 간단하게 하는 효과를 가져다 준다. \n이 단계에서는 모든 트랜잭션에 대해서 REDO 복구만 한다는 점이 중요한데, 이러한 REDO 복구가 완료된 시점의 데이터베이스 상태는 장애 발생 시점의 상태와 같게 된다. \n이전 상황을 그대로 재현하여 복원한다는 의미로 이 REDO 복구에서 이루어지는 작업을 repeating history(Mohan 외, 1992)라고 부른다.\n\n마지막 3단계는 UNDO 복구 단계로 로그를 최신 시점부터 역순으로 탐색하면서 UNDO 복구가 필요한 로그들에 대해서 UNDO 복구를 수행한다.\n여기서 수행하는 UNDO는 결국 위에서 설명한 트랜잭션 철회 시 수행하는 UNDO와 동일한 방식으로, repeating history를 통해 데이터베이스 상태를 장애 시점까지 복원해두고 UNDO 복구를 여러 트랜잭션의 철회로 간단하게 해결할 수 있다.\n한 트랜잭션만 철회 시키는 것이 아니라 여러 트랜잭션을 한 번에 철회해야 한다는 점이 다르다.\n이 단계의 UNDO 복구를 개별 트랜잭션의 UNDO와 구별하여 Global UNDO라고도 부른다.\n\n로그를 통한 복구 과정에서 특정 로그가 REDO 또는 UNDO가 필요한지 판단하는 기준이 필요하다.\n이미 로그가 바녕되어 있다면 그 로그에 대한 복구 연산은 필요치 않은데 이는 어떻게 해결할까?\n앞서 설명한 봐아 같이 모든 로그에는 LSN(Log Sequence Number)이라고 하는 식별자가 있는데, 데이터베이스의 모든 페이지는 page LSN이 저장되어 있다. \n이 page LSN은 페이지가 갱신될 때마다 해당 로그의 LSN으로 갱신된다. \n즉, 모든 페이지는 해당 페이지를 마지막으로 갱신한 로그의 식별자를 포함하고 있으므로, 로그를 적용해야 할지 여부는 해당 로그의 LSN과 page LSN을 비교함으로써 판단할 수 있다.\npage LSN이 어떤 로그의 LSN보다 예전 것이라면 해당 페이지는 반드시 해당 로그로 복구되어야 한다는 것을 의미하고, 반대로 page LSN이 해당 로그의 LSN과 같거나 더 최신의 값을 가지고 있다면 이 페이지는 해당 로그보다 나중에 쓰인 로그로 이미 갱신되었다는 것을 의미하므로 복구가 필요치 않다는 것을 의미한다.\n\n### 백업을 이용한 미디어 복구는 어떻게?\n\nDBMS에서 디스크 미디어에 문제가 발생하면 데이터베이스를 정상적으로 운영할 수 없게 된다.\n이때 수행하는 미디어 복구(archive recovery)가 있는데, 이는  데이터베이스의 백업으로부터 데이터를 복구를 하는 것을 의미한다.\n데이터베이스 백업 기법에는 여러 가지가 있는데, 퍼지(Fuzzy) 백업 은 DBMS가 실행 중에도 트랜잭션을 방해하지 않고 현재 스냅샷(snapshot)을 복사하는 방식으로, MySQL(InnoDB) 및 대부분의 상용 DBMS에서 사용하는 기법이다.\n\n트랜잭션이 수행되는 도중 데이터베이스 이미지를 복사하기 때문에 미처 커밋되지 않은 트랜잭션의 데이터가 포함될 수도 있고, 커밋된 트랜잭션의 데이터가 아직 반영되지 않은 상태로 복사될 수도 있다. \n이렇게 퍼지하게 복사된 데이터베이스 백업을 이용해 어떻게 복원(restore)할 수 있을까? 답은 로그에 있다.\n\n미디어 복구 시에는 백업된 데이터베이스 파일과 이에 포함된 로그, 그리고 장애 발생 시점까지의 로그를 활용하여 복구를 수행 한다. \n데이터베이스 백업은 단순히 데이터베이스 파일을 복사한 것이므로, 이를 새로운 디스크에 복사하고 데이터베이스를 재시작하면 미디어 복구 문제는 앞서 설명한 장애 발생 이후 재시작 복구와 동일한 문제가 된다. \n즉, 로그를 분석하여 백업 시점 이후에 반영되지 않은 커밋된 트랜잭션을 REDO하고, 커밋되지 않은 트랜잭션을 UNDO하는 방식으로 복구가 이루어진다.\n이러한 미디어 복구 시점의 재시작 복구를 특별히 roll-forward 복구라고 부르기도 한다.\n\n미디어 장애가 발생했을 때 마지막 데이터베이스 백업 이후의 모든 로그가 남아있다면, 장애 시점까지 손실 없이 데이터베이스를 복원할 수 있다.\n하지만 백업 이후의 일부 로그가 유실되었다면 최소한 백업 시점의 일관성이 유지된 데이터베이스 시점까지는 복원이 가능하다.\n미디어 복구를 이용하여 특정 시점으로 데이터베이스를 복원하는 것도 가능한데, 이는 roll-forward 과정을 현재 시점까지 전체를 수행하는 것이 아니라 DBA가 원하는 특정 시점까지만 REDO를 수행하면 된다.\n\n## 커밋을 하면 어떤 일이 일어나나?\n\n### 커밋을 하면 어떤 일이?\n\n커밋 트리거 혹은 지연된(deferred) 트리거가 정의되어 있다면 해당 트리거가 수행된다. \n또한, 트랜잭션 수행 도중에 생성했던 커서(질의 결과 집합)를 정리하게 된다. \nSQL 표준은 커서를 선언할 때 트랜잭션 커밋 이후에도 커서를 계속 유지하고 결과를 볼 수 있도록 하는 Holdable Cursor(Cursor (databases), 2013)로 선언한 커서만을 유지하고 그 외의 커서는 모두 해제할 것으로 정의하고 있는데, \n반면 JDBC에서는 기본으로 Holdable Cursor로 정의 하고 있다. 이는 JDBC의 기본 동작이 자동 커밋이기 때문에 사용자의 편의성을 고려한 결정인데, \n바깥쪽(outer) 커서에서 얻어온 결과를 기반으로 중첩 루프의 안쪽(inner)에서 다른 질의를 하는 경우에 전체를 묶어서 트랜잭션 처리를 하지 않으면 안쪽 질의가 커밋되는 순간 바깥쪽 커서마저 닫히는 문제가 발생 된다. \nHoldable Cursor가 지원되면 안쪽에서 커밋을 하더라도 바깥쪽 커서가 계속 유지되기 때문에 트랜잭션 처리를 하지 않아도 된다.\n\nDBMS는 트랜잭션을 수행하는 과정 중의 일부 내부 연산들(예를 들어, 리소스 반환과 같은 물리적인 연산)을 커밋이나 롤백과 같은 트랜잭션 종료 시점까지 연기(postpone) 시키는 경우가 있는데,\n이런 연기된 연산들이 포함되어 있었다면 커밋 시점에 수행된다.\n장애 대비를 위하여 데이터베이스 복제(replication)를 적용하고 있다면, 복제를 위한 로그를 쓰는 것과 같은 작업이 수행된다.\n복제는 DBMS마다 구현 전략이 상이하기 때문에 일반적으로 설명하기는 어렵지만, MySQL(InnoDB)의 경우, 트랜잭션 로그 기반 복제를 사용하여 커밋 시점에 복제를 위한 로그(Binlog)를 기록한다.\n트랜잭션을 수행하는 과정 중에 획득한 모든 락(lock)을 해제하고, 트랜잭션이 최종적으로 커밋했다는 로그를 기록한 후에 마지막으로 트랜잭션이 가지고 있던 메모리, 트랜잭션 식별자 등과 같은 리소스들을 반환하면서 비로소 트랜잭션이 종료된다.\n\n### 커밋을 하다가 오류가 발생되면?\n\n응용 프로그램의 커밋 요청으로 위에서 설명한 단계들을 수행하는 과정 중에 오류가 발생되면 어떻게 될까?\n\"끝나기 전까지는 끝난 것이 아니다.\"라는 말이 가장 적절한 설명이 될 것 같다.\n트랜잭션이 완전히 커밋되지 않았다면, 해당 트랜잭션은 수행되지 않은 것과 동일하게 취급된다.\n사용자의 커밋 요청이 오면 일단 해당 트랜잭션의 상태는 'partial commit' 상태가 된다.\n문제 없이 커밋할 수 있으면 'committed' 상태로 완료 되지만, 그렇지 않은 경우에는 다른 오류 발생과 마찬가지로 'failed' 상태를 거쳐 결국 'aborted' 상태에 다다르게 된다.\n\n![트랜잭션 상태 다이어그램(Silberschatz 외, 2010)](img_4.png)\n\n## 마치며\n\n지금까지 DBMS가 어떻게 트랜잭션을 관리하는가라는 주제로 트랜잭션 관리의 주요 원리들을 간략하게 살펴보았다. \nDBMS의 트랜잭션 관리는 워낙 방대하고 깊숙한 주제라 본 글에서는 주요 개념들을 개괄적으로 다루었는데, 이 부분에 대해서 좀 더 관심이 있으면 참고 단락에 수록된 자료들을 살펴보면 된다.\n\n## 참고\n\n[Cursor(databases) In Wikipedia.](https://en.wikipedia.org/wiki/Cursor_%28databases%29)<br>\n[fsync(2) - Linux man page.](http://linux.die.net/man/2/fsync)<br>\n[InnoDB Startup Options and System Variables.](http://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)<br>\n[Nilavalagan. (2009). \"Shadow Paging Recovery Technique.](https://www.classle.net/book/shadow-paging-recovery-technique)\n\n"},{"excerpt":"DBMS에는 저장되어 있는 데이터를 효율적으로 검색할 수 있게 해주는 인덱스가 있다.\n우리가 보통 애플리케이션의 백엔드 성능을 높이려고 종종 실행하는 SQL 튜닝은 이 인덱스를 SQL이 DBMS에서 최대한 활용할 수 있도록 SQL을 수정하는 것이라고 할 수 있다.\n그러니 인덱스에 대해 잘 이해하고 있다면 더 효율적인 SQL을 작성할 수 있을 것이고, 훨씬…","fields":{"slug":"/database-index-sql/"},"frontmatter":{"date":"January 27, 2025","title":"인덱스만 사용하면 성능이 향상될까?","tags":["Database"]},"rawMarkdownBody":"\nDBMS에는 저장되어 있는 데이터를 효율적으로 검색할 수 있게 해주는 인덱스가 있다. \n우리가 보통 애플리케이션의 백엔드 성능을 높이려고 종종 실행하는 SQL 튜닝은 이 인덱스를 SQL이 DBMS에서 최대한 활용할 수 있도록 SQL을 수정하는 것이라고 할 수 있다. \n그러니 인덱스에 대해 잘 이해하고 있다면 더 효율적인 SQL을 작성할 수 있을 것이고, 훨씬 더 성능 좋은 애플리케이션을 만들 수 있을 것이다.\n그래서 이 글에서는 MySQL 8.0에 적용된 인덱스 기법을 중심으로 인덱스 구조와 인덱스 활용 기법을 살펴보겠다.\n\n## 인덱스 구조\n\nMySQL 뿐만 아니라 거의 모든 DBMS는 B-Tree 계열 인덱스를 사용한다. \n인덱스 종류에 대한 특별한 언급이 없다면 아마도 B-Tree 계열 인덱스를 의미하는 것으로 봐도 무방할 정도이다. \nB-tree에서 변형된 B+-Tree도 있는데, 일반적인 B-Tree와 달리 데이터 포인터를 리프(Leaf) 노드에만 저장한다. \n리프 노드의 상위 레벨인 비리프(Non-Leaf) 노드는 전형적인 B-Tree 로 구성되며 리프 노드를 빠르게 찾는 인덱스 역할을 한다. 리\n프 노드에는 키와 키에 대응하는 데이터의 포인터가 저장되어 있다. 다음 그림은 전형적인 B+-Tree 모습이다.\n\n![B tree and B+ tree in DB](img_11.png)\n\n## 인덱스 스캔\n\nB+-Tree의 리프 노드는 링크드 리스트(linked list)로 서로 연결되어 있고, 저장된 키는 정렬되어 있어서 순차 처리가 용이하다.\n그렇기 때문에 범위를 검색하는 데 유리하다. \n테이블에서는 처음부터 끝까지 모든 레코드를 읽어야 완전한 결과 집합을 얻을 수 있지만, 인덱스는 키-칼럼 순으로 정렬되어 있기 때문에 특정 위치에서 검색을 시작해서 검색 조건이 일치하지 않는 값을 만나는 순간 검색을 멈출 수 있다. \n이것을 인덱스 범위 스캔(Index Range Scan)이라고 한다.\nMySQL(InnoDB)는 범위 스캔을 B+-Tree 검색의 기본 연산으로 제공하고 있다. 범위 스캔에는 두 개의 키가 필요한데, 범위의 양 끝을 표현하는 하위 키(Lower Key)와 상위 키(Upper Key)가 그것이다.\n인덱스 범위 스캔은 다음 그림과 같이 두 단계로 진행된다. \n첫 번째 단계에서는 루트에서부터 트리를 순회하여 리프 노드에서 하위 키를 찾는다. 두 번째 단계에서는 첫 번째 단계에서 찾은 키에서부터 상위 키까지 순차적으로 레코드를 읽어 처리한다. \n상위 키가 현재 노드에서 발견되지 않으면 다음 노드를 읽어 상위 키를 가진 노드까지 검색을 계속해 나간다. 상위 키까지 순차 검색이 끝나면 전체 범위 검색이 완료된다.\n\n![인덱스 범위 스캔](img_7.png)\n\n두 번째 단계에서 상위 키까지 찾아가는 과정은 레코드에서 키를 읽어와 상위 키와 비교하는 과정의 연속이다. \n상위 키가 최대 키이면 현재 노드의 키부터 마지막 노드까지 모두 검색 결과에 포함되기 때문에 비교 연산을 할 필요가 없어져서 검색의 성능이 좋아진다. \n검색 성능을 위해 옵티마이저는 입력된 쿼리를 재작성(rewrite)하며, MySQL은 특정 키를 찾는 검색도 범위 검색으로 변환하여 수행한다. \n특정 키를 찾는 검색을 범위 검색으로 변환할 때에는 하위 키와 상위 키 모두를 찾으려는 키로 동일하게 설정한다.\n\n## 인덱스 스캔을 이용한 질의 처리 과정\n\n다음 그림은 MySQL에서 아래의 SQL 질의로 테이블과 인덱스를 생성하고 데이터를 입력했을 때 인덱스 리프 노드와 테이블 데이터의 관계를 나타낸 그림이다. 왼쪽 인덱스 리프 노드에는 인덱스 키와 키에 대응되는 OID(레코드의 물리적 주소 값)가 저장되어 있다.\n\n```sql\nCREATE TABLE tbl  \n(a INT NOT NULL,\nb STRING,  \nc BIGINT);\n\nCREATE INDEX idx ON tbl  \n(a, b);\n\nINSERT INTO tbl VALUES  \n(1, 'ZZZ', 123456),\n(4, 'BBB', 123456789),\n(1, 'AAA', 123'),\n…\n(이하 생략)\n```\n\n![인덱스 리프 노드와 테이블 데이터의 관계](img_6.png)\n\n```sql\nSELECT * FROM tbl  \nWHERE a > 1 AND a < 5  \nAND b < 'K'  \nAND c > 10000  \nORDER BY b;  \n```\n\n위와 같은 SELECT 질의에서 WHERE 절에 있는 검색 조건은 다음과 같이 3가지로 나눌 수 있다.\n\n- Key Range: 인덱스 스캔 범위로 활용하는 조건이다(a > 1 AND a < 5). \n- Key Filter: Key Range에 포함할 수 없지만 인덱스 키로 처리 가능한 조건이다(b < 'K'). \n- Data Filter: 인덱스를 사용할 수 없는 조건이다. 테이블에서 레코드를 읽어야만 처리 가능한 조건이다(c > 10000).\n\nMySQL의 질의 처리 과정은 다음과 같다.\n인덱스 스캔인 경우 먼저 Key Range와 Key Filter를 적용하여 조건에 부합하는 OID 리스트를 만든다. 이 과정은 Key Range의 시작부터 끝까지 계속된다.\nOID를 이용해 데이터 페이지에서 해당 레코드를 읽어 Data Filter를 적용하거나 SELECT 리스트에 기술된 칼럼 값을 읽어와 결과를 저장하는 임시 페이지에 기록한다.\nORDER BY 절이나 GROUP BY 절이 있으면 임시 페이지에 저장된 레코드를 정렬하여 최종 결과를 생성한다.\n다음 그림은 위의 SELECT 질의가 처리되는 과정이다.\n\n![인덱스 스캔을 통한 질의 처리 과정](img_9.png)\n\n## 인덱스 사용하기\n\n옵티마이저가 인덱스를 사용하게 하려면 WHERE 절에 범위(Range) 조건이 있어야 한다. 범위 조건은 값의 비교 조건, 즉 크다, 작다, 크거나 같다, 작거나 같다, 같다와 같은 비교문으로 기술한다. 만약 범위 조건이 없다면 옵티마이저는 테이블 순차 스캔을 시도할 것이다.\n\n두 개 이상의 칼럼을 묶어서 인덱스를 만들 때는 칼럼의 순서가 매우 중요하다. 이런 인덱스를 다중 칼럼 인덱스(Multi-Column Index) 또는 복합 인덱스라고 한다. 복합 인덱스에서는 WHERE 절에 인덱스 키의 첫 번째 칼럼을 사용해야 인덱스 스캔을 수행한다. 인덱스가 여러 칼럼으로 조합되어 있을 때 칼럼 가운데 한 가지 칼럼만 사용해도 무방하다고 알려져 있는데, 잘못 알려진 것이라고 할 수 있다. 첫 번째 칼럼이 없는 상태에서는 두 번째 칼럼이 정렬된 상태라고 할 수 없기 때문에 범위를 정의할 수 없다. 따라서 반드시 첫 번째 칼럼이 조건에 있어야 하며, 첫 번째 이후의 칼럼은 조건에 없어도 상관없다.\n\n인덱스는 값의 대소 비교를 토대로 트리를 구성한다 따라서 값의 대소 비교가 아닌 조건은 B+-Tree를 사용해서 값을 찾을 수 없다. <>, != 와 같이 부정형 조건이나 NULL 비교는 인덱스를 사용할 수 없다. 인덱스의 칼럼을 조건절에서 가공할 때도 인덱스를 사용할 수 없다. 다음은 인덱스를 사용하지 못하는 쿼리와 튜닝 후 인덱스를 사용하도록 수정한 쿼리의 예이다.\n\n\n| 튜닝 전\t                                                                | 튜닝 후                                                                    |\n|:---------------------------------------------------------------------|:------------------------------------------------------------------------|\n| SELECT * FROM student WHERE grade <> 'A';\t                           | SELECT * FROM student WHERE grade > 'A';                                |\n| SELECT name, email_addr FROM student WHERE email_addr IS NULL;       | \tSELECT name,email_addr FROM student WHERE email_addr = '';             |\n| SELECT student_id FROM record WHERE substring(yymm, 1, 4) = '1997';\t | SELECT student_id FROM record WHERE yymm BETWEEN '199701' AND '199712'; |\n| SELECT * FROM employee WHERE salary * 12 < 10000;                    | \tSELECT * FROM employee WHERE salary < 10000 / 12;                      |\n\n\n\n작성한 SQL 질의가 DBMS에서 실행될 때 인덱스 스캔을 이용하는지 확인하려면 질의 실행 계획을 출력해 봐야 한다. 질의 실행 계획에서는 테이블 스캔(sscan)이나 인덱스 스캔(iscan) 여부, 예상되는 CPU 및 I/O 비용, 예상 결과 집합의 레코드 개수, 예상 페이지 접근 개수 등을 볼 수 있다.\n\n## 인덱스 활용 최적화\n\nB+-Tree는 특성상 어떤 리프 페이지에 접근하든 거의 동일한 비용이 든다. B+-Tree를 사용할 때 가장 큰 비용이 드는 부분은 Key Range의 시작부터 끝까지 인덱스 리프 노드를 따라 진행하는 스캔과 여기에 대응하는 테이블 데이터의 스캔이다.\n\n대부분의 DBMS가 페이지(또는 블록) 단위로 I/O를 수행하며 MySQL도 예외는 아니다. 즉, 하나의 레코드에서 하나의 칼럼만 읽으려 해도 레코드가 속한 페이지 전체를 디스크로부터 읽어온다. 따라서 질의 성능을 좌우하는 가장 중요한 성능 지표는 I/O를 수행하는 페이지 개수이며, 이 개수는 옵티마이저의 판단에 가장 큰 영향을 미친다. 옵티마이저가 인덱스를 읽을지, 테이블을 읽을지 결정하는데 있어 가장 중요한 판단 기준은 읽어야 할 레코드가 아니라 읽어야 할 페이지 개수인 것이다.\n\n디스크 I/O는 메모리 액세스에 비해 비용이 아주 크다. 질의 수행에 필요한 모든 데이터 페이지와 인덱스 페이지를 데이터베이스 버퍼에 로드해서 처리할 수 있다면 좋지만 그러기에는 한계가 있다. 결국 디스크 I/O를 최소화하고 대부분의 연산을 데이터베이스 버퍼에서 처리할 수 있도록 질의 처리 과정에서 액세스하는 페이지 수를 최소화하는 것이 튜닝의 핵심이다. 액세스하는 페이지 수가 적으면 자연스럽게 물리적으로 디스크에서 읽어야 할 페이지 수도 줄기 때문에 데이터베이스 버퍼 히트율(DB buffer hit ratio)이 높아져서 데이터베이스의 전체적인 성능이 높아진다. 그러면 지금부터 인덱스 스캔 과정에서 액세스해야 할 페이지 수를 줄일 수 있는 기법을 알아보자.\n\n## Key Filter 활용\n\n앞서 설명한 바와 같이 Key Filter는 Key Range에는 포함되지 않지만 인덱스 키로 처리할 수 있는 조건이다. 이러한 Key Filter가 WHERE 조건절에 포함되면 데이터 페이지에 접근하는 횟수를 줄일 수 있다. 데이터 페이지는 랜덤 액세스로 읽기 때문에 인덱스 페이지 스캔보다 많은 비용이 든다. 따라서 WHERE절에 Key Filter를 포함하면 성능 향상에 유리하다.\n\n또한 Data Filter가 Key Filter로 적용될 수 있도록 인덱스에 칼럼을 추가하는 것도 방법이 될 수 있다. 예를 들어 user 테이블에 (groupid, name)으로 구성된 인덱스 idx_1이 있는 상태에서 아래 질의를 수행한다고 하자.\n\n```sql\nSELECT * FROM user\nWHERE groupid = 10\n  AND age > 40; \n```\n\ngroupid=10인 조건을 만족하는 레코드가 100건이고 그 중 age > 40인 레코드가 10건이라고 하면, 인덱스 스캔으로 100건의 OID를 가져온 후, 최악의 경우 데이터 페이지로 100회의 액세스를 수행할 것이다. 그러나, idx_1 인덱스에 age 칼럼을 추가하여 (groupid, name, age)로 만들면 age > 40 조건이 Key Filter 조건으로 처리되어 인덱스 스캔으로 10건의 OID만 추출할 수 있다.\n\n## 커버링 인덱스\n\n만약 사용하는 인덱스로 SELECT 질의에 대한 결과를 모두 얻을 수 있는 상황이라면, 데이터 페이지에 저장되어 있는 레코드를 읽어오지 않아도 인덱스 키의 값만으로도 결과를 얻을 수 있다. 이와 같이 인덱스가 하나의 질의를 모두 '커버'한 경우를 '커버링 인덱스(Covering Index)'라고 한다.\n\n```sql\nSELECT a, b FROM tbl  \nWHERE a > 1 AND a < 5  \nAND b < 'K'  \nORDER BY b; \n```\n\n위의 SQL 질의에서 커버링 인덱스를 적용할 수 있다. 질의에 사용한 칼럼은 a, b 뿐이고 모두 인덱스 칼럼이기 때문이다. 질의에 커버링 인덱스가 활용되는지 확인하려면 다음 그림과 같이 질의 실행 계획에 covers라는 표시가 있는지 보면 된다.\n\n커버링 인덱스는 데이터 페이지를 읽지 않는다는 점, 그리고 해당 질의를 자주 사용하면 인덱스가 데이터베이스 버퍼에 캐시되어 있을 가능성이 높다는 점에서 디스크 I/O를 줄이는 데 큰 역할을 한다. 따라서 레코드 크기에 비해 인덱스 키의 크기가 작고, 커버링 인덱스를 이용하는 질의가 자주 수행되는 것이 확실하다면, 커버링 인덱스를 사용하여 SELECT 질의 성능을 크게 향상시킬 수 있다.\n\n## 정렬 연산 대체\n\n인덱스 스캔으로 생성한 결과 집합은 인덱스 칼럼 순으로 정렬된 상태이므로 ORDER BY 절이나 GROUP BY 절에 의한 정렬 연산을 생략하도록 질의를 작성할 수 있다.\n\n정렬 연산을 생략하려면 인덱스 칼럼의 순서대로 ORDER BY 절이나 GROUP BY 절에 칼럼이 지정되어야 한다. 단 인덱스 칼럼이 조건절에서 '=' 연산자로 동등 비교되는 경우에는 해당 칼럼이 ORDER BY나 GROUP BY 절에서 중간에 생략되어도 된다. 예를 들어, 인덱스 키가 (a, b)로 되어 있다면 \"ORDER BY a\" 또는 \"ORDER BY a, b\"처럼 정렬할 컬럼이 명시되어야 한다. \"ORDER BY b\" 는 정렬 연산을 대체할 수 없다. 인덱스 (a, b)에서 b는 a가 같은 값일 때 만 정렬된 상태가 보장되기 때문이다. 하지만, \"a = 2\"와 같은 조건이 WHERE 절에 있다면 \"ORDER BY b\"도 정렬 연산을 대체할 수 있다.\n\n아래 질의는 정렬 연산 없이 인덱스 스캔만으로 정렬된 결과를 만들어 내는 예이다.\n\n```sql\nSELECT * FROM tbl\nWHERE a = 2 AND b < 'K'\nORDER BY b;\n\nSELECT COUNT(*) FROM tbl\nWHERE a > 1 AND a < 5\n  AND b < 'K'\n  AND c > 10000\nGROUP BY a\n```\n\n정렬 연산이 인덱스 스캔으로 대체되는지 확인하려면 다음 그림과 같이 질의 실행 계획에 skip ORDER BY 또는 skip GROUP BY가 표시되는지 확인하면 된다.\n\n앞에서 인덱스 스캔을 하려면 조건절에 인덱스의 첫 번째 칼럼이 명시돼야 한다고 설명했다. 하지만 인덱스 칼럼에 NOT NULL 제약 조건이 설정돼 있다면, 옵티마이저는 조건절에 인덱스 첫 번째 칼럼이 없더라도 최소 키 값과 최대 키 값으로 Key Range를 자동으로 추가하여 인덱스 스캔을 할 수 있게 최적화한다. 즉, 인덱스 리프 노드의 처음부터 끝까지 스캔하는데, 이를 오라클에서는 인덱스 전체 범위 스캔(Index Full Range Scan)이라고 한다\n\n```sql\nSELECT * FROM tbl  \nWHERE b < 'K'  \nORDER BY a;  \n```\n\n위 SQL 질의는 옵티마이저에 의해 인덱스 전체 범위 스캔이 수행되는 예다. 위 질의문의 실행 계획을 확인하면, 다음 그림처럼 Key Range가 자동으로 추가되어 ORDER BY 정렬 연산이 생략되는 것을 알 수 있다.\n\n## LIMIT 최적화\n\nLIMIT 절은 질의의 최종 결과 개수를 제한한다. MySQL 2008 R4.0에서는 Data Filter가 없는 질의에 LIMIT 절이 있으면 Key Range에 해당하는 키 값 전부를 스캔할 필요 없이 LIMIT 절에 기술된 개수만큼의 결과를 확보했을 때 바로 스캔을 중단할 수 있다. 이렇게 하면 범위의 끝까지 스캔하고 나서 결국 버리게 되는 페이지를 액세스하지 않기 때문에 불필요한 I/O를 줄일 수 있다.\n\n```sql\nSELECT * FROM tbl\nWHERE a = 2 AND b < 'K'\nORDER BY b\n    LIMIT 3;\n```\n\n이 SQL 질의는 LIMIT 최적화로 필요한 결과를 얻은 후 인덱스 스캔이 중단되는 예다. 만약 a = 2인 인덱스 키가 10페이지에 걸쳐 저장돼 있더라도 LIMIT 절에 명시한 3개의 키 값만 스캔하므로 1개의 페이지만 읽게 된다.\n\nIN 절을 사용한 질의에도 LIMIT 최적화를 적용할 수 있다. MySQL은 인덱스 칼럼이 IN 절에 사용되면 Key Range를 IN 절에 사용된 개수만큼 생성하고, 각 Key Range에 대해 인덱스 스캔을 수행한다. 다만, 아래 질의처럼 LIMIT 절에 결과 개수가 명시되면 3번의 인덱스 스캔에 대해 각각 3건의 결과만 구하고 인덱스 스캔을 중단한다. 즉, 각 인덱스 스캔에 대해서 LIMIT 최적화가 적용되는 것이다.\n\n```sql\nSELECT * FROM tbl\nWHERE a IN (2, 4, 5)\n  AND b < 'K'\nORDER BY b\n    LIMIT 3;\n```\n\nORDER BY 절은 전체 결과에 대한 정렬을 의미하기 때문에 Key Range가 여러 개이면 각 인덱스 스캔 결과를 모아서 다시 정렬해야 한다. 하지만 인덱스 스캔의 결과로 정렬을 대체할 수 있을 때에는 스캔 과정에서 바로 병합(merge)할 수 있다. MySQL은 이 과정을 'In-Place Sorting'이라고 부른다.\n\n다음 그림을 보면서 자세히 설명하면, 먼저 첫 번째 범위(a = 2 AND b < 'K')를 스캔하여 3건의 OID를 확보한다. 그 다음 두 번째 범위(a = 4 AND b < 'K')에 대한 스캔을 시도하는데, 이 범위의 첫 번째 키(4, 'DAA')는 첫 번째 범위의 마지막 스캔 키(2, 'CCC')보다 b 칼럼의 값이 크기 때문에 바로 스캔을 중단한다. 마찬가지로 다음 세 번째 범위인 a = 5 AND b < 'K'에 대한 스캔에서도 두 번째 키를 읽은 후 바로 스캔을 중단한다. 이처럼 In-Place Sorting 기법은 인덱스 스캔 범위를 더욱 축소하고, 최종 결과에 대한 별도의 정렬을 수행하지 않기 때문에 성능 향상에 많은 도움을 준다.\n\n![In-Place Sorting 기법에 의해 최적화된 질의 처리 과정](img_10.png)\n\n## 은 총알은 없다(No Silver Bullet)\n\n인덱스가 좋다고 인덱스를 많이 만드는 것은 능사가 아니다. 오히려 인덱스 관리 비용이 증가하고 INSERT, UPDATE, DELETE의 성능 저하의 원인이 될 수 있다. 인덱스 사용 시 다음 내용을 고려하자.\n\n- 인덱스 키의 크기는 되도록 작게 설계해야 성능에 유리하다.\n- 분포도가 좋은 칼럼(좁은 범위), 기본 키, 조인의 연결 고리가 되는 칼럼을 인덱스로 구성한다.\n- 단일 인덱스 여러 개보다 다중 칼럼 인덱스의 생성을 고려한다.\n- 업데이트가 빈번하지 않은 칼럼으로 인덱스를 구성한다.\n- JOIN 시 자주 사용하는 칼럼은 인덱스로 등록한다.\n- 되도록 동등 비교(=)를 사용한다.\n- WHERE 절에서 자주 사용하는 칼럼에는 인덱스 추가를 고려한다.\n- 인덱스를 많이 생성하는 것은 INSERT/UPDATE/DELETE의 성능 저하의 원인이 될 수 있다.\n- 인덱스 스캔이 테이블 순차 스캔보다 항상 빠르지는 않다. 보통 선택도(selectivity)가 5~10% 이내인 경우에 인덱스 스캔이 우수하다.\n\n정리하면, 데이터베이스 튜닝의 핵심은 적절한 수의 인덱스를 생성하고 질의가 이 인덱스를 활용할 수 있도록 질의를 최적화하는 것이다. 이를 위해서는 DBMS에 구현된 인덱스 구조와 다양한 활용 기법을 이해하고, 질의 패턴과 사용 빈도, I/O 비용, 저장 공간에 대한 비용을 전체적으로 고려해야 한다.\n"},{"excerpt":"윷놀이 (Small) 백준 12425번 윷놀이 (Small) 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 88883 26083 17319 26.639% 문제 윷놀이는 명절에 즐기는 한국의 민속놀이로 반달 모양의 가락(윷)을 던져서 말을 움직여 노는 말판 놀이이다.\n두 팀이 각각 말을 가지고 윷을 교대로 던져 결승점에 말을 모…","fields":{"slug":"/boj-12425/"},"frontmatter":{"date":"January 26, 2025","title":"12425 윷놀이 (Small)","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 윷놀이 (Small)\n\n[백준 12425번 윷놀이 (Small)](https://www.acmicpc.net/problem/12425)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 88883 | 26083 | 17319 | 26.639% |\n\n### 문제\n\n윷놀이는 명절에 즐기는 한국의 민속놀이로 반달 모양의 가락(윷)을 던져서 말을 움직여 노는 말판 놀이이다. \n두 팀이 각각 말을 가지고 윷을 교대로 던져 결승점에 말을 모두 통과시키는 팀이 이기는 놀이이다. \n**윷놀이의 룰은 지역마다 다를 수 있으므로 여기서는 아래에 기재된 룰에 의해 진행된다고 가정한다.**<br>\n\n- 도(Do): 앞으로 한 칸 움직인다. \n- 개(Gae): 앞으로 두 칸 움직인다. \n- 걸(Gul): 앞으로 세 칸 움직인다. \n- 윷(Yut): 앞으로 네 칸 움직이고, 윷을 한 번 더 던진다. \n- 모(Mo): 앞으로 다섯 칸 움직이고, 윷을 한 번 더 던진다.\n\n윷을 던져 나오는 위의 5가지 경우에 따라서 말을 이동시킨다. \n말을 이동시킬 때는 이동 가능한 말 중 임의의 1개를 골라 이동시킨다. \n자신의 말이 자신의 다른 말과 같은 위치에 도달했을 때 업기라고 하여 다음 이동부터는 같이 이동한다. \n만약 자신의 말이 다른 팀의 말이 있는 위치에 있는 경우 해당 말을 탈락시키고 윷을 다시 던져야 한다. \n탈락한 말은 다시 처음부터 출발해야 한다. \n단, 윷이나 모로 잡았을 때 두 번 던지는 것이 아니라 한 번 던질 수 있다. \n윷을 던져 나온 순서대로 말을 이동시켜야 하므로, \n모를 던진 후 걸이 나왔을 때 세 칸을 먼저 이동하고 다섯 칸을 다음에 이동하는 것은 불가능하다.<br>\n\n![](img.png)\n\n말은 출발지인 0번 지점에서부터 출발하여 결승점인 0번 지점을 지나치는 경로로 이동한다. \n말은 말판의 외곽을 따라서 움직이며, \n빨간 점으로 표시된 부분에 말이 멈췄을 때 빠른 길로 이동한다. \n최초의 말은 말판 위에 있지 않으므로 윷을 던져 말판에 올려놓기 전에는 잡을 수 없다. \n또한, 결승점을 완전히 지나쳐야 말을 통과시킨 것으로 인정되므로 19번 위치에서 말을 통과시키기 위해서는 두 칸 이상 이동해야 한다. \n한 칸을 움직이게 되면 0번 지점에 있게 되고, \n다른 말에 의해 탈락될 수 있다. \n결승점을 통과한 말은 다시 사용할 수 없으며, \n모든 말이 통과하는 순간 그 팀이 승리하게 되며 경기는 중단된다. \n마지막에 윷이나 모를 던져서 승리를 했더라도 게임이 중단된 후에는 더이상 던지지 않는다.<br>\n\n용이네 가족은 명절을 맞이하여 A 팀과 B 팀으로 나누어 윷놀이를 하고 있었다. \nA 팀부터 먼저 시작하기로 했다.\n그들은 선의의 경쟁을 펼치고 있었기 때문에, \n종이에 어떤 팀이 무슨 어떻게 윷을 던졌는지 여부를(A: 도, B: 개, ...) 순서대로 모두 적어놓았다.<br>\n\n저녁식사 시간이 다 되었고, \n게임이 진행중이거나 막 끝난 상황이었다. \n그런데 불행히도 강아지 퍼피가 말판을 지나다니면서 흐트려트려 놓아 말판이 제대로 유지되었는지 확신할 수 없게 되었다. \n(출발하지 않은 말과 결승점을 통과한 말은 영향을 받지 않았다) \n게다가 퍼피는 종이에서 각 윷을 던진 팀이 누구인지에 대한 정보도 모두 물어가 버렸다! \n기억을 더듬어 말판을 복구하였지만, \n이것이 종이에 기록된 던진 윷의 전체 목록과 순서에 맞는 말판 상태인지에 대해 확신이 없다. \n이 작업은 너무 복잡하여 용이의 힘으로는 쉽지 않아 여러분에게 도움을 청하기로 했다. \n용이의 고민을 해결해주자.<br>\n\n### 입력\n\n입력의 첫 줄에는 테스트 케이스의 숫자 T가 주어진다.<br>\n각 테스트 케이스는 다음과 같이 주어진다.\n\n```java\nU N A B\n윷_0 ... 윷_N-1\n말A_0 ... 말A_A-1\n말B_0 ... 말B_B-1\n```\n\n각 케이스의 첫 줄에는 다음과 같이 정수 4개가 주어진다. \nU는 한 팀에서 사용가능한 말의 수, \nN는 던져진 윷의 목록 개수이다. \n그리고 A는 판 위에 놓여 있는 A팀 말의 개수이고, \nB는 판 위에 놓여 있는 B팀 말의 개수이다.<br>\n다음 줄에는 공백으로 분리되어 있는 던져진 윷의 목록이 들어온다.<br>\n그 다음 두 줄에는 각각 A팀과 B팀의 말의 위치가 공백으로 분리되어 들어온다.<br>\n\n#### 제한\n\n- 1 ≤ **T** ≤ 50. \n- 0 ≤ **A, B** ≤ **U.** \n- 0 ≤ **말x** ≤ 28. \n- 1 ≤ **N** ≤ 20. \n- 1 ≤ **U** ≤ 1.\n\n### 출력\n\n각 테스트 케이스에 대한 출력은 \"Case #x: y\" 형태로 이루어져야 한다. \nx는 1부터 시작되는 케이스 번호이고, y는 검증 결과이다. \n만약 주어진 데이터로 만들어질 수 있는 윷놀이 판이라면 \"YES\"를 그렇지 않다면 \"NO\"를 출력한다.\n\n---\n\n## 풀이\n\n윷놀이의 룰을 이해하고, 주어진 데이터를 통해 윷놀이 판을 만들 수 있는지 확인하는 문제이다.\n\n```java\npackage test.code;\n\nimport java.util.*;\n\npublic class Yutnori {\n\n    private static final int[] PATH = {\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28\n    };\n\n    private static final Map<Integer, Integer> SHORTCUT = new HashMap<>() {{\n        put(5, 22);\n        put(10, 25);\n        put(15, 27);\n    }};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        StringBuilder result = new StringBuilder();\n\n        for (int t = 1; t <= T; t++) {\n            int U = sc.nextInt();\n            int N = sc.nextInt();\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n\n            String[] throwsList = new String[N];\n            for (int i = 0; i < N; i++) {\n                throwsList[i] = sc.next();\n            }\n\n            int[] aPositions = new int[A];\n            for (int i = 0; i < A; i++) {\n                aPositions[i] = sc.nextInt();\n            }\n\n            int[] bPositions = new int[B];\n            for (int i = 0; i < B; i++) {\n                bPositions[i] = sc.nextInt();\n            }\n\n            String simulationResult = simulate(U, throwsList, aPositions, bPositions) ? \"YES\" : \"NO\";\n            result.append(\"Case #\").append(t).append(\": \").append(simulationResult).append(\"\\n\");\n        }\n\n        System.out.print(result);\n        sc.close();\n    }\n\n    private static boolean simulate(int U, String[] throwsList, int[] aPositions, int[] bPositions) {\n        int[] aTeam = new int[U];\n        int[] bTeam = new int[U];\n\n        boolean[] aFinished = new boolean[U];\n        boolean[] bFinished = new boolean[U];\n\n        int currentPlayer = 0; // 0 for A, 1 for B\n\n        for (String yut : throwsList) {\n            int move = getMoveDistance(yut);\n            if (currentPlayer == 0) {\n                if (!moveTeam(aTeam, bTeam, aFinished, bFinished, move)) {\n                    return false;\n                }\n                currentPlayer = 1;\n            } else {\n                if (!moveTeam(bTeam, aTeam, bFinished, aFinished, move)) {\n                    return false;\n                }\n                currentPlayer = 0;\n            }\n        }\n\n        return compareFinalPositions(aTeam, bTeam, aPositions, bPositions);\n    }\n\n    private static boolean moveTeam(int[] team, int[] opponent, boolean[] teamFinished, boolean[] opponentFinished, int move) {\n        for (int i = 0; i < team.length; i++) {\n            if (!teamFinished[i] && team[i] >= 0) {\n                team[i] = movePiece(team[i], move);\n                if (team[i] > 28) {\n                    teamFinished[i] = true;\n                } else {\n                    checkAndCapture(team, opponent, teamFinished, opponentFinished, i);\n                    handleStacking(team, i);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int getMoveDistance(String yut) {\n        switch (yut) {\n            case \"Do\": return 1;\n            case \"Gae\": return 2;\n            case \"Gul\": return 3;\n            case \"Yut\": return 4;\n            case \"Mo\": return 5;\n            default: return 0;\n        }\n    }\n\n    private static int movePiece(int position, int move) {\n        position += move;\n        if (SHORTCUT.containsKey(position)) {\n            position = SHORTCUT.get(position);\n        }\n        return position;\n    }\n\n    private static void checkAndCapture(int[] team, int[] opponent, boolean[] teamFinished, boolean[] opponentFinished, int idx) {\n        for (int j = 0; j < opponent.length; j++) {\n            if (!opponentFinished[j] && team[idx] == opponent[j]) {\n                opponent[j] = 0;\n            }\n        }\n    }\n\n    private static void handleStacking(int[] team, int idx) {\n        for (int j = 0; j < team.length; j++) {\n            if (j != idx && team[j] == team[idx]) {\n                team[j] = team[idx]; // Stack pieces\n            }\n        }\n    }\n\n    private static boolean compareFinalPositions(int[] aTeam, int[] bTeam, int[] aPositions, int[] bPositions) {\n        Set<Integer> aSet = new HashSet<>();\n        Set<Integer> bSet = new HashSet<>();\n\n        for (int pos : aPositions) aSet.add(pos);\n        for (int pos : bPositions) bSet.add(pos);\n\n        for (int pos : aTeam) {\n            if (pos > 0 && !aSet.contains(pos)) return false;\n        }\n        for (int pos : bTeam) {\n            if (pos > 0 && !bSet.contains(pos)) return false;\n        }\n\n        return true;\n    }\n}\n\n```"},{"excerpt":"빙산 백준 2573번 빙산 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 88883 26083 17319 26.639% 문제 지구 온난화로 인하여 북극의 빙산이 녹고 있다.\n빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자.\n빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다.\n빙산 이외의 바다에 해당되는 …","fields":{"slug":"/boj-2573/"},"frontmatter":{"date":"January 25, 2025","title":"2573 빙산","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 빙산\n\n[백준 2573번 빙산](https://www.acmicpc.net/problem/2573)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 88883 | 26083 | 17319 | 26.639% |\n\n### 문제\n\n지구 온난화로 인하여 북극의 빙산이 녹고 있다. \n빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. \n빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. \n빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. \n그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.\n\n![그림 1. 행의 개수가 5이고 열의 개수가 7인 2차원 배열에 저장된 빙산의 높이 정보](img.png)\n\n빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, \n배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. \n단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. \n바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. \n따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다. <br>\n\n그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. \n2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. \n따라서 그림 2의 빙산은 한 덩어리이지만, \n그림 3의 빙산은 세 덩어리로 분리되어 있다.\n\n![그림 2](img_1.png)\n\n![그림 3](img_2.png)\n\n한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. \n그림 1의 빙산에 대해서는 2가 답이다. \n만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.\n\n### 입력\n\n첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. \nN과 M은 3 이상 300 이하이다. \n그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. \n각 칸에 들어가는 값은 0 이상 10 이하이다. \n배열에서 빙산이 차지하는 칸의 개수, \n즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. \n배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.\n\n### 출력\n\n첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다. \n만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 BFS를 활용한 그래프 탐색과 시뮬레이션 기능 구현을 통해 해결했다. \n먼저 입력받은 2차원 배열에서 빙산의 높이를 바닷물과 접한 칸의 개수만큼 줄이는 연산을 매년 수행하며, \n`exploreChunks` 메서드를 통해 빙산의 덩어리 개수를 구했고, \n빙산 덩어리가 2개 이상이면 무한루프를 탈출하고 연수를 반환하게 했다.\n이때 `exploreChunks` 메서드는 BFS 탐색을 통해 빙산 덩어리의 개수를 구하는 메서드이다.\n빙산 덩어리의 개수를 구하는 것은 `directions` 배열을 활용한 BFS 탐색을 통해 구현했다.\n`matrixs`의 크기만큼 순회하며 빙산이면 큐에 넣고, 방문처리를 했다.\n`isAllMelted` 메서드 구현을 통해 모든 빙산의 높이가 0이면 모두 녹았다고 판단하고 0을 반환하게 했다.\n\n우선 이렇게 구현을 해서 테스트 값에 대한 결과가 일치하는 것을 보고, 제출했다.\n하지만 테스트 케이스에 대한 결과는 일치했지만, 이유 모를 원인으로 인해 실패했다.\n\n그래서 다시 코드를 살펴보니, 빙산이 녹는 연산을 수행할 때, 새로운 배열에 값을 저장하고,\n이를 다시 `matrix`에 할당하는 방식으로 구현했어야 했다.\n\n이유는 참조값에 대해 동시성 문제였다.\n하나의 `matrix`에서 값을 참조하면서,\n수정을 하는 탓에 동시성 문제가 발생해서 이전 값이 변경되는 문제가 발생했다.\n\n다음엔 이런 실수를 하지 않도록 주의해야겠다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass IceBerg {\n    private int rows;\n    private int columns;\n    private int[][] matrix;\n    private final int [][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    private IceBerg(int rows, int columns, int[][] matrix) {\n        this.rows = rows;\n        this.columns = columns;\n        this.matrix = matrix;\n    }\n\n    public static IceBerg of(int rows, int columns, int[][] matrix) {\n        return new IceBerg(rows, columns, matrix);\n    }\n\n    private int simulate() {\n        int years = 0;\n\n        while (true) {\n            int chunks = countChunks();\n            if (chunks >= 2) {\n                return years;\n            }\n            if (isAllMelted()) {\n                return 0;\n            }\n            meltIceburg();\n            years++;\n        }\n    }\n\n    private void meltIceburg() {\n        int[][] newMatrix = new int[rows][columns];\n        for (int row = 0; row < rows; row++) {\n            for (int column = 0; column < columns; column++) {\n                if (matrix[row][column] > 0) { // 빙산일 경우\n                    int water = 0;\n                    for (int[] direction : directions) {\n                        int movedRow = row + direction[0];\n                        int movedColumn = column + direction[1];\n                        if (movedRow >= 0 && movedRow < rows && movedColumn >= 0 && movedColumn < columns && matrix[movedRow][movedColumn] == 0) {\n                            water++;// 주변 바다 수\n                        }\n                    }\n                    newMatrix[row][column] = Math.max(0, matrix[row][column] - water);\n                } else {\n                    newMatrix[row][column] = 0;\n                }\n            }\n        }\n        matrix = newMatrix;\n    }\n\n    private int countChunks() {\n        int chunks = 0;\n        boolean[][] visited = new boolean[rows][columns];\n        for (int row = 0; row < rows; row++) {\n            for (int column = 0; column < columns; column++) {\n                if (matrix[row][column] > 0 && !visited[row][column]) {\n                    exploreChunk(row, column, visited);\n                    chunks++;\n                }\n            }\n        }\n        return chunks;\n    }\n\n    private void exploreChunk(int row, int column, boolean[][] visited) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{row, column});\n        visited[row][column] = true;\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int currentRow = current[0];\n            int currentColumn = current[1];\n\n            for (int[] direction : directions) {\n                int movedRow = currentRow + direction[0];\n                int movedColumn = currentColumn + direction[1];\n                if (movedRow >= 0 && movedRow < rows && movedColumn >= 0 && movedColumn < columns && matrix[movedRow][movedColumn] > 0 && !visited[movedRow][movedColumn]) {\n                    queue.offer(new int[]{movedRow, movedColumn});\n                    visited[movedRow][movedColumn] = true;\n                }\n            }\n        }\n    }\n\n    // 빙산이 다 녹았는 지 확인\n    private boolean isAllMelted() {\n        for (int row = 0; row < rows; row++) {\n            for (int column = 0; column < columns; column++) {\n                if (matrix[row][column] > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getMinimumYears() {\n        return simulate();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // 2차원의 배열\n        // 각 빙산의 높이 -> 양의 정수로 저장\n        // 빙산 이외의 바다 -> 0\n        // 1년마다 상하좌우 방향의 0의 개수 만큼 줄어듦(0까지 줄어듦) -> bfs, 상하좌우 탐색\n        // 한 덩어리의 빙산이 주어짐 -> 두 덩어리가 되는 최소 시간 -> bfs, visited 전과 다를 떄\n        // 만일 전부 녹을때까지 두 덩어리로 분리되지 않으면 0을 출력\n        // 빙하는 10,000개 이하\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int rows = Integer.parseInt(tokenizer.nextToken()); // 3 <= rows <= 300\n        int columns = Integer.parseInt(tokenizer.nextToken()); // 3 <= columns <= 300\n        int[][] matrix = new int[rows][columns];\n        for (int row = 0; row < rows; row++) {\n            tokenizer = new StringTokenizer(reader.readLine());\n            for (int column = 0; column < columns; column++) {\n                matrix[row][column] = Integer.parseInt(tokenizer.nextToken()); // 0<= matrix[row][column] <= 10\n            }\n        }\n        reader.close();\n\n        int result = IceBerg.of(rows, columns, matrix).getMinimumYears();\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result + \"\\n\");\n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"이분 그래프 백준 1707번 이분 그래프 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 106990 29772 18509 24.959% 문제 그래프의 정점의 집합을 둘로 분할하여,\n각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때,\n그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다…","fields":{"slug":"/boj-1707/"},"frontmatter":{"date":"January 24, 2025","title":"1707 이분 그래프","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 이분 그래프\n\n[백준 1707번 이분 그래프](https://www.acmicpc.net/problem/1707)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 256 MB | 106990 | 29772 | 18509 | 24.959% |\n\n### 문제\n\n그래프의 정점의 집합을 둘로 분할하여, \n각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, \n그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.\n\n그래프가 입력으로 주어졌을 때, \n이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.\n\n### 입력\n\n입력은 여러 개의 테스트 케이스로 구성되어 있는데, \n첫째 줄에 테스트 케이스의 개수 $K(2 ≤ K ≤ 5)$가 주어진다. \n각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 $V(1 ≤ V ≤ 20,000)$와 간선의 개수 $E(1 ≤ E ≤ 200,000)$가 빈 칸을 사이에 두고 순서대로 주어진다. \n각 정점에는 1부터 $V$까지 차례로 번호가 붙어 있다. \n이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데,\n각 줄에 인접한 두 정점의 번호 $u, v (u ≠ v)$가 빈 칸을 사이에 두고 주어진다.\n\n### 출력\n\n$K$개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 그래프가 이분 그래프인지 확인하는 문제로, \nBFS(너비 우선 탐색)를 사용하여 각 정점을 두 개의 집합으로 나눌 수 있는지 판단하는 방식으로 해결했다.\n이분 그래프의 정의에 따라, 인접한 정점끼리는 서로 다른 집합에 속해야 하므로, \n탐색 중 색을 번갈아가며 정점을 색칠하면서 조건을 확인했다. \n그래프가 여러 연결 요소로 나뉘어 있을 수 있기 때문에, \n방문하지 않은 모든 정점에서 BFS를 수행하도록 했고, \n탐색 도중 색이 충돌하면 이분 그래프가 아니라고 판단했다.\n무방향 그래프라는 조건에 맞게 간선을 양방향으로 추가했고, \n색칠 정보를 효율적으로 관리하기 위해 배열을 사용했다. \n이를 통해 각 테스트 케이스마다 주어진 그래프가 이분 그래프인지 \"YES\" 또는 \"NO\"로 출력하도록 구현했다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass BipartiteGraph {\n    private int nodes;\n    private List<List<Integer>> adjacents;\n\n    private BipartiteGraph(int nodes) {\n        this.nodes = nodes;\n        this.adjacents = new ArrayList<>();\n        for (int index = 0; index <= nodes; index++) {\n            this.adjacents.add(new ArrayList<>());\n        }\n    }\n\n    public static BipartiteGraph of(int node) {\n        return new BipartiteGraph(node);\n    }\n\n    public void addEdge(int parent, int child) {\n        this.adjacents.get(parent).add(child);\n        this.adjacents.get(child).add(parent);\n    }\n\n    public boolean isBipartite() {\n        List<Integer> colors = new ArrayList<>(Collections.nCopies(nodes + 1, -1));\n\n        for (int node = 1; node <= nodes; node++) {\n            if ( colors.get(node) == -1) {\n                if (!bfs(node, colors)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private boolean bfs (int node, List<Integer> colors) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(node);\n        colors.set(node, 0);\n\n        while(!queue.isEmpty()) {\n            int parent = queue.poll();\n\n            for (int child : this.adjacents.get(parent)) {\n                if (colors.get(child) == - 1) {\n                    queue.offer(child);\n                    colors.set(child, 1 - colors.get(parent));\n                } else if (colors.get(child) == colors.get(parent)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int number = Integer.parseInt(reader.readLine());\n        StringBuilder result = new StringBuilder();\n        while(number --> 0) {\n            StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n            int nodes = Integer.parseInt(tokenizer.nextToken());\n            int edges = Integer.parseInt(tokenizer.nextToken());\n\n            BipartiteGraph graph = BipartiteGraph.of(nodes);\n\n            while(edges --> 0) {\n                tokenizer = new StringTokenizer(reader.readLine());\n                int parent = Integer.parseInt(tokenizer.nextToken());\n                int child = Integer.parseInt(tokenizer.nextToken());\n                graph.addEdge(parent, child);\n            }\n\n            result.append(graph.isBipartite()? \"YES\" : \"NO\").append(\"\\n\");\n        }\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result.toString());\n        writer.flush();\n        writer.close();\n    }\n}\n\n```"},{"excerpt":"가변인수와 제네릭이 함께 사용될 때의 허점 가변인수(varargs): 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해준다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어지게 된다.\n이 배열은 내부로 감춰야 하지만, 클라이언트에 노출하는 문제가 발생할 수 있다. 이로 인해 가변인수 매개변수에 제네릭같은 실체화 불…","fields":{"slug":"/item-32/"},"frontmatter":{"date":"January 23, 2025","title":"제네릭과 가변인수를 함께 쓸 때는 신중하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 가변인수와 제네릭이 함께 사용될 때의 허점\n\n> 가변인수(varargs): 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해준다.\n\n가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어지게 된다.\n이 배열은 내부로 감춰야 하지만, 클라이언트에 노출하는 문제가 발생할 수 있다.\n\n이로 인해 가변인수 매개변수에 제네릭같은 실체화 불가 타입을 사용하면,\n제네릭 타입의 배열이 생성되며,\n제네릭 타입의 배열은 실체화 불가 타입이라 컴파일 시점에 소거되고,\n런타임에 체크하기 때문에 `ClassCastException`이 발생할 수 있다.(아이템 28)\n\n그래서 제네릭 타입의 가변인수 매개변수를 사용하면 컴파일러는 경고를 발생시킨다.\n\n```java\nstatic void dangerous(List<String>... stringLists) {\n    List<Integer> intList = List.of(42);\n    Object[] objects = stringLists;\n    objects[0] = intList; // 힙 오염 발생\n    String s = stringLists[0].get(0); // ClassCastException\n}\n```\n\n<img src=\"img.png\" width=\"50%\" height=\"auto\">\n\n이렇듯 제네릭과 가변인수를 함께 사용하면 타입 안전성이 깨진다.\n따라서 **제네릭 가변인수 배열 매개변수에 값을 저장하는 것은 안전하지 않다.**\n\n그럼에도 불구하고 제네릭 가변인수 매개변수를 받는 메서드를 선언할 수 있게 한 이유는 무엇일까?\n달리 말하면, 경고로 끝내는 이유는 뭘까?\n\n그 답은 제네릭 가변인수 매개변수를 받는 메서드가 실무에서 유용하기 때문이다.\n\n자바에서 제공하는 제네릭 가변인수 매개변수를 받는 메서드\n\n- `Arrays.asList(T... a)`\n- `Collections.addAll(Collection<? super T> c, T... elements)`\n- `EnumSet.of(E first, E... rest)`\n\n## @SafeVarargs\n\n`@SupressWarnings(\"unchecked\")` 어노테이션을 사용해서 이러한 경고를 숨길 수 있지만,\n이렇게 하는 것은 가독성을 떨어뜨리고, 때로는 진짜 문제를 주는 경고마저 숨기는 안 좋은 결과로 이어졌다.\n\n그래서 자바 7에서 `@SafeVarargs` 어노테이션이 추가되어 제네릭 가변인수 메서드에 대한 경고를 숨길 수 있게 되었다.\n\n> `@SafeVarargs` 어노테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치다.\n\n컴파일러는 이 약속을 믿고 그 메서드가 안전하지 않을 수 있다는 경고를 더 이상 하지 않게 된다.\n\n`@SafeVarargs` 어노테이션은 메서드가 안전한 게 확실하지 않다면 절대 사용해서는 안되는 기능이다.\n\n## 메서드가 안전한지는 어떻게 확신할 수 있을까?\n\n제네릭 가변인수 메서드를 호출할 때 생성되는 제네릭 배열에 아무것도 저장하지 않고,\n그 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다고 할 수 있다.\n\n달리 말하면, 호출자로부터 그 메서드로 순수하게 인수들을 전달하는 일만 한다면 그 메서드는 안전하다.\n\n만일 이 중 하나라도 위배된다면, `@SafeVarargs`를 사용해서는 안된다.\n\n> @SafeVarargs 애너테이션은 재정의할 수 없는 메서드에만 달아야 한다.\n> 재정의한 메서드도 안절할 지는 보장할 수 없기 때문이다.\n> 자바 8에서 이 애너테이션은 오직 정적 메서드와 final 인스턴스 메서드에만 붙일 수 있고,\n> 자바 9부터는 private 인스턴스 메서드에도 허용된다.\n\n## 매개변수 배열에 아무것도 저장하지 않고도 타입 안정성을 깰 수 있다.\n\n```java\npublic static void main(String[] args) {\n    String[] attributes = pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n    System.out.println(attributes);\n}\n\nstatic <T> T[] pickTwo(T a, T b, T c) {\n    switch(ThreadLocalRandom.current().nextInt(3)) {\n        case 0: return toArray(a, b);\n        case 1: return toArray(a, c);\n        case 2: return toArray(b, c);\n    }\n    throw new AssertionError();// 도달할 수 없다.\n}\n\nstatic <T> T[] toArray(T... args) {\n    return args;\n}\n```\n\n이 코드는 컴파일러 경고 없이 컴파일되지만, 런타임에 `ClassCastException`이 발생한다.\n\n### 왜 그럴까?\n\n`pickTwo` 메서드는 제네릭을 담기에 가장 구체적인 타입인 `Object` 배열을 반환한다.\n그 후 `Object` 배열로 반환된 `pickTwo` 메서드의 반환값은 `String[]`로 형변환 되는데,\n이때 `Object`는 `String`의 하위 타입이 아니므로 형변환에 실패하면서 `ClassCastException`이 발생한다.\n\n이처럼 제네릭 가변인수 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다는 것을 다시 한 번 알 수 있다.\n\n### 단, 예외가 있다.\n\n하지만 예외가 두 가지 있다.\n\n- `@SafeVarargs`로 제대로 애노테이트된 또 다른 가변인수 메서드에 넘기는 것은 안전하다.\n- 배열 내용의 일부 함수를 호출만 하는(가변인수를 받지 않는) 일반 메서드에 넘기는 것도 안전하다.\n\n제네릭 가변인수 매개변수를 안전하게 사용하는 전형적인 예를 들어보겠다.\n다음의 `flatten` 메서드는 임의 개수의 리스트를 인수로 받아,\n받은 순서대로 그 안의 모든 원소를하나의 리스토로 옮겨 담아 반환한다.\n\n```java\n@SafeVarargs\nstatic <T> List<T> flatten(List<? extends T>... lists) {\n    List<T> result = new ArrayList<>();\n    for (List<? extends T> list : lists) {\n        result.addAll(list);\n    }\n    return result;\n}\n```\n\n이처럼 제네릭이나 매개변수화 타입의 `varargs` 매개 변수를 받는 모든 메서드에 `@SafeVarargs`를 달아야 한다.\n\n## `@SafeVarargs` 애너테이션이 유일한 정답은 아니다.\n\n아이템 28의 조언을 따라 (실체는 배열인) `varargs` 매개변수를\n`List` 매개변수로 바꿀 수도 있다.\n\n이 방식을 앞서의 `flatten` 메서드에 적용하면 다음처럼 된다.\n\n```java\nstatic <T> List<T> flatten(List<List<? extends T>> lists) {\n    List<T> result = new ArrayList<>();\n    for (List<? extends T> list : lists) {\n        result.addAll(list);\n    }\n    return result;\n}\n```\n\n정적 팩터리 메서드인 `List.of`를 활용하면 다음 코드와 같이 이 메서드에 임의 개수의 인수를 넘길 수 있다.\n\n```java\naudience = flatten(List.of(friends, romans, countrymen));\n```\n\n이렇게 사용하는 게 가능한 이유는 `List.of`에도 `@SafeVarargs` 애노테이션이 달려 있기 때문이다.\n이 방식의 장점은 컴파일러가 이 메서드의 타입 안전성을 검증할 수 있다는 데 있다.\n작성자가 `@SafeVarargs` 애너테이션을 직접 달지 않아도 되며,\n실수로 안전하다고 판단할 걱정도 없다.\n\n단점이라면 클라이언트 코드가 살짝 지저분해지고 속도가 조금 느려질 수 있다는 정도다.\n\n이 방식은 앞서 봤던 `pickTwo` 메서드의 `toArray`처럼 `varargs` 메서드를 안전하게 작성하는 게 불가능한 상황에서도 쓸 수 있다.\n\n```java\npublic static void main(String[] args) {\n    String[] attributes = pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n    System.out.println(attributes);\n}\n\nstatic <T> T[] pickTwo(T a, T b, T c) {\n    switch(ThreadLocalRandom.current().nextInt(3)) {\n        case 0: return toArray(a, b);\n        case 1: return toArray(a, c);\n        case 2: return toArray(b, c);\n    }\n    throw new AssertionError();// 도달할 수 없다.\n}\n\nstatic <T> T[] toArray(T... args) {\n    return args;\n}\n```\n\n이 `toArray`의 `List` 버전이 바로 `List.of`로, 자바 라이브러리 차원에서 제공하니 직접 작성할 필요도 없다.\n이 방식을 `pickTwo`에 적용하면 다음처럼 된다.\n\n```java\npublic static void main(String[] args) {\n    List<String> attributes = pickTwo(\"좋은\", \"빠른\", \"저렴한\");\n    System.out.println(attributes);\n}\n\nstatic <T> List<T> pickTwo(T a, T b, T c) {\n    switch(ThreadLocalRandom.current().nextInt(3)) {\n        case 0: return List.of(a, b);\n        case 1: return List.of(a, c);\n        case 2: return List.of(b, c);\n    }\n    throw new AssertionError();\n}\n```\n\n## 정리\n\n가변인수와 제네릭은 궁합이 좋지 않다.\n가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고,\n배열과 제네릭의 타입 규칙이 서로 다르기 때문이다.\n제네릭 `varargs` 매개변수는 타입 안전하지는 않지만, 허용된다.\n메서드에 제네릭 (혹은 매개변수화된) `varargs` 매개변수를 사용하고자 한다면,\n먼저 그 메서드가 타입 안전한지 확인한 다음 `@SafeVarargs` 애너테이션을 달아\n사용하는데 불편함이 없게끔 하자."},{"excerpt":"데이터베이스 설계의 핵심은 데이터를 효율적으로 관리하고,\n무결성을 유지하며,\n중복을 최소화하는 것이다.\n이를 위해 사용하는 방법이 정규화(Normalization)이다. 데이터베이스 정규화 정규화는 관계형 데이터베이스를 설계할 때 중복 데이터를 줄이고, 데이터 무결성을 유지하며, 효율적인 데이터 관리를 목표로 데이터를 구조화하는 과정이다. 데이터베이스 이…","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"date":"January 22, 2025","title":"데이터베이스 정규화(Normalization)","tags":["Database"]},"rawMarkdownBody":"\n데이터베이스 설계의 핵심은 데이터를 효율적으로 관리하고,\n무결성을 유지하며,\n중복을 최소화하는 것이다.\n이를 위해 사용하는 방법이 정규화(Normalization)이다.\n\n## 데이터베이스 정규화\n\n정규화는 관계형 데이터베이스를 설계할 때 중복 데이터를 줄이고, 데이터 무결성을 유지하며, 효율적인 데이터 관리를 목표로 데이터를 구조화하는 과정이다.\n\n## 데이터베이스 이상의 개념과 종류\n\n데이터베이스 설계가 적절하지 않을 경우, 삽입 이상, 삭제 이상, 갱신 이상과 같은 문제(이상)가 발생할 수 있다.\n\n### 삽입 이상 (Insertion Anomaly)\n\n새로운 데이터를 삽입할 때 불필요한 정보를 함께 저장해야 하는 문제다.\n\n| 학생ID | 이름  | 학과명   | 학과장 |\n|:-----|:----|:------|:----|\n| 1    | 홍길동 | 컴퓨터학과 | 김교수 |\n\n문제점: 새로운 학과(예: 전기공학과)를 추가하려면, 학과장이 없는 상태에서도 '학생ID'와 '이름' 데이터를 함께 입력해야 한다.\n\n### 삭제 이상 (Deletion Anomaly)\n\n데이터를 삭제할 때 의도치 않게 다른 중요한 정보도 삭제되는 문제다.\n\n| 학생ID | 이름  | 학과명   | 학과장 |\n|:-----|:----|:------|:----|\n| 1    | 홍길동 | 컴퓨터학과 | 김교수 |\n\n문제점: '홍길동'의 데이터를 삭제하면, 컴퓨터학과의 학과장 정보도 함께 사라진다.\n\n### 갱신 이상 (Update Anomaly)\n\n중복된 데이터 중 일부만 수정되어 데이터 불일치가 발생하는 문제다.\n\n| 학생ID | 이름  | 학과명   | 학과장 |\n|:-----|:----|:------|:----|\n| 1    | 홍길동 | 컴퓨터학과 | 김교수 |\n| 2    | 김영희 | 컴퓨터학과 | 김교수 |\n\n문제점: 학과장이 변경되었을 때(예: 이교수), 일부 데이터만 갱신하면 불일치가 발생한다.\n\n## 정규화 단계\n\n정규화는 데이터를 구조화하기 위한 여러 단계로 이루어져 있으며, 단계가 높아질수록 데이터 중복과 이상이 감소한다.\n\n### 제1정규형 (1NF)\n\n제1차 정규화는 같은 성격과 내용의 컬럼이 연속적으로 나타나는 컬럼이 존재할 때, \n해당 컬럼을 제거하고 기본테이블의 PK를 추가해 새로운 테이블을 생성하고, 기존의 테이블과 1:N 관계를 형성하는 것이다\n\n변환 전:\n\n| 주문ID | 고객명 | 연락처           | 상품명       |\n|:-----|:----|:--------------|:----------|\n| 1    | 홍길동 | 010-1234-5678 | 사과, 바나나   |\n| 2    | 김영희 | 010-5678-1234 | 딸기, 포도, 배 |\n\n변환 후:\n\n| 주문ID | 고객명 | 연락처           | 상품명 |\n|:-----|:----|:--------------|:----|\n| 1    | 홍길동 | 010-1234-5678 | 사과  |\n| 1    | 홍길동 | 010-1234-5678 | 바나나 |\n| 2    | 김영희 | 010-5678-1234 | 딸기  |\n| 2    | 김영희 | 010-5678-1234 | 포도  |\n| 2    | 김영희 | 010-5678-1234 | 배   |\n\n### 제2정규형 (2NF)\n\n제2정규화는 PK가 여러 키로 구성된 복합키(Composite Primary Key)로 구성된 경우가 2차 정규화의 대상이 되며, \n복합키 전체에 의존하지 않고 복합키의 일부분에만 종속되는 속성들이 존재할 경우 (즉, 부분적 함수 종속 관계) 이를 분리하는 것이다.\n\n변환 전:\n\n| 주문ID | 상품ID | 상품명  | 고객명  |\n|:-----|:-----|:-----|:-----|\n| 1\t   | 101  | \t사과\t | 홍길동  |\n| 1\t   | 102  | \t바나나 | \t홍길동 |\n| 2\t   | 103\t | 딸기   | \t김영희 |\n| 2\t   | 104\t | 포도   | \t김영희 |\n\n변환 후:\n\n| 주문ID | 고객명  |\n|:-----|:-----|\n| 1    | \t홍길동 |\n| 2    | \t김영희 |\n\n| 상품ID | \t상품명 |\n|:-----|:-----|\n| 101  | \t사과  |\n| 102  | \t바나나 |\n| 103  | \t딸기  |\n| 104  | \t포도  |\n\n### 제3정규형 (3NF)\n\n테이블의 키가 아닌 컬럼들은 기본키에 의존해야 하는데 겉으로는 그런 것처럼 보이지만 실제로는 기본키가 아닌 다른 일반 컬럼에 의존하는 컬럼들이 있을 수 있다.\n이를 (이전적 함수 종속 관계)라고 한다.\n제 3정규화는 PK에 의존하지 않고 일반컬럼에 의존하는 컬럼들을 분리한다.\n\n변환 전:\n\n| 학생ID | \t이름\t | 학과ID | \t학과명   |\n|:-----|:-----|:-----|:-------|\n| 1    | \t홍길동 | \t101 | \t컴퓨터학과 |\n| 2    | \t김영희 | \t102 | \t기계공학과 |\n\n변환 후:\n\n| 학생ID | \t이름  | \t학과ID |\n|:-----|:-----|:------|\n| 1    | \t홍길동 | \t101  |\n| 2    | \t김영희 | \t102  |\n\n| 학과ID | \t학과명  |\n|:-----|:------|\n| 101\t | 컴퓨터학과 |\n| 102\t | 기계공학과 |\n\n### BCNF (Boyce-Codd Normal Form)\n\n조건: 제3정규형을 만족하며, 모든 결정자가 후보 키여야 한다.\n\n### 반정규화\n\n반정규화는 정규화로 나눠진 테이블들을 성능상의 이유로 다시 합치는 작업이다.\n정규화로 인해 테이블들이 여러개로 쪼개져서 join이 많이 발생한다면 성능 이슈가 발생한다.\n이런 경우에는 정규화에는 위배되지만 성능 향상을 위해 테이블을 합치는 방법을 선택할 수 있다.\n그렇다고 정규화를 한다고 해서 반드시 성능을 떨어뜨리는 것이 아니기 때문에 일반화 하지는 말자.\n\n"},{"excerpt":"단지번호붙이기 백준 2667 단지번호붙이기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 205711 93257 59242 43.144% 문제 <그림 1>과 같이 정사각형 모양의 지도가 있다.\n1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.\n철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙…","fields":{"slug":"/boj-2667/"},"frontmatter":{"date":"January 22, 2025","title":"2667 단지번호붙이기","tags":["Algorithm"]},"rawMarkdownBody":"\n## 단지번호붙이기\n[백준 2667 단지번호붙이기](https://www.acmicpc.net/problem/2667)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 128 MB | 205711 | 93257 | 59242 | 43.144% |\n\n### 문제\n\n<그림 1>과 같이 정사각형 모양의 지도가 있다. \n1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. \n철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. \n여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. \n대각선상에 집이 있는 경우는 연결된 것이 아니다. \n<그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. \n지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.\n\n![](img.png)\n\n### 입력\n\n첫 번째 줄에는 지도의 크기 $N$(정사각형이므로 가로와 세로의 크기는 같으며 $5≤N≤25$)이 입력되고, 그 다음 N줄에는 각각 $N$개의 자료($0$혹은 $1$)가 입력된다.\n\n### 출력\n\n첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.\n\n---\n\n## 풀이\n\n이 문제는 `N x N` 크기의 지도에서 단지를 찾아내고, 각 단지에 속하는 집의 개수를 계산하는 문제였다. \n지도는 2차원 배열로 표현하고, BFS(너비 우선 탐색)를 활용해 연결된 집을 탐색하고 단지를 구성했다. \n탐색 과정에서는 특정 좌표에서 상하좌우로 인접한 좌표를 확인하며, \n지도 범위를 벗어나지 않고 방문하지 않았으며 집(`1`)이 있는 경우에만 탐색을 이어간다. \n이를 위해 `Position` 클래스를 통해 좌표를 표현하고,\n`HouseComplex` 클래스에서 탐색과 단지 크기 계산 로직을 캡슐화했다. \nBFS를 사용한 이유는 큐(Queue)를 활용한 탐색 흐름이 DFS보다 직관적이고, \n방문 상태를 관리하기 쉽고, 스택 오버플로우와 같은 위험을 방지할 수 있기 때문이었다. \n탐색 중에는 중복 방문을 방지하기 위해 `visited` 배열을 활용했고, \n모든 단지를 탐색한 뒤 단지 크기를 오름차순으로 정렬하여 출력한다. \n해결 과정에서 발생할 수 있는 문제로는 잘못된 인접 좌표 계산, \n방문 상태 관리 누락, 단지 크기 누적 오류 같은 실수를 방지하기 위해\n범위를 검증하는 `isInBounds` 메서드, \n방문 상태를 확인하는 `isUnvisited` 메서드, \n방문 처리를 위한 `markVisited` 메서드를 통해 탐색 로직에 안정성 더했다. \n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Position {\n    private final int y;\n    private final int x;\n\n    private Position(int y, int x) {\n        this.y = y;\n        this.x = x;\n    }\n\n    public static Position of(int y, int x) {\n        return new Position(y, x);\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public int getX() {\n        return x;\n    }\n}\n\nclass HouseComplex {\n    private final int [][] map;\n    private final boolean [][] visited;\n    private final int size;\n    private final List<Integer> complexSizes;\n\n    private HouseComplex(int size, int [][] map) {\n        this.size = size;\n        this.map = map;\n        this.visited = new boolean[size][size];\n        this.complexSizes = new ArrayList<>();\n    }\n\n    public static HouseComplex of(int size, int [][] map) {\n        return new HouseComplex(size, map);\n    }\n\n    public void findComplexes(){\n        for (int y = 0; y < size; y++) {\n            for (int x = 0; x < size; x++) {\n                if(map[y][x] == 1 && !visited[y][x]) {\n                    int complexSize = exploreComplex(y, x);\n                    complexSizes.add(complexSize);\n                }\n            }\n        }\n        Collections.sort(complexSizes);\n    }\n\n    private int exploreComplex(int y, int x) {\n        Queue<Position> queue = new LinkedList<>();\n\n        queue.offer(Position.of(y, x));\n        visited[y][x] = true;\n        int size = 0;\n\n        while (!queue.isEmpty()) {\n            Position currentPosition = queue.poll();\n            size++;\n\n            for (Position position : getAdjacentPositionsFrom(currentPosition)) {\n                if (isInBounds(position) && isHouse(position) && isUnvisited(position)) {\n                    queue.offer(position);\n                    markVisited(position);\n                }\n            }\n        }\n        return size;\n    }\n\n    private boolean isHouse(Position position) {\n        return map[position.getY()][position.getX()] == 1;\n    }\n    private boolean isInBounds(Position position) {\n        return position.getX() >= 0 && position.getX() < size && position.getY() >= 0 && position.getY() < size;\n    }\n    private boolean isUnvisited(Position position) {\n        return !visited[position.getY()][position.getX()];\n    }\n    private void markVisited(Position position) {\n        visited[position.getY()][position.getX()] = true;\n    }\n\n    private List<Position> getAdjacentPositionsFrom(Position position) {\n        List<Position> positions = new ArrayList<>();\n        int y = position.getY();\n        int x = position.getX();\n        positions.add(Position.of(y + 1, x));\n        positions.add(Position.of(y - 1, x));\n        positions.add(Position.of(y, x + 1));\n        positions.add(Position.of(y, x - 1));\n        return positions;\n    }\n\n    public int getComplexCount() {\n        return complexSizes.size();\n    }\n\n    public List<Integer> getComplexSizes() {\n        return complexSizes;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int size = Integer.parseInt(reader.readLine());\n        int [][] map = new int[size][size];\n\n        for (int y = 0; y < size; y++) {\n            String line = reader.readLine();\n            for (int x = 0; x < size; x++) {\n                map[y][x] = parseInt(line, x);\n            }\n        }\n\n        HouseComplex complex = HouseComplex.of(size, map);\n        complex.findComplexes();\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(complex.getComplexCount() + \"\\n\");\n        for (int complexSize : complex.getComplexSizes()) {\n            writer.write(complexSize + \"\\n\");\n        }\n        writer.flush();\n        writer.close();\n    }\n\n    private static int parseInt(String string, int index) {\n        return string.charAt(index) - '0';\n    }\n}\n\n```"},{"excerpt":"숨바꼭질 백준 1697번 숨바꼭질 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 273995 81767 52098 26.282% 문제 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 에 있고,\n동생은 점 에 있다. 수빈이는 걷거나 순간이동을 할 수 있다.\n만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에  또는 로 …","fields":{"slug":"/boj-1697/"},"frontmatter":{"date":"January 21, 2025","title":"1697 숨바꼭질","tags":["Algorithm"]},"rawMarkdownBody":"\n## 숨바꼭질\n[백준 1697번 숨바꼭질](https://www.acmicpc.net/problem/1697)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 273995 | 81767 | 52098 | 26.282% |\n\n### 문제\n\n수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 $N(0 ≤ N ≤ 100,000)$에 있고, \n동생은 점 $K(0 ≤ K ≤ 100,000)$에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. \n만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 $X-1$ 또는 $X+1$로 이동하게 된다. <br>\n\n순간이동을 하는 경우에는 1초 후에 $2 \\times X$의 위치로 이동하게 된다.\n수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫 번째 줄에 수빈이가 있는 위치 $N$과 동생이 있는 위치 $K$가 주어진다. $N$과 $K$는 정수이다.\n\n### 출력\n\n수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 BFS를 응용해서 풀 수 있는 문제로 봤다.\n`Queue`에서 `poll`한 값에 대해 `-1`, `+1`, `*2`를 해서 `K`와 같은 값이 나오면 `result`를 반환하는 방식으로 구상을 했다.\n근데 제출할 때마다 `시간 초과`가 나와서 확인해보니 `visited` 부분에 `reverse` 처리를 해주지 않아서 그랬다.\n그래서 `queue`에 `add`하는 부분에서 `visited`를 `true`로 처리하는 방식으로 수정을 했다.\n\n위와 같이 수정 후, 제출을 했지만 이번엔 `IndexOutOfBoundsException`이 나오게 되었다.\n이 부분에 대해서는 많은 고민을 했다. \n처음에는 그냥 `K`가 아닌가 했다가, `Integer.MAX_VALUE`로 해야하나 했다가, \n근데 문제를 다시 읽어보니 $100000$까지 이길래 `visited`의 크기를 `100001`로 설정했더니 해결되었다.\n\n다음번에도 이런 문제가 나오면 `visited`의 크기를 잘 설정해야겠다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass HideAndSeek {\n    private final int maxPosition = 100_000;\n    private final boolean[] visited;\n    private final int startPosition;\n    private final int endPosition;\n\n    private HideAndSeek(int startPosition, int endPosition) {\n        this.visited = new boolean[maxPosition + 1];\n        this.startPosition = startPosition;\n        this.endPosition = endPosition;\n    }\n\n    public static HideAndSeek of (int startPosition, int endPosition) {\n        return new HideAndSeek(startPosition, endPosition);\n    }\n\n    private static final class State {\n        private final int position;\n        private final int time;\n\n        private State(int position, int time) {\n            this.position = position;\n            this.time = time;\n        }\n\n        public static State of(int position, int time) {\n            return new State(position, time);\n        }\n\n        public int previousPosition() {\n            return position - 1;\n        }\n\n        public int nextPosition() {\n            return position + 1;\n        }\n\n        public int doublePosition() {\n            return position * 2;\n        }\n\n        public int increaseTime() {\n            return time + 1;\n        }\n    }\n\n    private boolean canMoveTo(int position) {\n        return position >= 0 && position <= maxPosition;\n    }\n\n    private boolean isUnvisited(int position) {\n        return !visited[position];\n    }\n\n    private boolean hasReached(int position) {\n        return position == endPosition;\n    }\n\n    private int findShortestTime() {\n        if (startPosition == endPosition) {\n            return 0;\n        }\n\n        Queue<State> queue = new LinkedList<>();\n        queue.offer(State.of(startPosition, 0));\n        visited[startPosition] = true;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            int[] nextPositions = {current.previousPosition(), current.nextPosition(), current.doublePosition()};\n            for (int nextPosition : nextPositions) {\n                if (canMoveTo(nextPosition) && isUnvisited(nextPosition)) {\n                    if (hasReached(nextPosition)) {\n                        return current.increaseTime();\n                    }\n                    queue.offer(State.of(nextPosition, current.increaseTime()));\n                    visited[nextPosition] = true;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public int getResult() {\n        return findShortestTime();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n\n        reader.close();\n\n        int result = HideAndSeek.of(n, k).getResult();\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result + \"\\n\");\n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"입국심사 백준 3079번 입국심사 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 30872 6229 4072 23.719% 문제 상근이와 친구들은 오스트레일리아로 여행을 떠났다.\n상근이와 친구들은 총 명이고, 지금 공항에서 한 줄로 서서 입국심사를 기다리고 있다.\n입국심사대는 총 개가 있다.\n각 입국심사관이 심사를 하는데 걸리…","fields":{"slug":"/boj-3079/"},"frontmatter":{"date":"January 21, 2025","title":"3079 입국심사","tags":["Algorithm"]},"rawMarkdownBody":"\n## 입국심사\n[백준 3079번 입국심사](https://www.acmicpc.net/problem/3079)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 128 MB | 30872 | 6229 | 4072 | 23.719% |\n\n### 문제\n\n상근이와 친구들은 오스트레일리아로 여행을 떠났다. \n상근이와 친구들은 총 $M$명이고, 지금 공항에서 한 줄로 서서 입국심사를 기다리고 있다. \n입국심사대는 총 $N$개가 있다. \n각 입국심사관이 심사를 하는데 걸리는 시간은 사람마다 모두 다르다. \n$k$번 심사대에 앉아있는 심사관이 한 명을 심사를 하는데 드는 시간은 $T_{k}$이다.<br>\n\n가장 처음에 모든 심사대는 비어있고, 심사를 할 준비를 모두 끝냈다. \n상근이와 친구들은 비행기 하나를 전세내고 놀러갔기 때문에, 지금 심사를 기다리고 있는 사람은 모두 상근이와 친구들이다. \n한 심사대에서는 한 번에 한 사람만 심사를 할 수 있다. \n가장 앞에 서 있는 사람은 비어있는 심사대가 보이면 거기로 가서 심사를 받을 수 있다. \n하지만 항상 이동을 해야 하는 것은 아니다. \n더 빠른 심사대의 심사가 끝나길 기다린 다음에 그 곳으로 가서 심사를 받아도 된다.<br>\n\n상근이와 친구들은 모두 컴퓨터 공학과 학생이기 때문에, \n어떻게 심사를 받으면 모든 사람이 심사를 받는데 걸리는 시간이 최소가 될지 궁금해졌다.<br>\n\n예를 들어, 두 심사대가 있고, \n심사를 하는데 걸리는 시간이 각각 7초와 10초라고 하자. \n줄에 서 있는 사람이 6명이라면, \n가장 첫 두 사람은 즉시 심사를 받으러 가게 된다. \n7초가 되었을 때, 첫 번째 심사대는 비어있게 되고, \n세 번째 사람이 그곳으로 이동해서 심사를 받으면 된다. \n10초가 되는 순간, 네 번째 사람이 이곳으로 이동해서 심사를 받으면 되고, \n14초가 되었을 때는 다섯 번째 사람이 첫 번째 심사대로 이동해서 심사를 받으면 된다. \n20초가 되었을 때, 두 번째 심사대가 비어있게 된다. \n하지만, 여섯 번째 사람이 그 곳으로 이동하지 않고, \n1초를 더 기다린 다음에 첫 번째 심사대로 이동해서 심사를 받으면, \n모든 사람이 심사를 받는데 걸리는 시간이 28초가 된다. \n만약, 마지막 사람이 1초를 더 기다리지않고, \n첫 번째 심사대로 이동하지 않았다면, \n모든 사람이 심사를 받는데 걸리는 시간이 30초가 되게 된다.\n\n상근이와 친구들이 심사를 받는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 $N$과 $M$이 주어진다. ($1 ≤ N ≤ 100,000$, $1 ≤ M ≤ 1,000,000,000$)\n\n다음 $N$개 줄에는 각 심사대에서 심사를 하는데 걸리는 시간인 $Tk$가 주어진다. ($1 ≤ T_{k} ≤ 10^9$)\n\n### 출력\n\n첫째 줄에 상근이와 친구들이 심사를 마치는데 걸리는 시간의 최솟값을 출력한다.\n\n---\n\n## 풀이\n\n문제의 시간 제한은 1초이다.\n문제를 보면 최적화 문제로 보인다.\n그래서 주어진 사람 수에 대한 이미그레이션 심사를 하는 가장 최적의 시간을 구하라는 문제로 해석했다.\n입력으로 주어지는 개수는 최대값을 보면 $1,000,000,000$개이다.\n대충 어디에 정확히 사용할 지 모르지만 `long`으로 변수 초기화를 하면 될 것 같다는 생각을 했다.\n값이 많은 상태에서 최적화된 값을 도출하라는 문제의 특성을 보고 바로 이진 탐색을 이용하면 될 것 같았다.\n그리고 최솟값을 위한 최적화이기에 `Lower Bound`를 사용하면 될 것 같았다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Immigration {\n    private final long friends;\n    private final long[] times;\n\n    private Immigration (long friends, long[] times) {\n        this.friends = friends;\n        Arrays.sort(times);\n        this.times = times;\n    }\n\n    public static Immigration of (long friends, long[] times) {\n        return new Immigration(friends, times);\n    }\n\n    public long getMinimumTime () {\n        long left = 1;\n        long right = (long) times[times.length - 1] * friends;\n        long result = 0;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            long checked = 0;\n\n            for (long time : times) {\n                checked += mid / time;\n                if (checked >= friends) {\n                    break;\n                }\n            }\n\n            if (checked >= friends) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int checkpoints = Integer.parseInt(tokenizer.nextToken());\n        long friends = Long.parseLong(tokenizer.nextToken());\n\n        long[] times = new long[checkpoints];\n        for (int i = 0; i < checkpoints; i++) {\n            times[i] = Long.parseLong(reader.readLine());\n        }\n        reader.close();\n\n        long result =Immigration.of(friends, times).getMinimumTime();\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result + \"\\n\");\n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"입국심사 프로그래머스 입국심사 문제 n명이 입국심사를 위해 줄을 서서 기다리고 있습니다.\n각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다.\n한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다.\n가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다.\n하지만 더 빨리 끝나는 심사…","fields":{"slug":"/prog-immigration/"},"frontmatter":{"date":"January 20, 2025","title":"프로그래머스 입국심사","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 입국심사\n\n[프로그래머스 입국심사](https://programmers.co.kr/learn/courses/30/lessons/43238)\n\n### 문제\n\nn명이 입국심사를 위해 줄을 서서 기다리고 있습니다. \n각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.<br>\n\n처음에 모든 심사대는 비어있습니다. \n한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. \n가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. \n하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.<br>\n\n모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.<br>\n\n입국심사를 기다리는 사람 수 n, \n각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, \n모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.<br>\n\n#### 제한사항\n\n- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.\n- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.\n- 심사관은 1명 이상 100,000명 이하입니다.\n\n### 입출력\n\n| n  | times   | return |\n|:---|:--------|:-------|\n| 6  | [7, 10] | 28     |\n\n가장 첫 두 사람은 바로 심사를 받으러 갑니다.\n7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.\n10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.\n14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.\n20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고,\n1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.\n\n---\n\n## 풀이\n\n이 문제는 이진 탐색을 활용하여 해결할 수 했다. \n주어진 심사관들이 특정 시간 동안 처리할 수 있는 사람 수를 계산하고, \n이를 기준으로 심사 시간을 최소화하는 접근 방식으로 접근했다. \n먼저, 최소 시간은 1분, 최대 시간은 가장 느린 심사관이 모든 사람을 처리하는 데 걸리는 시간으로 설정하고 \n이 범위에서 이진 탐색을 진행했다. \n그리고 중간 시간(mid)을 계산한 뒤, \n각 심사관이 해당 시간 동안 처리할 수 있는 사람 수를 합산하여 총 처리 가능 인원을 구했다. \n만약 이 합계가 심사를 받아야 하는 사람 수(n) 이상이면 현재 시간이 가능하므로 최소 시간을 줄이기 위해 범위를 좁히고, \n그렇지 않으면 더 많은 시간이 필요하므로 범위를 늘려 나갔다. \n이러한 과정을 반복하면서 최소 시간을 갱신해 최적의 해를 찾아낼 수 있었다.\n\n\n```java\nimport java.util.*;\n\nclass Immigration {\n    private final int people;\n    private final int[] times;\n\n    private Immigration(int people, int[] times) {\n        this.people = people;\n        Arrays.sort(times);\n        this.times = times;\n    }\n\n    public static Immigration of (int people, int[] times) {\n        return new Immigration(people, times);\n    }\n\n    public long getMinScreeningTime() {\n        long left = 1;\n        long right = (long) times[times.length - 1] * people;\n        long result = 0;\n\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            long total = 0;\n            for (int time : times) {\n                total += mid / time;\n                if (isScreened(total, people)) {\n                    break;\n                }\n            }\n\n            if (isScreened(total, people)) {\n                result = mid;\n                right = mid -1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n\n    private boolean isScreened(long screenedPeople, long totalPeople) {\n        return Long.compare(screenedPeople, totalPeople) >= 0;\n    }\n}\n\nclass Solution {\n    public long solution(int n, int[] times) {\n        return Immigration.of(n, times).getMinScreeningTime();\n    }\n}\n```"},{"excerpt":"DFS와 BFS 백준 1260번 DFS와 BFS 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 315827 125581 74304 38.332% 문제 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오.\n단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고,\n더…","fields":{"slug":"/boj-1260/"},"frontmatter":{"date":"January 20, 2025","title":"1260 DFS와 BFS","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## DFS와 BFS\n[백준 1260번 DFS와 BFS](https://www.acmicpc.net/problem/2110)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 315827 | 125581 | 74304 | 38.332% |\n\n### 문제\n\n그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. \n단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, \n더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.\n\n### 입력\n\n첫째 줄에 정점의 개수 $N(1 ≤ N ≤ 1,000)$, $간선의 개수 M(1 ≤ M ≤ 10,000)$, \n탐색을 시작할 정점의 번호 V가 주어진다. \n다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. \n어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. \n입력으로 주어지는 간선은 양방향이다.\n\n### 출력\n\n첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. \nV부터 방문된 점을 순서대로 출력하면 된다.\n\n---\n\n## 풀이\n\n이 문제는 그래프를 DFS와 BFS로 탐색한 결과를 출력하는 문제이다.\nDFS와 BFS는 각각 스택과 큐를 활용하여 구현할 수 있으며,\n이를 위해 각 정점의 연결 정보를 저장하는 인접 리스트를 활용한다.\n먼저 DFS는 재귀 호출을 통해 구현하며, 방문한 정점을 스택에 저장하여\n스택이 빌 때까지 반복하여 탐색한다.\nBFS는 큐를 활용하여 구현하며, 방문한 정점을 큐에 저장하여\n큐가 빌 때까지 반복하여 탐색한다.\n\n\n```java\npackage test.code;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());//정점의 개수\n        int M = Integer.parseInt(tokenizer.nextToken());//간선의 개수\n        int V = Integer.parseInt(tokenizer.nextToken());//시작 정점\n\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            tokenizer = new StringTokenizer(reader.readLine());\n            int a = Integer.parseInt(tokenizer.nextToken());\n            int b = Integer.parseInt(tokenizer.nextToken());\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n\n        for (int i = 0; i <= N; i++) {\n            Collections.sort(graph.get(i));\n        }\n\n        boolean[] visited = new boolean[N+1];\n        dfs(graph, V, visited);\n\n        System.out.println();\n\n        bfs(graph, V);\n\n\n    }\n\n    private static void dfs(List<List<Integer>> graph, int V, boolean[] visited) {\n        visited[V] = true;\n        System.out.print(V + \" \");\n\n        for (int adjacent : graph.get(V)) {\n            if (!visited[adjacent]) {\n                dfs(graph, adjacent, visited);\n            }\n        }\n    }\n\n    private static void bfs(List<List<Integer>> graph, int V) {\n        boolean[] visited = new boolean[graph.size()];\n        Queue<Integer> queue = new LinkedList<>();\n\n        queue.add(V);\n        visited[V] = true;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            System.out.print(current + \" \");\n\n            for (int adjacent : graph.get(current)) {\n                if (!visited[adjacent]) {\n                    queue.add(adjacent);\n                    visited[adjacent] = true;\n                }\n            }\n        }\n    }\n}\n```"},{"excerpt":"공유기 설치 백준 2110번 공유기 설치 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 83981 30721 21201 37.071% 문제 도현이의 집 N개가 수직선 위에 있다.\n각각의 집의 좌표는  이고, 집 여러개가 같은 좌표를 가지는 일은 없다. 도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려…","fields":{"slug":"/boj-2110/"},"frontmatter":{"date":"January 19, 2025","title":"2110 공유기 설치","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 공유기 설치\n[백준 2110번 공유기 설치](https://www.acmicpc.net/problem/2110)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 83981 | 30721 | 21201 | 37.071% |\n\n### 문제\n\n도현이의 집 N개가 수직선 위에 있다. \n각각의 집의 좌표는 $x_{1}, ..., x_{N}$ 이고, 집 여러개가 같은 좌표를 가지는 일은 없다.<br>\n\n도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. \n최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, \n가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다. <br>\n\nC개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.<br>\n\n### 입력\n\n첫째 줄에 집의 개수 $N (2 ≤ N ≤ 200,000)$과 공유기의 개수 $C (2 ≤ C ≤ N)$이 하나 이상의 빈 칸을 사이에 두고 주어진다. \n둘째 줄부터 $N$개의 줄에는 집의 좌표를 나타내는 $x_{i} (0 ≤ x_{i} ≤ 1,000,000,000)$가 한 줄에 하나씩 주어진다.\n\n### 출력\n\n첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 집의 좌표가 주어졌을 때, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 값을 구하는 문제이다. \n접근 방식은 이진 탐색과 정렬을 활용하며, 먼저 집의 좌표를 정렬한 뒤 가능한 거리의 범위를 최소 거리와 최대 거리로 설정한다. \n이때 최소 거리는 항상 $1$, 최대 거리는 정렬된 좌표의 최댓값과 최솟값의 차이로 초기화한다. \n이진 탐색을 통해 현재 거리(`mid`)가 주어졌을 때,\n공유기를 설치할 수 있는지 판단하는 함수(`canInstall`)로 설치 가능한지 확인을 한다. \n이 함수는 첫 번째 집에 공유기를 설치한 후, \n현재 거리 조건을 만족하는 다음 위치에 공유기를 설치하며, \n이렇게 설치한 공유기의 수가 목표 개수 이상인지 확인한다. \n만약 설치 가능하다면 현재 거리를 결과로 저장하고 더 큰 거리를 탐색하며, \n불가능하다면 거리를 줄여 탐색을 계속한다. 최종적으로 이진 탐색이 종료되면, \n저장된 최대 거리를 출력하여 문제를 해결한다. \n이와 같은 방식은 정렬에 $(O(N \\log N)$, \n탐색에 $O(\\log(max\\_distance) \\times N)$이 소요된 시간복잡도를 가진다.\n\n\n```java\npackage test.code;\n\n\nimport java.io.*;\nimport java.util.*;\n\nclass House implements Comparable<House> {\n    private final long cooridnate;\n\n    private House (long cooridnate) {\n        this.cooridnate = cooridnate;\n    }\n\n    public static House of(long cooridnate) {\n        return new House(cooridnate);\n    }\n\n    @Override\n    public int compareTo(House other) {\n        return Long.compare(this.cooridnate, other.cooridnate);\n    }\n\n    public long minusTo(House other) {\n        return this.cooridnate - other.cooridnate;\n    }\n}\n\nclass RouterInstaller {\n    private final List<House> houses;\n    private final int routes;\n\n    private RouterInstaller(List<House> houses, int routes) {\n        Collections.sort(houses);\n        this.houses = houses;\n        this.routes = routes;\n    }\n\n    public static RouterInstaller of(List<House> houeses, int routes) {\n        return new RouterInstaller(houeses, routes);\n    }\n\n    private long getMaxDistance() {\n        long left = 1;\n        long right = houses.get(houses.size() - 1).minusTo(houses.get(0));\n        long result = 0;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n\n            if (canInstall(mid)) {\n                result = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    private boolean canInstall(long distance) {\n        int count = 1;\n        House lastInstalledHouse = houses.get(0);\n\n        for (int i = 1; i< houses.size(); i++) {\n            if (houses.get(i).minusTo(lastInstalledHouse) >= distance ) {\n                count++;\n                lastInstalledHouse = houses.get(i);\n                if (count >= routes) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public void printDistance() {\n        System.out.println(getMaxDistance());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int number = Integer.parseInt(tokenizer.nextToken());\n        int routes = Integer.parseInt(tokenizer.nextToken());\n        List<House> houses = new ArrayList<>();\n\n        for (int i = 0; i < number; i++) {\n            houses.add(House.of(Long.parseLong(reader.readLine())));\n        }\n\n        RouterInstaller.of(houses, routes).printDistance();\n    }\n}\n```"},{"excerpt":"SSD(Solid State Drive)는 HDD(Hard Disk Drive)에 비해 데이터 처리 속도가 빠르다.\n이로 인해 운영체제나 여러 프로그램의 성능 향상이 일반적이다.\n그렇다면 DBMS의 저장 매체를 HDD에서 SSD로 전환하면 DBMS의 속도도 빨라질까? 디스크 드라이브와 데이터 버퍼링 DBMS에서는 저장 매체를 SSD로 바꾸어도 성능이 큰 …","fields":{"slug":"/database-ssd-faster-than-hdd/"},"frontmatter":{"date":"January 17, 2025","title":"SSD를 사용하면 DBMS가 빨라질까?","tags":["Database"]},"rawMarkdownBody":"\nSSD(Solid State Drive)는 HDD(Hard Disk Drive)에 비해 데이터 처리 속도가 빠르다.\n이로 인해 운영체제나 여러 프로그램의 성능 향상이 일반적이다.\n그렇다면 DBMS의 저장 매체를 HDD에서 SSD로 전환하면 DBMS의 속도도 빨라질까?\n\n## 디스크 드라이브와 데이터 버퍼링\n\nDBMS에서는 저장 매체를 SSD로 바꾸어도 성능이 큰 폭으로 개선되지 않을 수 있다.\n그 이유는 DBMS의 데이터 버퍼링(페이지 버퍼링) 기능 때문이다.\n데이터 버퍼링은 데이터의 지역성이 높은 경우(같은 데이터나 인접한 데이터에 자주 접근하는 경우) \n메모리에 데이터를 미리 저장하여 디스크 I/O를 줄이는 캐시 시스템으로,\n이를 통해 저장 매체의 I/O를 줄일 수 있다.\n즉, 데이터 버퍼링 같은 캐시 시스템의 히트율(hit ratio)이 높은 환경인 경우라면\n저장 매체의 I/O 실행 성능이 상대적으로 중요하지 않게 되는 것이다.\n\n그래서 HDD를 SSD로 바꾸어 DBMS의 성능 향상 효과를 기대하려면\nDBMS의 데이터 버퍼링이 효율적으로 동작하고 있는지 파악한 이후에 결정하는 것을 권장한다.\n이유는 위에서 언급했듯이 저장 매체를 SSD로 변경하지 않고 데이터 버퍼링을 효율적으로 관리하면\n충분히 DBMS의 성능 향상을 기대할 수 있기 때문이다.\n\n그럼 저장 매체를 SSD로 변경하는 것이 DBMS의 성능 향상에 도움이 되지 않는가?\n이를 알아보기 위해 먼저 디스크 드라이브와 데이터 버퍼링의 관계에 대해 알아야 한다.\n\n## HDD의 구조와 I/O 특성\n\nHDD는 플래터(회전하는 자기 디스크)에 데이터를 기록한다.\nHDD에는 여러 개의 플래터가 있는데, 이 플래터는 각각 독립적으로 회전하는 것이 아니라 동시에 모두 회전한다.\n다음 그림에서 보듯이 플래터의 중심을 중점으로 하는 동심원을 트랙이라고 한다.\n그리고 여러 플래터에서 같은 위치의 트랙을 실린더라고 한다.\n이 플래터에 자기 정보를 읽고 쓰는 것을 헤드라고 하는데 \n플래터 양면에 정보를 기록할 수 있기 때문에 각각의 플래터마다 두 개의 헤드가 있다.\n그리고 헤드는 디스크 암의 끝에 위치한다.\n\n![HDD의 구조](img.png)\n\n데이터는 빠르게 회전하는 플래터의 실린더에 순차적으로 블록 단위로 기록된다.\n그래야 연속된 데이터를 한 번의 이동(플래터 회전과 디스크 암 이동)으로 읽을 수 있기 때문이다.\n그래서 HDD의 I/O 시간이란 `디스크 암이 해당 실린더까지 이동하는 시간인 seek time`과\n`플래터가 해당 블록(섹터)까지 회전하는 retional latency`, 그리고\n`헤드가 데이터를 읽거나 쓰는 시간인 data transfer time`을 모두 합이라고 말할 수 있다.\n\n![HDD 내부](img_1.png)\n\n여기서 data transfer time 보다 seek time과 rotational latency가 더 크기 때문에\n(약 10배 이상, seek >> rotational latency > data transfer),\nHDD의 성능을 최적화하려면 이 두 가지를 줄이는 것이 중요하다.\n이를 위해 운영체제는 이러한 헤드의 이동과 플래터의 회전을 최소화하기 위해 최적화 스케줄링(I/O Scheduling) 방식을 사용한다.\n\n하지만 애플리케이션은 운영체제에 빈번하게 I/O 요청하고 운영체제 입장에서는 이러한 시기를 예측할 수 없기 때문에 \n언제나 I/0 스케줄링의 효과를 기대하기 어렵다.\n예를 들어 애플케이션이 `데이터를 적게 읽고 쓰는 대용량의 요청`을 하기보다\n`작은 크기의 데이터를 빈번하게 읽고 쓰는 요청`을 하는 패턴이라면  \n운영체제의  I/O 스케줄링의 효과가 제한적일 수 있다.\n\n## SSD의 구조와 I/O 특성\n\nSSD는 HDD와 달리 회전 디스크나 이동하는 물리적 헤드가 없고, 플래시 메모리(flask memory)를 저장 매체로 사용하는 디스크이다.\n플래시 메모리는 전자적으로 메모리의 내용을 읽는 것 외에, 프로그래밍(write)하거나 초기화(erase)할 수 있는 EEPROM의 일종이다.\n\n![SSD 내부](img_2.png)\n\nHDD는 헤드가 데이터를 읽는 시간과 쓰는 시간이 거의 비슷한 반면에 SSD는 읽기 성능과 쓰기 성능이 다르다.\n보통 페이지를 읽는 시간(read time)이 수백 ns 수준이라면,\n페이지를 쓰는 시간(write time)은 us 단위이고, 초기화(erase)하는 시간은 ms 단위이다.\n\n초기화는 한 영역에 대해서 동시에 진행하기 때문에 칩 전체를 초기화하거나 몇몇 페이지를 초기화하거나\n보통 동일한 시간이 소요된다.\n그래서 일반적으로 여러 페이지의 묶음인 섹터나 블록 단위로 초기화를 수행하도록 구성한다.\n\n플래시 메모리의 특성상 섹터 당 초기화 횟수에 한계(보통 수만~수십만 정도)가 있다.\n그래서 FAT에서 처럼 특정 부분이 자주 갱신되는 경우가 없도록,\n논리 블록 주소에 대한 물리 블록 주소를 다르게 매핑하여 각 섹터별 초기화 횟수가 고르게 되도록 한다.\n이러한 방법을 wear leveling이라고 한다.\n\n이러한 특성들 때문에 SSD의 I/O 특성은 HDD와 다르다.\n\n읽기의 경우에는 HDD와 다르게 seek time, rotational latency가 없이 data transfer time만 소요되기 때문에,\nrandom read에서도 일정한 응답 속도가 보장된다.\n그러나 쓰기의 경우에는 wear leveling을 진행하다 비어 있는 공간이 없으면 섹터 단위로 초기화하게 되고 이 작업 동안 해당 섹터에 대한\nI/O 요청 작업이 모두 대기 상태가 된다.\n\n## DBMS의 데이터 버퍼\n\nDBMS의 데이터 버퍼는 메모리 기반 캐시로, 디스크 I/O를 최소화하여 성능을 높인다.\n메모리가 디스크 드라이브에 비해 빠르고, 최근에 자주 사용된 데이터를 메모리에 저장하여,\n디스크 드라이브에 접근이 아닌 메모리에 접근하도록 한 것이다.\n\nDBMS의 데이터 버퍼는 일반적으로 LRU(Least Recently Used) 알고리즘을 기반으로 사용하고 있지만,\nhot zone과 cold zone을 분리하여 LRU 관리 비용을 줄이는 방법도 있다.\n\nDBMS의 I/O 요청에 대한 전체 처리 시간은 다음과 같이 표현할 수 있다.\n\n$$Total Access Time = A \\cdot HR + B \\cdot (1 - HR)$$\n\n각 항의 의미는 다음과 같다.\n\n- $A$: 메모리 접근(Access) 시간\n- $B$: 스토리지의 평균 접근(Access) 시간\n- $HR$: 버퍼의 히트율\n\n 전체 처리 시간이 위와 같이 때문에 HDD와 SSD의 처리 시간 차이인 $B \\cdot (1 - BR)$의 히트율이 클수록 차이가 줄어든다.\n일반적인 데이터 버퍼 히트율은 90% 이상으로, 디스크의 성능 차이가 DBMS의 성능에 미치는 영향은 상대적으로 작다.\n\n## 데이터 버퍼 설정에 따른 HDD와 SSD의 성능 비교 실험\n\n데이터 버퍼와 저장매체의 변경에 따른 DBMS의 성능변화를 시험한 사례를 보겠다.\n시험은 나머지 사양은 동일하고 저장 매체로 HDD와 SSD를 사용하는 두 DBMS에 대해\n데이터 버퍼의 크기를 2GB에서 12GB까지 1GB 단위로 변경하며\nHDD와 SSD 환경에서 TPS(Transactions Per Second), 히트율, I/O 요청 횟수를 측정했다.\n\n### 실험 환경\n\n사용한 DBMS 서버 사양은 다음과 같다.\n\n- CPU: Xeon® CPU L5650 (2.27GHz 2*6 cores)\n- Memory: 16GB \n- HDD: 300GB * 2 \n- SSD: 64GB * 4 \n- OS: CentOS 5.3 x86_64 \n- DBMS: CUBRID 2008 R4.1 (8.4.1.0516) (64bit release build for linux_gnu)\n- TOOL: Yahoo! YCSB (Latest 분포 사용)\n\n> YCSB는 Yahoo!에서 클라우드 서비스의 스토리지를 벤치마킹하기 위해 개발한 도구로, 쿼리 패턴이나 분포를 설정하여 분석할 수 있다.\n\n### 실험 방법\n\n실험은 HDD와 SSD 환경에서 데이터 버퍼 크기를 2GB에서 12GB까지 1GB 단위로 변경하며\nTPS(Transactions Per Second), 히트율, I/O 요청 횟수를 측정했다.\n\n### 실험 결과\n\n실험을 통해 다음과 같은 결과를 얻었다.\n\n#### TPS 추이\n\n먼저 TPS 추이 그래프는 다음과 같다.\n\nDBMS의 데이터 버퍼가 커질수록 SSD, HDD의 TPS가 모두 증가하는 것을 확인한다.\n상대적으로 HDD가 더 느리기 때문에 HDD에서 페이지 버퍼 크기를 늘릴수록 TPS가 증가하는 것이 눈에 띄게 확인할 수 있다.\n\nSSD의 그래프는 2GB에서 4GB까지 구간의 결과를 제외하면 단순 비례 관계를 보여 준다.\n반면 HDD의 그래프는 10GB 부근에서 변곡점이 있는 S자형 곡선을 보이며 성능 증가 폭이 감소한 것을 볼 수 있다.\n\n![데이터 버퍼 크기에 따른 TPS 추이](img_3.png)\n\n#### I/O 요청 처리 추이\n\n다음 그림은 DBMS가 운영체제에 요청한 I/O 요청 추이를 나타낸 것으로,\nI/O 요청의 결과는 SSD를 사용했을 때는 버퍼 크기가 증가할수록 I/O 요청 횟수가 지수적으로 감소하는 형태를 띄고 있다.\n반면 HDD의 경우에는 TPS의 그래프와 유사하게 6GB에서 10GB까지 구간에서 급감하다가, I/O 처리 한계에 도달하여 성능 정체 현상을 보이고 있다.\n\n![데이터 버퍼 크기에 따른 I/O 요청 처리 횟수 추이](img_4.png)\n\n#### 데이터 버퍼 히트율 추이\n\nDBMS의 데이터 버퍼에 대한 히트율 그래프는 다음과 같다.\n동일한 분포로 실험했기 때문에 SSD와 HDD의 히트율은 동일한 패턴을 보인다.\n히트율은 동일하지만 처리 속도 차이 때문에 I/O 요청은 위에 I/O 요청 처리 추이 그래프 처럼 다른 양상을 보인다.\n\n그래프 패턴은 100%를 접선으로 하는 지수적 증가 형태로, 버퍼 크기가 커질수록 기울기가 완만해지는 것을 확인할 수 있다.\n\n\n![데이터 버퍼 크기에 따른 히트율 추이](img_5.png)\n\n### 결과 분석\n\n실험 결과와 같이 DBMS의 성능의 핵심은 데이터 버퍼의 히트율에 달려 있다.\n그렇기 때문에 DBMS의 성능을 향상시키는 데에는 데이터 버퍼가 충분한 히트율을 유지라도록 관리하는 것이 중요하다.\n\n데이터 버퍼가 주요 워킹셋(자주 사용하는 데이터 집합)을 충분히 포함할 수 있도록 적정한 크기를 유지해야 한다.\n이 방법으로도 만족할 만한 히트율을 유지하지 못하게 되었을 때는 성능을 일정 수준 이상 유지하기 위해 SSD 도입을 고려할 수 있다.\nSSD는 HDD보다 Random Read 성능이 뛰어나므로, 버퍼 미스가 발생하더라도 HDD에 비해 성능 저하를 최소화할 수 있다.\n\n이 결론에 따라 실험 결과를 다시 자세히 분석해 본다.\n\n위의 실험 결과를 종합해서 보면 히트율은 8GB 부분부터 완만해지기 시작하나 \nTPS는 오히려 기울기가 커지다 10GB 부근에서 급격히 감소하는 것을 확인할 수 있다.\n결국 8GB에서 10GB 사이 부근에서 데이터 버퍼의 비용 대비 성능 향상이 가장 크다는 것을 알 수 있다.\n이런 환경에서는 데이터 버퍼를 10GB 수준으로 증설하는 것이 저장 매체를 SSD로 변경하는 것보다 \n비용에 대비해 성능을 더 효율적으로 향상시킬 수 있다.\n\n## 참고\n\n[Hard disk drive](https://en.wikipedia.org/wiki/Cylinder-head-sector)\n"},{"excerpt":"두 용액 백준 2470번 두 용액 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 69612 22739 16419 31.602% 문제 KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다.\n각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.\n산성 용액의 특성값은 1부터 1,000,00…","fields":{"slug":"/boj-2470/"},"frontmatter":{"date":"January 17, 2025","title":"2470 두 용액","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 두 용액\n[백준 2470번 두 용액](https://www.acmicpc.net/problem/2470)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 128 MB | 69612 | 22739 | 16419 | 31.602% |\n\n### 문제\n\nKOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. \n각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. \n산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.<br>\n\n같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. \n이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.<br>\n\n예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 \n특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, \n이 용액이 특성값이 0에 가장 가까운 용액이다. \n참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.<br>\n\n산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, \n이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.<br>\n\n### 입력\n\n첫째 줄에는 전체 용액의 수 N이 입력된다. \nN은 2 이상 100,000 이하이다. \n둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. \n이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. \nN개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.\n\n### 출력\n\n첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. \n출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. \n특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 특성값이 주어진 용액들의 배열에서 두 용액의 합이 0에 가장 가까운 조합을 찾는 것으로, \n정렬과 투 포인터(two pointers) 알고리즘을 활용해 효율적으로 해결한다. \n먼저 입력된 용액 배열을 오름차순으로 정렬하여 값의 크기 순서를 보장한 후, \n배열의 양 끝에서 시작하는 두 포인터를 사용해 합을 계산한다. \n합이 음수면 왼쪽 포인터를 증가시켜 더 큰 값을 탐색하고, \n양수면 오른쪽 포인터를 감소시켜 더 작은 값을 탐색하며, \n각 단계에서 0에 가장 가까운 합을 갱신한다. \n이를 위해 `Liquid`와 `Liquids`라는 두 개의 클래스를 설계하여 데이터를 추상화하고, 각 클래스에 책임을 명확히 분배했다. \n`Liquid` 클래스는 용액의 특성값과 관련된 단일 값 동작(sum, compareTo)을 담당하며, \n`Liquids` 클래스는 모든 용액의 정렬 및 최적 조합을 찾는 논리를 포함한다. \n\n```java\npackage test.code;\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nclass Liquid implements Comparable<Liquid> {\n    private final long value;\n\n    private Liquid (long value) {\n        this.value = value;\n    }\n\n    public static Liquid of (long value) {\n        return new Liquid(value);\n    }\n\n    @Override\n    public int compareTo(Liquid other) {\n        return Long.compare(this.value, other.value);\n    }\n\n    public long sum(Liquid other) {\n        return Long.sum(this.value, other.value);\n    }\n\n    @Override\n    public String toString() {\n        return String.valueOf(value);\n    }\n}\n\nclass Liquids {\n    private final List<Liquid> liquids;\n\n    private Liquids (List<Liquid> liquids) {\n        this.liquids = liquids;\n        Collections.sort(this.liquids);\n    }\n\n    public static Liquids of(List<Liquid> liquids) {\n        return new Liquids(liquids);\n    }\n\n    public void printPair() {\n        Liquid[] liquidsPair = getPair();\n        System.out.println(liquidsPair[0] + \" \" + liquidsPair[1]);\n    }\n\n    private Liquid[] getPair() {\n        int left = 0;\n        int right = liquids.size() - 1;\n        long min = Long.MAX_VALUE;\n        Liquid[] pair = new Liquid[2];\n        while (left < right) {\n            Liquid leftLiquid = liquids.get(left);\n            Liquid rightLiquid = liquids.get(right);\n            long sum = leftLiquid.sum(rightLiquid);\n\n            if (isOptimal(sum, min)) {\n                min = sum;\n                pair[0] = leftLiquid;\n                pair[1] = rightLiquid;\n            }\n\n            if (sum < 0) {\n                left++;\n            } else if (sum > 0){\n                right--;\n            } else {\n                break;\n            }\n        }\n        return pair;\n    }\n\n    private boolean isOptimal(long sum, long min) {\n        return Math.abs(sum) < Math.abs(min);\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int number = Integer.parseInt(reader.readLine());\n\n        List<Liquid> liquidList = Arrays.stream(reader.readLine().split(\" \"))\n                .map(Long::parseLong)\n                .map(Liquid::of)\n                .collect(Collectors.toList());\n\n        Liquids.of(liquidList).printPair();\n    }\n}\n```"},{"excerpt":"HDD와 SSD CPU의 처리 속도와 RAM과 같은 전기적인 원리로 동작하는 메모리의 I/O 속도는 지속적으로 빠르게 발전해왔다.\n반면, 디스크와 같은 기계적 장치는 CPU나 RAM에 비해 발전 속도가 상대적으로 제한적이었다.\n특히 HDD는 마치 LP판과 유사한 원리로 동작한다.\n디스크 헤드가 특정 위치로 이동해 플래터(원판)를 회전시키며 데이터를 읽거나…","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"date":"January 16, 2025","title":"저장 매체와 랜덤 I/O, 순차 I/O","tags":["Database","Index"]},"rawMarkdownBody":"\n## HDD와 SSD\n\nCPU의 처리 속도와 RAM과 같은 전기적인 원리로 동작하는 메모리의 I/O 속도는 지속적으로 빠르게 발전해왔다. \n반면, 디스크와 같은 기계적 장치는 CPU나 RAM에 비해 발전 속도가 상대적으로 제한적이었다. \n특히 HDD는 마치 LP판과 유사한 원리로 동작한다. \n디스크 헤드가 특정 위치로 이동해 플래터(원판)를 회전시키며 데이터를 읽거나 쓰는 방식으로 작동하기 때문에 속도가 느릴 수밖에 없다. \n이를 보완하기 위해 플래시 메모리를 활용한 SSD가 등장했으며, SSD는 HDD에 비해 훨씬 빠른 속도를 제공한다.\n\n## 컴퓨터 컴포넌트별 IOPS 비교\n\nHDD와 메모리 간의 I/O 속도 차이는 약 10만 배에 달한다. \n반면, SSD는 플래시 메모리를 사용하여 메모리와의 속도 차이를 약 1,000배 수준으로 줄였다. \n특히 순차 I/O의 경우 SSD는 HDD보다 약간 빠른 수준이지만, 랜덤 I/O에서는 SSD가 HDD에 비해 월등히 우수하다. \n이는 대부분의 DBMS I/O가 랜덤 I/O로 발생하기 때문에 중요하다.\n\n책 *Real MySQL 8.0*에 따르면, HDD와 SSD를 비교했을 때 초당 트랜잭션 처리 성능은 SSD가 HDD 대비 약 7배 높은 성능을 보인다. \n이러한 이유로 최근 DBMS 서버는 대부분 SSD를 채택하고 있다.\n\n## DBMS에서 SSD와 HDD의 성능 차이가 설계 및 운영에 미치는 영향\n\nSSD의 도입은 데이터베이스 설계 및 운영 방식에 큰 변화를 가져왔다. \n과거 HDD 기반 환경에서는 디스크 I/O의 높은 지연 시간 때문에 디스크 접근을 최소화하는 설계가 필수적이었다. \n이를 위해 인덱스 최적화, 데이터 압축, 파티셔닝 등 다양한 기법이 활용되었다. \n반면 SSD는 훨씬 빠른 I/O 성능을 제공하므로, 일부 설계 요소를 단순화하거나, 데이터 중복을 허용하여 읽기 성능을 극대화하는 전략이 가능하다.\n\n또한 SSD는 랜덤 I/O 성능이 뛰어나므로, 데이터 분산 및 샤딩 전략에서 물리적 연속성을 고려할 필요가 적어졌다. \n하지만 SSD도 무한한 성능을 제공하는 것은 아니며, 특히 쓰기 성능 저하와 셀 마모 문제가 있기 때문에 로그 쓰기 또는 캐싱 전략을 통해 SSD 수명을 최적화해야 한다.\n\n## 랜덤 I/O와 순차 I/O\n\n랜덤 I/O는 읽어야 할 데이터가 물리적으로 불연속적인 위치에 있을 때 발생하며, 디스크 헤더를 여러 번 이동시키면서 데이터를 읽는다. \n이 과정에서 디스크 헤더의 이동 시간, 즉 Seek Time이 성능에 큰 영향을 미친다. \n반면, 순차 I/O는 데이터가 물리적으로 연속적으로 저장된 경우에 발생하며, 디스크 헤더를 이동시키지 않고 데이터를 읽을 수 있다. \n따라서 디스크의 성능은 순차적으로 데이터를 저장하고 읽는 능력에 크게 좌우된다.\n\nSSD는 디스크 원판이 없기 때문에 랜덤 I/O와 순차 I/O 간의 성능 차이가 적을 것처럼 보이지만, SSD에서도 랜덤 I/O는 순차 I/O에 비해 처리율(throughput)이 떨어지는 경향이 있다.\n\n## SSD 내부에서 랜덤 I/O 성능이 순차 I/O보다 떨어지는 이유\n\nSSD 내부 구조는 플래시 메모리 셀로 구성되어 있으며, 데이터는 페이지 단위로 읽고 블록 단위로 쓰인다. \n랜덤 I/O가 순차 I/O보다 느린 이유는 크게 두 가지로 나뉜다. \n첫째, SSD의 내부 컨트롤러는 데이터의 위치를 추적하기 위해 논리적 블록 주소(LBA)와 실제 물리적 주소를 매핑하는 작업을 수행해야 한다. \n랜덤 I/O가 많아질수록 이 매핑 테이블의 참조와 갱신 빈도가 증가하면서 컨트롤러의 부하가 커진다.\n\n둘째, SSD는 데이터 쓰기 시 기존 데이터를 직접 덮어쓰지 못하고, 새로운 블록에 데이터를 기록한 뒤 가비지 컬렉션(Garbage Collection)을 통해 이전 블록을 정리하는 방식으로 동작한다. \n랜덤 I/O가 많을수록 이 과정에서 비효율이 발생하며, 특히 여러 블록에 분산된 데이터를 처리할 경우 병목현상이 심화된다.\n\n\n## DBMS에서 I/O 최적화의 중요성\n\nDBMS는 디스크에 데이터를 빈번히 읽고 쓰는 작업을 수행하기 때문에, MySQL 서버는 그룹 커밋, 바이너리 로그, InnoDB 로그 버퍼 등 다양한 최적화 기능을 내장하고 있다. \n쿼리를 튜닝한다고 해서 랜덤 I/O가 순차 I/O로 변하는 일은 흔하지 않다. \n따라서 쿼리 튜닝의 목적은 랜덤 I/O를 줄이고 꼭 필요한 데이터만 읽도록 개선하는 데 있다.\n\n인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용한다. \n큰 테이블에서 많은 데이터를 읽어야 할 경우, 옵티마이저가 인덱스 사용 대신 풀 테이블 스캔을 유도하는 전략을 선택할 수도 있다. \n이러한 상황에서는 쿼리 성능 최적화를 통해 불필요한 랜덤 I/O를 줄이는 것이 중요하다.\n"},{"excerpt":"인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다. 물론 인덱스가 없는 데이터…","fields":{"slug":"/database-index/"},"frontmatter":{"date":"January 16, 2025","title":"인덱스(Index)","tags":["Database","Index"]},"rawMarkdownBody":"\n인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다.\n\n물론 인덱스가 없는 데이터베이스에서도 데이터를 조회할 수 있지만, 데이터베이스의 크기가 크면 클수록 인덱스가 필요해진다.\n인덱스는 데이터베이스의 크기가 커져도 빠르게 데이터를 조회할 수 있도록 도와준다.\n\n> 그럼 모든 컬럼에 인덱스를 걸면 좋을까? 아니다.\n> 인덱스를 효율적으로 사용한다면 매우 빠른 데이터 조회가 가능하고, 쿼리의 부하가 줄어들어 데이터베이스의 성능을 향상시킬 수 있지만,\n> 인덱스 역시 하나의 데이터 덩어리이기 때문에 적절한 인덱스를 사용하지 않으면 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n\n> 그럼 어떤 기준으로 인덱스를 설정해야할까?\n> 검색 조건에 주로 사용되고 카디널리티가 높은 컬럼을 인덱스로 설정하면 좋다.\n> 카디널리티는 인덱스에 해당하는 컬럼 기준으로 테이블에서 유일한 레코드 개수를 의미한다.\n> 카디널리티가 높을 컬럼에 인덱스를 걸면 그만큼 검색 대상이 줄어들기 때문에 빠르게 레코드에 접근할 수 있다.\n\n때문에 인덱스를 효율적으로 사용하기 위해서는 인덱스의 동작 방식과 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.\n\n## 인덱스 알고리즘\n\n인덱스 알고리즘은 B-Tree와 Hash Index으로 분류하여 구분할 수 있다. \n이 중에서도 B-Tree 알고리즘은 Balanced Tree 알고리즘으로, 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.\n인덱스는 이러한 B-Tree 알고리즘을 사용하며 데이터가 정렬된 상태를 유지한다.\n때문에 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다.\n\n> 트리의 높이가 다른 경우 차이가 발생할 수 있지만, 일반적으로 B-Tree는 O(logN)의 시간복잡도를 가진다.\n\n### B-Tree\n\nMySQL에서 사용하는 인덱스 알고리즘으로, 별다른 데이터의 변형을 가하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.\nB-Tree는 최상위에 하나의 루트 노드가 있고, 그 아래에 여러 개의 브랜치 노드가 있으며, 가장 하위에는 리프 노드가 있는 형태이다.\n\n해당 알고리즘의 장점은 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다는 것이다.\n하지만 어떤 데이터를 조회를 하더라도 루트 노드부터 리프 노드까지 탐색해야하기 때문에,\n데이터가 적은 테이블의 경우에는 인덱스를 사용하지 않는 것이 더 빠를 수 있다.\n\n### B+Tree\n\nB+Tree는 B-Tree의 변형 알고리즘으로, B-Tree와 달리 리프 노드가 연결 리스트로 연결되어 있다.\n또한 리프 노드에만 데이터가 저장되어 있고, 브랜치 노드에는 데이터가 저장되어 있지 않다.\n이러한 구조로 인해 범위 검색에 특화되어 있으며, 데이터베이스에서 범위 검색이 많은 경우에 사용된다.\n\n해당 알고리즘의 장점으로는 범위 검색에 특화되어 있어, 범위 검색이 많은 데이터베이스에서 빠른 검색 속도를 가진다.\n또한 리프 노드가 연결 리스트로 연결되어 있기 때문에 범위 검색을 할 때, 리프 노드를 순회하면 되기 때문에 빠른 검색 속도를 가진다.\n그러나 B-Tree에 비해 높이가 더 높아져서, B-Tree보다 더 많은 블록을 읽어야 한다.\n또한, 리프 노드가 연결 리스트로 연결되어 있기 때문에, 범위 검색이 아닌 동등 비교 검색에는 B-Tree보다 느릴 수 있다.\n\n### Hash Index\n\nHash Index 알고리즘은 데이터를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하는 알고리즘이으로, 특히 동등 비교 검색에 특화되어 있다.\n하지만 값을 해시값으로 변환하기 때문에 범위 검색이나 정렬된 데이터를 조회하는데는 적합하지 않다.\n주로 인메모리 데이터베이스에서 사용되는 인덱스 알고리즘이다.\n\n> 인메모리 데이터베이스는 데이터를 메모리에 저장하고, 디스크에 저장하지 않는 데이터베이스이다. 예를 들어 Redis가 있다.\n\n이러한 해시 인덱스의 장점으로는 실제 키 값과는 관계없이 해시값을 통해 데이터를 저장하기 때문에 데이터의 길이에 상관없이 일정한 시간복잡도를 가진다.\n그래서 타 인덱싱 알고리즘에 비해 빠른 검색 속도를 가진다.\n그러나 해시 인덱스는 각 해쉬값에 주소값을 지정하는 인덱스의 특성상, 범위로 조회하는 쿼리에는 적합하지 않다.\n또한 데이터베이스의 크기가 커질수록 충돌이 발생할 확률이 높아지기 때문에, 충돌을 해결하는 방법이 필요하다.\n\n## 인덱스 타입\n\n인덱스의 타입은 크게 클러스터 인덱스와 세컨더리 인덱스로 나눌 수 있다.\n클러스터 인덱스는 처음부터 정렬된 상태로 데이터가 저장되는 인덱스이며, 세컨더리 인덱스는 정렬되지 않은 상태로 데이터가 저장되는 인덱스이다.\n영어사전을 예로 들면, 영어사전의 알파벳 순으로 정렬된 상태를 클러스터 인덱스라고 할 수 있고,\n영어사전의 단어가 추가되는 순서대로 저장된 상태를 세컨더리 인덱스라고 할 수 있다.\n\n각 인덱스의 특징에 따라 사용하는 경우가 다르다.\n\n### 클러스터 인덱스\n\nMySQL의 InnoDB 엔진은 기본적으로 클러스터 인덱스로 저장되는데,\n클러스터 인덱스는 기본키가 비슷한 레코드끼리 묶어서 인접한 물리적 위치에 저장하는 것을 뜻한다.\n그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬되어 저장되기 때문에, 기본키 기반 검색이 매우 빠르다.\n하지만, 이러한 정렬 방식 때문에 이미 대용량의 데이터가 저장된 상태라면 인덱스 생성은 시스템 부하를 일으킬 수 있다.\n\n클러스터 인덱스는 한 개의 테이블에 하나만 생성할 수 있으며, 기본키에 대해서만 생성할 수 있다.\n\n> MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, \n> 없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지않는 컬럼을 만들어 Clustered Index로 지정한다.\n\n### 세컨더리 인덱스\n\n세컨더리 인덱스는 논 클러스터 인덱스(Non-Clustered Index)라고도 불린다.\n클러스터 인덱스와는 다르게 후보키 기반으로 생성되는 인덱스로, 기본키와는 별개로 생성된다.\n세컨더리 인덱스 생성 시에는 데이터 페이지는 정렬되지 않은 상태에서 별도의 인덱스 페이지에 인덱스가 생성된다.\n별도의 인덱스 페이지에 인덱스가 생성하여 구성하기 때문에 클러스터와는 달리 자동 정렬을 하지 않는다.\n때문에 클러스터형 보다 느리게 검색되지만, 데이터 삽입, 수정, 삭제에 대한 부하가 적다.\n\n> 세컨더리 인덱스는 여러 개 생성할 수 있으나, 이를 남용할 경우 오히려 성능이 저하될 수 있다.\n\n### 클러스터 + 세컨더리 인덱스\n\n클러스터 인덱스와 세컨더리 인덱스를 함께 사용하는 방법도 있다.\n클러스터 인덱스는 기본키 기반 검색에 특화되어 있고, 세컨더리 인덱스는 범위 검색에 특화되어 있기 때문에,\n클러스터 인덱스와 세컨더리 인덱스를 함께 사용하면 더 빠른 검색 속도를 가질 수 있다.\n\n> 클러스터 인덱스와 세컨더리 인덱스를 함께 사용할 경우, 세컨더리 인덱스는 클러스터 인덱스를 참조하는 형태로 사용된다.\n\n\n\n\n"},{"excerpt":"데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다.\n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다. 인덱스 스캔 방식 인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은…","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"date":"January 16, 2025","title":"실행 계획과 쿼리 최적화","tags":["Database","Index"]},"rawMarkdownBody":"\n데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다. \n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다.\n\n### 인덱스 스캔 방식\n\n인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은 MySQL을 기준으로 설명하였다).\n\n#### 인덱스 레인지 스캔(Index Range Scan)\n인덱스 레인지 스캔은 특정 범위 내의 데이터를 검색할 때 사용된다.\n이는 일반적으로 `WHERE` 절에 `BETWEEN`, `IN`, `>`, `<` 등의 연산자가 사용될 때 발생한다.\nMySQL은 루트 노드에서 시작하여 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾은 후, \n리프 노드 간의 링크를 따라 검색 종료점 리프 노드 까지 데이터를 스캔한다.\n이때 레코드를 랜덤 엑세스로 읽어 들이게 된다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 레인지 스캔이 발생한다.\n\n```sql\nSELECT * FROM users WHERE age BETWEEN 20 AND 30;\n```\n\n이 쿼리는 `users` 테이블에서 `age` 컬럼에 인덱스가 걸려 있다면, 해당 범위 내의 데이터를 효율적으로 검색할 수 있다. \n\n#### 인덱스 풀 스캔(Index Full Scan)\n인덱스 풀 스캔은 인덱스의 처음부터 끝까지 전체를 스캔하는 방식이다.\n이는 `WHERE` 절에 조건에서 인덱스의 특정 순서를 활용할 필요가 없거나, 범위가 명확하지 않은 조건에서 발생한다.\n인덱스 풀 스캔은 레인지 스캔에 비해 더 많은 블록을 읽어야 하기 때문에, 레인지 스캔보다 느릴 수 있다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 풀 스캔이 발생한다.\n\n```sql\nSELECT * FROM users WHERE job = 'developer';\n```\n\n`users` 테이블에서 `job` 컬럼에 인덱스가 존재하지만, 검색 조건이 인덱스의 순서를 활용하지 못하는 경우, 인덱스 풀 스캔이 발생한다.\n\n\n## 인덱스 설계\n\n인덱스의 스캔 방식과에 대해 알아봤다면, 이젠 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.\n\n### 효율적인 인덱스 설계\n\n다음은 효율적인 인덱스 설계를 위한 몇 가지 팁이다.\n\n- `WHERE` 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.\n- `SELECT` 절에 자주 사용되는 컬럼들을 조합해서 인덱스로 만들어 커버링 인덱스를 사용하는 것이 좋다. \n- `JOIN` 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.\n- `ORDER` BY 절에 자주 사용되는 컬럼에 클러스터형 인덱스를 사용하는 것이 좋다.\n\n### 지양해야할 인덱스 설계\n\n다음은 지양해야할 인덱스 설계를 위한 몇 가지 팁이다.\n\n- 대용량 데이터가 자주 입력되는 경우 클러스터형 인덱스의 페이징이 빈번하게 발생해 시스템에 부하가 걸릴 수 있다. 때문에 클러스터 대신 세컨더리 인덱스를 사용하는 것이 좋을 수 있다.\n- 데이터 중복도가 높은 컬럼에 인덱싱을 하는 것은 효율적이지 않다. 중복도가 높은 컬럼에 인덱싱을 하게 되면 인덱스의 크기가 커지고, 인덱스를 탐색하는데 시간이 오래걸릴 수 있다.\n- 인덱스를 많이 사용하게 되면 인덱스를 관리하는데 시간이 오래걸리게 되고, 인덱스의 크기가 커지게 된다. 때문에 인덱스를 많이 사용하는 것은 지양해야한다.\n- 자주 사용되지 않는 컬럼에 인덱싱을 하는 것은 효율적이지 않다.\n\n## 인덱스 스캔 방식\n\n인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다. 인덱스 스캔 방식에는 여러가지가 있는데, 그 중에서 대표적인 방식은 다음과 같다.\nB Tree 기준으로 설명하자면, 인덱스 레인지 스캔은 검색 해야할 인덱스의 범위가 결정 됐을때 사용하는 방식이다.\n루트 노드, 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾고,\n리프 노드간의 링크를 통해 검색 종료점 리프 노드까지 스캔하면서 레코드를 랜덤 엑세스로 읽어 들인다.\n인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 스캔하는 방식이다.\n예를들어 a,b,c 컬럼에 복합 인덱스가 걸려있고 쿼리의 조건절에는 b 또는 c 컬럼이 들어가 있을 경우 인덱스 풀 스캔이 발생한다. \n테이블 풀 스캔보다는 효율적이다.\n\n## 쿼리 실행 계획\n\n쿼리 실행 계획(Query Plan)은 데이터베이스 관리 시스템(DBMS)이 SQL 쿼리를 처리하기 위해 사용하는 실행 계획이다.\n이것은 DBMS에서 쿼리를 처리할 때 데이터베이스에서 데이터를 검색하고 가져오는 방법을 결정하는데 사용된다.\n쿼리 실행에 필요한 단계를 보여주며, 각 단계에서 DBMS가 사용하는 액세스 경로를 보여주고, 쿼리 실행에 필요한 리소스 및 비용 정보를 제공한다.\n즉, SQL을 실행하는데 있어 사용되는 cost와 어떠한 방식이 가장 적절한지 판단하고, 올바른 플랜 중 평가하여 어떠한 순서와 방식으로 처리할 것인지 계획을 세우고 필요에 따라 변경하여 성능을 개선하는데 사용된다.\n이를 통해 DBMS는 쿼리 실행에 필요한 최소한의 리소스를 사용하면서 최적의 성능을 제공할 수 있다.\n\n### 쿼리 실행 계획 확인 방법\n\n쿼리 실행 계획을 확인하는 방법은 DBMS마다 다르지만, 대부분의 DBMS에서는 `EXPLAIN` 명령어를 사용하여 확인할 수 있다.\n`EXPLAIN` 명령어는 쿼리 실행 계획을 확인하는 명령어로, 쿼리를 실행하기 전에 어떠한 방식으로 실행할지에 대한 정보를 제공한다.\n예를 들어, MySQL에서는 다음과 같이 사용할 수 있다.\n\n```sql\nEXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;\n```\n\n위 쿼리를 실행하면, 해당 쿼리의 실행 계획을 확인할 수 있다.\n\n### 쿼리 실행 계획 확인 방법\n\n이러한 쿼리 실행 계획은 옵티마이저가 사용하게 되는데 이때 예상치 못한 문제가 발생할 수 있다.\n이러한 문제를 해결하기 위해 쿼리 힌트를 사용할 수 있다. \n쿼리 힌트는 옵티마이저가 쿼리를 처리하는 방식을 제어하는 방법으로, 쿼리에 힌트를 추가하여 옵티마이저가 쿼리를 처리하는 방식을 변경할 수 있다.\n\n## 인덱스 동작 확인 방법\n\n인덱스 동작을 확인하는 방법은 쿼리에 대한 실행 계획을 보면서 인덱스가 어떻게 걸리는지 확인하여 실제 조회 시 속도와 성능을 확인할 수 있다.\n하지만 가끔씩 인덱스가 제대로 동작하지 않는 경우가 있을 수 있다.\n이런 경우에는 `sys.shema_unused_indexes`를 사용해 인덱스 동작 여부를 확인할 수 있다.\n\n```sql\nSELECT  * FROM sys.shema_unused_indexes;\n```\n\n이렇게 사용되지 않는 인덱스를 확인하고, 필요한 인덱스를 추가하거나 사용되지 않는 인덱스를 삭제하여 성능을 향상시킬 수 있다.\n\n## ORDER BY 와 GROUP BY에 대한 인덱스\n\n인덱스는 WHERE 절에 사용되는 컬럼에 대해서만 동작하는 것이 아니라, ORDER BY와 GROUP BY에도 영향을 줄 수 있다.\n하지만 조건이 있는데 GROUP BY 기준으로 예를 들자면, 복합인덱스를 사용한다고 가정했을 때 GROUP BY (복합인덱스 컬럼들)로 사용해야 인덱스가 동작한다.\nORDER BY의 경우에는 인덱스의 정렬 방식과 일치해야 인덱스가 동작한다.\n\n> 커버링 인덱스 : 쿼리 조회 결과가 인덱스에 해당하는 컬럼 값으로만 이루어진 것을 커버링 인덱스라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 그만큼 랜덤 엑세스가 줄어들고 성능은 빨라진다.<br>\n> 다중 컬럼 인덱스 : 다중 컬럼 인덱스는 2개 이상의 컬럼으로 이루어진 인덱스다. 2개의 컬럼으로 이루어진 인덱스가 있을때, 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다는 특징이 있다는 것을 고려해서 사용해야한다."},{"excerpt":"나무 자르기 백준 2805번 나무 자르기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 227847 68338 42397 26.636% 문제 상근이는 나무 M미터가 필요하다.\n근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다.\n정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, …","fields":{"slug":"/boj-2805/"},"frontmatter":{"date":"January 16, 2025","title":"2805 나무 자르기","tags":["Algorithm"]},"rawMarkdownBody":"\n## 나무 자르기\n\n[백준 2805번 나무 자르기](https://www.acmicpc.net/problem/2805)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 227847 | 68338 | 42397 | 26.636% |\n\n### 문제\n\n상근이는 나무 M미터가 필요하다. \n근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. \n정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.<br>\n\n목재절단기는 다음과 같이 동작한다. \n먼저, 상근이는 절단기에 높이 H를 지정해야 한다. \n높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. \n그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. \n따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. \n예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. \n상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, \n상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) \n절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.<br>\n\n상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. \n이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. \n(1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)<br>\n\n둘째 줄에는 나무의 높이가 주어진다. \n나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. \n높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.\n\n### 출력\n\n적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 나무의 높이를 기준으로 이분 탐색을 수행하여 필요한 나무 길이 이상을 얻을 수 있는 절단기 높이의 최댓값을 찾는 방식으로 접근한다. \n먼저, 입력으로 주어진 나무의 높이를 정렬하고, 절단기의 최소 높이 `0`과 최대 높이를 설정한 후, 이분 탐색을 시작한다. \n각 중간값(`mid`)에서 나무를 절단했을 때 잘린 나무의 총 길이를 계산하고, 이 길이가 목표 길이 이상이면 절단기 높이를 더 높게 설정하여 탐색 범위를 좁힌다. \n반대로, 목표 길이보다 작으면 절단기 높이를 낮추어 다시 탐색한다. \n탐색이 종료되면 최적의 절단기 높이를 출력하며, 시간 복잡도는 정렬 $(O(N \\log N)$과 이분 탐색 $(O(N \\log H)$을 합쳐 $(O(N \\log N + N \\log H)$로 효율적이다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nclass Tree implements Comparable<Tree> {\n    private long height;\n\n    private Tree(long height) {\n        this.height = height;\n    }\n\n    public static Tree of(long height) {\n        return new Tree(height);\n    }\n\n    public long getHeight() {\n        return height;\n    }\n\n    @Override\n    public int compareTo(Tree other) {\n        return Long.compare(this.height, other.height);\n    }\n\n    public long cutHeight(long other) {\n        return this.height - other;\n    }\n\n    public boolean isCuttable(long midHeight) {\n        return Long.compare(this.height, midHeight) > 0;\n    }\n}\n\nclass Trees {\n    private List<Tree> trees;\n\n    private Trees(List<Tree> trees) {\n        this.trees = trees.stream().sorted().collect(Collectors.toList());\n    }\n\n    public static Trees of(List<Tree> trees) {\n        return new Trees(trees);\n    }\n\n    public List<Tree> getTrees() {\n        return trees;\n    }\n\n    public long getMaxHeight() {\n        return trees.get(trees.size() - 1).getHeight();\n    }\n\n    public int size() {\n        return trees.size();\n    }\n}\n\nclass TreeCutter {\n    private Trees trees;\n    private int target;\n\n    private TreeCutter(Trees trees, int target) {\n        this.trees = trees;\n        this.target = target;\n    }\n\n    public static TreeCutter of(Trees trees, int target) {\n        return new TreeCutter(trees, target);\n    }\n\n    private long cut() {\n        long minHeight = 0;\n        long maxHeight = trees.getMaxHeight();\n        long result = 0;\n        while (minHeight <= maxHeight) {\n            long midHeight = (minHeight + maxHeight) / 2;\n            long sumHeight = 0;\n\n            for (Tree tree : trees.getTrees()) {\n                if(tree.isCuttable(midHeight)) {\n                    sumHeight += tree.cutHeight(midHeight);\n                }\n            }\n\n            if (sumHeight >= target) {\n                result = midHeight;\n                minHeight = midHeight + 1;\n            } else {\n                maxHeight = midHeight - 1;\n            }\n        }\n        return result;\n    }\n\n    public void printResult() {\n        System.out.println(cut());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());// 나무의 수 1 <= N <= 1,000,000\n        int target = Integer.parseInt(tokenizer.nextToken());// 나무의 길이 1 <= target <= 2,000,000,000\n        List<Tree> trees = new ArrayList<>();\n        tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i < N; i++) {\n            long height = Long.parseLong(tokenizer.nextToken());\n            Tree tree = Tree.of(height);\n            trees.add(tree);\n        }\n        TreeCutter.of(Trees.of(trees), target).printResult();\n    }\n}\n```"},{"excerpt":"기타 레슨 백준 2343번 기타 레슨 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 41659 14728 10194 33.343% 문제 강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다.\n블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다.\n순서가 뒤바뀌는 경우에는…","fields":{"slug":"/boj-2343/"},"frontmatter":{"date":"January 16, 2025","title":"2343 기타 레슨","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 기타 레슨\n[백준 2343번 기타 레슨](https://www.acmicpc.net/problem/2343)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 41659 | 14728 | 10194 | 33.343% |\n\n### 문제\n\n강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다. \n블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. \n순서가 뒤바뀌는 경우에는 강의의 흐름이 끊겨, 학생들이 대혼란에 빠질 수 있기 때문이다. \n즉, i번 강의와 j번 강의를 같은 블루레이에 녹화하려면 i와 j 사이의 모든 강의도 같은 블루레이에 녹화해야 한다.<br>\n\n강토는 이 블루레이가 얼마나 팔릴지 아직 알 수 없기 때문에, 블루레이의 개수를 가급적 줄이려고 한다. \n오랜 고민 끝에 강토는 M개의 블루레이에 모든 기타 강의 동영상을 녹화하기로 했다. \n이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다. \n단, M개의 블루레이는 모두 같은 크기이어야 한다.<br>\n\n강토의 각 강의의 길이가 분 단위(자연수)로 주어진다. \n이때, 가능한 블루레이의 크기 중 최소를 구하는 프로그램을 작성하시오.<br>\n\n### 입력\n\n첫째 줄에 강의의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. \n다음 줄에는 강토의 기타 강의의 길이가 강의 순서대로 분 단위로(자연수)로 주어진다. \n각 강의의 길이는 10,000분을 넘지 않는다.\n\n### 출력\n\n첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 이분 탐색(Binary Search)을 활용하여 최적의 블루레이 크기를 찾는 방식으로 해결할 수 있었다.\n여기서 핵심은 강의는 순서를 바꿀 수 없으며, 강의 길이의 합을 기준으로 블루레이 크기를 최소화해야 한다는 것이다. \n가장 긴 강의가 들어가야하므로 블루레이 크기의 최소값은 가장 긴 강의의 길이이며, 최대값은 모든 강의 길이의 합으로 설정했다. \n그리고 이분 탐색을 통해 블루레이 크기를 조정하며, \n각 중간값(`mid`)을 블루레이 크기로 설정하고 M개의 블루레이에 강의를 나눌 수 있는지 확인한다. \n현재 블루레이 크기(`mid`)로 강의를 순서대로 배치하다가 크기를 초과하면 새로운 블루레이를 사용하며, \n사용된 블루레이 개수가 M개를 초과하면 `min` 값을 `mid+1`로 하여 더 큰 크기를 탐색하고, \nM개 이하로 나눌 수 있다면 크기를 줄이는 방향으로 탐색한다. \n`getMinDuration` 메서드는 이 과정을 통해 최소 블루레이 크기를 계산하며, \n`canDivide` 메서드는 특정 크기에서 M개의 블루레이로 나눌 수 있는지 여부를 판단한다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass BlueRayMaker {\n    private int[] lectures;\n    private int maxDuration;\n    private int sumDuration;\n    private int blueRayCount;\n\n    private BlueRayMaker(int[] lectures, int blueRayCount) {\n        this.lectures = lectures;\n        this.maxDuration = Arrays.stream(lectures).max().orElse(0);\n        this.sumDuration = Arrays.stream(lectures).sum();\n        this.blueRayCount = blueRayCount;\n    }\n\n    public static BlueRayMaker from(int[] lectures, int blueRayCount) {\n        return new BlueRayMaker(lectures, blueRayCount);\n    }\n\n    private int getMinDuration() {\n        int min = maxDuration;\n        int max = sumDuration;\n        int result = max;\n\n        while (min <= max) {\n            int mid = (min + max) / 2;\n\n            if (canDivide(mid)) {\n                result = mid;\n                max = mid - 1;\n            } else {\n                min = mid + 1;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean canDivide(int size) {\n        int count = 1;\n        int currentSum = 0;\n\n        for (int lecture : lectures) {\n            if (currentSum + lecture > size) {\n                count++;\n                currentSum = lecture;\n\n                if (count > blueRayCount) {\n                    return false;\n                }\n            }\n            else {\n                currentSum += lecture;\n            }\n        }\n        return true;\n    }\n\n    public void printMinDuration() {\n        System.out.println(getMinDuration());\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int lectureCount = Integer.parseInt(tokenizer.nextToken());\n        int blueRayCount = Integer.parseInt(tokenizer.nextToken());\n        int[] lectures = new int[lectureCount];\n\n        tokenizer = new StringTokenizer(reader.readLine());\n        for (int index = 0; index < lectureCount; index++) {\n            lectures[index] = Integer.parseInt(tokenizer.nextToken());\n        }\n        BlueRayMaker.from(lectures, blueRayCount).printMinDuration();\n    }\n}\n```"},{"excerpt":"자바 8 이전에는 기존 인터페이스에 메서드르 추하려면 기존 구현체를 수정해야 했고,\n이를 안할 시 컴파일 오률를 일으켰다.\n자바 8에서는 디폴트 메서드라는 기능을 도입하면서 인터페이스에 새로운 메서드를 추가할 수 있게 되었지만,\n모든 상황에 대비하여 안전하게 동작하리라는 보장은 없다. 디폴트 메서드와 위험성 디폴트 메서드는 인터페이스 구현체에서 재정의하지…","fields":{"slug":"/item-21/"},"frontmatter":{"date":"January 16, 2025","title":"인터페이스는 구현하는 쪽을 생각해 설계하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n자바 8 이전에는 기존 인터페이스에 메서드르 추하려면 기존 구현체를 수정해야 했고,\n이를 안할 시 컴파일 오률를 일으켰다.\n자바 8에서는 디폴트 메서드라는 기능을 도입하면서 인터페이스에 새로운 메서드를 추가할 수 있게 되었지만,\n모든 상황에 대비하여 안전하게 동작하리라는 보장은 없다.\n\n## 디폴트 메서드와 위험성\n\n디폴트 메서드는 인터페이스 구현체에서 재정의하지 않으면 기본 구현을 사용한다.\n이런 면에서 기존 클래스들은 새로운 메서드의 동작과 충돌할 수 있다.\n예를 들어, `removeIf` 디폴트 메서드는 대부분의 상황에서 잘 동작하지만,\n기존 구현체가 가진 고유 불변식이나 동기화 정책을 깨뜨릴 위험이 있다.\n\n실제로 아파치 토미캣 8.5 버전에서는 `removeIf` 메서드를 사용하면 `ConcurrentModificationException`이 발생하는 문제가 있었다.\n이는 아파치 커먼즈의 `Collectoins.synchronizedCollection` 클래스는 동기화를 위해 메서드 호출하다 락을 걸지만,\n`removeIf` 디폴트 구현은 동기화와 관련된 지식이 없기 때문이다.\n\n## 디폴트 메서드와 기존 구현체의 충돌\n\n이렇듯 디폴트 메서드는 기존 구현체와 충돌할 수 있다.\n그럼 자바 표준 라이브러리에서는 어떻게 이 문제를 해결했을까?\n자바에서는 기존 인터페이스를 구현하는 클래스에서 디폴트 메서드를 재정의하거나,\n디폴트 메서드를 호출하기 전 동기화같은 작업을 수행하도록 했다.\n\n```java\n@Override\npublic synchronized boolean removeIf(Predicate<? super E> filter) {\n    return c.removeIf(filter); // c는 내부 컬렉션 객체\n}\n\n```\n\n하지만 자바 플랫폼에 속하지 않은 제 3자의 라이브러리의 구현체들은 이런 수정이 어려우며, 이로인해 런타임 오류가 발생할 수도 있다\n\n## 디폴트 메서드의 설계 원칙\n\n위와 같이 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 대한 런타임 오류를 일으킬 수 있다.\n책은 이를 방지하기 위해서 다음과 같은 원칙을 제시한다.\n\n1. 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.\n2. 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을지 테스트해야 한다.\n3. 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 것은 기존 클라이언트를 망가뜨리게 되므로 피해야 한다.\n\n## 정리\n디폴트 메서드는 유용한 도구지만, 기존 인터페이스를 수정할 때는 매우 신중해야 한다.\n사용을 한다면, 다양한 테스트를 통해 완성도를 높이고, 릴리스 전에 결함을 수정해야 한다.\n\n"},{"excerpt":"잘 설계된 컴포넌트 책에서는 잘 설계된 컴포넌트에 대해 다음과 같이 설명한다. 클래스 내부 데이터와 내부 구현 정보를 외부로 부터 잘 숨겨야 한다. API를 통해서만 다른 컴포넌트와 소통해야 하며, 내부 동작 방식에 개의치 않아야 한다. 이는 캡슐화(정보 은닉)의 개념으로, 이를 잘 지키는 것이 잘 설계된 컴포넌트라고 말하고 있다. 캡슐화의 장점 캡슐화는…","fields":{"slug":"/item-15/"},"frontmatter":{"date":"January 16, 2025","title":"클래스와 멤버의 접근 권한을 최소화하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 잘 설계된 컴포넌트\n\n책에서는 잘 설계된 컴포넌트에 대해 다음과 같이 설명한다.\n\n- 클래스 내부 데이터와 내부 구현 정보를 외부로 부터 잘 숨겨야 한다.\n- API를 통해서만 다른 컴포넌트와 소통해야 하며, 내부 동작 방식에 개의치 않아야 한다.\n\n이는 캡슐화(정보 은닉)의 개념으로, 이를 잘 지키는 것이 잘 설계된 컴포넌트라고 말하고 있다.\n\n## 캡슐화의 장점\n\n캡슐화는 각각의 컴포넌트들을 서로 독립시켜서 개별적으로 동작할 수 있게 함으로써 다음과 같은 장점이 있다.\n\n- 각각의 컴포넌트를 병렬로 개발할 수 있끼에 개발 속도를 높인다.\n- 각 컴포넌트를 더 빨리 파악하여 디버깅이 할 수 있고, 교체 부담이 적어서 시스템 관리 비용을 낮춘다.\n- 다른 컴포넌트에 영향을 안주고 해당 컴포넌트만 최적화가 가능하여 성능 최적화에 도움을 준다(아이템 67).\n- 기존 환경에 대한 의존성이 낮아 독자적으로 동작이 가능해 다른 환경에서의 이식성 및 재사용성을 높인다.\n- 개별 컴포넌트의 동작을 검증할 수 있어, 큰 시스템 상황에서 제작 및 관리하는 난이도를 낮춘다.\n\n## 접근 제어자\n\n자바에서는 이러한 캡슐화를 제공하기 위해 다양한 장치를 제공한다.\n그 중 하나가 접근 제어자이다.\n접근 제어자를 통해 클래스, 인터페이스, 멤버의 접근 허용 범위를 명시할 수 있다.\n\n## 톱레벨 클래스와 인터페이스\n\n가장 외부의 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 `package-private`와 `public`이다.  \n톱레벨 클래스와 인터페이스에 대해서는 패키지 외부에서 사용할 이유가 없다면, `package-private`로 선언하라고 권장한다.\n그 이유는 클라이언트에 영향을 주지 않고 내부 구현을 변경할 수 있기 때문이다.\n반면, `public`으로 선언하면 해당 클래스나 인터페이스를 사용하는 클라이언트에게 영구적인 API로 제공하게 되므로, 하위 호환성 유지를 위해 내부 구현 변경이 어려워진다.\n\n> 톱레벨에 위치한다는 것은 같은 패키지의 모든 클래스가 해당 클래스에 접근할 수 있다는 것을 의미한다.\n> 하지만 한 클래스에서만 사용하는 `package-private` 톱레벨 클래스는 외부 접근을 방지하기 위해 `private static`으로 중첩시키는 것을 권장한다.\n\n```java\npublic class Outer {\n    private static class Inner { ... }\n}\n```\n\n## 멤버의 접근 수준\n\n그럼 `public`만 신경 쓰면 될까?\n책에서는 `public`일 필요가 없는 클래스의 접근 수준을 `package-private` 톱레벨 클래스로 더 좁게 최소한으로 설정하라고 권장하고 있다.\n멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 다음과 같다.\n\n- `private`: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.\n- `package-private`: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다(단, 인터페이스의 멤버는 기본적으로 `public`이 적용된다).\n- `protected`: `package-private`의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다(제약이 조금 따른다).\n- `public`: 모든 곳에서 접근할 수 있다.\n\n이러한 접근 제어자를 통해 공개 API를 엄격히 설계해야 한다.\n다른 클래스가 반드시 접근해야 하는 멤버에 한하여 `private`를 제거해, `package-private`으로 풀어줘도 된다.\n하지만, 이러한 상황이 빈번하게 발생한다면 시스템 컴포넌트를 더 분해해야 하는지 고려해봐야한다.\n\n`package-private`에서 `protected`로 접근 수준을 넓히는 순간 그 멤버에 대한 대상 범위가 넓어지게 되는데,\n이때 `public` 뿐만 아니라 `protected`도 공개 API로 취급되기 때문에, 내부 동작 방식이 담긴 API 문서화의 대상이 된다.\n그래서 `protected`의 멤버를 최대한 줄이고, `private`과 `package-private`을 사용하는 것이 좋다.\n\n> `private`과 `package-private` 멤버는 공개 API에게 영향을 주지 않는 것이 보통이지만, `Serializable`을 구현하는 클래스에서는 의도치 않게 공개 API로 노출될 수 있다.\n\n그런데 멤버 접근성을 좁히지 못하게 방해하는 제약이 있다.\n상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스의 접근 수준보다 좁게 설정할 수 없다.\n이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체할 수 있어야 한다는 규칙 리스코프 치환 법칙을 지키기 위해 필요하다.\n만일 이 제약을 어기면 컴파일 단계에서 오류가 날 것이다.\n\n## 테스트와 접근 제어자\n\n테스트 코드를 작성하기 위해 클래스, 인터페이스, 멤버의 접근 범위를 넓혀야 할 때가 있다.\n`private`에서 `package-priavte` 까지의 완화 허용을 하지만,\n그 이상으로 완화해서 공개 API로 노출 시키는 것을 피해야 한다.\n\n> 실제로 테스트 코드를 같은 패키지에 두면 `package-private` 멤버에 접근할 수 있기 때문에, 테스트 코드를 같은 패키지에 두는 것이 일반적이다.\n\n## public 필드의 위험성과 해결책\n\n`final`이 아닌 인스턴스 필드를 `publi`c으로 선언하는 것은 좋지 않다.\n이는 필드에 대한 제어권을 잃어 불변식을 보장할 수 없게 되기 때문이다.\n또한, 필드가 수정될 때 락(Lock) 같은 작업을 할 수 없게 되어 멀티 스레드 환경에서 스레드 안정성을 보장하지 못한다.\n\n그러면 `public final`로 선언하면 되지 않을까?라고 생각할 수 있지만, 이는 불변식을 보장하지만, 캡슐화를 깨는 행위이다.\n\n```java\npublic final int[] VALUES = {1, 2, 3};\n\npublic void test() {\n    VALUES[0] = 4; // 이러한 변경이 가능해진다.\n    assertThat(VALUES[0]).isNotEqualTo(1);\n}\n```\n\n> 상수라는 예외가 하나 있다. 이럴 때 `public static final`로 선언하는 것하여 공개하여 사용해도 된다.\n> 이때, 관례상 상수의 이름은 대문자로 작성하며, 단어 사이는 밑줄로 구분한다. 또한 이런 필드는 반드시 기본 타입이나 불변 객체로 초기화해야 한다.\n\n이러한 문제를 해결하기 위해, 책에서는 두 가지 방법을 제시한다.\n\n```java\npublic static final Thing[] VALUES = { ... };// 접근이 가능해서 배열의 내용을 변경할 수 있다.\n```\n\n첫 번째 방법으로는 `public` 배열을 `private`으로 만들고, `public` 불변 리스트를 추가하는 것이다.\n\n```java\nprivate static final Thing[] PRIVATE_VALUES = { ... };\npublic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));\n```\n\n두 번째 방법으로는 `private` 배열을 만들고, 그 복사본을 반환하는 `public` 메서드를 추가하는 방법이다(방어적 복사).\n\n```java\nprivate static final Thing[] PRIVATE_VALUES = { ... };\npublic static final Thing[] values() {\n    return PRIVATE_VALUES.clone();\n}\n```\n\n## 자바 9 모듈 시스템\n\n자바 9에서 도입된 모듈 시스템은 패키지의 몪음 단위로 접근성을 제어한다.\n모듈 선언 파일(module-info.java)에서 `exports` 키워드를 사용해 패키지를 공개할 수 있다.\n이를 통해 모듈의 공규 여부와 상관없이 모듈 내부의 패키지를 외부로 노출하지 않고, 자유롭게 공유할 수 있다.\n이러한 기술 활용한 대표 사례가 JDK이다.\n하지만, 사용이 간단하지 않고, 모듈 시스템을 사용하려면 모든 코드를 모듈 시스템에 맞게 수정해야 한다.\n이로 인해, 반드시 필요한 경우가 아니라면 모듈 시스템을 사용하지 않는 것이 좋다.\n\n## 정리\n\n프로그램 요소의 접근 성은 가능한 한 최소한으로 해서 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.\n그리고 public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.\n\n"},{"excerpt":"예산 백준 2512번 예산 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 66885 25609 18686 37.058% 문제 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다.\n국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다.\n그래서 정해진 총액 이하에서…","fields":{"slug":"/boj-2512/"},"frontmatter":{"date":"January 15, 2025","title":"2512 예산","tags":["Algorithm"]},"rawMarkdownBody":"\n## 예산\n[백준 2512번 예산](https://www.acmicpc.net/problem/2512)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 128 MB | 66885 | 25609 | 18686 | 37.058% |\n\n### 문제\n\n국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. \n국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. \n그래서 정해진 총액 이하에서 **가능한 한 최대의** 총 예산을 다음과 같은 방법으로 배정한다.\n\n1. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.\n2. 모든 요청이 배정될 수 없는 경우에는 특정한 **정수** 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다.\n\n예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. \n이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다.\n\n여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에는 지방의 수를 의미하는 정수 $N$이 주어진다. \n$N$은 $3$ 이상 $10,000$ 이하이다. \n다음 줄에는 각 지방의 예산요청을 표현하는 $N$개의 정수가 빈칸을 사이에 두고 주어진다. \n이 값들은 모두 $1$ 이상 $100,000$ 이하이다. \n그 다음 줄에는 총 예산을 나타내는 정수 $M$이 주어진다. $M$은 $N$ 이상 $1,000,000,000$ 이하이다.\n\n### 출력\n\n첫째 줄에는 배정된 예산들 중 최댓값인 정수를 출력한다.\n\n---\n\n## 풀이\n\n문제의 시간 제한은 1초이다.\n문제를 보면 최적화 문제로 보인다.\n그리고 최솟값을 위한 최적화이기에 `Upper Bound`를 사용하면 될 것 같았다.\n총 예산 보다 적게 배정한다면 쉽게 구할 수 있을 것 같았다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass BudgetDistributor {\n    private final long[] budgetRequests;\n    private final long totalBudget;\n\n    private BudgetDistributor(long[] budgetRequests, long totalBudget) {\n        Arrays.sort(budgetRequests);\n        this.budgetRequests = budgetRequests;\n        this.totalBudget = totalBudget;\n    }\n\n    public static BudgetDistributor of(long[] budgetRequests, long totalBudget) {\n        return new BudgetDistributor(budgetRequests, totalBudget);\n    }\n\n    public long getMaxBudget() {\n        long left = 1;\n        long right = budgetRequests[budgetRequests.length - 1];\n        long result = 0;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            long currentBudget = 0;\n\n            for (long budgetRequest : budgetRequests) {\n                currentBudget += Math.min(mid, budgetRequest);\n            }\n\n            if (currentBudget <= totalBudget) {\n                result = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(reader.readLine());\n\n        long[] requests = new long[n];\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i < n; i++) {\n            requests[i] = Long.parseLong(tokenizer.nextToken());\n        }\n\n        long m = Long.parseLong(reader.readLine());\n\n        reader.close();\n\n        long result = BudgetDistributor.of(requests, m).getMaxBudget();\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        writer.write(result + \"\\n\");\n        writer.flush();\n        writer.close();\n    }\n}\n```"},{"excerpt":"선분 위의 점 백준 11663번 선분 위의 점 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 5062 1883 1406 37.049% 문제 일차원 좌표상의 점 N개와 선분 M개가 주어진다.\n이때, 각각의 선분 위에 입력으로 주어진 점이 몇 개 있는지 구하는 프로그램을 작성하시오. 입력 첫째 줄에 점의 개수 N과 선분의 개수 M…","fields":{"slug":"/boj-11663/"},"frontmatter":{"date":"January 15, 2025","title":"11663 선분 위의 점","tags":["Algorithm"]},"rawMarkdownBody":"\n## 선분 위의 점\n[백준 11663번 선분 위의 점](https://www.acmicpc.net/problem/2776)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 5062 | 1883 | 1406 | 37.049% |\n\n### 문제\n\n일차원 좌표상의 점 N개와 선분 M개가 주어진다. \n이때, 각각의 선분 위에 입력으로 주어진 점이 몇 개 있는지 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 점의 개수 N과 선분의 개수 M이 주어진다.(1 ≤ N, M ≤ 100,000) \n둘째 줄에는 점의 좌표가 주어진다. \n두 점이 같은 좌표를 가지는 경우는 없다. \n셋째 줄부터 M개의 줄에는 선분의 시작점과 끝점이 주어진다. \n입력으로 주어지는 모든 좌표는 1,000,000,000보다 작거나 같은 자연수이다.\n\n### 출력\n\n입력으로 주어진 각각의 선분 마다, 선분 위에 입력으로 주어진 점이 몇 개 있는지 출력한다.\n\n---\n\n## 풀이\n\n문제의 시간 제한은 1초이다. 입력으로 주어지는 좌표의 개수는 최대 100,000개이다.\n그리고 탐색을 하여 몇개의 점이 선분위에 위치하는지 요구하는 문제인 것을 알 수 있다.\n그래서 이 문제는 이분 탐색 방식을 사용하고자 했다.\n문제 지문을 자세히 보고 생각난 풀이법은 백준 1654번 문제를 해결하기 위한 Upper Bound와 Lower Bound를 사용하는 방법을 사용하는 것을 떠올렸다.\nUpper Bound로 선분의 끝점보다 큰 점의 인덱스를 찾고, Lower Bound로 선분의 시작점보다 크거나 같은 점의 인덱스를 찾아서 두 인덱스의 차이를 구하면 된다.\n그리고 저번 문제에서 실수한 long 타입을 사용하지 않아서 발생한 오류를 방지하기 위해 long 타입을 사용했다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Point implements Comparable<Point> {\n    private final long coordinate;\n\n    private Point(long coordinate) {\n        this.coordinate = coordinate;\n    }\n\n    public static Point of(long coordinate) {\n        return new Point(coordinate);\n    }\n\n    public long getCoordinate() {\n        return coordinate;\n    }\n\n    @Override\n    public int compareTo(Point other) {\n        return Long.compare(this.coordinate, other.coordinate);\n    }\n}\n\nclass Segment {\n    private final Point startPoint;\n    private final Point endPoint;\n\n    private Segment(long startPoint, long endPoint) {\n        this.startPoint = Point.of(startPoint);\n        this.endPoint = Point.of(endPoint);\n    }\n\n    public static Segment of(long start, long end) {\n        return new Segment(start, end);\n    }\n\n    public Point getStartPoint() {\n        return startPoint;\n    }\n\n    public Point getEndPoint() {\n        return endPoint;\n    }\n}\n\nclass PointCounter {\n    private final List<Point> points;\n    private final List<Segment> segments;\n\n    private PointCounter(List<Point> points, List<Segment> segments) {\n        this.points = points;\n        this.segments = segments;\n    }\n\n    public static PointCounter of(List<Point> points, List<Segment> segments) {\n        return new PointCounter(points, segments);\n    }\n\n    private List<Long> count() {\n        Collections.sort(points);\n        List<Long> result = new ArrayList<>(segments.size());\n\n        for (Segment segment : segments) {\n            Point startPoint = segment.getStartPoint();\n            Point endPoint = segment.getEndPoint();\n\n            long leftIndex = lowerBound(points, startPoint);\n            long rightIndex = upperBound(points, endPoint);;\n\n            result.add(rightIndex - leftIndex);\n        }\n\n        return result;\n    }\n\n    private int lowerBound(List<Point> points, Point startPoint) {\n        int left = 0;\n        int right = points.size();\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n\n            if (points.get(mid).getCoordinate() >= startPoint.getCoordinate()) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    private int upperBound(List<Point> points, Point endPoint) {\n        int left = 0;\n        int right = points.size();\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n\n            if (points.get(mid).getCoordinate() > endPoint.getCoordinate()) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    public void printResult() {\n        StringBuilder output = new StringBuilder();\n        List<Long> result = count();\n        for (long count : result) {\n            output.append(count).append(\"\\n\");\n        }\n        System.out.print(output);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());// 점의 개수, 1 <= N <= 100,000\n        int M = Integer.parseInt(tokenizer.nextToken());// 선분의 개수, 1 <= M <= 100,000\n\n        tokenizer = new StringTokenizer(reader.readLine());\n        List<Point> points = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            long point = Long.parseLong(tokenizer.nextToken());\n            Point newPoint = Point.of(point);\n            points.add(newPoint);\n        }\n\n        List<Segment> segments = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            tokenizer = new StringTokenizer(reader.readLine());\n            long start = Long.parseLong(tokenizer.nextToken());\n            long end = Long.parseLong(tokenizer.nextToken());\n            Segment newSegment = Segment.of(start, end);\n            segments.add(newSegment);\n        }\n\n        PointCounter.of(points, segments).printResult();\n    }\n}\n\n```"},{"excerpt":"랜선 자르기 백준 1654번 랜선 자르기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 254208 61202 41370 21.687% 문제 집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다.\n박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.  이미 오영식은 자체적으로 …","fields":{"slug":"/boj-1654/"},"frontmatter":{"date":"January 14, 2025","title":"1654 랜선 자르기","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 랜선 자르기\n[백준 1654번 랜선 자르기](https://www.acmicpc.net/problem/1654)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 256 MB | 254208 | 61202 | 41370 | 21.687% |\n\n### 문제\n\n집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. \n박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다. <br>\n\n이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. \n그러나 K개의 랜선은 길이가 제각각이다. \n박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. \n예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.) <br>\n\n편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. \n그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. \nN개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. \n이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. \nK는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. \n그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. \n랜선의 길이는 231-1보다 작거나 같은 자연수이다.\n\n### 출력\n\n첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.\n\n---\n\n## 풀이\n\n랜선 자르기 문제는 탐색 알고리즘을 사용해 해결해야 하는 전형적인 문제다. \n문제를 분석해 보면, 랜선의 최대 길이를 구하기 위해 어떤 탐색 알고리즘을 선택해야 할지 판단해야 한다. \n시간 제한과 탐색해야 할 범위를 고려했을 때, 이 문제는 이분 탐색(Binary Search)을 사용해야 효율적으로 해결할 수 있다.\n\n단순히 순차 탐색(Linear Search)을 사용하는 경우, \n랜선의 개수 $K$는 최대 $10^4$과 필요한 랜선의 개수 $N$이 최대 $10^6$까지 주어질 수 있으므로 \n최악의 경우 $O(K \\times N)$의 시간이 소요된다. \n이는 약 $10^{10}$번의 연산으로, 현실적으로 시간 제한에 걸리게 된다. \n따라서 더 나은 시간 복잡도를 제공하는 이분 탐색을 사용하는 것이 적합합니다. \n이분 탐색은 $O(K \\cdot \\log M)$의 시간 복잡도를 가지며, 여기서 $M$은 가장 긴 랜선의 길이다.\n\n이분 탐색을 적용하기 위해서는 다음과 같은 과정이 필요하다.\n\n### 랜선 길이의 범위 설정\n- 최소 길이는 $1$, 최대 길이는 주어진 랜선 길이 중 가장 긴 값으로 설정한다.\n- 중간값을 기준으로 탐색하며 범위를 점점 좁혀간다.\n\n### 랜선 자르기 개수 계산\n- 현재 중간값으로 랜선을 자를 경우 몇 개의 랜선을 만들 수 있는지 계산한다.\n- 필요한 랜선 개수 $N$ 이상을 만들 수 있는 경우, 더 긴 길이를 탐색한다.\n- 필요한 랜선 개수 $N$ 미만인 경우, 더 짧은 길이를 탐색한다.\n\n### 결과 저장\n- 조건을 만족하는 경우, 중간값을 최적의 값으로 저장하고 탐색이 끝날 때까지 반복한다.\n\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass LanCableCutter {\n    private final int number;\n    private final int target;\n    private final long[] cables;\n\n    private LanCableCutter(int number, int target, long[] cables) {\n        this.number = number;\n        this.target = target;\n        this.cables = cables;\n    }\n\n    public static LanCableCutter from(int number, int target, long[] cables) {\n        return new LanCableCutter(number, target, cables);\n    }\n\n    private long getMax() {\n        return Arrays.stream(cables).max().getAsLong();\n    }\n\n    private long cut() {\n        long min = 1;\n        long max = getMax();\n        long length = 0;\n\n        while(min <= max) {\n            long count = 0;\n            long mid = (min + max ) / 2;\n            for(int i = 0; i < number; i++) {\n                count += cables[i] / mid;\n            }\n            if (count >= target) {\n                length = mid;\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n\n        return length;\n    }\n\n    public void getResult() {\n        System.out.println(cut());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int number = Integer.parseInt(tokenizer.nextToken());\n        int target = Integer.parseInt(tokenizer.nextToken());\n        long[] array = new long[number];\n        for (int i = 0; i < number; i++){\n            array[i] = Long.parseLong(reader.readLine());\n        }\n        LanCableCutter.from(number, target, array).getResult();\n    }\n}\n```"},{"excerpt":"암기왕 백준 2776번 암기왕 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 34230 11755 7914 32.139% 문제 연종이는 엄청난 기억력을 가지고 있다.\n그래서 하루 동안 본 정수들을 모두 기억 할 수 있다.\n하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다.\n동규는 연종을 따라 다니며, 연종이 …","fields":{"slug":"/boj-2776/"},"frontmatter":{"date":"January 13, 2025","title":"2776 암기왕","tags":["Algorithm"]},"rawMarkdownBody":"\n## 암기왕\n[백준 2776번 암기왕](https://www.acmicpc.net/problem/2776)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 256 MB | 34230 | 11755 | 7914 | 32.139% |\n\n### 문제\n\n연종이는 엄청난 기억력을 가지고 있다. \n그래서 하루 동안 본 정수들을 모두 기억 할 수 있다. \n하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. \n동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다. \n그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. \n질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다. \n연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다. \n집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다. \n동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자.\n\n### 입력\n\n첫째 줄에 테스트케이스의 개수 T가 들어온다. \n다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다. \n그 다음 줄에  ‘수첩 1’에 적혀 있는 정수들이 N개 들어온다. \n그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다. \n모든 정수들의 범위는 int 로 한다.\n\n### 출력\n\n‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다.\n\n---\n\n## 풀이\n\n문제를 보면 해당 문제는 탐색 알고리즘을 사용해서 해결하라는 것을 알 수 있다.\n어떤 탐색 알고리즘을 사용하냐는 시간제한과 실제 탐색해야할 개수를 보고 선택해야 한다.\n내가 생각한 건 2가지 방식이다.\n하나는 순차 탐색하여 해결하는 방식과 나머지 하나는 이분 탐색으로 해결하는 방식이다.\n직접 탐색에 경우는 `N`과 `M`이 각가 최대 $10^6$이므로 단순히 순차 탐색(Linear Search)을 하면 최악의 경우 $O(N \\times M)$의 시간이 소요된다.\n이렇게 하면 $10^6 \\times 10^6(ms) \\approx 166(s)$이므로 시간 제한에 걸린다.\n따라서, 이보다 더 빠른 $O(M \\log N)$ 복잡도를 가진 이분 탐색(Binary Search)로 구현을 필요로 한다.\n\n이분 탐색은 정렬된 배열에서만 사용해야하기에 `수첩1`의 데이터를 정렬하고 `수첩2`의 데이터를 탐색하는 코드를 구현했다.\n\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Notebook {\n    private final int[] numbers;\n\n    Notebook(int count, String input, boolean shouldSort) {\n        int[] numbers = new int[count];\n        numbers = Arrays.stream(input.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        if (shouldSort) {\n            Arrays.sort(numbers);\n        }\n        this.numbers = numbers;\n    }\n\n    public static Notebook from(int count, String text, boolean shouldSort) {\n        return new Notebook(count, text, shouldSort);\n    }\n\n    public int[] getNumbers() {\n        return numbers;\n    }\n\n    public boolean contains(int number) {\n        return Arrays.binarySearch(numbers, number) >= 0;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int T = Integer.parseInt(br.readLine()); // 테스트케이스 개수\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0; i < T; i++) {\n            int N = Integer.parseInt(br.readLine());\n            Notebook notebook1 = Notebook.from(N, br.readLine(), true);// 수첩 1\n            int M = Integer.parseInt(br.readLine());\n            Notebook notebook2 = Notebook.from(M, br.readLine(), false);// 수첩 2\n\n            StringBuilder sb = new StringBuilder();\n\n            for(int number : notebook2.getNumbers()) {\n                if(notebook1.contains(number)) {\n                    sb.append(1).append(\"\\n\");\n                } else {\n                    sb.append(0).append(\"\\n\");\n                }\n            }\n            result.append(sb);\n        }\n        System.out.println(result);\n    }\n}\n```"},{"excerpt":"LIMIT  절은 쿼리 결과에서 지정한 행 수만 레코드를 제한하여 가져오는데 사용한다. 위의 쿼리는  테이블에서 10개의 레코드만 가져온다.\n이때 MySQL의  절은 항상 쿼리의 마지막에 실행된다.  절은 두 개의 인수를 가질 수 있다.\n첫 번째 인수는 가져올 레코드의 시작 위치를 나타내며, 두 번째 인수는 가져올 레코드의 수를 나타낸다. 위의 쿼리는  …","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"date":"January 11, 2025","title":"MySQL의 Pagination","tags":["Database","MySQL"]},"rawMarkdownBody":"\n\n## LIMIT\n`LIMIT` 절은 쿼리 결과에서 지정한 행 수만 레코드를 제한하여 가져오는데 사용한다.\n\n```sql\nSELECT * FROM table_name LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 10개의 레코드만 가져온다.\n이때 MySQL의 `LIMIT` 절은 항상 쿼리의 마지막에 실행된다.\n\n`LIMIT` 절은 두 개의 인수를 가질 수 있다.\n첫 번째 인수는 가져올 레코드의 시작 위치를 나타내며, 두 번째 인수는 가져올 레코드의 수를 나타낸다.\n\n```sql\nSELECT * FROM table_name LIMIT 5, 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 6번째부터 15번째까지의 레코드를 가져온다.\n\n## OFFSET\n\n`OFFSET` 절은 `LIMIT` 절과 함께 사용되어, 결과에서 지정한 행 수만큼 건너뛴 후 레코드를 가져오는데 사용된다.\n\n```sql\nSELECT * FROM table_name LIMIT 5 OFFSET 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 11번째부터 15번째까지의 레코드를 가져온다.\n\n`OFFSET` 절은 `LIMIT` 절과 함께 사용되어야 하며, `LIMIT` 절보다 먼저 사용될 수 없다.\n\n## Pagination\n\n`LIMIT`과 `OFFSET`을 사용하면 페이지네이션을 구현할 수 있다.\n예를 들어, 한 페이지에 10개의 레코드를 보여주고 싶다면, 다음과 같이 쿼리를 작성할 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 0, 10;\n```\n\n다음 페이지를 보여주고 싶다면, `OFFSET`을 사용하여 다음 페이지의 레코드를 가져올 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 10, 10;\n```\n\n이렇게 `LIMIT`과 `OFFSET`을 사용하면 페이지네이션을 쉽게 구현할 수 있다.\n\n## No OFFSET\n\n`LIMIT`을 사용할 때 주의 해야 할 것이 있는데 `LIMIT` 절의 `OFFSET`이 큰 경우 성능이 저하될 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 0, 10; -- 10 rows in 0.0001 seconds\nSELECT * FROM table_name LIMIT 1000000, 10; -- 10 rows in 0.1 seconds\n```\n\n위의 쿼리는 `table_name` 테이블에서 1,000,000번째부터 1,000,010번째까지의 레코드를 가져온다.\n이때 `OFFSET`이 큰 경우 MySQL은 `OFFSET`만큼의 레코드를 건너뛴 후 결과를 가져오기 때문에 성능이 저하될 수 있다.\n\n따라서 `LIMIT`을 사용할 때는 `OFFSET`을 최대한 작게 사용하는 것이 좋다.\n즉, `LIMIT 0, 10`과 같이 `OFFSET`을 0으로 설정하는 것이 좋다.\n\n```sql\nSELECT * FROM table_name WHERE id < 1000000 ORDER BY id DESC LIMIT 10; -- 10 rows in 0.0001 seconds\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 1,000,000보다 작은 레코드를 가져온다.\n이렇게 `WHERE` 절을 사용하여 `OFFSET`을 최대한 작게 사용하면 성능을 향상시킬 수 있다.\n\n## cursor\n\n`LIMIT`과 `OFFSET`을 사용하여 페이지네이션을 구현할 수 있지만, `OFFSET`이 큰 경우 성능이 저하될 수 있다.\n이러한 문제를 해결하기 위해 `cursor`를 사용할 수 있다.\n\n`cursor`는 `LIMIT`과 `OFFSET`을 사용하지 않고 페이지네이션을 구현할 수 있는 방법이다.\n`cursor`는 이전 페이지의 마지막 레코드를 기준으로 다음 페이지의 레코드를 가져오는 방식이다.\n\n```sql\nSELECT * FROM table_name WHERE id > 0 ORDER BY id LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 0보다 큰 레코드를 가져온다.\n이때 `ORDER BY` 절을 사용하여 `id`를 기준으로 정렬하고, `LIMIT`을 사용하여 10개의 레코드를 가져온다.\n\n다음 페이지를 가져오기 위해서는 이전 페이지의 마지막 레코드를 기준으로 `WHERE` 절을 사용하여 다음 페이지의 레코드를 가져올 수 있다.\n\n```sql\nSELECT * FROM table_name WHERE id > 10 ORDER BY id LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 10보다 큰 레코드를 가져온다.\n이렇게 `cursor`를 사용하면 `OFFSET`을 사용하지 않고 페이지네이션을 구현할 수 있다.\n\n`cursor`를 사용하면 `OFFSET`을 사용하지 않기 때문에 성능이 향상될 수 있다.\n따라서 `cursor`를 사용하여 페이지네이션을 구현하는 것이 좋다."},{"excerpt":"테이블의 데이터를 삭제 시 , ,  을 사용할 수 있다. 각각의 차이점을 알아보자. DELETE 는 데이터를 하나하나 삭제면서 제거하는 방식이다.\n 절을 사용하여 조건에 맞는 행만 삭제할 수 있다.\n이러한 방식으로 데이터를 삭제해서 다른 삭제 방식보다는 느리지만 을 하지 않으면 으로 데이터는 복구할 수 있다. TRUNCATE 는 테이블의 모든 데이터를 삭…","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"date":"January 10, 2025","title":"MySQL의 DELETE, TRUNCATE, DROP 차이","tags":["Database","MySQL"]},"rawMarkdownBody":"\n\n테이블의 데이터를 삭제 시 `DELETE`, `TRUNCATE`, `DROP` 을 사용할 수 있다. 각각의 차이점을 알아보자.\n\n## DELETE\n`DELETE`는 데이터를 하나하나 삭제면서 제거하는 방식이다.\n`WHERE` 절을 사용하여 조건에 맞는 행만 삭제할 수 있다.\n이러한 방식으로 데이터를 삭제해서 다른 삭제 방식보다는 느리지만 `COMMIT`을 하지 않으면 `ROLLBACK`으로 데이터는 복구할 수 있다.\n\n```sql\nDELETE FROM table_name WHERE condition;\n```\n\n## TRUNCATE\n\n`TRUNCATE`는 테이블의 모든 데이터를 삭제하는 방식이다.\n`DELETE`와 달리 `WHERE` 절을 사용할 수 없다.\n`TRUNCATE`는 `COMMIT`을 자동으로 실행하기에  `ROLLBACK`으로 데이터를 복구할 수 없다.\n\n```sql\nTRUNCATE table_name;\n```\n\n## DROP\n\n`DROP`은 테이블 자체를 삭제하는 방식이다.\n테이블을 삭제하면 테이블의 구조와 데이터 모두 삭제된다.\n`DROP` 또한 `COMMIT`을 자동으로 실행하기에 `ROLLBACK`으로 데이터를 복구할 수 없다.\n\n```sql\nDROP table_name;\n```\n\n[//]: # (SELECT FOR UPDATE 가 배타락인지)"},{"excerpt":"캡슐화의 이점을 제공하지 못하는 클래스 위와 같은 코드는 데이터 필드에 대한 직접적인 접근을 허용한다.\n이러한 코드는 캡슐화의 이점을 제공하지 못한다.(아이템15와 이어지는 맥락) API를 수정하지 않고는 내부 표현을 바꿀 수 없다.  필드로만 구성되어 있기 때문에 내부 표현을 변경하기 위해서는 외부 API를 변경해야 한다. 책에서는 다음과 같이  클래스…","fields":{"slug":"/item-16/"},"frontmatter":{"date":"January 09, 2025","title":"public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n## 캡슐화의 이점을 제공하지 못하는 클래스\n\n```java\nclass Point {\n    public double x;\n    public double y;\n}\n```\n\n위와 같은 코드는 데이터 필드에 대한 직접적인 접근을 허용한다.\n이러한 코드는 캡슐화의 이점을 제공하지 못한다.(아이템15와 이어지는 맥락)\n\n### API를 수정하지 않고는 내부 표현을 바꿀 수 없다.\n`public` 필드로만 구성되어 있기 때문에 내부 표현을 변경하기 위해서는 외부 API를 변경해야 한다.\n\n책에서는 다음과 같이 `Point` 클래스에 접근자 메서드를 추가하는 방법을 제시한다.\n\n```java\npublic getx() { \n    return x; \n}\npublic gety() { \n    return y;\n}\n```\n\n### 불변식을 보장할 수 없다.\n`public` 필드는 클라이언트가 필드에 접근하여 값을 변경할 수 있기 때문에 불변식을 보장할 수 없다.\n\n```java\npublic static void main(String[] args) {\n    Point point = new Point(1, 1);\n    System.out.println(point.x); //1\n    point.x += 1; // x값 변경\n    System.out.println(point.x); //2\n}\n```\n\n### 외부에서 필드에 접근할 때 부수 작업을 수행할 수 없다.\n위 코드에서의 `point.x` 같이 필드에 직접 접근하는 경우, 1차원적인 접근만 가능해 필드에 접근할 때 추가적긴 연산 로직 같은 부수 작업을 삽입할 수 없다.\n\n## 접근자와 수정자 메서드를 사용한 캡슐화\n\n필드를 모두 `private`으로 선언하고, `public`한 접근자(`getter`)와 수정자(`setter`) 메서드를 사용하여 필드에 접근하도록 한다.\n\n```java\nclass Point {\n    private double x;\n    private double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setX(double x) {\n        this.x = x;\n    }\n\n    public void setY(double y) {\n        this.y = y;\n    }\n}\n```\n\n이렇게 패키지 외부에서 접근할 수 있는 클래스 접근자(`getter`,`setter`)를 제공하게 구현을 하면\n클래스 내부 표현 방식을 변경해도 API를 수정하지 않고도 변경할 수 있다.\n이러한 클래스의 내부 표현 방식으로 언제든지 내부표현을 유연하게 변경할 수 있다.\n\n## package-private 클래스나 private 중첩 클래스에서는 public 필드를 사용해도 된다.\n책에서는 또 다른 유용한 예로, `package-private` 클래스나 `private` 중첩 클래스을 들고 있다.\n\n> `package-private` 클래스는 같은 패키지 내에서만 접근이 가능한 클래스이다.\n> `private` 중첩 클래스는 해당 클래스를 포함하는 클래스 내에서만 접근이 가능한 클래스이다.\n\n`package-private` 클래스나 `private` 중첩 클래스라면,\n필드를 노출해도 클래스가 표현하려는 추상 개념만 문제가 되지 않는다.\n\n다음 코드는 `private` 중첩 클래스에서 `public` 필드를 사용한 예시이다.\n\n```java\npublic class Shape {\n    private static class Point {\n        private final int x;\n        private final int y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int getX() {\n            return x;\n        }\n\n        public int getY() {\n            return y;\n        }\n    }\n\n    public static Point createPoint(int x, int y) {\n        return new Point(x, y);\n    }\n}\n```\n\n위 코드를 보면 `Point` 클래스는 `Shape` 클래스 내부에 캡슐화되어 외부에서 직접적인 접근할 수 없다.\n하지만 `Shape` 클래스에서는 얼마든지 `Point` 객체를 생성하고, `Point` 객체의 필드에 접근할 수 있다.\n이렇게 함으로써 처음 제시된 3가지 문제점을 해결할 수 있고,\n클래스와 필드를 선언하는 면에서나 클라이언트 코드면에서나 접근자 방식보다 깔끔하게 표현이 된다.\n\n>`private` 중첩 클래스는 같은 패키지 내에서만 해당 클래스에 대한 접근이 가능하다면 값 변경 시\n> 생성한 객체를 통해서만 접근 및 변경이 가능하다.\n> 그래서 `package-private` 클래스보다 `private` 중첩 클래스가 더 제한적이다.\n\n## 자바 라이브러리에서 public 클래스의 필드를 직접 노출시킨 사례\n자바 라이브러리에서도 public 클래스의 필드를 직접 노출하지 말라는 규칙을 어기는 경우가 있다.\n책에 서는 이러한 경우를 통해 타산지석으로 삼아야 한다고 한다며,\n대표적인 예로 `java.awt.package` 패키지의 `Point`와 `Dimension` 클래스를 들고 있다.\n\n### `java.awt.Point` 클래스 내부\n\n```java\npublic class Point extends Point2D implements Serializable {\n    public int x;\n    public int y;\n}\n```\n\n### `java.awt.Dimensoin` 클래스 내부\n\n```java\npublic class Dimension extends Dimension2D implements Serializable {\n    public double width;\n    public double height;\n}\n```\n\n##  불변 필드를 노출한 public 클래스\n그럼 `final` 키워드로 선언된 불변 필드를 노출하는 경우는 어떨까?\n책에서는 `public` 클래스에서 `final` 키워드로 선언된 불변 필드를 노출하는 것은 괜찮다고 한다.\n하지만 API를 변경하지 않고는 내부 표현을 바꿀 수 없다는 문제점과 부수 작업을 수행할 수 없다는 문제점은 여전히 남아있어\n추천하진 않는다.\n\n```java\npublic final class Time {\n    private static final int HOURS_PER_DAY = 24;\n    private static final int MINUTES_PER_HOUR = 60;\n\n    public final int hour;\n    public final int minute;\n\n    public Time(int hour, int minute) {\n        if (hour < 0 || hour >= HOURS_PER_DAY) {\n            throw new IllegalArgumentException(\"시간: \" + hour);\n        }\n        if (minute < 0 || minute >= MINUTES_PER_HOUR) {\n            throw new IllegalArgumentException(\"분: \" + minute);\n        }\n        this.hour = hour;\n        this.minute = minute;\n    }\n}\n```\n\n## 정리\n`public` 클래스는 절대로 가변 필드를 직접 노출해서는 안된다.\n불변 필드라도 `public`으로 선언하면 해당 필드를 수정할 수 없다는 보장이 없다.\n그럼에도 필드를 `public`으로 선언해야 하는 경우라면 `package-private` 클래스나 `private` 중첩 클래스에서 사용하는 방법을 사용하자."},{"excerpt":"제약 조건(Constraints) 제약 조건이란 데이터의 무결성을 보장하기 위해, 데이터베이스에 저장되는 데이터의 논리적인 조건을 의미한다.\n이러한 제약 조건은 문을 사용하여 테이블을 생성할 때나,\n문을 사용하여 테이블을 생성한 후에 제약조건을 지정할 수 있다.\n이와 같은 DDL(Data Definition Language) 문을 사용하여 테이블에 설정할…","fields":{"slug":"/database-constraints/"},"frontmatter":{"date":"January 09, 2025","title":"제약 조건(Constraints)","tags":["Database"]},"rawMarkdownBody":"\n\n## 제약 조건(Constraints)\n제약 조건이란 데이터의 무결성을 보장하기 위해, 데이터베이스에 저장되는 데이터의 논리적인 조건을 의미한다.\n이러한 제약 조건은 `CREATE TABLE`문을 사용하여 테이블을 생성할 때나,\n`ALTER TABLE`문을 사용하여 테이블을 생성한 후에 제약조건을 지정할 수 있다.\n이와 같은 DDL(Data Definition Language) 문을 사용하여 테이블에 설정할 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type CONSTRAINT constraint_name constraint_type\n);\n```\n\n## NOT NULL\n`NOT NULL` 제약 조건은 특정 컬럼에 NULL 값을 허용하지 않도록 설정하는 제약 조건이다.\n테이블의 필드를 `NOT NULL`로 설정하면, 해당 필드에는 `NULL` 값의 저장을 허용하지 않는다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type NOT NULL\n);\n```\n\n```sql\nALTER TABLE table_name ADD CONSTRAINT constraint_name NOT NULL (column_name); -- ALTER TABLE 문을 사용하여 제약 조건 추가\nALTER TABLE table_name MODIFY column_name data_type NOT NULL; -- ALTER TABLE 문을 사용하여 제약 조건 수정\n```\n\n## UNIQUE\n\n`UNIQUE` 제약 조건은 특정 컬럼에 중복된 값을 허용하지 않도록 설정하는 제약 조건이다.\n이 제약 조건은 테이블의 각 행을 고유하게 식별하는데 사용된다.\n즉, 특정 열의 경우 모든 행은 고유한 값을 가져야 한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type UNIQUE -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name UNIQUE (column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type UNIQUE; -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name); -- 이름 설정 가능\n```\n\n`UNIQUE` 제약 조건을 설정하면, 해당 필드는 자동으로 보조 인덱스(INDEX)가 생성된다.\n만일 제약 조건에 이름을 설정하면, 다음과 같은 쿼리로 해당 제약 조건을 삭제할 수 있다.\n\n```sql\nALTER TABLE table_name DROP INDEX constraint_name;\nDROP INDEX constraint_name ON table_name;\n```\n\n## PRIMARY KEY\n`PRIMARY KEY` 제약 조건은 테이블의 각 행을 고유하게 식별하는데 사용되는 제약 조건이다.\n테이블의 필드가 기본 키인 경우 필드는 `NULL` 값을 포함할 수 없으며 모든 행은 이 필드에 대해 고유한 값을 가져야 한다.\n즉, `PRIMARY KEY` 제약 조건은 `UNIQUE` 제약 조건과 `NOT NULL` 제약 조건을 모두 포함한다.\n테이블은 기본 키로 하나의 필드만 가질 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type PRIMARY KEY -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name PRIMARY KEY (column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type PRIMARY KEY; -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name); -- 이름 설정 가능\n```\n\n## FOREIGN KEY\n`FOREIGN KEY` 제약 조건은 참조하는 테이블의 기본 키를 참조하는 필드이다.\n이때 반드시 `UNIQUE`나 `PRIMARY KEY` 제약 조건이 설정되어 있어야 한다.\n일반적으로 이렇게 테이블 간에 일종의 관계를 만든다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name \n    ADD CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name); -- 이름 설정 가능\n```\n\n## CHECK\n`CHECK` 제약 조건은 특정 컬럼에 저장할 수 있는 값의 범위를 제한하는 제약 조건이다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type CHECK (condition) -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name CHECK (condition) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type CHECK (condition); -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK (condition); -- 이름 설정 가능\n```\n\n## DEFAULT\n`DEFAULT` 제약 조건은 특정 컬럼에 기본값을 설정하는 제약 조건이다.\n이 제약 조건은 특정 컬럼에 값을 입력하지 않았을 때, 자동으로 설정된 기본값이 입력된다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type DEFAULT default_value -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type DEFAULT default_value; -- 이름 설정 불가\n```\n\n## ON DELETE / ON UPDATE\n`ON DELETE`와 `ON UPDATE` 제약 조건은 외래 키 제약 조건을 설정할 때 사용된다.\n`ON DELETE` 제약 조건은 참조하는 테이블의 행이 삭제될 때, 참조하는 테이블의 행에 대한 처리 방법을 설정한다.\n반면, `ON UPDATE` 제약 조건은 참조하는 테이블의 행이 업데이트될 때, 참조하는 테이블의 행에 대한 처리 방법을 설정한다.\n\n이때 참조한고 있는 테이블의 동작은 다음 키워드를 사용하여 `FOREIGN KEY` 제약 조건을 설정할 때 설정할 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE action ON UPDATE action -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name \n    ADD CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE action ON UPDATE action; -- 이름 설정 가능\n```\n\n설정할 수 있는 `action`은 다음과 같다.\n\n- `CASCADE`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행도 삭제되거나 업데이트된다.\n- `SET NULL`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행의 외래 키 값을 `NULL`로 설정한다.\n- `SET DEFAULT`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행의 외래 키 값을 기본값으로 설정한다.\n- `RESTRICT`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행이 삭제되거나 업데이트되지 않는다.\n- `NO ACTION`: `RESTRICT`와 동일한 동작을 수행한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE CASCADE ON UPDATE CASCADE -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n## CASCADE\n`CASCADE` 제약 조건은 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행도 삭제되거나 업데이트 하게 하여 참조 무결성을 유지한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE CASCADE ON UPDATE CASCADE -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n하지만, `CASCADE` 제약 조건은 데이터의 무결성 유지하는데 유용하지만 위협할 수 있으므로 주의해서 사용해야 한다.\n대표적인 예로, 부모 테이블의 행이 삭제되면 자식 테이블의 행도 삭제되는데, 이러한 경우 데이터 손실이 발생할 수 있다."},{"excerpt":"캐시는 데이터를 저장하는 장소로, 데이터를 빠르게 조회할 수 있도록 도와주어 성능 향상과 부하 감소를 목표로 한다.\n이때 캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도 한다.\n따라서, 캐싱 전략을 이해하는 것은 중요하다. Cache Aside(Lazy Loading) Cache Aside 방식은 캐시 히트 시 캐시에서 데이터를 불러오며, 캐시 미스 …","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"date":"January 09, 2025","title":"캐싱 전략(Caching Strategy)","tags":["Database"]},"rawMarkdownBody":"\n캐시는 데이터를 저장하는 장소로, 데이터를 빠르게 조회할 수 있도록 도와주어 성능 향상과 부하 감소를 목표로 한다.\n이때 캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도 한다.\n따라서, 캐싱 전략을 이해하는 것은 중요하다.\n\n## Cache Aside(Lazy Loading)\nCache Aside 방식은 캐시 히트 시 캐시에서 데이터를 불러오며, 캐시 미스 발생 시 원본 데이터베이스에서 조회하여 반환한다.\n애플리케이션은 캐시 미스가 발생하면 해당 데이터를 캐시에 적재한다.\n\n해당 방식은 실제 요청된 데이터만 캐시에 저장되므로 불필요한 데이터 캐싱을 줄일 수 있다.\n또한, 캐시에 문제가 발생해도 애플리케이션은 원본 데이터베이스 직접 접근할 수 있기 때문에 서비스가 계속 작동할 수 있다는 장점이 있다.\n하지만, 캐시 미스가 발생하는 경우에만 데이터를 캐시에 적재하기 때문에 원본 데이터베이스와 같은 데이터가 아닐 수도 있으며,\n초기에는 대량의 캐시 미스로 인한 데이터베이스 부하가 발생할 수 있다.\n\n## 캐시 불일치를 해소할 수 있는 쓰기 전략\n캐시 불일치(Cachge Inconsistency) 란 원본 데이터베이스에 저장된 데이터와 캐시에 저장된 데이터가 서로 다른 상황을 의미한다.\nWrite Through, Cache Invalidation, Write Behind 방식으로 이러한 캐시 불일치를 해소할 수 있다.\n\n### Write Through\nWrite Through 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n매번 캐시에 해당 데이터를 찾아 함께 변경하는 방식이다.\n2번 쓰기가 발생하지만, 캐시는 항상 최신 데이터를 가지고 있다.\n캐시는 다시 조회되는 경우에 빛을 발휘한다.\n무작정 데이터를 갱신하거나 저장하는 방식은 리소스 낭비가 될 수 있으니 해당 방식을 사용하는 경우, 만료 시간을 사용하는 것이 권장된다.\n\n### Cache Invalidation\nCache Invalidation 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n캐시 데이터를 만료시키는 방식이다.\nWrite Through 방식의 단점을 보완한 방식이며 캐시에 데이터가 삭제되니 캐시 불일치에 대한 걱정을 하지 않아도 된다.\n\n### Write Behind(Write Back)\nWrite Behind(Write Back) 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n캐시를 먼저 업데이트한 이후 추후에 원본 데이터를 변경한다.\n디스크 쓰기 작업을 비동기 작업으로 수행하여 성능을 개선할 수 있다.\n원본 데이터와 캐시가 일시적으로 일치하지 않을 수 있있기 때문에\n쓰기 작업이 빈번하며 일시적인 캐시 불일치를 허용하는 서비스에서 유용하게 사용될 수 있다.\n\n## 참고\n- [10분 테코톡 저문, 라온의 Cache & Redis](http://youtube.com/watch?feature=shared&v=tVZ15cCRAyE)\n- [잘못된 캐싱 전략이 당신의 서비스를 망치고 있습니다](https://maily.so/devpill/posts/8do7dxleogq)"},{"excerpt":"SQL(Structured Query Language) SQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 조작하기 위한 구조화된 질의 언어이다.\n기능에 따라 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 데이터 제어 언어(DCL) 등으로 나뉜다. SQL 동작 과정 SQL은 데이터베이스에 대한 질의를 수행하기…","fields":{"slug":"/database-sql/"},"frontmatter":{"date":"January 08, 2025","title":"SQL(Structured Query Language)","tags":["Database"]},"rawMarkdownBody":"\n## SQL(Structured Query Language)\nSQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 조작하기 위한 구조화된 질의 언어이다.\n기능에 따라 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 데이터 제어 언어(DCL) 등으로 나뉜다.\n\n### SQL 동작 과정\nSQL은 데이터베이스에 대한 질의를 수행하기 위해 다음과 같은 과정을 거친다.(MySQL 기준)\n\n1. 사용자가 작성한 SQL 문장을 데이터베이스로 전송한다.\n2. MySQL 쿼리 파서는 SQL 문장을 토큰으로 분리하여 트리를 생성한다. 이 트리 Parse Tree라고 하는데 이를 통해 문장의 구조를 파악하여 쿼리를 실행한다. 이 과정에서 문법 오류도 검출한다.\n3. 다음으로 전처리기가 Parse Tree를 기반으로 SQL 문장구조에 문제가 없는지 검사한다. 이 과정에서 테이블이나 컬럼이 유효한지, 사용자가 접근권한이 있는지 등을 검사한다.\n4. 옵티마이저가 SQL 실행을 최적화하기 위해 실행 계획을 수립한다.\n5. 마지막으로 쿼리 실행 엔진이 옵티마이저가 수립한 실행 계획을 기반으로 스토리지 엔진을 호출해서 쿼리를 수행하고 결과를 반환한다.\n\n## SQL 문장 종류\n\n### DDL(Data Definition Language)\nDDL(Data Definition Language)은 데이터 정의어로 테이블 생성, 변경, 삭제 등 데이터베이스의 구조를 정의하는 명령어이다.\n주요 DDL 명령어로는 `CREATE`, `ALTER`, `DROP`, `TRUNCATE` 등이 있다.\n\n### DML(Data Manipulation Language)\nDML(Data Manipulation Language)은 데이터 조작어로 데이터베이스에 저장된 데이터를 조회, 삽입, 수정, 삭제하는 명령어이다.\n주요 DML 명령어로는 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 등이 있다.\n\n### DCL(Data Control Language)\nDCL(Data Control Language)은 데이터 제어어로 데이터베이스에 저장된 데이터에 대한 접근 권한을 제어하는 명령어이다.\n주요 DCL 명령어로는 `GRANT`, `REVOKE` 등이 있다.\n\n## CASCADE\nCASCADE는 외래 키 제약 조건을 설정할 때 사용되는 옵션 중 하나로, 참조하는 테이블의 레코드가 변경되거나 삭제될 때 참조하는 테이블의 레코드도 함께 변경되거나 삭제되도록 설정하는 것이다.\n하지만 CASCADE 옵션을 사용할 때는 주의해야 한다.\nCASCADE 옵션을 사용하면 참조하는 테이블의 레코드가 변경되거나 삭제될 때 참조되는 테이블의 레코드도 함께 변경되거나 삭제되므로 데이터 무결성에 영향을 줄 수 있다.\n그래서 실무에서는 CASCADE 옵션을 사용할 때는 신중하게 사용해야 한다.\n\n## VIEW\nVIEW는 하나 이상의 테이블로부터 유도된 가상 테이블로, 실제 데이터를 저장하지 않고 SELECT 문을 통해 필요한 데이터를 동적으로 생성하는 객체이다.\nVIEW는 데이터를 저장하지 않고 SELECT 문을 통해 필요한 데이터를 동적으로 생성하기 때문에 실제 데이터를 변경하지 않고도 데이터를 조회하거나 조작할 수 있다.\n또한 원본 테이블을 노출시키지 않게 함으로 데이터 보안성을 제공할 수 있다.\n\n## 질의 처리 과정\nMySQL에서 SQL 질의 처리 과정은 다음과 같다.\n\n1. FROM 절에서 타겟 테이블이 정해진다. 이때, 테이블을 참조할 때는 테이블에 대한 락을 걸어 다른 사용자가 변경하지 못하도록 한다.\n2. WHERE 절에서 조건에 맞는 투플이 필터링 된다. 이때, 인덱스를 사용하여 검색 속도를 높일 수 있다.\n3. GROUP BY 절에서 지정한 컬럼을 기준으로 그룹핑이 이루어진다.\n4. `DISTINCT`가 사용되면 중복된 투플이 필터링 된다.\n5. HAVING이 사용되어 적용되면 GROUP BY 절에서 그룹핑된 투플에 대한 추가 필터링이 이루어진다.\n6. ORDER BY 절에서 지정한 컬럼을 기준으로 정렬이 이루어진다.\n7. LIMIT이 사용되어 적용되면 결과 튜플의 개수가 제한이 되어 반환된다.\n\n## SELECT FOR UPDATE\n`SELECT FOR UPDATE`를 사용하면 트랜잭션 내에서 특정 행을 읽을 때 해당 행에 대한 락을 걸어 다른 트랜잭션이 해당 행을 변경하지 못하도록 한다.\n\n## GROUP BY\n`GROUP BY`는 특정 컬럼을 기준으로 그룹핑을 하여 그룹별로 집계 함수를 적용할 수 있도록 하는 절이다.\n주로 집계 함수와 함께 사용되며, 집계 함수를 사용하지 않는 경우에는 `DISTINCT`와 비슷한 역할을 한다.\n\n```sql\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE condition\nGROUP BY column_name;\n```\n\n## ORDER BY\n`ORDER BY`절을 사용해서 특정 컬럼을 기준으로 조회 결과를 정렬할 수 있다.\n기본적으로 오름차순(ASC)으로 정렬되며, 내림차순(DESC)으로 정렬하려면 DESC 키워드를 사용한다.\n\n```sql\nSELECT column_name\nFROM table_name\nORDER BY column_name ASC|DESC;\n```\n\n## JOIN\n`JOIN`은 두 개 이상의 테이블을 연결하여 하나의 결과 집합으로 만드는 연산이다.\n```sql\nSELECT column_name(s)\nFROM table1\nJOIN table2\nON table1.column_name = table2.column_name;\n```\n\n### INNER JOIN과 OUTER JOIN\n\nINNER JOIN 을 통해 두 테이블의 교집합을 구할 수 있다.\n```sql\nSELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;\n```\n\nOUTER JOIN은 INNER JOIN과 달리 두 테이블의 합집합을 구할 수 있다.\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n## LEFT OUTER JOIN과 RIGHT OUTER JOIN\nLEFT OUTER JOIN은 왼쪽 테이블의 모든 행과 오른쪽 테이블의 일치하는 행을 반환한다.\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n이떄 왼쪽 테이블의 모든 행을 반환하고 오른쪽 테이블의 일치하는 행이 없는 경우에는 NULL 값을 반환한다.\n\nRIGHT OUTER JOIN은 LEFT OUTER JOIN과 반대로 오른쪽 테이블의 모든 행과 왼쪽 테이블의 일치하는 행을 반환한다.\n```sql\nSELECT column_name(s)\nFROM table1 \nRIGHT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n## CROSS JOIN\n\nCROSS JOIN을 하면 두 테이블의 가능한 모든 조합 결과를 생성해 반환한다.\n두 테이블의 각 레코드 수를 곱한 개수만큼 결과가 반환된다.\n카테시안 곱이라고도 한다.\n```sql\nSELECT column_name(s)\nFROM table1\nCROSS JOIN table2;\n```\n\n## Subquery\n\n서브쿼리는 쿼리문 안에 또 다른 쿼리문을 사용하는 것이다.\n서브쿼리는 주로 WHERE 절, FROM 절, SELECT 절, HAVING 절에 사용된다.\n\n## DROP, TRUNCATE, DELETE\n\n### TRUNCATE\n`TRUNCATE`는 테이블의 모든 행을 삭제하지만 테이블 스키마는 그대로 남겨둔다.\n수행 시 DELETE처럼 행마다 로그를 남기지 않고 테이블 전체를 한 번에 삭제하기 때문에 속도가 빠르다.\n하지만 ROLLBACK이 불가능하고, 테이블에 대한 LOCK이 걸리기 때문에 다른 사용자가 해당 테이블을 사용하지 못한다.\n또한 AUTO_INCREMENT 값도 초기화 되기도 한다.\n\n### DELETE\n\n`DELETE`는 DML로 테이블의 행을 삭제하는 명령어이다. DELETE는 행마다 로그를 남기기 때문에 ROLLBACK이 가능하다.\n하지만 DELETE는 행마다 로그를 남기기 때문에 TRUNCATE보다 속도가 느리다.\nWHERE 절을 사용하여 특정 행만 삭제할 수 있다.\n\n### DROP\n\n`DROP`은 DDL로 테이블을 삭제하는 명령어이다. 테이블을 삭제하면 테이블 스키마와 데이터 모두 삭제된다.\n데이터를 복구할 수 없으므로 주의해서 사용해야 한다.\n\n## DISTINCT\n\n`DISTINCT`는 중복된 행을 제거하는 명령어이다.\n```sql\nSELECT DISTINCT column_name\nFROM table_name;\n```\n\n## SQL Injection\n\nSQL Injection은 악의적인 사용자가 웹 애플리케이션의 입력 폼에 SQL 쿼리를 삽입하여 데이터베이스를 비정상적으로 조작하는 공격이다.\n\n실행할 SQL 구문을 미리 Prepared Statement로 정해두고, 사용자 입력값에 따라 매핑하여 파라미터로만 전달하는 방식을 사용하면, SQL Injection을 통해 비정상적인 쿼리 수행을 방지할 수 있다.\n\n## SQL Anti Patterns\n\nSQL Anti Patterns는 SQL을 사용할 때 발생할 수 있는 잘못된 사용 방법을 말한다.\n\n1. SELECT *\n2. SELECT DISTINCT\n3. SELECT COUNT(*)\n8. SELECT column FROM table WHERE column LIKE '%value%'\n9. SELECT column FROM table WHERE column = NULL\n10. SELECT column FROM table WHERE column != value\n11. SELECT column FROM table WHERE column = value OR column = value2\n\n특히, SELECT 절에서 LIKE를 사용할 때 와일드 카드를 앞뒤로 사용하는 방식 `%value%`은\n앞의 와일드 카드로 인해 정렬 기준이 없어져서 인덱스를 사용하지 못해서\n테이블을 Full Scan하기 때문에 성능이 떨어진다.\n이러한 안티패턴 사용을 지양 해야 한다.\n\n## Pagination\n\nPagination은 페이지 단위로 데이터를 나누어 보여주는 기능을 말한다.\nPagination을 구현할 때는 `LIMIT`와 `OFFSET`을 사용한다.\n\n```sql\nSELECT column_name\nFROM table_name\nLIMIT 10 OFFSET 10;\n```\n\n페이지 번호는 OFFSET을 통해, 페이지에 보여줄 데이터 수는 LIMIT을 통해 설정한다.\n"},{"excerpt":"관계형 데이터베이스 관리 시스템 관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)은\n관계형 데이터 모델을 기반으로 한 데이터베이스 관리 시스템을 말한다.\n대부분의 데이터베이스 시스템은 RDBMS를 기반으로 설계되어 있으며,\n대표적인 RDBMS로는 Oracle, MySQL, PostgreSQL…","fields":{"slug":"/database-rdbms/"},"frontmatter":{"date":"January 03, 2025","title":"관계형 데이터베이스 관리 시스템(RDBMS)","tags":["Database"]},"rawMarkdownBody":"\n## 관계형 데이터베이스 관리 시스템\n\n관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)은\n관계형 데이터 모델을 기반으로 한 데이터베이스 관리 시스템을 말한다.\n대부분의 데이터베이스 시스템은 RDBMS를 기반으로 설계되어 있으며,\n대표적인 RDBMS로는 Oracle, MySQL, PostgreSQL, SQL Server 등이 있다.\n\n## 관계형 데이터 모델\n\n관계형 데이터 모델은 데이터를 테이블 형태로 구조화하여 저장하는 데이터 모델이다.\n하나의 개체에 대한 데이터를 릴레이션에 저장하고, 릴레이션 간의 관계를 통해 데이터를 관리한다.\n그럼 릴레이션이란 무엇일까? 관계형 데이터 모델을 이해하기 위해서는 릴레이션에 대한 이해가 필요하다.\n릴레이션에 대해 알아보자.\n\n## 릴레이션\n릴레이션은 행과 열로 구성된 테이블을 말한다.\n관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이기도 하다.\n여기서 행은 레코드(Record)라고도 하며, 열은 속성(Attribute)이라고 한다.\n\n## 릴레이션 스키마와 릴레이션 인스턴스\n릴레이션은 스키마와 인스턴스로 구분된다.\n릴레이션 스키마(Relation Schema)는 릴레이션의 구조를 정의한 것으로,\n속성의 이름과 도메인을 정의한다.\n릴레이션 인스턴스(Relation Instance)는 릴레이션 스키마에 따라 실제 저장된 데이터를 말한다.\n\n### 릴레이션 스키마\n릴레이션 스키마는 릴레이션의 구조를 정의한 것으로, 속성의 이름과 도메인을 정의한다.\n속성의 이름은 속성을 식별하기 위한 이름인 건 알겠는데, 도메인은 무엇일까?\n도메인은 속성이 가질 수 있는 값의 범위를 정의한 것으로, 속성의 타입을 정의한다.\n컴퓨터는 속성만으로 어떤 타입의 값인지 알 수 없기 때문에, 속성의 도메인을 정의하여 속성의 타입을 명시한다.\n참고로 이런 속성 집합의 개수를 차수(Degree)라고 한다.\n\n예를 들어 만약 상품 릴레이션은 상품명, 가격, 수량의 속성을 가진다면,\n상품명은 문자열, 가격은 숫자, 수량은 정수와 같이 속성의 도메인을 정의할 수 있다.\n\n### 릴레이션 인스턴스\n릴레이션 인스턴스는 릴레이션 스키마에 따라 어느 한 시점에 실제 저장된 데이터의 집합을 의미한다.\n즉, 릴레이션 스키마에 따라 정의된 속성에 실제 데이터가 저장된 것이 릴레이션 인스턴스이다.\n\n예를 들어 상품 릴레이션의 릴레이션 스키마가 상품명, 가격, 수량의 속성을 가지고 있다면,\n상품 릴레이션의 릴레이션 인스턴스는 상품명이 '사과', 가격이 1000원, 수량이 10개인 데이터가 저장된 것이다.\n\n이러한 릴레이션 인스턴스에서 각각의 행을 튜플이라고 하는데, 같은 릴레이션에서의 모든 튜플은 릴레이션 스키마에 따라 같은 속성을 가진다.\n여기서 튜플은 릴레이션 안에서 서로 중복되지 않아야 하는 특성을 가진다.\n릴레이션에서는 이러한 튜플의 개수를 카디널리티(Cardinality)라고 하며, 카디널리티는 투플의 연산 과정에서 수시로 변한다.\n\n### 릴레이션 특징\n위에 설명한 릴레이션의 특성은 다음과 같다.\n\n- 튜플의 유실성: 릴레이션에서는 튜플의 중복이 없어야 한다.\n- 튜플의 무순서: 릴레이션에서는 튜플의 순서가 중요하지 않다.\n- 속성의 무순서: 릴레이션에서는 속성의 순서가 중요하지 않다.\n- 속성의 원자성: 속성 값은 원자 값이어야 한다.\n\n## 키\n\n키는 릴레이션에서 튜플들을 식별하는 역할을 하는 속성 또는 속성들의 집합이라고 할 수 있다.\n튜플을 식별하기 위해서 키는 릴레이션에서 유일한 값을 가져야하는 유일성을 가져야하고,\n최소한의 속성으로 구성되어야 하는 최소성을 가져야 한다.\n키의 종류에는 슈퍼키, 후보키, 기본키, 대체키, 대리키, 외래키 등이 있다.\n\n### 슈퍼키\n슈퍼키는 튜플을 고유하게 식별할 수 있는 속성 또는 속성의 집합을 말한다.\n대상관계의 모든 속성이 함수 종속하는 속성의 집합으로도 정의된다.\n\n후보키와의 차이는, 슈퍼 키는 '고유하게 식별하는 모든 조합'을 뜻하는 점이다.\n즉, 후보 키에 불필요한 속성을 덧붙여 장황하게 한 것은 후보 키는 아니지만 여전히 슈퍼 키이다.\n더 줄일 수 없는 슈퍼 키, 즉 속성의 중복이 없는 슈퍼 키는 후보 키이기도 하다.\n\n### 후보키\n후보키는 슈퍼키 중 더 이상 줄일 수 없는 최소성의 형태을 가진 키를 말한다.\n더 이상 줄일 수 없다는 것은 수퍼 키를 구성하는 속성 중 어느 하나라도 제외될 경우 유일성을 확보할 수 없게 되는 것을 말한다.\n이를 최소성을 만족한다라고도 한다.\n즉, 튜플의 식별을 위해 필요한 특성 또는 그 집합이 후보 키이다.\n후보 키는 튜플의 식별자라고 할 수도 있다.\n후보 키라는 이름은 그것이 기본 키로 선정될 수 있는 후보이기 때문에 유래했다.\n\n하나의 릴레이션에서 관계를 정의할 때, 적어도 하나의 후보 키가 존재한다.\n물론 하나의 릴레이션에 후보 키가 두 개 이상 존재할 수 있다.\n\n### 기본키\n기본 키(primary key)는  \n튜플의 식별자로 이용하기에 가장 적합한 것을 릴레이션마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다.\n유일 키는 0~1개 이상의 속성의 집합으로 볼 수 있다.\n즉, 릴레이션에 저장된 튜플를 고유하게 식별하는 후보 키의 집합 중, 설계자가 일반적으로 이용되어야한다고 정해 놓은 것을 가리킨다.\n\n반드시 기본 키를 사용해야만 하는 경우가 아니면, 다른 후보 키로 대체되어도 기능 수행에는 문제가 없다.\n따라서 기본 키의 이론적 의의는 크지 않지만 실무에서 널리 사용되고 있는 개념이다.\n그러나 기본 키는 NULL의 존재가 허용되지 않지만, 후보 키에 허용이 되는 차이가 있다.  \n릴레이션에 있는 후보 키가 하나인 때에는 그 후보 키가 당연히 기본 키가 된다.\n\n### 대체키\n대체키(Surrogate key)란 자연키에 대한 대체용으로 인공적이거나 합성적인 키를 말하며,\n주로 주민등록번호 같은 중요한 자료를 숨기기 위해 대체키로 사용하거나,\n여러 개의 컬럼을 합성하여 검색 시 속도 향상을 위해 사용한다.\n\n### 대리키\n대리키는 식별자가 너무 길거나 여러 개의 속성으로 구성되어 있는 경우 인위적으로 추가하는 식별자로, 인공키라고도 부른다.\n한 실체에서 식별자가 여러 속성으로 구성된 경우는 데이터를 수정하거나 검색을 하는데 수행 속도가 떨어질 수 있다.\n실체간에 관계가 생길 때 부모의 기본키가 자식의 외부키로 공유 되는데, 외부키가 단일해지기 때문에 조인의 속도를 향상시키기 위해 많이 사용한다.\n\n### 외래키\n외래 키는 참조하는 테이블에서 1개의 키(속성 또는 속성의 집합)에 해당하고,\n참조하는 측의 관계 변수는 참조되는 측의 테이블의 키를 가리킨다.\n참조하는 테이블의 속성의 행 1개의 값은,\n참조되는 측 테이블의 행 값에 대응된다.\n이 때문에 참조하는 테이블의 행에는, 참조되는 테이블에 나타나지 않는 값을 포함할 수 없다.\n이러한 참조 관계는 2개의 테이블을 연관시키기 위한 관계 정규화의 본질적인 부분이다.\n참조하는 테이블의 행 여러 개가, 참조되는 테이블의 동일한 행을 참조할 수 있다.\n참조하는 테이블과 참조되는 테이블이 동일할 수도 있다. 이 경우는 외래 키가 자기 자신을 참조하는 것이다.\n\n## 무결성 제약 조건\n무결성 제약 조건은 데이터를 정확하고 유효하게 유지하는 무결성을 보장하기 위해 설정하는 제약 조건이다.\n위와 같은 키를 통해 데이터의 무결성을 보장하고, 무결성 제약 조건을 통해 데이터의 정확성을 유지할 수 있다.\n무결성 제약 조건에는 개체 무결성, 참조 무결성, 도메인 무결성, 사용자 정의 무결성 등이 있다.\n\n### 개체 무결성\n개체 무결성(Entity integrity)은 고유 키(유일 키)의 개념과 관련된다.\n개체 무결성은 모든 테이블이 기본 키(primary key)를 가져야 하며 기본 키로 선택된 열은 고유하여야 하며 빈 값은 허용치 않음을 규정한다.\n\n### 참조 무결성\n참조 무결성(referential integrity)은 2개의 관련 있던 릴레이션 간의 일관성(데이터 무결성)을 말한다.\n참조 무결성은 종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다.\n참조 무결성이 강제 적용되면 외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다.\n예를 들어, 다른 관계 변수의 외래 키에 의해 참조되는 쌍(dupe 행)을 제거하는 것은 참조 무결성을 파괴해 버리게 되기 때문에 관계 데이터베이스 관리 시스템(RDBMS) 참조 무결성을 유지하도록 일반적으로 삭제를 방지한다.\n예외적으로 참조하는 외래 키를 포함하는 쌍을 연결하고 제거하는 것이 수반되어 삭제를 수행할 수 있으며,이 경우 참조 무결성이 유지된다.\n외부 키에 의해 참조되는 듀프를 제거할 수 있는 지 여부는 데이터 정의 언어(DDL)에 의한 참조 무결성 제약 조건(constraint)에 의해 정의된다.\n\n### 도메인 무결성\n도메인 무결성(Domain integrity)은 정의된 범위에서 관계형 데이터베이스의 모든 열이 선언되도록 규정한다.\n\n## MySQL\nMySQL에 대해 간단히 소개하자면, MySQL은 세계에서 가장 많이 쓰이는 오픈 소스 관계형 데이터베이스 관리 시스템(RDBMS)이다.\n구조질의어 형식의 데이터베이스 관리 시스템으로 오라클이 관리 및 지원하고 있다.\n\n### MySQL 엔진\nMySQL은 사용자가 요청한 파서를 통해 SQL 쿼리를 분석 및 파싱하고,\n옵티마이저를 통해 최적의 실행 계획을 수립하고,\n스토리지 엔진을 호출하여 데이터를 저장하고 관리하는 역할을 한다.\nMySQL 8.0 버전에서는 다음과 같은 스토리지 엔진을 제공한다.\n\n- InnoDB\n- MyISAM\n- Memory\n- CSV\n- Archive\n- Blackhole\n- ND\n\n### InnoDB\nInnoDB는 MySQL의 기본 스토리지 엔진으로,\n트랜잭션 처리와 ACID(Atomicity, Consistency, Isolation, Durability) 특성을 지원한다.\n\nInnoDB는 트랜잭션 롤백, 커밋, 복구같은 장애 복구 기능을 지원한다.\n무결성을 가져하는 중요한 데이터를 필요로할 때 유용하게 사용된다.\n\nInnoDB 테이블은 기본적으로 클러스터형 테이블로 저장된다.\n클러스터형 테이블은 레코드를 기본키 순으로 정렬해서 저장하고,\n기본키에 대한 인덱스를 자동 생성해주기 때문에 기본키를 통한 범위 검색에 유리하다\n\n또한 InnoDB는 레코드의 여러 버전을 유지할 수 있게 해주는 MVCC라는 기술을 통해 트랜잭션이 가능하게 해준다.\n\n추가로 버퍼풀이라는 메모리 영역을 사용하여 데이터를 캐싱하고, 쓰기 지연 용도로 사용하여 디스크 I/O를 줄일 수 있다는 장점이 있다.\n\n\n\n## 참고\n- [InnoDB 스토리지 엔진](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)"},{"excerpt":"데이터 독립성 데이터 독립성(Data Independence)이란 데이터베이스 시스템의 중요한 특징 중 하나로,\n데이터베이스 시스템은 데이터와 응용 프로그램을 독립적으로 관리할 수 있도록 설계되어 있다.\n이러한 데이터 독립성은 데이터베이스의 유지보수와 확장성을 향상시키는 장점을 가진다.\n데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌…","fields":{"slug":"/database-data-independency/"},"frontmatter":{"date":"January 02, 2025","title":"데이터 독립성(Data Independence)","tags":["Database"]},"rawMarkdownBody":"\n\n## 데이터 독립성\n\n데이터 독립성(Data Independence)이란 데이터베이스 시스템의 중요한 특징 중 하나로,\n데이터베이스 시스템은 데이터와 응용 프로그램을 독립적으로 관리할 수 있도록 설계되어 있다.\n이러한 데이터 독립성은 데이터베이스의 유지보수와 확장성을 향상시키는 장점을 가진다.\n데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌 수 있다.\n\n### 논리적 데이터 독립성\n\n논리적 데이터 독립성은 데이터베이스의 논리적 구조와 응용 프로그램 간의 독립성을 의미한다.\n즉, 데이터베이스의 논리적 구조가 변경되어도 응용 프로그램은 영향을 받지 않는다.\n예를 들어, 데이터베이스의 테이블 구조가 변경되어도 쿼리나 트랜잭션은 변경되지 않고 그대로 사용할 수 있다.\n하지만 논리적 데이터 독립성은 한계가 있다.\n컬럼이 추가되거나 삭제되는 경우에는 해당 컬럼을 참조하는 쿼리에서 오류가 발생할 수 있다.\n이로 인해 논리적 데이터 독립성이 완전히 보장되지는 않는다.\n즉, 논리적 데이터 독립성은 주로 데이터베이스 구조의 변경에 따른 영향을 최소화하는 데 중점을 둔다.\n\n### 물리적 데이터 독립성\n\n물리적 데이터 독립성은 데이터베이스의 물리적 구조가 변경되어도 논리적 구조나 데이터의 내용에 영향을 주지 않는 것을 의미한다.\n예를 들어, 파일의 저장 방식이나 인덱스의 구성이 바뀌어도 데이터베이스의 스키마나 데이터는 그대로 유지될 수 있다.\n\n## 스키마\n이러한 데이터 독립성은 데이터베이스의 구조가 변경되더라도 응용 프로그램이나 사용자에게 영향을 주지 않으므로,\n시스템의 안정성과 신뢰성을 높일 수 있다.\n데이터 독립성 보장을 위한 데이터베이스 구조에는 3단계 데이터베이스 구조가 있다.\n3단계 데이터베이스 구조를 알아보기 전에 스키마에 대해 먼저 알아볼 필요가 있다.\n\n스키마는 데이터베이스를 구성하는 데이터 개체(Entity),\n개체의 특성을 나타내는 속성(Attribute),\n개체 사이에 존재하는 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관하여 기술한다.\n이를 메타데이터(MetaData)라고도 한다.\n\n쉽게 말해 DB 내에 데이터가 어떤 구조로 저장되는가를 나타내는 데이터베이스 구조를 스키마라고 한다.\n\n## 3단계 데이터베이스 구조\n\n이제 3단계 데이터베이스 구조에 대해 알아보자.\n앞서 소개한 스키마는 데이터베이스의 전체적인 모습을 보여주는 외부 스키마,\n데이터베이스의 물리적인 저장 방식을 결정하는 내부 스키마,\n그리고 외부 스키마와 내부 스키마 사이의 관계를 매핑하는 개념 스키마로 구성된다\n이렇게 3단계로 나뉘는 데이터베이스 구조를 3단계 데이터베이스 구조라고 한다.\n\n### 외부 스키마\n\n외부 스키마는 사용자의 요구에 따라 데이터베이스의 논리적 구조를 정의하는 것으로,\n사용자의 관점에서 데이터를 접근하고 조작할 수 있도록 한다.\n이러한 외부 스키마는 하나의 데이터베이스 시스템에서 다수로 존재하며,\n하나의 외부 스키마를 여러 응용 프로그램이나 사용자가 공유할 수 있다.\n또한 외부 스키마는 같은 데이터베이스에 대해 서로 다른 논리적 구조를 가질 수 있도록 정의하는 것을 허용하며,\nSQL과 같은 질의어를 이용하여 이를 조작할 수 있다.\n\n### 개념 스키마\n\n개념 스키마는 데이터베이스의 전체적인 논리적 구조로,\n모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다.\n이러한 개념 스키마는 개체간의 관계와 제약 조건을 나타내고\n데이터베이스의 접근 권한, 보안 및 무결성 규칙에 대해 정의를 한다.\n이렇게 개념 스키마는 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것으로,\n단순히 스키마라고 하면 개념 스키마를 의미한다.\n\n### 내부 스키마\n\n내부 스키마는 물리적 저장 방식을 결정하는 것으로, 저장장치와 관련된 세부적인 사항을 정의한다.\n실제로, 내부 스키마는 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고,\n인덱스의 생성 여부, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 결정한다.\n\n### 사상(mapping)\n\n3단계 데이터베이스 구조에서는 외부 스키마와 개념 스키마, 개념 스키마와 내부 스키마 사이의 관계를 매핑(mapping)한다.\n이러한 매핑은 데이터베이스의 논리적 구조와 물리적 구조 사이의 독립성을 보장하며,\n데이터베이스의 논리적 구조가 변경되어도 물리적 구조에 영향을 주지 않도록 한다.\n즉, 데이터 독립성을 실현하는 핵심적인 요소이다.\n위에서 언급했듯이 데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌 수 있으며, 각각의 사상이 이를 보장하는 역할을 한다.\n\n### 외부/개념 사상\n\n외부 스키마와 개념 스키마 사이의 사상을 외부/개념 사상이라고 하며, 응용 프로그램과 데이터베이스 사이의 인터페이스 역할을 한다.\n외부 스키마 사상은 사용자의 요구에 따라 데이터베이스의 논리적 구조를 정의하고, 논리적 데이터 독립성을 보장하는 역할을 한다.\n\n### 개념/내부 사상\n\n개념 스키마와 내부 스키마 사이의 사상을 개념/내부 사상이라고 하며, 데이터베이스의 논리적 구조와 물리적 구조 사이의 매핑을 담당한다.\n개념/내부 사상은 데이터베이스의 논리적 구조가 변경되어도 물리적 구조에 영향을 주지 않도록 하며, 물리적 데이터 독립성을 보장하는 역할을 한다.\n\n## 정리\n\n3단계 데이터베이스 구조를 통해, 사용자와 애플리케이션을 물리적인 데이터베이스로부터 독립시켜,\n데이터베이스의 물리적 구조나 저장 방식이 변경되더라도 사용자나 애플리케이션에 영향을 주지 않도록 한다.\n이를 통해 데이터 독립성을 보장하고, 데이터베이스의 유지보수와 확장성을 향상시킬 수 있다.\n\n## 참고\n\n- [데이터 독립성](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%8F%85%EB%A6%BD%EC%84%B1)\n- [데이터베이스 시스템](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C)\n- [데이터베이스 스키마](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8A%A4%ED%82%A4%EB%A7%88)\n- [데이터베이스 구조](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B5%AC%EC%A1%B0)\n- [데이터베이스 관리 시스템](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C)\n- [데이터베이스 시스템의 구조](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98_%EA%B5%AC%EC%A1%B0)"},{"excerpt":"많은 경우의 클래스들은 하나 이상의 리소스에 의존하는 양상을 띈다.\n알림을 보내는  클래스와 이메일을 보내는  클래스가 있다고 가정해보자.\n는 를 사용하여 이메일을 보낸다.\n여기서 가  리소스에 의존한다고 말한다.\n이때  클래스는 다음과 같이 구현하는 경우가 있다. 정적 유틸리티 클래스(Static Utility Class) 다음 코드는 알림을 보내는 를…","fields":{"slug":"/item-05/"},"frontmatter":{"date":"January 01, 2025","title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n많은 경우의 클래스들은 하나 이상의 리소스에 의존하는 양상을 띈다.\n알림을 보내는 `NotificationService` 클래스와 이메일을 보내는 `EmailSender` 클래스가 있다고 가정해보자.\n`NotificationService`는 `EmailSender`를 사용하여 이메일을 보낸다.\n여기서 `NotificationService`가 `EmailSender` 리소스에 의존한다고 말한다.\n이때 `NotificationService` 클래스는 다음과 같이 구현하는 경우가 있다.\n\n## 정적 유틸리티 클래스(Static Utility Class)\n다음 코드는 알림을 보내는 `NotificationService`를 정적 유틸리티 클래스로 구현한 경우이다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private static final Sender sender = new EmailSender();\n\n    private NotificationService() {\n        throw new AssertionError();\n    }\n\n    public static boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n```\n\n위 코드에서는 `NotificationService` 클래스가 `EmailSender` 리소스에 직접 의존하고 있다.\n이 경우 알림 방식 추가 및 변경을 하기 위해서는 `NotificationService` 클래스를 수정해야 한다.\n또한 정적 메서드는 Mocking이 어렵고, 테스트가 제한되어 어려움이 있다.\n다음 경우를 보자.\n\n## 싱글톤(Singleton)\n다음 코드는 알림을 보내는 `NotificationService`를 싱글톤으로 구현한 경우이다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender = new EmailSender();\n\n    private NotificationService() {\n        throw new AssertionError();\n    }\n\n    public static final NotificationService INSTANCE = new NotificationService();\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n```\n\n위 코드 또한 `NotificationService` 클래스가 `EmailSender` 리소스에 직접 의존하고 있다.\n마찬가지로 알림 방식 추가 및 변경을 하기 위해서는 `NotificationService` 클래스를 수정해야 한다.\n테스트부분 또한 싱글톤 패턴은 Mocking이 어렵고, 테스트가 제한되어 어려움이 있다.\n\n## 의존 객체 주입(Dependency Injection)\n앞서 구현한 두 가지 방식은 `EmailSender`만 사용하는 경우에는 문제가 없지만, 언급했듯이 알림 방식을 추가하거나 변경할 때 문제가 발생한다.\n이처럼 어떤 클래스가 사용할 의존 리소스에 따라 동작이 달라지는 경우에는 정적 유틸리티 클래스나 싱글톤 패턴을 사용하는 것은 부적절해 보인다.\n그럼 `EmailSender` 대신 `SmsSender`를 사용하거나 추가하고 싶다면 어떻게 해야할까?\n이때는 새로운 인스턴스를 생성할 때 생성자에 필요한 리소스를 주입하는 방식을 사용하면 된다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender;\n\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        String MESSAGE = \"Hello, World!\";\n        \n        NotificationService emailNotificationService = new NotificationService(new EmailSender());\n        emailNotificationService.sendNotification(MESSAGE);\n\n        NotificationService smsNotificationService = new NotificationService(new SmsSender());\n        smsNotificationService.sendNotification(MESSAGE);\n    }\n}\n```\n\n앞선 두 가지 경우의 구현과 유사해보이지만 `NotificationService`는 런타임과정에서 생성자를 통해 `Sender` 인터페이스를 구현한 클래스를 주입받는다.\n이렇게 하면 무슨 이점이 있을까?\n`NotificationService`는 `Sender` 인터페이스를 구현한 클래스에만 의존하고 있기 때문에,\n`EmailSender` 대신 `SmsSender`와 같은 다양한 구현체를 사용하거나 추가하는 것이 쉬워져 유연성이 생기게 된다.\n또한 테스트 코드에서는 `Mocking`을 통해 테스트가 용이해진다.\n이 경우, `Mock`을 사용하면 테스트 시 실제 알림 없이도 검증이 가능하다.\n하지만 다른 방식으로 구현한 경우에는 의존성 주입이 불가능해 `Mocking`이 어렵고 테스트가 제한되어 어려움이 있다.\n\n```java\nclass NotificationServiceTest {\n\n    @DisplayName(\"의존 객체 주입 테스트\")\n    @Test\n    public void testNotificationService() throws Exception {\n        //given\n        Sender mockSender = mock(Sender.class);\n        when(mockSender.send(anyString())).thenReturn(false);\n        NotificationService notificationService = new NotificationService(mockSender);\n        //when\n        boolean result = notificationService.sendNotification(\"test\");\n        //then\n        assertThat(result).isFalse();\n        verify(mockSender).send(\"test\");\n    }\n}\n```\n\n위 의존 객체 주입 방식을 변형하여 리소스의 생성을 팩터리 메서드에 위임하는 방식인 팩터리 메서드 패턴(Factory Method Pattern)가 있다.\n이 방식은 `Supplier<T>` 인터페이스가 제공하는 `get()` 메서드를 이용하여 리소스를 생성하는 방식이다.\nSupplier<T>`를 인자로 받는 메서드는 보통 `bounded wildcard type`을 사용하여 제한을 두는 것이 좋다.\n\n```java\npublic class NotificationService {\n    private final Supplier<Sender> senderSupplier;\n\n    public NotificationService(Supplier<Sender> senderSupplier) {\n        this.senderSupplier = senderSupplier;\n    }\n\n    public boolean sendNotification(String message) {\n        return senderSupplier.get().send(message);\n    }\n}\n\nNotificationService service = new NotificationService(() -> new EmailSender());\n```\n\n## DI 프레임워크\n이처럼 의존 객체 주입을 사용하면 유연성이 높아지고 테스트가 용이하지만,\n프로젝트가 커질수록 생성자에 많은 인자가 필요한 경우 관리가 어려워질 수 있다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender;\n\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n\n// 의존성 관리 클래스\npublic class Application {\n    private final NotificationService emailService;\n    private final NotificationService smsService;\n\n    public Application() {\n        Sender emailSender = new EmailSender();\n        Sender smsSender = new SmsSender();\n\n        // 모든 의존성을 수작업으로 생성하고 주입\n        this.emailService = new NotificationService(emailSender);\n        this.smsService = new NotificationService(smsSender);\n    }\n\n    public void run() {\n        emailService.sendNotification(\"Hello Email!\", \"email@example.com\");\n        smsService.sendNotification(\"Hello SMS!\", \"123-456-7890\");\n    }\n\n    public static void main(String[] args) {\n        Application app = new Application();\n        app.run();\n    }\n}\n\n```\n\n이때 DI 프레임워크(컨테이너를) 사용하면 이를 효과적으로 관리할 수 있다.\n`Spring`은 `@Autowired` 어노테이션을 통해 의존성을 자동으로 주입해주며, `@Component` 어노테이션을 통해 `Spring`이 관리하는 빈으로 등록할 수 있다.\n이렇게 하면 `Spring`이 의존성을 관리하고 주입하는 과정을 자동화하여 위 문제를 해결할 수 있다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\n@Component\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\n@Component\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\n// NotificationService에 @Service 추가\n@Service\npublic class NotificationService {\n    private final Sender sender;\n\n    // 의존성 자동 주입\n    @Autowired\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public void sendNotification(String message) {\n        sender.send(message);\n    }\n}\n\n// Application 클래스에 @SpringBootApplication 추가\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n정리하자면 의존하는 리소스가 클래스의 동작에 영향을 미친다면, 정적 유틸리티 클래스나 싱글톤 패턴을 사용하는 것은 부적절하다.\n이러한 경우, 의존 객체 주입을 사용하면 구현체 교체와 테스트가 용이해지고, 코드의 유연성과 유지보수성이 향상된다.\n프로젝트 규모가 커질수록 의존성 주입을 효과적으로 관리하기 위해 DI 프레임워크를 사용하는 것이 좋다.\n\n## 참고\n* [의존성 주입](https://ko.wikipedia.org/wiki/의존성_주입)\n* [Mock](https://www.crocus.co.kr/1555)\n* [Spring DI](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)\n* [팩토리 메소드 패턴](https://ko.wikipedia.org/wiki/팩토리_메서드_패턴)\n* [Supplier 인터페이스](https://docs.oracle.com/javase/8/docs/api///?java/util/function/Supplier.html)"},{"excerpt":"자바가 제공하는 열거형(Enum) 타입은 서로 연관된 상수들의 집합을 의미한다.\n이러한 자바의 열거형을 이해하기 전에 먼저 열거형이 생겨난 이유에 대해 알아야 한다. 문자열과 타입 안전성 다음과 같은 상황을 가정하고 코드를 구현해 가면서 근본적인 문제점을 파악해 보겠다. 요구사항은 다음과 같다.\n고객을 , ,  등급으로 분류하고 각 등급에 따라 할인율을 …","fields":{"slug":"/java-enum/"},"frontmatter":{"date":"December 28, 2024","title":"자바 열거형 타입(Type-Safe Enum Pattern)","tags":["Java"]},"rawMarkdownBody":"\n자바가 제공하는 열거형(Enum) 타입은 서로 연관된 상수들의 집합을 의미한다.\n이러한 자바의 열거형을 이해하기 전에 먼저 열거형이 생겨난 이유에 대해 알아야 한다.\n\n## 문자열과 타입 안전성\n다음과 같은 상황을 가정하고 코드를 구현해 가면서 근본적인 문제점을 파악해 보겠다.\n\n요구사항은 다음과 같다.\n고객을 `BASIC`, `GOLD`, `DIAMOND` 등급으로 분류하고 각 등급에 따라 할인율을 부여한다.\n각각의 할인율은 10%, 20%, 30%이다. 할인 시 소수점 이하는 버린다.\n\n이제 회원 등급과 가격을 입력하면 할인 금액을 계산하는 코드를 구현해보자.\n\n```java\npublic class DiscountService {\n    public int discount(String grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade.equals(\"BASIC\")) {\n            discountPercent = 10;\n        } else if (grade.equals(\"GOLD\")) {\n            discountPercent = 20;\n        } else if (grade.equals(\"DIAMOND\")) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n위 코드에 대해서 설명하자면 `price * discountPercent / 100`는 `가격 * 할인율 / 100`을 계산하여 할인 금액을 구하는 코드이다.\n회원 등급 외 다른 값이 입력되면 가격을 그대로 반환한다. 이 경우 할인율이 0%이므로 가격 그대로 반환하는 것이다.\n상황을 단순화하기 위해 회원 등급에 `null`은 입력되지 않는다고 가정한다.\n\n지금과 같이 단순히 문자열을 사용하여 회원 등급을 구분하는 방식은 문제점이 있다.\n오타가 발생하기 쉽고, 유효하지 않는 값이 입력될 수 있다는 것이다.\n\n이것 또한 코드를 구현해가며 확인해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        // 존재하지 않는 등급을 입력\n        int vip = discountService.discount(\"VIP\", price);\n        System.out.println(\"VIP 등급의 할인 금액: \" + vip);\n\n        // 오타 입력\n        int godl = discountService.discount(\"GODL\", price);\n        System.out.println(\"GODL 등급의 할인 금액: \" + godl);\n        \n        // 소문자 입력\n        int basic = discountService.discount(\"basic\", price);\n        System.out.println(\"basic 등급의 할인 금액: \" + basic);\n    }\n}\n```\n\n위 코드는 다음과 같은 문제가 발생하고 있다.\n먼저 존재하지 않는 등급인 `VIP`를 입력하고 있다.\n그리고 두 번째로는 `GOLD` 등급을 오타로 `GODL`로 입력하고 있다.\n마지막으로는 `BASIC` 등급을 소문자로 입력하고 있다.\n\n이러한 문제의 코드는 문자열 오타가 발생하기 쉽고, 유효하지 않은 값이 입력될 수 있어서 타입 안정성 부족하며,\n`BASIC`, `basic`, `Basic` 등 다양한 형태로 입력될 수 있는 문자열을 입력할 수 있어 데이터의 일관성 또한 떨어진다.\n\n이 문제의 원인은 `String`을 사용하여 회원 등급을 구분하고 있기 때문에 발생한 것이다.\n`String`으로 상태나 카테고리를 표현하면, 이처럼 잘못된 입력이 발생할 수 있다.\n이러한 잘못된 값은 컴파일 시 확인할 수 없고, 런타임 시에 확인할 수 있기에 디버깅이 어려워질 수 있다.\n\n이런 문제를 해결하기 위해서는 입력을 특정 범위로 제한을 해야한다.\n예를 들면 `BASIC`, `GOLD`, `DIAMOND` 등의 값만 `discount()` 메서드에 전달될 수 있도록 제한을 해야한다.\n하지만 `String` 자체에는 문자열이면 무엇이든 할당할 수 있기에 자바 문법 관점에서 아무런 문제가 없다.\n이 말은 즉, `String` 타입을 사용해서는 문제를 해결할 수 없다는 말이 된다.\n\n이런 문제를 해결하기 위한 대안으로 문자열 상수를 사용해서 미리 정의한 변수명만 사용할 수 있게 하는 방법이 있다.\n코드를 통해 알아보도록 하겠다.\n\n```java\npublic class Grade {\n    public static final String BASIC = \"BASIC\";\n    public static final String GOLD = \"GOLD\";\n    public static final String DIAMOND = \"DIAMOND\";\n}\n```\n\n위 코드는 `Grade` 클래스를 생성하고 `BASIC`, `GOLD`, `DIAMOND` 등의 상수를 정의하였다.\n이제 `DiscountService` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class DiscountService {\n    public int discount(String grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade.equals(Grade.BASIC)) {\n            discountPercent = 10;\n        } else if (grade.equals(Grade.GOLD)) {\n            discountPercent = 20;\n        } else if (grade.equals(Grade.DIAMOND)) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n이제 `Main` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        int basic = discountService.discount(Grade.BASIC, price);\n        int gold = discountService.discount(Grade.GOLD, price);\n        int diamond = discountService.discount(Grade.DIAMOND, price);\n\n        System.out.println(\"BASIC 등급의 할인 금액: \" + basic);\n        System.out.println(\"GOLD 등급의 할인 금액: \" + gold);\n        System.out.println(\"DIAMOND 등급의 할인 금액: \" + diamond);\n    }\n}\n```\n\n문자열 상수를 사용한 덕분에 오타를 방지할 수 있고, 유효하지 않은 값이 입력될 수 없게 되었다.\n그리고 `discount()` 메서드에 전달되는 값은 `Grade` 클래스에 정의된 상수만 사용할 수 있게 되었다.\n이 덕분에 만약 `Grade` 클래스에 정의되지 않은 값이 입력되면 컴파일 에러가 발생하게 되고, 오류를 쉽고 빠르게 찾을 수 있게 되었다.\n\n하지만 이 방법에도 문제점이 있다.\n문자열 상수를 사용해도, 지금까지 발생한 문제들을 근본적으로 해결할 수 없다.\n왜냐하면 아직도 `String`을 사용하고 있기 때문에 문자열이면 무엇이든 입력할 수 있기 때문이다.\n여기서 어떤 개발자가 앞서 테스트한 것처럼 `VIP`, `GODL`, `basic` 등의 값이 입력되어도 방지할 수 있는 방법이 없다.\n\n그리고 사용해야 하는 문자열 상수가 어디에 있는지 `discount()` 메서드를 사용하는 개발자가 알아야 한다.\n코드를 보면 `String`은 다 입력 가능하게 되어있다.\n```java\npublic int discount(String grade, int price) {}\n```\n이렇게 되면 `discount()` 메서드를 사용하는 개발자가 `Grade` 클래스에 정의된 상수만 사용해야 한다는 것을 알 수 없다.\n주석을 남기거나 해서 알려줄 수 있지만, 이러한 방법은 개발자가 주석을 읽고 이해해야 하고 주석을 잊어버리고 직접 문자열을 입력할 수 있다.\n이렇게 문자열 상수를 사용하는 방법 또한 문제점이 많다.\n\n## Type-Safe Enum Pattern\n많은 개발자들도 이러한 문제점을 해결하기 위해 오랜기간 고민을 해왔고,\n이를 해결하기 위해 나온 결과가 타입 안전 열거형 패턴(Type-Safe Enum Pattern)이다.\n\n여기서 `Enum`은 `Enumeration`의 줄임말로 번역하면 열거라는 뜻이다.\n즉, 어떤 것을 나열한 것을 뜻한다.\n지금 상황에서는 `BASIC`, `GOLD`, `DIAMOND`이라는 회원 등급을 열거한 것이다.\n여기서 타입 안전 열거형 패턴을 사용하면 이렇게 나열한 항목만 사용할 수 있게 된다는 것이 핵심이다.\n이 말은 즉, `String`처럼 어떤 값이든 입력할 수 있는 것이 아니라, `BASIC`, `GOLD`, `DIAMOND`만 사용할 수 있게 된다는 것이다.\n\n이제 타입 안전 열거형 패턴을 구현하여 문제를 해결해보자.\n\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n}\n```\n\n위 코드는 `Grade` 클래스를 생성하고 `BASIC`, `GOLD`, `DIAMOND` 등의 상수를 선언하였다.\n각각을 상수로 선언하기 위해 `static`과 `final` 키워드를 사용하였다.\n이때 각각의 상수마다 별도의 인스턴스를 생성하고, 생성한 인스턴스를 상수에 할당하였다.\n\n![Enum Instance](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-enum/java-enum_1.png){: width=\"500\" }\n\n코드를 통해 확실한 이해를 해보도록 하겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"class BASIC = \" + Grade.BASIC.getClass());\n        System.out.println(\"class GOLD = \" + Grade.GOLD.getClass());\n        System.out.println(\"class DIAMOND = \" + Grade.DIAMOND.getClass());\n\n        System.out.println(\"ref BASIC = \" + Grade.BASIC);\n        System.out.println(\"ref GOLD = \" + Grade.GOLD);\n        System.out.println(\"ref DIAMOND = \" + Grade.DIAMOND);\n    }\n}\n```\n\n위 코드를 실행하면 다음과 같은 결과가 출력된다.\n\n```java\nclass BASIC = class enumeration.test.Grade\nclass BASIC = class enumeration.test.Grade\nclass BASIC = class enumeration.test.Grade\nref BASIC = enumeration.test.Grade@1b6d3586\nref GOLD = enumeration.test.Grade@4554617c\nref DIAMOND = enumeration.test.Grade@74a14482\n```\n\n각각의 상수는 모두 `Grade` 타입을 기반으로한 인스턴스이기에 `getClass()` 메서드를 호출하면 `Grade` 클래스가 출력된다.\n하지만 각각의 상수는 모두 별도의 `Grade` 인스턴스이기에 서로 다른 메모리 주소를 가지고 있다.\n\n또한 `static`을 사용하여 클래스 변수로 선언하였기에 `Grade` 클래스의 인스턴스를 생성하지 않고도 `Grade.BASIC`, `Grade.GOLD`, `Grade.DIAMOND` 상수를 사용할 수 있다.\n\n이제 `DiscountService` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class DiscountService {\n    public int discount(Grade grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade == Grade.BASIC) {\n            discountPercent = 10;\n        } else if (grade == Grade.GOLD) {\n            discountPercent = 20;\n        } else if (grade == Grade.DIAMOND) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n위 코드에서는 `discount()` 메서드의 매개변수 타입을 `String`에서 `Grade`로 변경하였다.\n또한 값을 비교할 떄는 `grade == Grade.BASIC`와 같이 `==` 연산자를 사용하여 비교하였다.\n\n이제 `Main` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        int basic = discountService.discount(Grade.BASIC, price);\n        int gold = discountService.discount(Grade.GOLD, price);\n        int diamond = discountService.discount(Grade.DIAMOND, price);\n\n        System.out.println(\"BASIC 등급의 할인 금액: \" + basic);\n        System.out.println(\"GOLD 등급의 할인 금액: \" + gold);\n        System.out.println(\"DIAMOND 등급의 할인 금액: \" + diamond);\n    }\n}\n```\n\n이제 `discount()`를 호출할 떄 미리 정의된 `Grade` 클래스의 상수만 사용할 수 있게 되었다.\n\n하지만 이 방법에도 문제점이 있다.\n그것은 외부에서 임의로 `Grade` 클래스의 인스턴스를 생성할 수 있다는 것이다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n\n        Grade vip = new Grade();\n        int vipDiscount = discountService.discount(vip, price);\n        System.out.println(\"VIP 등급의 할인 금액: \" + vipDiscount);\n    }\n}\n```\n\n이 문제를 해결하기 위해서는 생성자를 `private`으로 선언하여 외부에서 인스턴스를 생성할 수 없도록 제한하면 된다.\n\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n이제 `Grade` 클래스의 생성자를 `private`으로 선언하였기에 외부에서 인스턴스를 생성할 수 없게 되었다.\n또한 `Grade` 클래스의 인스턴스는 `BASIC`, `GOLD`, `DIAMOND` 상수만 사용할 수 있게 되었다.\n만일 `Grade` 클래스의 인스턴스를 생성하거나 정의된 값이 아닌 다른 값을 사용하려고 하면 컴파일 에러가 발생하게 된다.\n\n이렇게 함으로써 타입 안전 열거형 패턴을 구현할 수 있었고, 이를 통해 정해진 객체만 사용할 수 있기에 잘몬된 값을 입력하는 문제를 근본적으로 방지할 수 있게 되었다.\n또한 정해진 객체만 사용하므로 데이터의 일관성이 보장된다.\n\n> 참고 <br>\n> **제한된 인스턴스 생성**: 클래스는 사전에 정의된 몇 개의 인스턴스만 생성하고, 외부에서는 이 인스턴스들만 사용할 수 있도록 한다. 이를 통해 미리 정의된 값들만 사용하도록 보장한다.<br>\n> **타입 안전성**: 이 패턴을 사용하면, 잘못된 값이 할당되거나 사용되는 것을 컴파일 시점에 방지할 수 있다. 예를 들어, 특정 메서드가 특정 열거형 타입의 값을 요구한다면, 오직 그 타입의 인스턴스만 전달할 수 있다.\n\n이 패턴을 구현하려면 다음과 같이 코드가 길어지고, `private` 생성자를 선언해야 하는 등 번거로운 작업이 필요하다.\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n## Enum Type\n자바에서는 타입 안전 열거형 패턴을 더 쉽게 구현할 수 있도록 `Enum` 타입을 제공한다.\n`Enum` 타입은 열거형 상수를 정의하고 사용할 수 있도록 한다.\n`Enum` 타입을 사용하면 열거형 상수를 쉽게 정의하고 사용할 수 있으며, `Enum` 타입을 사용하면 `private` 생성자를 선언하거나 인스턴스를 생성하는 등의 작업을 할 필요가 없다.\n\n이제 `Enum` 타입을 사용하여 `Grade` 클래스를 구현해보자.\n\n```java\npublic enum Grade {\n    BASIC, GOLD, DIAMOND\n}\n```\n\n열거형을 정의할 때는 위 코드 처럼 `enum` 키워드를 사용하고, 열거형 상수를 정의하여 나열하면 된다.\n앞서 직접 `Grade` 클래스를 구현할 때와 달리 `private` 생성자를 선언하거나 인스턴스를 생성하는 등의 작업을 할 필요가 없다.\n\n자바의 열거형으로 작성한 `Grade` 클래스는 다음과 거의 같다고 할 수 있다.\n\n```java\npublic class Grade extends Enum {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n열거형도 클래스이다.\n또한 자동(강제)으로 `java.lang.Enum` 클래스를 상속받기 때문에 `Enum` 클래스의 메서드를 사용할 수 있다.\n그리고 `Enum` 클래스는 `private` 생성자를 가지고 있기에 외부에서 인스턴스를 생성할 수 없다.\n생성할 경우 `enum classes may not be instantiated`라는 에러 메시지를 뱉어내며, 컴파일 에러가 발생하게 된다.\n\n이러한 열거형은 사전에 정의된 값만 사용할 수 있기에 타입 안전성을 보장한다.\n그리고 열거형을 사용하면 `static import`와 `switch`를 적절하게 사용할 수도 있고, 이로 인해 코드가 간결해지고 명확해져 가독성이 좋아진다.\n또한 데이터 일관성도 보장할 수 있게 된다.\n만일 새로운 타입을 추가하거나 삭제하려면 `Grade` 열거형에만 추가하거나 삭제하면 되기에 확장성 측면에서도 좋다.\n\n\n### Enum Type의 메서드\n앞서 열거형도 클래스라고 했다.\n그 말은 즉, 열거형 클래스가 제공하는 메서드들을 사용할 수 있다는 것이다.\n\n주요 메서드는 다음과 같다.\n- `values()`: 열거형의 모든 상수를 배열에 담아 반환한다.\n- `valueOf(String name)`: 지정된 이름(name)과 일치하는 열거형 상수를 반환한다.\n- `name()`: 열거형 상수의 이름을 문자열로 반환한다.\n- `ordinal()`: 열거형 상수가 정의된 순서를 반환한다.\n- `toString()`: 열거형 상수의 이름을 문자열로 반환한다.\n\n하지만 여기서 `ordinal()` 메서드는 사용을 지양해야 한다.\n왜냐하면 이 값을 사용하다가 중간에 상수를 선언하는 위치가 변경되면 전체 상수의 순서가 변경되기 때문이다.\n\n### Enum Type 사용한 리팩토링\n이제 `Enum` 타입을 사용하여 `Grade` 클래스 코드를 리팩토링해보자.\n코드의 응집성을 위해 등급별 할인율과 할인 금액을 계산하는 코드를 `Grade` 열거형에 추가하고,\n`DiscountService` 클래스에서 `Grade` 열거형을 사용하도록 코드를 수정했다.\n\n\n```java\npublic enum Grade {\n    BASIC(10), GOLD(20), DIAMOND(30);\n    \n    private final int discountPercent;\n    \n    Grade(int discountPercent) {\n        this.discountPercent = discountPercent;\n    }\n    \n    public int getDiscountPercent() {\n        return discountPercent;\n    }\n    \n    public int discount(int price) {\n        return price * discountPercent / 100;\n    }\n}\n```\n\n여기서 기존 `DiscountService` 클래스의 기능을 `Grade` 열거형에 추가하였다.\n더는 `DiscountService` 클래스에서 할인율을 계산하는 코드를 작성할 필요가 없어졌다.\n\n이제 `main` 메서드를 수정하여 `Grade` 열거형을 사용하도록하고 중복된 코드를 제거하는 방향으로 수정해보겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        Grade[] grades = Grade.values();\n        for (Grade grade : grades) {\n            printDiscount(grade, price);\n        }\n    }\n    \n    private static void printDiscount(Grade grade, int price) {\n        System.out.println(grade.name() + \" 등급의 할인 금액: \" + grade.discount(price));\n    }\n}\n```\n\n이제 `main` 메서드에서는 `Grade` 열거형의 모든 상수를 배열로 가져와서 반복문을 통해 할인 금액을 출력하도록 수정하였다.\n이렇게 함으로써 중복된 코드를 제거하고, 코드의 응집성을 높일 수 있게 되었다."},{"excerpt":"Class 클래스 자바에서  클래스는 클래스의 정보(메타데이터)를 다루는데 사용된다.\n 클래스를 토앻 개발자는 실행 중인 자바 애플리케이션 내에서 필요한 클래스의 정보를 조회하고 조작할 수 있다.  클래스의 주요 기능은 다음과 같다. 타입 정보 얻기: 클래스의 이름, 슈퍼 클래스, 인터페이스, 필드, 메서드, 생성자 정보 등과 같은 정보를 얻을 수 있다.…","fields":{"slug":"/java-class-system/"},"frontmatter":{"date":"December 27, 2024","title":"자바 Class 클래스와 System 클래스","tags":["Java"]},"rawMarkdownBody":"\n# Class 클래스\n자바에서 `Class` 클래스는 클래스의 정보(메타데이터)를 다루는데 사용된다.\n`Class` 클래스를 토앻 개발자는 실행 중인 자바 애플리케이션 내에서 필요한 클래스의 정보를 조회하고 조작할 수 있다.\n\n`Class` 클래스의 주요 기능은 다음과 같다.\n- 타입 정보 얻기: 클래스의 이름, 슈퍼 클래스, 인터페이스, 필드, 메서드, 생성자 정보 등과 같은 정보를 얻을 수 있다.\n- 리플렉션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고, 이들을 통해 클래스의 인스턴스를 생성하거나 메서드를 호출는 등의 작업을 할 수 있다.\n- 동적 로딩과 생성: `Class.forName()` 메서드를 사용해 동적으로 클래스를 로딩하고, `newInstance()` 메서드를 사용해 클래스의 인스턴스를 생성할 수 있다.\n- 애노테이션 처리: 클래스에 적용된 애노테이션 정보를 조회하고, 이를 통해 클래스의 동작을 변경할 수 있는 기능을 제공한다.\n\n예를 들어, `String.class`는 `String` 클래스의 정보를 담고 있는 `Class` 객체를 반환한다.\n이를 통해 `String` 클래스의 정보를 조회하거나 조작할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class stringClass = String.class; //클래스에서 조회 \n        //Class stringClass = \"java.lang.String\".getClass(); // 인스턴스에서 조회\n        //Class stringClass = Class.forName(\"java.lang.String\"); // 문자열로 조회\n        \n        \n        // 모든 필드 조회\n        Field[] fields = stringClass.getDeclared;\n        for (Field field : fields) {\n            System.out.println(\"Field: \" + field.getType() + field.getName());\n        }\n        \n        // 모든 메서드 조회\n        Method[] methods = stringClass.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(\"Method: \" + method.getReturnType() + method.getName());\n        }\n        \n        // 상위 클래스 조회\n        System.out.println(stringClass.getSuperclass()); // class java.lang.Object\n        \n        // 인터페이스 조회\n        Class[] interfaces = stringClass.getInterfaces();\n        for (Class inter : interfaces) {\n            System.out.println(\"Interface: \" + inter.getName());\n        }\n    }\n}\n```\n\n위 코드의 실행 결과는 다음과 같다.\n\n```\nField: class java.lang.Stringvalue\n...\nMethod: class java.lang.StringcharAt\nMethod: class java.lang.StringcodePointAt\n...\nSuperclass: java.lang.Object\nInterface: java.io.Serializable\nInterface: java.lang.Comparable\n```\n\n`Class` 클래스는 다음과 같이 3가지 방법으로 조회할 수 있다.\n```java\nClass stringClass = String.class; //클래스에서 조회\nClass stringClass = \"java.lang.String\".getClass(); // 인스턴스에서 조회\nClass stringClass = Class.forName(\"java.lang.String\"); // 문자열로 조회\n```\n\n## Class 클래스의 주요 메서드\n`Class` 클래스는 다음과 같은 주요 메서드를 제공한다.\n\n- `getDeclaredFields()`: 모든 필드를 조회한다.\n- `getDeclaredMethods()`: 모든 메서드를 조회한다.\n- `getSuperclass()`: 슈퍼 클래스를 조회한다.\n- `getInterfaces()`: 인터페이스를 조회한다.\n\n이러한 메서드들을 통해 해당 클래스의 다양한 정보를 확인할 수 있다.\n\n## 클래스 생성\n`Class` 클래스에는 클래스의 모든 정보가 담겨 있기 때문에, 이를 통해 클래스의 인스턴스를 생성하거나, 메서드를 호출하고, 필드의 값도 변경할 수 있다.\n이 문단에서는 간단하게 클래스의 인스턴스를 생성하는 방법을 알아본다.\n\n```java\npublic class Hello {\n    public void hello() {\n        System.out.println(\"Hello, Java!\");\n    }\n}\n```\n\n위와 같은 `Hello` 클래스가 있다고 가정하자.\n이 클래스의 인스턴스를 생성하고, `hello()` 메서드를 호출하는 코드는 다음과 같다.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class helloClass = Hello.class;\n        Hello hello = (Hello) helloClass.getDeclaredConstructor().newInstance();\n        hello.hello();\n    }\n}\n```\n\n위 코드의 실행 결과는 다음과 같다.\n\n```\nHello, Java!\n```\n\n코드에서 사용된 `getDeclaredConstructor().newInstance()` 메서드에 기능은 다음과 같다.\n`getDeclaredConstructor()` 메서드를 통해 클래스의 생성자를 조회하고, `newInstance()` 메서드를 통해 생성자를 호출하여 인스턴스를 생성한다.\n\n## 리플렉션(Relfection)\n`Class` 클래스를 통해 클래스의 메타 데이터를 기반으로 클래스의 인스턴스를 생성하거나, 메서드를 호출하는 등의 작업을 할 수 있다.\n이러한 작업을 리플렉션(Reflection)이라고 한다.\n추가로 애노테이션 정보를 읽어서 특별한 기능을 수행하거나 클래스의 동작을 변경하는 등의 작업도 가능하다.\n최신 프레임워크들은 리플렉션을 적극 활용하여 다양한 기능을 제공하고 있다.\n\n# System 클래스\n\n`System` 클래스는 자바 프로그램과 관련된 시스템과 관련된 정보를 다루는데 사용된다.\n주요 기능을 코드를 통해 알아보겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 현재 시간(밀리초)를 가져온다.\n        long currentTimeMillis = System.currentTimeMillis();\n        System.out.println(\"currentTimeMillis: \" + currentTimeMillis);\n\n        // 현재 시간(나노초)를 가져온다.\n        long currentTimeNano = System.nanoTime();\n        System.out.println(\"currentTimeNano: \" + currentTimeNano);\n        \n        // 환경 변수를 읽는다.\n        System.out.println(\"getenv = \" + System.getenv());\n        \n        // 시스템 속성을 읽는다.\n        System.out.println(\"properties = \" + System.getProperties());\n        System.out.println(\"Java version: \" + System.getProperty(\"java.version\"));\n        \n        // 배열을 고속으로 복사한다.\n        char[] originalArray = new char[]{'h', 'e', 'l', 'l', 'o'};\n        char[] copiedArray = new char[5];\n        System.arraycopy(originalArray, 0, copiedArray, 0,\n                originalArray.length);\n        \n        // 배열 출력\n        System.out.println(\"copiedArray = \" + copiedArray);\n        System.out.println(\"Arrays.toString = \" + Arrays.toString(copiedArray));\n        \n        //프로그램 종료\n        System.exit(0);\n    }\n}\n```\n\n- 표준 입력, 출력, 에러 스트림: `System.in`, `System.out`, `System.err` 필드를 통해 표준 입력, 출력, 에러 스트림을 사용할 수 있다.\n- 시간 측정: `System.currentTimeMillis()`, `System.nanoTime()`를 통해 현재 시간을 밀리초, 나노초 단위로 가져올 수 있다.\n- 환경 변수 읽기: `System.getenv()`를 통해 환경 변수를 읽을 수 있다.\n- 시스템 속성 읽기: `System.getProperties()`로 시스템 속성을 읽을 수 있고, `System.getProperty(String key)` 메서드를 통해 특정 속성을 읽을 수 있다.\n- 시스템 종료: `System.exit(int status)`를 통해 프로그램을 종료할 수 있다. 여기서 `status`는 종료 상태를 나타낸다. 일반적으로 0은 정상 종료, 그 외의 값은 비정상 종료를 의미한다.\n- 배열 고속 복사: `System.arraycopy()`는 시스템 레벨에서 최적화된 방식으로 메모리 복사를 연산을 수행한다. 직접 반복문을 사용해서 배열을 복사하는 것보다 수 배 이상 빠른 성능을 제공한다.\n\n"},{"excerpt":"Wrapper Class 자바에서 기본형 타입을 객체로 다루기 위해 제공하는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n래퍼 클래스는 기본형의 한계 때문에 객체로 다루어야 할 때 사용한다. 기본형의 한계 자바는 객체 지향 언어이지만, 자바가 제공하는 것들 중 객체가 아닌 것들이 있다.\n그것들은 , , ,  등과 같은 기본형(Primitiv…","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"date":"December 26, 2024","title":"래퍼 클래스(Wrapper Class)","tags":["Java"]},"rawMarkdownBody":"\n# Wrapper Class\n자바에서 기본형 타입을 객체로 다루기 위해 제공하는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n래퍼 클래스는 기본형의 한계 때문에 객체로 다루어야 할 때 사용한다.\n\n## 기본형의 한계\n자바는 객체 지향 언어이지만, 자바가 제공하는 것들 중 객체가 아닌 것들이 있다.\n그것들은 `int`, `char`, `float`, `double` 등과 같은 기본형(Primitive Type)이다.\n기본형은 앞서 말했듯이 객체가 아니기에 다음과 같은 한계가 있다.\n\n## 객체가 아니기에 발생하는 한계\n\n계속 언급했듯이 기본형 데이터는 객체가 아니기 때문에, 객체 지향 프로그래밍의 특징과 장점을 살릴 수 없다.\n예를 들자면 객체는 유용한 메서드를 가지고 있고 제공할 수 있지만, 기본형은 객체가 아니기에 메서드를 가질 수도 제공할 수도 없다.\n그리고 객체 참조가 필요한 컬렉션 프레임워크를 사용할 수 없고, 제네릭 또한 사용할 수 없다.\n\n기본형의 한계를 이해하기 위해 코드로 예시를 들어보겠다.\n예시 코드는 두 값을 비교해서 다음과 같은 결과를 출력한다\n- 두 값이 같다면 `0`\n- 첫 번째 값이 더 크다면 `1`\n- 두 번째 값이 더 크다면 `-1`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int value = 10;\n        int intValue1 = compareTo(value, 5);\n        int intValue2 = compareTo(value, 10);\n        int intValue3 = compareTo(value, 15);\n\n        System.out.println(\"intValue1: \" + intValue1);\n        System.out.println(\"intValue2: \" + intValue2);\n        System.out.println(\"intValue3: \" + intValue3);\n    }\n\n    public static int compareTo(int value, int target) {\n        if (value < target) {\n            return -1;\n        } else if (value > target) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n```\n\n위 코드는 `value`와 비교 대상 값을 `compareTo` 메서드에 넘겨주어 비교한 후 결과를 출력한다.\n그런데 자기 사신인 `value`와 다른 값을 연산하는 것이기에 항상 자기 자신의 값인 `value`가 사용된다.\n이런 경우 만약 `value`가 객체라면 `value` 객체 스스로 자기 자신의 값과 비교 대상 값을 비교할 수 있는 메소드를 만드는 것이 더 효율적일 것이다.\n\n그래서 이런 한계를 극복하기 위해 자바는 기본형을 객체로 다루기 위한 래퍼 클래스를 제공한다.\n이 문단에서는 래퍼 클래스를 구현해서 기본형의 한계를 극복하는 방법을 알아보겠다.\n\n먼저 `int`를 객체로 다루기 위한 래퍼 클래스를 구현해보자.\n`int`는 클래스가 아니지만, `int` 값을 가지고 있는 객체를 만들어서 `int`를 객체로 다룰 수 있다.\n다음 코드는 `int`를 객체로 다루기 위한 래퍼 클래스를 구현한 코드이다.\n이렇게 특정 기본형을 감싸서(Wrap) 객체로 만들어주는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n\n```java\npublic class IntWrapper {\n    \n    private final int value;\n\n    public IntWrapper(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public int compareTo(int target) {\n        if (value < target) {\n            return -1;\n        } else if (value > target) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    \n    @Override\n    public String toString() {\n        return String.valueOf(value);tring\n    }\n}\n```\n\n위 코드에서 `IntWrapper` 클래스는 `int` 값을 가지고 있는 객체를 만들어주는 래퍼 클래스이다.\n이를 통해 기본형 변수를 편리하게 사용할 수 있도록 다양한 메소드를 제공한다.\n앞에서 구현한 `compareTo` 메서드를 `IntWrapper` 클래스에 내부로 캡슐화하여 구현했다.\n그리고 이클래스는 불변으로 만들기 위해 `value` 필드를 `final`로 선언했다.\n\n이제 `IntWrapper` 클래스를 사용해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntWrapper value = new IntWrapper(10);\n        int intValue1 = value.compareTo(5);\n        int intValue2 = value.compareTo(10);\n        int intValue3 = value.compareTo(15);\n\n        System.out.println(\"intValue1: \" + intValue1);\n        System.out.println(\"intValue2: \" + intValue2);\n        System.out.println(\"intValue3: \" + intValue3);\n    }\n}\n```\n\n위 코드는 `IntWrapper` 클래스의 `compareTo` 메서드를 사용하여 `value`와 비교 대상 값을 비교한다.\n`IntWrapper`는 객체이기에 예시 코드처럼 자신이 가진 메서드를 편리하게 호출할 수 있다.\n\n## null 값을 가질 수 없는 한계\n\n기본형은 항상 값을 가져야 한다. 하지만 프로그래밍을 하다보면 상황에 따라 데이터가 없는 경우가 발생한다.\n그리고 이때 데이터가 없음을 나타내기 위해 `null`이라는 상태가 필요할 수 있다.\n하지만 기본형은 `null` 값을 가질 수 없기 때문에 이런 상황을 처리하기 어렵다.\n\n해당 상황에 대한 예시 코드를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int[] values = {-1, 0, 1, 2, 3};\n        System.out.println(findValue(values, -1)); // -1\n        System.out.println(findValue(values, 0)); // 0\n        System.out.println(findValue(values, 1)); // 1\n        System.out.println(findValue(values, 100)); // -1\n    }\n\n    public static int findValue(int[] values, int target) {\n        for (int value : values) {\n            if (value == target) {\n                return value;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n위 코드는 `findValue` 메서드를 사용하여 배열에서 특정 값을 찾는다.\n그리고 해당 값이 있으면 값을 반환하고, 없으면 `-1`을 반환한다.\n`findValue`는 결과로 항상 `int`를 반환하게 되는데, 이때 `int`와 같은 기본형은 항상 값이 있어야 한다.\n여기서도 값을 반환할 때 값을 찾지 못한다면 숫자 중에 하나를 반환해야 하는데 보통 이때는 `-1`이나 `0`을 반환한다.\n\n하지만 이런 경우에는 `-1`이나 `0`이 실제로 배열에 있는 값일 수도 있다.\n코드를 보면 `-1`일 때 `-1`을 반환하는 경우가 있는데, 배열에 없는 값 `100`을 입력해도 같은 `-1`을 반환한다.\n그래서 이런 경우에는 `-1`을 반환하는 것이 정상적인 결과인지 아닌지 판단하기 어렵다.\n\n객체의 경우는 이런 상황에서 데이터가 없다는 것을 나타내기 위해 `null`을 사용할 수 있다.\n그럼 이제 `null`을 가질 수 있는 래퍼 클래스를 이용한 코드를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntWrapper[] values = {new IntWrapper(-1), new IntWrapper(0), new IntWrapper(1), new IntWrapper(2), new IntWrapper(3)};\n        System.out.println(findValue(values, new IntWrapper(-1))); // -1\n        System.out.println(findValue(values, new IntWrapper(0))); // 0\n        System.out.println(findValue(values, new IntWrapper(1))); // 1\n        System.out.println(findValue(values, new IntWrapper(100))); // null\n    }\n    \n    private static IntWrapper findValue(IntWrapper[] values, IntWrapper target) {\n        for (IntWrapper value : values) {\n            if (value.equals(target)) {\n                return value;\n            }\n        }\n        return null;\n    }\n}\n```\n\n위 코드에선 앞서 구현해놓은 `IntWrapper` 클래스를 사용하여 `null`을 반환할 수 있는 `findValue` 메서드를 구현했다.\n실행결과를 보면 `findValue` 메서드는 배열에서 특정 값을 찾아서 반환하는데, 값이 없다면 `null`을 반환한다.\n이렇게함으로써 `null`을 반환하면 값이 없다는 것을 명확하게 나타낼 수 있다.\n\n앞선 `IntWrapper`를 사용하지 않은 예시에서도 본 것 처럼 기본형은 항상 값이 존재해야 한다.\n반면에 객체인 참조형은 값이 없다는 `null`을 사용할 수 있다.\n물론 `null` 값을 반환하는 경우 잘못하면 `NullPointerException`이 발생할 수 있기 때문에 주의해서 사용해야 한다.\n\n## 자바 래퍼 클래스\n위에서 설명한 것처럼 래퍼 클래스는 기본형을 객체로 감싸서 더 편리하게 사용할 수 있도록 다양한 기능을 제공하기에 상당히 유용하다는 것을 알 수 있었다.\n지금까지 설명은 기본형의 한계로 인한 래퍼 클래스에 대한 필요성을 이해하고자 설명을 한 것이다.\n그래서 자바에서는 기본형을 객체로 다루기 위한 래퍼 클래스를 제공한다.\n\n자바는 다음과 같이 기본형에 대응하는 래퍼 클래스를 기본으로 제공한다.\n- `byte`: `Byte`\n- `short`: `Short`\n- `int`: `Integer`\n- `long`: `Long`\n- `float`: `Float`\n- `double`: `Double`\n- `char`: `Character`\n- `boolean`: `Boolean`\n\n그리고 자바가 제공하는 기본 래퍼 클래스는 다음과 같은 특징을 가진다.\n- 불변(Immutable)이어서 값을 변경할 수 없다.\n- `equals()`로 값을 비교해야한다.\n\n### 박싱(Boxing)\n앞서 말해듯이 자바의 기본 래퍼 클래스는 기본형을 객체로 다루기 위해 존재한다.\n기본형을 객체로 다루기 위해 래퍼 클래스로 변경하는 모습이 마치 상자에 기본형을 담는 것과 같다고 해서 이런 행위를 박싱(Boxing)이라고 한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int intValue = 10;\n        Integer integerValue = Integer.valueOf(intValue); // Boxing\n    }\n}\n```\n\n### 언박싱(Unboxing)\n박싱과 반대로 래퍼 클래스를 기본형으로 변경하는 것을 언박싱(Unboxing)이라고 한다.\n박스에 담겨져 있는 것을 꺼내는 것 같다고 해서 이런 행위를 언박싱이라고 한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue = Integer.valueOf(10);\n        int intValue = integerValue.intValue(); // Unboxing\n    }\n}\n```\n\n### 비교는 equals() 사용\n래퍼 클래스는 객체이기에 `==` 연산자로 비교하면 주소값을 비교하게 된다.\n그래서 래퍼 클래스는 `equals()` 메서드를 재정의하여 내부의 값을 비교하도록 구현되어 있다.\n따라서 래퍼 클래스의 값을 비교할 때는 `equals()` 메서드를 사용해야 한다.\n참고로 래퍼 클래스 객체를 그대로 출해도 내부의 값을 출력하도록 `toString()` 메서드 역시 재정의되어 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue1 = Integer.valueOf(10);\n        Integer integerValue2 = Integer.valueOf(10);\n        System.out.println(integerValue1 == integerValue2); // false\n        System.out.println(integerValue1.equals(integerValue2)); // true\n    }\n}\n```\n\n### 오토 박싱(Auto Boxing)과 오토 언박싱(Auto Unboxing)\n자바에서는 기본형에서 래퍼 클래스로 변환하는 작업이 자주 발생하기 때문에 이를 편리하게 사용할 수 있도록 오토 박싱(Auto Boxing)과 오토 언박싱(Auto Unboxing) 기능을 제공한다.\n여기서 오토 박싱은 기본형을 래퍼 클래스로 자동으로 변환하는 것이고, 오토 언박싱은 래퍼 클래스를 기본형으로 자동으로 변환하는 것이다.\n자동으로 변환되기 때문에 개발자는 이를 명시적으로 변환하지 않아도 된다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue = 10; // Auto Boxing\n        int intValue = integerValue; // Auto Unboxing\n    }\n}\n```\n\n## 래퍼 클래스 주요 메서드\n래퍼 클래스는 기본형을 객체로 다루기 위한 클래스이기에 기본형과 관련된 다양한 메서드를 제공한다.\n래퍼 클래스의 주요 메서드는 다음과 같다.\n\n- `valueOf()`: 기본형 값을 래퍼 클래스 객체로 변환한다.\n- `parseInt()`: 문자열을 정수로 변환한다.\n- `compareTo()`: 두 값을 비교한다.\n- `Integer.sum()`, `Integer.max()`, `Integer.min()`: `static` 메서드로 두 값을 더하거나 최대값, 최소값을 구한다.\n\n### parseInt()와 valueOf()\n`parseInt()`와 `valueOf()` 메서드는 문자열을 정수로 변환하는 메서드이다.\n`parseInt()`는 정적 메서드로 문자열을 정수로 변환하고, `valueOf()`는 인스턴스 메서드로 문자열을 정수로 변환한다.\n- `parseInt(\"10\")`은 기본형인 `int`를 반환한다.\n- `valueOf(\"10\")`은 래퍼 클래스인 `Integer`를 반환한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int intValue1 = Integer.parseInt(\"10\");\n        Integer integerValue2 = Integer.valueOf(\"10\");\n    }\n}\n```\n\n## 래퍼 클래스 성능\n래퍼 클래스는 객체이기에 기본형보다 다양한 메서드를 제공하고 편리하게 사용할 수 있다.\n근데 그렇다면 기본형 보다 좋은 래퍼 클래스만 사용하면 되지 왜 기본형을 제공하고 사용하는 것일까?\n다음 코드를 통해 래퍼 클래스와 기본형의 성능 차이를 알아보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int iterations = 1_000_000_000;\n        long startTime, endTime;\n        long sumPrimitive = 0;\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < iterations; i++) {\n            sumPrimitive += i;\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"기본 자료형 연산 경과 시간: \" + (endTime - startTime) + \"ms\");\n        \n        Long sumWrapper = 0L;\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < iterations; i++) {\n            sumWrapper += i;\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"래퍼 클래스 연산 경과 시간: \" + (endTime - startTime) + \"ms\");\n        \n    }\n}\n```\n\n단순히 값을 반복해서 10억번 더하는 코드를 작성했다.\n그리고 기본형 `long`과 래퍼 클래스 `Long`을 사용하여 성능을 비교했다.\n결과는 다음과 같다.\n\n```java\n기본 자료형 연산 경과 시간: 361ms\n래퍼 클래스 연산 경과 시간: 1828ms\n```\n\n물론 시스템 성능의 따라 다르겠지만, 기본형 연산이 래퍼 클래스 연산보다 약 5배 정도 빠르다는 것을 확인 할 수 있다.\n그 이유는 기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지한다. 예를들면 `int`는 4바이트, `long`은 8바이트이다.\n하지만 래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 외에도 자바에서 객체를 다루는데 필요한 객체 메타데이터를 포함하므로 더 많은 메모리를 차지한다.\n대략 래퍼 클래스는 기본형의 2배 정도의 메모리를 차지한다.\n\n### 유지보수와 최적화\n그럼 뭐를 사용하라는 것일까?\n아까는 래퍼 클래스가 기본형보다 편해서 좋다고 했다가,\n지금은 기본형이 래퍼 클래스보다 성능이 좋다고 했다가\n혼란스럽지 않은가?\n\n앞서 실험한 코드를 보면 5배라는 성능 차이는 10억번의 연산을 수행했을 때 발생한 것이다.\n기본형이든 래퍼 클래스든 이것을 1회로 환산하면 둘 다 매우 빠르게 연산이 수행된다.\n즉 10억번 연산의 결과인 0.3초와 1.8초라는 차이는 사실 1번 연산의 결과로 환산하면 0.3초 나누기 10억과 1.8초 나누기 10억이라는 매우 작은 차이이다.\n일반적인 애플리케이션을 만드는 관점에서 봤을 때 이정도의 성능 차이는 최적화를 한다 해도 큰 의미가 없다.\n\n만약 이렇게 유지보수와 최적화를 두고 둘중에 하나를 선택해야 한다면 유지보수를 먼저 고려하는 것이 좋다.\n우선 요즘 컴퓨터는 매우 빠르기 때문에 이정도의 성능 차이는 크게 의미가 없다.\n그리고 코드 변경 없이 성능 최적화를 하면 가장 좋겠지만, 성능 최적화는 대부분 단순함보다 복잡함을 요구하고, 더 많은 코드를 추가로 작성해야 한다.\n이는 최적화를 위해 유지보수 해야 할 코드가 늘어난다는 것이다.\n그런데 여기서 진짜 문제는 최적화를 한다고 했지만 전체 애플리케이션의 성능 관점에서 보면 불필요한 최적화일 수 있다.\n시간과 노력을 들여서 최적화를 했지만, 전체 애플리케이션의 성능에는 큰 영향을 미치지 않는다면 그것은 얼마나 비효율적인가?\n\n특히 웹 어플리케이션의 경우, 메모리 안에서 발생하는 연산 속도보다 네트워크 호출 속도가 수천수만배는 더 느리다.\n이 말은 자바 메모리 내부에서 발생하는 연산을 수천번에서 한 번으로 줄이는 것보다, 네트워크 호출 한 번을 줄이는 것이 훨씬 더 중요하다는 것이다.\n그래서 성능 최적화를 할 때는 전체 애플리케이션의 성능을 고려해야 한다.\n\n\n"},{"excerpt":"String Optimization 자바 컴파일러는 다음과 같이 문자열을 처리하는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다. String literal 결합 최적화 위 코드는 과 를 합쳐 에 저장하는 코드이다. 하지만 자바 컴파일러는 이 코드를 다음과 같이 최적화하여 처리한다. 컴파일과정에서 문자열을 합치는 코드를 만나면, 이를 최적화하…","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"date":"December 24, 2024","title":"문자열 최적화(String Optimization)","tags":["Java"]},"rawMarkdownBody":"\n# String Optimization\n자바 컴파일러는 다음과 같이 문자열을 처리하는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다.\n\n## String literal 결합 최적화\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\nString str3 = str1 + str2;\n```\n\n위 코드는 `str1`과 `str2`를 합쳐 `str3`에 저장하는 코드이다. 하지만 자바 컴파일러는 이 코드를 다음과 같이 최적화하여 처리한다.\n\n```java\nString str3 = \"HelloWorld\";\n```\n\n컴파일과정에서 문자열을 합치는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다.\n따라서 런타임에 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상된다.\n\n## String 변수 최적화\n문자열 변수의 경우 그 안에 어떤 문자열이 들어있는지 컴파일 시점에서는 알 수 없기 때문에, 단순하게 결합할 수 없다.\n\n```java\nString result = str1 + str2;\n```\n\n이런 상황인 경우, 다음과 같이 최적화를 수행한다.(최적화 방식은 자바 버전에 따라 다를 수 있다.)\n\n```java\nString result = new StringBuilder().append(str1).append(str2).toString();\n```\n\n> 참고\n> 자바 9부터는 `StringConcatFactory` 클래스를 통해 `invokedynamic`를 사용하여 문자열 결합 최적화를 수행한다.\n\n이렇듯 자바가 최적화 처리해주기 때문에 간단한 경우에는 `StringBuilder`를 사용하지 않아도 된다.\n\n## String 최적화가 어려운 경우\n하지만 다음과 같이 문자열을 루프안에서 문자열을 결합하는 경우에는 최적화가 이루어지지 않는다.\n\n```java\nString result = \"\";\nfor (int i = 0; i < 10000; i++) {\n    result += i;\n}\n```\n\n왜냐하면 루프안에서 문자열을 결합할 때마다 다음과 같이 새로운 문자열을 생성하기 때문이다.\n\n```java\nString result = \"\";\nfor (int i = 0; i < 10000; i++) {\n    result = new StringBuilder().append(result).append(i).toString();\n}\n```\n\n반복문의 내부에서는 최적화가 되는 것 처럼 보이지만, 실제로는 반복 횟수만큼 새로운 문자열을 생성하고 이를 참조하게 된다.\n반복문 내에서의 문자열 연결은 런타임에 연결할 문자열의 개수와 내용이 결정된다.\n이런 경우, 컴파일러는 얼마나 많은 반복이 일어날지, 각 반복에서 어떤 문자열이 결합될지 알 수 없기 때문에 최적화를 수행하기에 어려움이 있다.\n\n`StringBuffer`도 마찬가지로 최적화가 이루어지지 않을 것이다.\n아마도 대략 반복 횟수인 10,000번만큼 `StringBuffer` 객체를 생성하고, 이를 참조하게 했을 것이다.\n\n위 코드를 실행하면, `String`을 사용한 경우에는 약 1초 정도가 걸렸다.\n이럴 떄는 `StringBuilder`를 사용하면 된다.\n\n```java\nStringBuilder result = new StringBuilder();\nfor (int i = 0; i < 10000; i++) {\n    result.append(i);\n}\n```\n\n`StringBuilder`를 사용한 경우에는 1ms도 걸리지 않는다.\n\n정리를 하자면 문자열을 결합하는 상황의 대부분의 경우 최적화가 되므로 `+` 연산을 사용하면 된다.\n하지만 `StringBuiler`를 사용하는 것이 더 좋은 경우도 있다.\n\n\n## StringBuilder를 직접 사용하는 것이 더 좋은 경우\n반복문에서 반복해서 문자를 연결할 때\n조건문을 통해 동적으로 문자열을 조합할 때\n복잡한 문자열의 특정 부분을 변경해야 할 때\n매우 긴 대용량 문자열을 다룰 때\n\n> 참고 - StringBuilder vs StringBuffer\n> `StringBuilder` 와 똑같은 기능을 수행하는 `StringBuffer` 클래스도 있다.\n> `StringBuffer` 는 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인해 성능이 느리다.\n> `StringBuilder` 는 멀티 쓰레드에 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 속도가 빠르다.\n> 자세한 내용은 [String vs StringBuilder vs StringBuffer](https://023-dev.github.io/2024-11-05/java-string-stringbuffer-stringbuilder)를 참고하면 되겠다.\n\n## StringBuilder와 Method Chain\n`String`은 `char[]`를 보다 효율적이고 쉽게 다룰 수 있도록 한 클래스이다.\n`StringBuilder` 또한 이러한 기능들을 제공하는데 그 중 하나가 메서드 체인(Method Chain)이다.\n\n`StringBuilder`의 `append()` 메서드의 내부코드를 보면 `this`로 자기 자신의 참조값을 반환하고 있다.\n\n```java\npublic StringBuilder append(String str) {\n    super.append(str);\n    return this;\n}\n```\n\n`StringBuilder`에서 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 `this`를 반환하고 있다.\n이를 이용하면 다음과 같이 메서드를 연쇄적으로 호출할 수 있다.\n\n대표적으로 `insert()`, `delete()`, `reverse()`, `replace()` 등이 있다.\n\n앞서 `StringBuilder`를 사용한 코드를 다음과 같이 개선할 수 있다.\n\n```java\nStringBuilder sb = new StringBuilder();\nString string = sb.append(\"A\").append(\"B\").append(\"C\").append(\"D\")\n        .insert(4, \"Java\")\n        .delete(4, 8)\n        .reverse()\n        .toString();\n\nSystem.out.println(string); // DCBA\n```\n\n이렇게 메서드 체인을 사용하면 코드가 간결해지고 가독성이 좋아진다.\n메서드 체이닝의 구현은 복잡하고 번거롭지만 사용하는 입장에서는 편리함을 경험할 수 있다.\n자바의 라이브러리와 오픈 소스들은 메서드 체이닝 기법을 많이 사용하고 있다.\n\n"},{"excerpt":"불변 객체(Immutable Object) 객체의 상태(객체 내부 데이터, 필드, 속성)가 객체의 수명 동안 변하지 않는 객체를 불변 객체(Immutable Object)라고 한다.\n불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다. 자바에서 가장 많이 사용되는  또한 불변 객체이다.\n뿐만…","fields":{"slug":"/java-immutable/"},"frontmatter":{"date":"December 23, 2024","title":"불변 객체(Immutable Object)","tags":["Java"]},"rawMarkdownBody":"\n# 불변 객체(Immutable Object)\n객체의 상태(객체 내부 데이터, 필드, 속성)가 객체의 수명 동안 변하지 않는 객체를 불변 객체(Immutable Object)라고 한다.\n불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다.\n\n자바에서 가장 많이 사용되는 `String` 또한 불변 객체이다.\n뿐만 아니라 자바가 기본적으로 제공하는 래퍼클래스나 `LocalDate`, `LocalTime`, `LocalDateTime` 등도 불변으로 설계되어 있다.\n이러한 클래스를 제대로 활용하기 위해서는 불변 객체에 대한 원이를 제대로 이해해야 할 것이다.\n\n## 불변 객체 설계\n불변 클래스는 다음 코드와 같이 만들 수 있다.\n\n```java\npublic class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n위 코드에서 `ImmutablePerson` 클래스는 `name`과 `age` 필드를 가지고 있다.\n내부 값이 변경되지 않기 위해 필드를 `final`로 선언하고, 생성자를 통해 필드 값을 초기화를 제한한다.\n또한 값을 변경할 수 있는 `setter` 메소드를 제공하지 않는다.\n이 클래스는 생성자를 통해 값을 초기화하고, 이후에는 값을 변경하는 것이 불가능하다.\n\n이렇듯 불변 클래스를 만드는 방법은 아주 단순하다.\n어떻게든 객체의 상태를 변경하는 메소드를 제공하지 않고, 객체의 상태를 변경할 수 없도록 만들면 된다.\n\n이러한 불변이라는 단순한 제약을 사용해서 참조형 객체를 사용할 때 발생할 수 있는 사이드 이펙트라는 문제를 방지할 수 있다.\n하지만 불변 객체는 설계상 값을 변경할 수 없다.\n따라서 불변 객체의 값을 변경하고자 한다면 변경하고 싶은 값으로 새로운 불변 객체를 생성해야 한다.\n이렇게 해야 기존 변수들이 참조하는 값에 영향을 주지 않고 새로운 값을 생성할 수 있다.\n\n> 참고 - 가변(Mutable) 객체와 불변(Immutable) 객체\n> 가변은 이름 그대로 처음 만든 이후 상태가 변할 수 있는 객체를 의미한다.\n> 가변 객체는 객체의 상태가 변할 수 있기 때문에 객체를 생성한 시점의 상태를 유지하지 않으며, 객체의 상태를 변경할 수 있다.\n> 불변은 처음 만든 이후 상태가 변하지 않는 객체를 의미한다.\n> 불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다.\n\n## 값 변경\n이러한 불변 객체를 사용하지만 그래도 값을 변경해야 하는 경우가 있다.\n그럼 어떻게 해야 할까?\n기존 객체의 값을 변경하는 대신 그대로 두고 대신에 변경된 결과를 가지는 새로운 객체를 생성하여 반환하면 된다.\n이때 불변 객체에서 변경과 관련된 메서드들은 보통 객체를 새로 생성해서 반환하기 때문에\n반환 값을 받아야 한다.\n\n```java\npublic class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public ImmutablePerson changeName(String name) {\n        return new ImmutablePerson(name, this.age);\n    }\n\n    public ImmutablePerson changeAge(int age) {\n        return new ImmutablePerson(this.name, age);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n위 코드에서 `changeName`과 `changeAge` 메소드는 이름과 나이를 변경한 새로운 `ImmutablePerson` 객체를 생성하여 반환한다.\n이렇게 하면 기존 객체의 상태를 변경하지 않고 새로운 객체를 생성하여 변경된 값을 가질 수 있다.\n\n## 불변 객체 존재 이유\n보통 우리가 설계하는 대부분의 클래스는 가변 객체일 것이다.\n이렇게 까지 불변 객체를 사용하는 이유는 무엇일까?\n그것은 불변 객체가 가지는 여러 장점 때문이다.\n먼저 캐시 안정성이다.\n불변 객체는 한 번 생성되면 그 상태가 변하지 않기 때문에 캐싱할 수 있다.\n또한 멀티 스레드 안전성을 보장한다.\n불변 객체는 여러 스레드에서 동시에 접근해도 안전하다.\n마지막으로 엔티티의 값 타입으로 사용할 수 있다.\n불변 객체는 값 타입으로 사용하기에 적합하다. \n\n"},{"excerpt":"Phantom Read란 무엇인가? Phantom Read는 트랜잭션이 동일한 조건의 쿼리를 반복 실행할 때, 나중에 실행된 쿼리에서 처음에는 존재하지 않았던 새로운 행이 나타나는 현상을 말한다.\n이는 주로 읽기 일관성(Read Consistency) 을 유지하는 과정에서 발생할 수 있는 문제로, 데이터의 삽입이나 삭제가 다른 트랜잭션에 의해 이루어질 때…","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"date":"December 21, 2024","title":"Phantom Read와 Gap Lock, Next-Key Lock","tags":["Database"]},"rawMarkdownBody":"\n# Phantom Read란 무엇인가?\n\nPhantom Read는 트랜잭션이 동일한 조건의 쿼리를 반복 실행할 때, 나중에 실행된 쿼리에서 처음에는 존재하지 않았던 새로운 행이 나타나는 현상을 말한다.\n이는 주로 읽기 일관성(Read Consistency) 을 유지하는 과정에서 발생할 수 있는 문제로, 데이터의 삽입이나 삭제가 다른 트랜잭션에 의해 이루어질 때 발생한다.\n\n```sql\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A 첫 번째 조회\nSELECT * FROM orders WHERE amount > 150;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B 새로운 행 삽입\nINSERT INTO orders (customer_id, amount) VALUES (4, 250);\n\n-- 트랜잭션 B 커밋\nCOMMIT;\n\n-- 동일한 조건으로 트랜잭션 A 두 번째 조회시, 트랜잭션 A의 첫 번째 조회에는 존재하지 않던,\n-- 트랜잭션 B에서 삽입된 새로운 행이 함께 조회됨\nSELECT * FROM orders WHERE amount > 150;\n```\n\n# 갭락(Gap Lock)이란?\n\n[당근 기술 블로그](https://medium.com/daangn/mysql-gap-lock-다시보기-7f47ea3f68bc)\n갭 락은 특정 인덱스 값 사이의 공간을 잠그는 락을 의미한다.\n기존 레코드 간의 간격을 보호하여 새로운 레코드의 삽입을 방지한다.\n갭 락은 범위 내에 특정 레코드가 존재하지 않을 때 적용된다.\n트랜잭션이 특정 범위 내에서 데이터의 삽입을 막아 팬텀 읽기(Phantom Read) 현상을 방지한다.\n예를 들어, 인덱스 값 10과 20 사이의 갭을 잠그면 이 범위 내에 새로운 레코드 15를 추가할 수 없다.\n\n```sql\n-- id 1, 3, 5가 저장된 orders 테이블\n\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A 1-3과 3-5 사이의 갭과 3 레코드 락 설정(넥스트키 락)\nSELECT * FROM orders WHERE orders_id BETWEEN 2 AND 4 FOR UPDATE;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B가 id 4에 데이터 삽입 시도 시, 갭락으로 인해 삽입이 차단되어 대기\nINSERT INTO orders (orders_id, orders_amount) VALUES (4, 200);\n...\n```\n\n# 넥스트키 락(Next-Key Lock)이란?\n\n넥스트키 락은 레코드 락과 갭락을 결합한 형태로, 특정 인덱스 레코드와 그 주변의 갭을 동시에 잠그는 락이다.\n이를 통해 레코드 자체의 변경과 함께 그 주변 공간의 변경도 동시에 제어할 수 있다.\n\n넥스트키 락은 특정 레코드와 그 주변 공간을 잠그기 때문에, 다른 트랜잭션이 새로운 레코드를 삽입하여 팬텀 리드를 발생시키는 것을 방지한다.\n\n|orders_id|orders_amount|\n|---|---|\n|1|100|\n|2|200|\n|3|300|\n\n\n```sql\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A amount = 200인 orders_id = 2 레코드에 대한 레코드 락과 1-2, 2-3에 대한 갭락을 동시에 잠금으로써 넥스트키 락을 설정\nSELECT * FROM orders WHERE orders_amount = 200 FOR UPDATE;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B orders_id = 4, orders_amount = 200인 레코드 삽입 시도 시, 넥스트키 락으로 인해 차단되어 대기\nINSERT INTO orders (orders_id, order_amount) VALUES (4, 200);\n...\n```\n\n# 갭락과 넥스트키 락을 통한 팬텀 리드 방지 메커니즘\n\n트랜잭션 A가 특정 범위의 데이터를 조회할 때, 해당 범위에 대해 갭락 또는 넥스트키 락을 설정한다.\n락이 설정된 범위 내에서는 트랜잭션 B가 새로운 레코드를 삽입하거나 기존 레코드를 수정하는 것이 차단된다.\n따라서, 트랜잭션 A가 다시 동일한 조건으로 조회를 수행하더라도, 트랜잭션 B에 의해 새로운 데이터가 삽입되지 않아 팬텀 리드가 발생하지 않는다."},{"excerpt":"여기서 가치있는 정보를 얻으려면 데이터를 많이 수집해야하지만, 무조건 많이 수집하는 것만으로는 충분하지 않다.\n수집된 데이터를 효율적으로 관리하고 언제든 필요한 정보를 빠르게 찾아낼 수 있어야 한다.\n이 글에서는 이러한 효율적인 데이터 관리를 위한 데이터베이스 관리 시스템(DBMS)에 대해 알아본다. 파일 시스템의 문제점 데이터베이스 관리 시스템(DBMS…","fields":{"slug":"/database-dbms/"},"frontmatter":{"date":"December 21, 2024","title":"데이터베이스 관리 시스템(DBMS)","tags":["Database"]},"rawMarkdownBody":"\n여기서 가치있는 정보를 얻으려면 데이터를 많이 수집해야하지만, 무조건 많이 수집하는 것만으로는 충분하지 않다.\n수집된 데이터를 효율적으로 관리하고 언제든 필요한 정보를 빠르게 찾아낼 수 있어야 한다.\n이 글에서는 이러한 효율적인 데이터 관리를 위한 데이터베이스 관리 시스템(DBMS)에 대해 알아본다.\n\n## 파일 시스템의 문제점\n\n데이터베이스 관리 시스템(DBMS)에 대해 알아보기 전에, 데이터베이스 이전에 데이터를 관리하기 위해 가장 먼저 사용되던 방식은 파일 시스템에 대해 알아보자.\n파일 시스템은 데이터를 파일 단위로 저장하고 관리하는 방식이다.\n\n그럼 왜 파일 시스템을 사용하지 않고 데이터베이스를 사용할까?\n이것을 알아가기 전에 먼저 파일 시스템의 저장 방식을 알아야 한다.\n파일 시스템은 데이터를 파일 단위로 저장하고, 이 파일을 읽고 쓰는 방식으로 데이터를 처리한다.\n흔히 사용되는 윈도우 파일 탐색기를 예로 들 수 있다.\n이러한 파일 시스템은 애플리케이션마다 필요한 데이터를 독립적으로 저장하고 관리한다.\n이는 특정 하드웨어나 소프트웨어에 종속되는 것을 의미한다.\n\n그럼 이제 왜 파일 시스템을 사용하지 않고 데이터베이스를 사용하는지 파일 시스템의 문제점을 살펴보자.\n\n### 데이터 종속의 문제\n위에서 언급한 것처럼 파일 시스템은 특정 하드웨어나 소프트웨어에 종속되어 있다.\n이는 데이터를 저장하는 방식이나 데이터에 접근하는 방식이 특정 시스템에 의존적이라는 것을 의미한다.\n이러한 종속성은 데이터를 다른 시스템으로 마이그레이션하거나 다른 시스템에서 사용하기 어렵게 만든다.\n\n### 데이터 중복의 문제\n파일 시스템은 애플리케이션마다 필요한 데이터를 독립적으로 저장하고 관리한다고 언급했다.\n이때 애플리케이션 별로 데이터를 생성하기에 동일한 데이터가 여러 번 중복되어 저장될 수 있다.\n이렇게 생성된 중복 데이터들은 데이터의 일관성을 해치는 다양한 문제를 야기한다.\n어떠한 데이터를 수정할 때 동일한 그리고 중복된 모든 데이터를 수정해야 하기에 데이터 관리가 어려워진다.\n그리고 중복 데이터를 저장하는 것은 그만큼 저장 공간을 차지하여 낭비하는 것이기에 경제성 또한 떨어진다.\n중복된 데이터는 보안성에서도 문제가 되는데, 각각의 동일 데이터에 대한 보안 수준을 유지하기 어려워 진다.\n\n### 무결성 훼손의 문제\n데이터의 무결성은 데이터의 정확성과 일관성을 의미한다.\n이러한 무결성을 보장하기 위해서는 제약조건을 설정하고 이를 지키는 것이 중요하다.\n파일 시스템은 데이터를 독립적으로 저장하고 이에따른 수많은 중복 데이터가 많아짐에 따른 개별 데이터들을 모니터링을 하여 이러한 제약조건을 지키기 어렵다.\n이로 인해 데이터의 무결성이 훼손될 가능성이 높아진다.\n\n### 동시 접근의 문제\n파일 시스템에서 다수의 사용자가 동시에 데이터에 접근하려고 할 때 문제가 발생할 수 있다.\n예를 들어 사용자 A가 파일을 수정하고 있는 동안 사용자 B가 동일 파일을 읽으려고 한다면 어떻게 될까?\n이 경우에 사용자 B는 수정 중인 파일을 읽을 수 없게 된다.\n이러한 문제를 해결하기 위해서는 파일을 읽기 전에 잠금을 걸어 다른 사용자가 파일을 수정하지 못하게 해야 한다.\n하지만 파일 시스템은 이러한 동시 접근 문제를 해결하기 위한 기능을 제공하지 않는다.\n\n## 데이터베이스의 정의\n파일 시스템의 문제점을 해결하기 위해 등장한 방식이 데이터베이스이다.\n데이터베이스는 무엇인지에 대한 정의는 다음과 같다.\n\n### 통합된 데이터\n데이터베이스는 중복 데이터를 최소화하고 중복 데이터를 피하기 위해 데이터를 통합하여 저장한다.\n이를 통해 데이터의 일관성을 유지하고 데이터의 정확성을 보장한다.\n\n### 저장된 데이터\n데이터베이스의 데이터는 컴퓨터가 접근할 수 있는 저장 매체에 저장된다.\n이러한 저장 매체는 하드디스크, SSD, 메모리 등이 있을 수 있다.\n\n### 운영 데이터\n데이터베이스는 조직의 운영에 필요한 데이터를 저장하고 관리한다.\n이러한 데이터는 조직의 운영에 필요한 데이터로, 조직의 목적에 따라 다양한 데이터가 저장될 수 있다.\n\n### 공용 데이터\n데이터베이스는 여러 사용자가 동시에 데이터에 접근할 수 있도록 공유된다.\n이러한 공용 데이터는 여러 사용자가 동시에 데이터에 접근할 수 있도록 하기 위해 데이터베이스 관리 시스템(DBMS)에 의해 관리된다.\nDBMS에 대해서는 뒤에서 자세히 다룰 것이다.\n\n## 데이터베이스의 특징\n데이터베이스에 대해 알아보았다.\n그럼 이러한 데이터베이스는 어떻게 파일 시스템과 다른지 그리고 어떻게 파일 시스템의 문제점을 해결할 수 있는지 데이터베이스가 가지는 특징을 살펴보자.\n\n\n### 실시간 접근성\n데이터베이스는 사용자의 수시적이고 비정형적인 질의 요구에 실시간으로 응답할 수 있어야 한다.\n실시간 처리에서는 사용자의 개인 특성이나 제공되는 서비스 유형에 따라 허용되는 응답 시간이 다르지만 대개 몇 초를 넘지 않는 시간 내에 데이터를 제공할 수 있어야 한다.\n\n### 지속적인 변화\n데이터베이스는 현실 세계의 상태르 정확히 반영해야 의미가 있다.\n그렇지만 현실 세계는 끊임없이 변화한다.\n이에 데이터베이스는 지속적인 변화를 반영할 수 있어야 한다.\n즉, 데이터베이스는 동적인 상태 유지를 위해 새로운 데이터의 삽입(Insert),삭제(Delete),갱신(Update)로 항상 최신의 데이터를 유지해야 한다.\n\n### 동시 공유\n데이터베이스는 동시 공유의 특성을 제공해 다수의 사용자가 동시에 데이터에 접근하고 데이터를 수정할 수 있도록 해야 한다.\n여기서 공시 공유는 사용자가 서로 다른 데이터를 동시에 접근하는 것뿐만아니라, 동일한 데이터에 대해 동시에 접근하는 것도 포함한다.\n\n### 내용에 의한 참조\n일반적인 컴퓨터 시스템의 검색은 저장된 데이터의 주소를 알아야 가능하다.\n하지만 데이터베이스는 저장된 주소가 아닌 데이터의 내용이나 값으로 데이터를 찾아 참조할 수 있다.\nC언어의 포인터나, URL 주소를 떠올리면 된다.\n\n## 데이터베이스 관리 시스템(DBMS) 특징\n데이터베이스 관리 시스템(DBMS)은 데이터베이스를 사용하는 사용자나 응용 프로그램이 데이터베이스에 접근할 수 있도록 해주며, 데이터베이스의 보안, 무결성, 백업, 복구 등을 관리한다.\n이러한 DBMS는 데이터베이스의 효율적인 관리를 위해 다양한 기능을 제공하고 다음과 같은 특징을 가진다.\n\n### 데이터 독립성\n데이터베이스를 이용하면 업무의 흐름에 따라 데이터를 통합 및 분리하여 관리할 수 있게 되므로 중복성을 줄일 수 있다.\n이 부분은 모델링의 정규화에 대한 이야기로, 데이터의 중복성을 줄이고 데이터의 일관성을 유지하기 위한 방법이다.\n\n### 데이터 무결성\n데이터베이스는 데이터의 무결성을 보장하기 위해 제약조건을 설정할 수 있다.\n제약조건에 맞지 않는 데이터의 삽입, 수정, 삭제를 방지하여 데이터의 무결성을 보장한다.\n기능적으로는 참조 무결성, 개체 무결성, 도메인 무결성 등이 있다.\n\n### 데이터 보안성\n데이터베이스 시스템의 데이터는 중요한 정보를 담고 있기 때문에 데이터의 보안성이 중요하다.\nDBMS는 데이터베이스에 접근하는 사용자의 권한을 관리하여 데이터의 보안성을 보장한다.\n\n### 데이터 일관성\n데이토의 불일치성을 미리 방지하여 데이터를 정확하게 유지하여 사용자에게 일관된 정보를 제공한다.\n트랜잭션이라는 작업의 논리적 단위를 통해 데이터의 일관성을 유지한다.\n\n\n## 참고\n- [데이터베이스](https://ko.wikipedia.org/wiki/데이터베이스)\n- [데이터베이스 관리 시스템](https://ko.wikipedia.org/wiki/데이터베이스_관리_시스템)\n- [파일 시스템](https://ko.wikipedia.org/wiki/파일_시스템)\n- [데이터베이스의 정의와 특징](https://coding-factory.tistory.com/214)"},{"excerpt":"기본형(Primitive)과 참조형(Reference) 자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을…","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"date":"December 20, 2024","title":"기본형(Primitive)과 참조형(Reference)","tags":["Java"]},"rawMarkdownBody":"\n# 기본형(Primitive)과 참조형(Reference)\n자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을 살펴보자.\n\n## 데이터 공유\n기본형은 하나의 값을 여러 변수에서 절대로 공유할 수 없디.\n하지만, 참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.\n\n여기서 하나의 값을 공유하거나 공유하지 않는다는 것은 무엇을 의미할까?\n기본형과 참조형의 차이를 이해하기 위해 아래의 코드를 살펴보자.\n\n먼저 기본형의 경우를 살펴보자.\n기본형은 하나의 값을 여러 변수에서 공유할 수 없다.\n\n```java\nint a = 10;\nint b = a;\na = 20;\nSystem.out.println(b); // 10\n```\n\n우선 기본형 변수 `a`와 `b`는 절대로 같은 값을 공유하지 않는다.\n`b = a`라고 하더라도 `b` 변수는 `a` 변수의 값을 복사하여 가지고 있는다.\n그래서 `a`와 `b` 변수는 같은 숫자 값을 가지고 있게되지만, `a`가 가지고 있는 `10`과 `b`가 가지고 있는 `10`은 복사된 완전히 다른 `10`이다.\n메모리 상에서도 `a`와 `b`는 서로 다른 메모리 주소를 가지고 있다.\n\n이제 참조형의 경우를 살펴보자.\n참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.\n\n```java\nclass Person {\n    String name;\n    int age;\n}\n\nPerson person1 = new Person();\nperson1.name = \"Alice\";\nperson1.age = 20;\n\nPerson person2 = person1;\nperson1.name = \"Bob\";\nSystem.out.println(person2.name); // Bob\n```\n\n위 코드는 `Person` 클래스를 정의하고, `Person` 객체를 생성하여 `person1` 변수에 할당한다.\n그리고 `person2` 변수에 `person1` 변수를 할당한다.\n`person1` 변수의 `name` 필드를 변경한 후, `person2` 변수의 `name` 필드를 출력하면 어떻게 되는지 테스트하는 코드다.\n코드의 결과는 `Bob`이 출력된다.\n\n참조형 변수들은 같은 참조값을 공유해 같은 인스턴스를 가리킨다.\n따라서 `person1` 변수의 `name` 필드를 변경하면, `person2` 변수도 같은 인스턴스를 가리키고 있기 때문에 `person2` 변수의 `name` 필드도 변경된다.\n\n## 공유 참조와 사이드 이펙트\n사이드 이펙트(Side Effect)는 함수나 메소드가 주된 행위 및 작업 외에 추가적인 부수 효과를 일으키는 것을 의미한다.\n앞서 살펴본 참조형 변수의 경우, `person1`의 `name` 필드를 변경하고자 `person1.name = \"Bob\"`를 실행한다.\n하지만 `person2`가 `person1`과 같은 참조값을 가지고 있기 때문에 `person2`의 `name` 필드도 변경된다.\n이렇게 같은 참조값을 공유할 때 발생하는 사이드 이펙트로 인해 디버깅이 어려워지고 코드의 안정성이 저하될 수 있다.\n\n## 사이드 이펙트 방지\n사이드 이펙트를 방지하기 위해서는 참조형 변수를 공유하지 않도록 해야한다.\n그러면 어떻게 참조형 변수를 공유하지 않도록 할 수 있을까?\n그것은 생각보다 단순하다.\n참조형 변수를 공유하지 않으려면 새로운 인스턴스를 생성하여 참조값을 할당하면 된다.\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n위 코드는 `Person` 클래스의 인스턴스를 두 개 생성하여 `person1` 변수와 `person2` 변수에 할당한다.\n이제 `person1` 변수와 `person2` 변수는 서로 다른 인스턴스를 가리키고 있기 때문에 `person1` 변수의 필드를 변경하더라도 `person2` 변수의 필드는 변경되지 않는다.\n\n사실 이러한 사이드 이펙트를 방지하기 위해 불변 객체(Immutable Object)를 사용하는 방법 또한 존재한다.\n불변 객체란 간단히 말해 객체의 상태가 변경되지 않는 객체를 의미한다.\n이러한 불변 객체를 사용하면 객체의 상태가 변경되지 않기 때문에 사이드 이펙트를 방지할 수 있다.\n불변 객체에 대한 자세한 내용은 [Immutable Object](https://023-dev.github.io/2024-12-23/java-immutable-object)를 참고하자."},{"excerpt":"동일성와 동등성 자바에서는 두 객체가 같은지 비교하는 두 가지 방법이 있다. 동일성(Identity):  연산자를 사용하여 두 객체의 주소값을 비교해서 동일한 객체를 참조하는지 확인 동등성(Equality):  메서드를 사용하여 두 객체의 내용이 같은지 확인 쉽게 설명하면  연산자는 두 객체의 주소값을 비교하는 것이고,  메서드는 두 객체의 내용을 비교하…","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"date":"December 19, 2024","title":"동일성(Identity)와 동등성(Equality)","tags":["Java"]},"rawMarkdownBody":"\n# 동일성와 동등성\n자바에서는 두 객체가 같은지 비교하는 두 가지 방법이 있다.\n- 동일성(Identity): `==` 연산자를 사용하여 두 객체의 주소값을 비교해서 동일한 객체를 참조하는지 확인\n- 동등성(Equality): `equals()` 메서드를 사용하여 두 객체의 내용이 같은지 확인\n\n쉽게 설명하면 `==` 연산자는 두 객체의 주소값을 비교하는 것이고, `equals()` 메서드는 두 객체의 내용을 비교하는 것이다.\n\n예를 들어 같은 내용을 가진 두 객체를 생성하고 `==` 연산자와 `equals()` 메서드를 사용하여 비교해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = new String(\"hello\");\n        String str2 = new String(\"hello\");\n\n        System.out.println(str1 == str2); // false\n        System.out.println(str1.equals(str2)); // true\n    }\n}\n```\n\n동일성을 비교하는 `==` 연산자는 두 객체의 주소값을 비교하기 때문에 `str1`과 `str2`는 서로 다른 객체를 참조하고 있기 때문에 `false`를 반환한다.\n반면에 동등성을 비교하는 `equals()` 메서드는 두 객체의 내용을 비교하기 때문에 `str1`과 `str2`는 내용이 같기 때문에 `true`를 반환한다.\n\n![In Java, Compare Identity & Equality](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-identity-equality/java-identity-equality_1.png){: width=\"500\" }\n\n## equals() 메서드\n`equals()` 메서드는 두 객체의 내용이 같은지 비교하는 메서드이다.\n`Object` 클래스에서는 `equals()` 메서드가 두 객체의 주소값을 비교하기 때문에 `==` 연산자와 같은 결과를 반환한다.\n내부 구현은 다음과 같다.\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n동등성이라는 개념은 객체마다 다르게 정의할 수 있다. 어떤 객체는 회원번호를 비교하고, 어떤 객체는 주민번호를 비교할 수 있다.\n따라서 동등성 비교를 위해서는 `equals()` 메서드를 오버라이딩하여 적절한 객체의 내용을 비교하도록 구현해야 한다.\n\n회원 객체를 생성하고 `equals()` 메서드를 오버라이딩하여 회원번호가 같은지 비교하는 것으로 예를 들어보겠다.\n\n```java\npublic class Member {\n    private int memberId;\n\n    public Member(int memberId) {\n        this.memberId = memberId;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Member) {\n            Member member = (Member) obj;\n            return this.memberId == member.memberId;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Member member1 = new Member(1);\n        Member member2 = new Member(1);\n\n        System.out.println(member1.equals(member2)); // true\n        System.out.println(member1 == member2); // false\n    }\n}\n```\n\n`equals()` 메서드를 오버라이딩하여 회원번호를 비교하도록 구현하였기 때문에 `member1`과 `member2`는 회원번호가 같기 때문에 `true`를 반환한다.\n반면 이것을 동일성 관점에서 보면 `member1`과 `member2`는 서로 다른 객체를 참조하고 있기 때문에 `false`를 반환해야 한다.\n\n## 정확한 동등성 비교를 위한 equals() 메서드 구현\n앞서 살펴본 `equals()` 메서드는 회원번호를 비교하는 것으로 간단한 예제를 보여주었다.\n하지만 실제 프로젝트에서 `equals()` 메서드를 오버라이딩하여 정확한 동등성 비교를 위해서는 다음과 같은 사항을 고려해야 한다.\n- 반사성(Reflexivity): 객체는 자기 자신과 동등해야한다. 즉, `x.equals(x)`는 항상 `true`를 반환해야 한다.\n- 대칭성(Symmetry): 두 객체가 동등하다면, 서로에 대해서도 동등해야 한다. 즉, `x.equals(y)`가 `true`를 반환하면 `y.equals(x)`도 `true`를 반환해야 한다.\n- 추이성(Transitivity): 세 객체가 동등하다면, 이들 간의 모든 비교에서 동등해야 한다. 즉, `x.equals(y)`와 `y.equals(z)`가 모두 `true`를 반환하면 `x.equals(z)`도 `true`를 반환해야 한다.\n- 일관성(Consistency): 객체의 내용이 변경되지 않았다면, `equals()` 메서드의 결과는 항상 동일해야 한다.\n- null 비교: `null`과의 비교는 항상 `false`를 반환해야 한다.\n\n참고로 동일성 비교가 항상 필요한 것은 아니다.\n동등성 비교가 필요한 경우에만 `equals()` 메서드를 오버라이딩하여 구현하면 된다.\n\n## hashCode() 메서드\n해시코드는 객체의 주소값을 기반으로 생성되는 정수값으로 `hashCode()` 메서드는 객체의 해시코드를 반환하는 메서드이다.\n`hashCode()` 메서드는 보통 `equals()` 메서드와 함께 사용되는데, `equals()` 메서드로 두 객체의 내용이 같은지 비교한 후에 `hashCode()` 메서드로 두 객체가 같은 객체인지 해시코드를 비교한다.\n\n그럼 `hashCode()` 메서드를 오버라이딩해야 하나라는 의문이 들 것이다.\n`hashCode()` 메서드를 오버라이딩하지 않으면 `equals()` 메서드를 오버라이딩한 클래스에서 `hashCode()` 메서드를 호출할 때 `Object` 클래스의 `hashCode()` 메서드가 호출되어 객체의 주소값을 기반으로 해시코드를 생성한다.\n따라서 `equals()` 메서드와 `hashCode()` 메서드의 일관성을 유지하기 위해서는 `hashCode()` 메서드를 오버라이딩해야 한다.\n\n회원 객체를 생성하고 `hashCode()` 메서드를 오버라이딩하여 회원번호를 기반으로 해시코드를 생성하는 것으로 예를 들어보겠다.\n\n```java\npublic class Member {\n    private int memberId;\n\n    public Member(int memberId) {\n        this.memberId = memberId;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Member) {\n            Member member = (Member) obj;\n            return this.memberId == member.memberId;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return memberId;\n    }\n\n    public static void main(String[] args) {\n        Member member1 = new Member(1);\n        Member member2 = new Member(1);\n\n        System.out.println(member1.equals(member2)); // true\n        System.out.println(member1.hashCode() == member2.hashCode()); // true\n    }\n}\n```\n\n`hashCode()` 메서드를 오버라이딩하여 회원번호를 기반으로 해시코드를 생성하도록 구현하였기 때문에 `member1`과 `member2`는 회원번호가 같기 때문에 `true`를 반환한다.\n"},{"excerpt":"Object 클래스를 알아가기 전에 먼저 Object 클래스가 속한 패키지에 대해 알아야 한다.\nObject 클래스가 속한 패키지는  패키지에 포함되어 있다. java.lang 패키지 소개 자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 패키지로 여기서 은 를 의미한다. 즉, 자바를 이루는 가장 기본이 되는 클래스들의 패키지라고 …","fields":{"slug":"/java-object/"},"frontmatter":{"date":"December 16, 2024","title":"자바 Object 클래스","tags":["Java"]},"rawMarkdownBody":"\nObject 클래스를 알아가기 전에 먼저 Object 클래스가 속한 패키지에 대해 알아야 한다.\nObject 클래스가 속한 패키지는 `java.lang` 패키지에 포함되어 있다.\n# java.lang 패키지 소개\n자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 패키지로 여기서 `lang`은 `Language`를 의미한다. 즉, 자바를 이루는 가장 기본이 되는 클래스들의 패키지라고 생각하면 된다.\n그런 이유 때문인지 `java.lang` 패키지는 모든 자바에서 자동으로 `import`된다. 따라서 따로 `import` 구문을 사용하지 않아도 된다.\n## java.lang 대표적인 클래스\n- `Object`: 모든 자바 객체의 부모 클래스\n- `String`: 문자열\n- `Integer`, `Long`, `Double`: 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것\n- `Class`: 클래스 메타 정보\n- `System`: 시스템과 관련된 기본 기능들을 제공\n\n# Object 클래스\n자바에서 모든 클래스의 최상위 부모 클래스는 항상 `Object` 클래스이다.\n![Java Object Class Inheritance.png](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_1.png){: width=\"400\" }\n\n근데 여기서 의문이 든다. 내가 생성한 클래스에는 아무것도 `extends`을 한 것이 없는데 어떻게 `Object` 클래스를 상속받은 클래스로 알고 있는걸까 이 의문에 답은 바로  클래스들은 부모 클래스가 없으면 자바가 알아서 묵시적(`Implicit`)으로  `Object` 클래스를 상속 받기 때문이다.\n아래 코드로 예를 들어보겠다.\n```java\npublic class Parent {\n\tpublic void parent() {System.out.println(\"Parent.parentMethod\");}\n}\n```\n보기엔 `Parent` 클래스에는 부모 클래스가 없어 보이지만, 사실 다음 코드와 같다고 볼 수 있다.\n```java\npublic class Parent extends Object {\n\tpublic void parent() {System.out.println(\"Parent.parentMethod\");}\n}\n```\n이처럼 자바가 `extends Object` 코드를 자동으로 생성해 주기때문에 `extends Object`를 생략해주는 것을 권장한다. 또한 이때 `Parent` 클래스에서는  `Obejct` 클래스를 묵시적(`Implicit`)으로 상속 받았기 때문에 메모리에도 함께 생성된다.\n\n그럼 `Parent`를 상속받은 클래스에서는 어떨지 의문이 들 수 있다.\n```java\npublic class Child extends Parent {\n\tpublic void childMethod() {System.out.println(\"Child.childMethod\");}\n}\n```\n이처럼 클래스에 상속받을 부모 클래스를 명시적(`Explicit`)으로 지정하면 `Object` 클래스를 상속 받지 않는다.\n\n> 여기서 묵시적(`Implicit`)이란 개발자가 코드에 직접 기술해서 작동하는 것을 의미하는 명시적(`Explicit`)이란 개념과 상반된 개념으로 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미한다.\n\n위의 말대로 라면 아무 클래스를 상속받지 않는 `Parent`  클래스에서는 `Object` 클래스를 묵시적(`Implicit`)으로 상속받기에 `Parent` 클래스를 상속받은 `Child` 클래스도 `Object`의 메서드를 사용할 수 있어야 한다. 이 말이 맞는지 확인해보자.\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tChild child = new Child();\n\t\tchild.childMethod();\n\t\tchild.parentMethod();\n\n\t\tString childToString = child.toString();\n\t\tSystem.out.println(childToString);\n\t}\n}\n```\n`toString`은 `Object` 클래스의 메서드로 객체의 정보를 반환한다.\n\n실행결과는 다음과 같다.\n```java\nChild.childMethod\nParent.parentMethod\nlang.object.Child@3feba861\n```\n동작 과정은 다음과 같다.\n- `child.toString()`을 호출한다.\n- 먼저 본인의 타입인 `Child`에서 `toString()`을 찾는다. 없으면 부모 타입으로 올라가서 찾는다.\n- 부모 타입인 `Parent`에서 찾는다. 이 곳에서도 없으므로 부모 타입으로 올라가서 찾는다.\n- 부모 타입인 `Object`에서 찾는다. `Object`에 `toString()`이 있으므로 해당 메서드를 호출한다.\n\n이해를 돕기 위해 그림을 그려봤다.\n![Java Object Class Inheritance Detail.png](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_2.png){: width=\"500\" }\n\n## 자바에서 Object 클래스가 최상위 부모 클래스인 이유\n모든 클래스가 `Object` 클래스를 상속받는 이유는 공통 기능 제공하는 것과 다형성의 기본 구현함에 있다.\n\n### 공통 기능 제공\n객체의 정보나 다른 객체와 비교하는 기능과 기능들은 모든 객체가 필요로 하는 기본 기능일 것이다. 이러한 기능들을 객체를 구현할 때마다 항상 정의해서 만들어야 한다면 상당히 비효율적일 것이다. 그리고 이를 구현하게 되면 개발자가 누구인지에 따라 메서드의 이름부터 해서 달라질 수 있기에 일관성 또한 없을 것이다.\n\n`Object` 클래스에서는 이러한 모든 객체가 필요로 하는 기능들을 구현한 공통 기능을 제공한다. 이렇게 하면 위에서 증명했듯이 `Object`가 최상위 부모 클래스일 수 밖에 없기 때문에 모든 객체는 공통 기능을 상속 받아 효율적으로 제공 받을 수 있어 프로그래밍이 단순화되고 일관성을 가질 수 있게 된다.\n\n`Object` 클래스가 제공하는 공통 기능은 다음과 같다.\n- 객체의 정보를 제공하는 `toString()`\n- 객체를 비교하는 `equals()`\n- 객체의 클래스 정보를 제공하는 `getClass()`\n- `hashCode()`, `notify()`, etc.\n\n### 다형성의 기본 구현\n`Object` 클래스는 모든 클래스의 부모 클래스라는 것을 알 수 있었다. 따라서 모든 객체를 참조할 수 있다는 것을 알 수 있다. 이 말은 모든 자바 객체가 `Object` 타입으로 처리될 수 있고, `Object` 타입으로 다양한 타입의 객체를 통합적으로 처리할 수 있다는 것을 의미한다. 즉, `Object`는 모든 객체를 담을수도 있고 타입이 각각 다른 객체들을 보관할 수 있다는 것이다.\n\n## Object 다형성\n`Object`는 모든 클래스의 부모 클래스로 모든 객체를 참조할 수 있는 다형적 참조가 가능하다고 언급을 했다.\n하지만 `Object`가 자식들의 모든 메서드를 알 수 없기에 `Object`를 통해 전달 받은 객체를 호출하기 위해서는 각 객체에 맞는 다운캐스팅 과정이 필요하다.\n\n\n```java\npublic class Car {\n\tpublic void move() { System.out.println(\"car moving\"); }\n}\n```\n```java\npublic class Dog {\n\tpublic void sound() { System.out.println(\"dog sound\"); }\n}\n```\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tCar car = new Car();\n\n\t\taction(dog);\n\t\taction(car);\n\t}\n\n\tprivate static void action(Object obj) {\n\t\tobj.move();\n\t\tobj.sound();\n\t}\n}\n```\n만일 다운캐스팅을 하지 않는다면 `Object`타입에서 `move()`와 `sound` 메서드를 찾을 수 없고, 뿐만아니라 최상위 부모이므로 더는 올라가서 찾을 수 없다.\n따라서 action`메서드에서 컴파일 날 것이다.\n\n![Java Object Class Poly](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_3.png){: width=\"500\" }\n\n그래서 해당 상황에서 오류없이 컴파일 하기 위해서는 다운 캐스팅을 해야한다.\n```java\nprivate static void action(Object obj) {    \n    //객체에 맞는 다운캐스팅 필요  \n    if (obj instanceof Dog dog) {  \n        dog.sound();  \n    } else if (obj instanceof Car car) {  \n        car.move();  \n    }  \n}\n```\n\n![Java Object Class Poly Solution](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_4.png){: width=\"500\" }\n\n이처럼 `Object`는 다형적 참조가 가능하지만, 메서드 오버라이딩을 활용 할 수 없기에 다형성을 활용하기에 한계가 있다.\n\n# Object 배열\n`Object` 클래스는 모든 클래스의 부모 클래스이기 때문에 `Object` 배열을 선언하면 모든 객체를 담을 수 있다.\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        Car car = new Car();\n        Object object = new Object();\n        Object[] objects = {dog, car, object};\n        size(objects);\n    }\n    private static void size(Object[] objects) {\n        System.out.println(\"전달된 객체의 수는: \" + objects.length);\n    }\n}\n```\nsize 메서드에서 전달된 객체의 수를 출력하는 메서드이다. 실행결과는 다음과 같다.\n```java\n전달된 객체의 수는: 3\n```\n이 메서드는 `Object` 배열을 매개변수로 받기 때문에 모든 객체를 담을 수 있기 때문에,\n클래스가 추가되거나 변경되어도 메서드를 수정할 필요가 없다.\n`Object`의 메서드들은 모든 객체가 공통으로 가지고 있는 메서드들이기 때문에 이러한 다형성을 활용할 수 있다.\n\n![Java Object Array](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_5.png){: width=\"500\" }\n\n## Object가 없다면?\n만일 `Object` 클래스가 없다면 어떻게 될까?\n모든 클래스가 `Object` 클래스를 상속받지 않는다면 다형성을 활용할 수 없게 된다.\n또한 모든 객체를 담을 수 있는 컬렉션을 만들 수 없게 된다.\n그리고 직접 정의를 하게되는 경우 모든 클래스에 공통적으로 필요한 메서드를 모든 개발자가 직접 구현해야 하기에 매우 비효율적일 것이다.\n따라서 `Object` 클래스가 없다면 자바의 객체지향 프로그래밍은 불가능할 것이다.\n\n# toString()\n`toString()` 메서드는 객체의 정보를 문자열로 반환한다.\n이러한 `toString()` 메서드는 디버깅과 로깅을 할 때 객체의 정보를 확인하기 위해 유용하게 사용된다.\n이 메서드는 `Object` 클래스에서 정의되어 있기 때문에 모든 클래스에서 상속받아 사용할 수 있다.\n내부 구현은 다음과 같다.\n\n```java\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n`getClass().getName()`은 패키지를 포함한 객체의 클래스 이름을 반환하고, `hashCode()`는 객체의 해시 코드 값을 반환하는데 `Integer.toHexString(hashCode())`는 이를 16진수로 변환한다.\n\n## println()와 toString()\n`println()`과 `toString()` 메서드는 서로 연관이 있다.\n각 메서드를 호출한 결과 값은 같다.\n그 이유는 `System.out.println()` 메서드는 객체를 출력할 때 `toString()` 메서드를 호출하기 때문이다.\n내부 구현은 다음과 같다.\n\n```java\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    if (getClass() == PrintStream.class) {\n        // need to apply String.valueOf again since first invocation\n        // might return null\n        writeln(String.valueOf(s));\n    } else {\n        synchronized (this) {\n            print(s);\n            newLine();\n        }\n    }\n}\npublic static String valueOf(Object obj) {\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n그래서 `System.out.println(dog)`를 호출하면 `dog.toString()`이 호출되어 `Dog` 클래스에서 오버라이딩한 `toString()` 메서드가 호출된다.\n\n## toString() 오버라이딩\n`Object.toString()` 메서드는 객체의 정보를 문자열로 반환하는데, 이는 객체의 메모리 주소를 반환하기 때문에 객체의 정보를 확인하기 어렵다.\n따라서 `toString()` 메서드를 오버라이딩하여 객체의 정보를 반환하도록 구현하여 사용한다.\n\n![Java Object Overriding](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_6.png){: width=\"150\" }\n\n```java\npublic class Dog {\n    private String name;\n    private int age;\n\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Dog{name='\" + name + \"', age=\" + age + \"}\";\n    }\n}\n```\n이렇게 하면 `Dog` 객체의 정보를 확인하기 쉽게 출력할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"멍멍이\", 2);\n        System.out.println(dog);\n    }\n}\n```\n실행결과는 다음과 같다.\n```java\nDog{name='멍멍이', age=2}\n```\n\n# Object 클래스와 OCP\n\n만약 `Object` 클래스가 없다면 어떻게 될까?\n객체지향 프로그래밍에서는 객체를 다형적으로 사용하는 것이 중요하다.\n그러나 모든 클래스가 `Object` 클래스를 상속받지 않는다면 다형성을 활용할 수 없게 된다.\n\n## OCP 원칙\nOCP(Open-Closed Principle)는 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙이다.\n- Open: 기존 코드를 변경하지 않고 새로운 기능을 확장할 수 있어야 한다.\n- Closed: 기존 코드를 수정하지 않아야 한다.\n  이 원칙은 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있어야 한다는 것을 의미한다.\n\n## 구체적인 개념에 의존\n`Object` 클래스가 없다면 모든 클래스가 `Object` 클래스를 상속받지 않기 때문에 다형성을 활용할 수 없게 된다.\n따라서 다형성을 활용하기 위해서는 구체적인 클래스에 의존하게 되어 유연성이 떨어지게 된다.\n이는 객체지향 프로그래밍의 핵심인 OCP(Open-Closed Principle)를 위배하게 된다.\n만약 `Object` 클래스가 없다면 새로운 클래스를 추가할 때마다 코드를 수정해야 하기 때문에 OCP를 위배하게 된다.\n\n## 추상적인 개념에 의존\n반면에 `Object` 클래스가 있다면 모든 클래스가 `Object` 클래스를 상속받기 때문에 다형성을 활용할 수 있게 된다.\n따라서 추상적인 개념에 의존하게 되어 유연성이 높아지게 된다.\n이는 OCP를 준수하게 되어 새로운 클래스를 추가할 때 코드를 수정할 필요가 없게 된다.\n\n## System.out.println()\n`System.out.println()` 메서드는 `Object` 타입을 매개변수로 받기 때문에 모든 객체를 출력할 수 있다.\n만약 `Object` 클래스가 없다면 `System.out.println()` 메서드는 모든 클래스를 매개변수로 받아야 하기 때문에 유연성이 떨어지게 된다.\n따라서 `Object` 클래스가 없다면 이와같은 메서드들을 구현하기 위해서는 매우 많은 오버로딩을 해야 하기 때문에 유지보수가 어려워진다.\n이러한 이유로 자바에서는 `Object` 클래스를 제공을 한다.\n\n> 참고 - 정적 의존관계와 동적 의존관계\n> 정적 의존관계는 컴파일 시점에 결정되는 의존관계를 말한다. 즉, 코드를 작성하는 시점에 이미 결정되는 의존관계이다. 예를 들어, 클래스 A가 클래스 B를 사용한다면 A 클래스는 B 클래스에 정적 의존관계를 가진다. 이는 코드를 작성하는 시점에 이미 결정되어 있기 때문에 변경이 어렵다. 따라서 유연성이 떨어진다.\n> 동적 의존관계는 실행 시점에 결정되는 의존관계를 말한다. 즉, 코드를 실행하는 시점에 결정되는 의존관계이다. 예를 들어, 객체 A가 객체 B를 사용한다면 A 객체는 B 객체에 동적 의존관계를 가진다. 이는 코드를 실행하는 시점에 결정되기 때문에 변경이 쉽다. 따라서 유연성이 높다."},{"excerpt":"JVM(Java Virtual Machine) JVM(Java Virtual Machine)은 자바 프로그램이 실행되는 환경으로, 운영체제와 독립적으로 동작할 수 있도록 중간 역할을 한다.\n그럼 어떻게 JVM이 동작하길래 운영체제에 독립적인지 알아보자. JVM 동작 방식 JVM은 자바 애플리케이션을 실행하기 위해 메모리를 할당받고, 자바 소스 파일을 바이…","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"date":"November 25, 2024","title":"자바 가상 머신(Java Virtual Machine)","tags":["Java"]},"rawMarkdownBody":"\n# JVM(Java Virtual Machine)\n\n<hr>\n\nJVM(Java Virtual Machine)은 자바 프로그램이 실행되는 환경으로, 운영체제와 독립적으로 동작할 수 있도록 중간 역할을 한다.\n그럼 어떻게 JVM이 동작하길래 운영체제에 독립적인지 알아보자.\n\n# JVM 동작 방식\n\n<div class=\"mermaid\">\ngraph TD\n    A[JAVA Source] -->|JAVA Compiler| B[JAVA Byte Code]\n    B --> C[Class Loader]\n    subgraph JVM [JVM]\n        C <--> D[Runtime Data Area]\n        D <--> E[Execution Engine]\n        C <--> E\n    end\n</div>\n\n1. JVM은 자바 애플리케이션을 실행하기 위해 메모리를 할당받고, 자바 소스 파일을 바이트 코드로 변환하여 실행하는 역할을 한다.\n2. 자바 프로그램 실행 시, 자바 컴파일러(`javac`)는 소스 코드(`.java`)를 바이트 코드(`.class`)로 변환된다.\n3. 이후 바이트 코드는 JVM의 `Class Loader`를 통해 필요한 클래스들이 동적으로 로딩되고 링크되어 `Runtime Data Area`에 배치된다.\n4. 이 영역은 실행 중 메모리를 관리하는 핵심 공간으로, 여기에 로드된 바이트 코드는 JVM의 `Execution Engine`에 의해 해석되고 실행된다.\n5. 이 과정에서 `Garbage Collector`가 메모리 관리를 담당하며, `Thread` 동기화와 같은 멀티스레드 환경에서의 작업도 `Execution Engine`에 의해 처리된다.\n\n이러한 동작 방식은 자바 프로그램의 효율적인 실행을 보장하는 동시에 플랫폼 독립성을 실현하는 기반이 된다.\n> 2번 컴파일하는 이러한 동작방식으로 JVM은 속도 저하라는 단점을 가지고 있지만, JIT(Just-In-Time) 컴파일러를 통해 이를 개선하려는 시도를 하고 있다.\n\n# JVM의 구조\n\n<div class=\"mermaid\"> \ngraph TD\nA[Java Source File] -->|Java Compiler| B[Java Byte Code]\nB --> C[Class Loader]\n    subgraph JVM [JVM]\n        C --> D[Execution Engine]\n        D --> D1[Interpreter]\n        D --> D2[JIT Compiler]\n        D --> D3[Garbage Collector]\n        C --> E[Runtime Data Areas]\n        E --> E1[Method Area]\n        E --> E2[Heap]\n        E --> E3[PC Register]\n        E --> E4[JVM Stack]\n        E --> E5[Native Method Stack] \n        E5 --> F[Native Method Interface]\n        F --> G[Native Method Library]\n    end\n</div>\n\nJVM(Java Virtual Machine)의 구조는 자바 애플리케이션 실행 과정에서 핵심 역할을 담당하는 다양한 구성 요소로 이루어져 있다.\n이 중 가장 중요한 세 가지 구성 요소는 클래스 로더(Class Loader), 실행 엔진(Execution Engine), 그리고 런타임 데이터 영역(Runtime Data Area)이다.\n클래스 로더는 자바 바이트 코드(.class 파일)를 메모리에 로드하고, 필요한 클래스와 자원을 동적으로 링크한다.\n실행 엔진은 로드된 바이트 코드를 해석하거나(JIT 컴파일러와 인터프리터 사용) 실행하며, 이 과정에서 가비지 콜렉터(Garbage Collector)를 통해 메모리를 관리한다.\n런타임 데이터 영역은 JVM이 애플리케이션 실행 시 사용하는 메모리 구조로, 메소드 영역(Method Area), 힙 영역(Heap), PC 레지스터(PC Register), 스택 영역(Stack Area), 네이티브 메소드 스택(Native Method Stack)으로 구성된다.\n추가적으로 네이티브 메소드 인터페이스(JNI)는 네이티브 메소드 라이브러리와 상호작용하여 JVM에서 자바 이외의 언어로 작성된 코드를 호출할 수 있도록 한다.\n이러한 구조는 JVM의 동작을 효율적으로 지원하며, 자바 프로그램이 플랫폼 독립적으로 실행될 수 있는 기반을 제공한다.\n\n## 클래스 로더 (Class Loader)\n\n클래스 로더(Class Loader)는 JVM에서 클래스 파일(*.class)을 동적으로 로드하고 이를 링크(Linking)를 통해 JVM 메모리 영역(Runtime Data Areas)에 배치하는 역할을 담당한다.\n클래스 로더는 자바 애플리케이션 실행 시 필요한 클래스만 동적으로 메모리에 적재하며, 모든 클래스를 한 번에 로드하지 않음으로써 메모리 효율성을 높인다.\n클래스 로딩 과정은 크게 로딩(Loading), 링킹(Linking), **초기화(Initialization)**의 3단계로 이루어진다.\n\n<div class=\"mermaid\">\ngraph TD\n    A[Loading] --> B[Verifying]\n    D --> E[Initializing]\n    subgraph Linking\n        B --> C[Preparing]\n    C --> D[Resolving]\n    end\n</div>\n\n1. **Loading(로드)**: 클래스 파일을 읽어 JVM 메모리로 로드하는 단계이다. 필요한 시점에 동적으로 로드된다.\n2. **Linking(링크)**: 로드된 클래스 파일을 검증하고 사용할 준비를 하는 과정으로, 다시 세부적으로 나뉜다.\n    - **Verifying(검증)**: 클래스 파일이 JVM 명세를 준수하는지 확인한다.\n    - **Preparing(준비)**: 클래스가 필요로 하는 메모리를 할당한다.\n    - **Resolving(분석)**: 클래스의 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변환하여 메모리 주소를 연결한다.\n3. **Initialization(초기화)**: 클래스 변수(static 필드 등)를 지정된 초기값으로 설정하고 필요한 초기화 작업을 수행한다.\n\n## 실행 엔진(Execution Engine)\n\n실행 엔진(Execution Engine)은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 읽고 이를 명령어 단위로 실행하는 역할을 한다.\n자바의 바이트 코드(.class 파일)는 기계가 직접 이해할 수 있는 언어가 아니라, JVM이 이해할 수 있는 중간 단계의 코드이기 때문에 실행 엔진은 이 바이트 코드를 실제로 기계어(Native Code)로 변환하여 실행한다.\n이 과정에서 실행 엔진은 **인터프리터(Interpreter)**와 **JIT 컴파일러(Just-In-Time Compiler)** 두 가지 방식을 사용한다.\n인터프리터는 바이트 코드를 한 줄씩 해석하며 실행하지만, 반복적으로 호출되는 메소드의 경우 속도가 느려지는 단점이 있다.\n이를 보완하는 JIT 컴파일러는 반복되는 코드를 네이티브 코드로 변환한 후 캐싱하여, 이후에는 직접 실행함으로써 성능을 개선한다.\nJIT 방식은 변환 비용이 소요되므로 JVM은 초기에는 인터프리터 방식을 사용하다가 일정 기준이 넘으면 JIT 컴파일러를 활성화한다.\n\n또한, 실행 엔진에는 **가비지 컬렉터(Garbage Collector, GC)**가 포함되어 있어 힙(Heap) 메모리에서 사용하지 않는 객체를 자동으로 회수한다.\nC 언어와 달리 자바는 메모리를 개발자가 직접 관리할 필요 없이 GC가 이를 자동으로 처리하므로, 프로그래밍의 생산성과 안정성이 높아진다.\n단, GC는 실행 시간이 정해져 있지 않고, Full GC가 발생하면 모든 스레드가 일시 정지되므로 성능 문제나 장애가 발생할 수 있다.\n참고로 `System.gc()` 메서드를 통해 GC를 수동으로 요청할 수 있지만, 실제 실행이 보장되지는 않는다.\n실행 엔진의 이러한 설계는 자바 애플리케이션의 효율적인 실행과 메모리 관리의 자동화를 지원하며, 자바의 주요 강점 중 하나로 작용한다.\n\n## 런타임 데이터 영역(Runtime Data Area)\n런타임 데이터 영역(Runtime Data Area)은 JVM의 메모리 공간으로, 자바 애플리케이션 실행 시 사용되는 데이터를 저장하는 영역이다.\n이 영역은 크게 **메서드 영역(Method Area)**, **힙 영역(Heap Area)**, **스택 영역(Stack Area)**, **PC 레지스터(Program Counter Register)**, **네이티브 메서드 스택(Native Method Stack)**으로 나뉜다. 이 중 **메서드 영역**과 **힙 영역**은 모든 쓰레드가 공유하며, **스택 영역**, **PC 레지스터**, **네이티브 메서드 스택**은 각 쓰레드마다 독립적으로 생성된다.\n\n### 메서드 영역(Method Area)\n**메서드 영역(Method Area)**은 JVM 시작 시 생성되며, 클래스 정보(필드, 메서드, 타입 정보 등)를 저장하는 공간이다.\n이 영역은 클래스 로딩 시 초기화되며, JVM 종료 시까지 유지된다.\n정적 필드, 메서드 정보와 함께 **런타임 상수 풀(Constant Pool)**도 포함되어 있어 클래스와 인터페이스의 참조 정보를 관리한다.\n\n### 힙 영역(Heap Area)\n**힙 영역(Heap Area)**은 런타임 시 동적으로 객체를 할당하는 공간이다.\n모든 쓰레드가 공유하며, `new` 연산자로 생성된 객체와 배열 등이 저장된다.\n힙 영역은 가비지 컬렉터(GC)에 의해 관리되며, **Young Generation**(Eden, Survivor 영역)과 **Old Generation**으로 나뉘어 효율적인 메모리 관리를 수행한다.\n객체가 참조되지 않으면 GC에 의해 제거된다.\n\n### 스택 영역(Stack Area)\n**스택 영역(Stack Area)**은 메서드 호출 시 사용되는 공간으로, 기본 자료형 및 지역 변수를 저장한다.\n메서드 호출 시 **스택 프레임(Stack Frame)**이 생성되며, 호출이 종료되면 프레임이 제거된다.\nLIFO 구조로 동작하며, 스택 오버플로우가 발생할 수 있으므로 크기가 제한된다.\n\n### PC 레지스터(Program Counter Register)\n**PC 레지스터(Program Counter Register)**는 현재 실행 중인 JVM 명령어의 주소를 저장하는 공간으로, 쓰레드가 실행 중인 명령을 추적한다.\n자바 명령은 PC 레지스터에 저장되지만, 네이티브 메서드를 실행할 때는 `undefined` 상태가 된다.\n\n### 네이티브 메서드 스택(Native Method Stack)\n**네이티브 메서드 스택(Native Method Stack)**은 자바가 아닌 네이티브 코드(C, C++ 등)로 작성된 메서드를 실행하기 위한 공간이다. JIT 컴파일러에 의해 네이티브 코드로 변환된 메서드도 이 스택에서 실행된다.\n네이티브 메서드는 JNI(Java Native Interface)와 연결되어 JVM 외부의 네이티브 라이브러리를 호출하거나 실행한다.\n\n## JNI(Java Native Interface)\n\n<div class=\"mermaid\">\ngraph LR\n    A[C / C++ Side] <--> B[JNI]\n    B <--> C[Java Side]\n\n    subgraph TD \n    A[C / C++ Side]\n        A1[Function]\n        A2[Library]\n    end\n\n    subgraph TD\n     C[Java Side]\n        C1[Exception]\n        C2[Class]\n        C3[VM]\n    end\n</div>\n\nJNI(Java Native Interface)는 자바가 다른 언어로 작성된 애플리케이션과 상호작용할 수 있도록 지원하는 인터페이스를 제공한다.\n이를 통해 자바는 JVM 내부에서 네이티브 메서드를 로드하고 실행할 수 있으며, C/C++와 같은 언어로 구현된 라이브러리나 기능을 호출하여 사용할 수 있다.\n주로 네이티브 코드와의 통합이 필요한 상황에서 활용되며, 네이티브 코드의 강력한 성능과 자바의 이식성을 결합할 수 있는 장점을 제공한다.\n하지만 실제로는 C나 C++ 언어와의 상호작용에 가장 적합하게 설계되어 있어, 다른 언어와의 호환성은 제한적이다.\nJNI를 활용하면 네이티브 코드 기반의 고성능 기능을 자바 애플리케이션에서 손쉽게 호출할 수 있지만, 네이티브 코드 관리와 디버깅이 복잡해질 수 있으므로 신중하게 사용해야 한다.\n\n## Native Method Library\n\n<div class=\"mermaid\">\ngraph TD\n    A[Class loader sub system] <-->|Class files| B[Runtime data areas]\n    subgraph B[Runtime data areas]\n        B1[Method area]\n        B2[Heap]\n        B3[Java stacks]\n        B4[PC Registers]\n        B5[Native method stacks]\n    end\n\n    B <--> C[Execution Engine]\n    B5 <--> D[Native method interface]\n    D <--> E[Native method library]\n    C <--> D\n</div>\n\n**Native Method Library**는 C, C++로 작성된 라이브러리를 지칭하며, 자바 애플리케이션이 네이티브 메서드를 호출할 때 사용된다.\n이 라이브러리는 JNI(Java Native Interface)에 의해 JVM이 로드하여 실행된다.\n자바 코드가 네이티브 메서드를 호출하면, JVM은 필요한 네이티브 라이브러리를 메모리에 로드하고 실행 환경을 제공한다.\n필요할 경우, JNI는 네이티브 메서드 실행에 필요한 헤더 파일을 생성하거나 참조하며, 이를 통해 자바와 네이티브 코드를 연결한다.\nNative Method Library는 자바가 제공하지 않는 플랫폼 고유의 기능을 활용하거나, 성능이 중요한 로우레벨 작업을 수행할 때 유용하게 사용된다.\n"},{"excerpt":"GC(Garbage Collection) **가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와…","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"date":"November 24, 2024","title":"가비지 컬렉션(Garbage Collection)","tags":["Java"]},"rawMarkdownBody":"\n\n# GC(Garbage Collection)\n\n<hr>\n\n**가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와 달리, 자바에서는 GC가 메모리 관리를 대신 처리해줌으로써 메모리 누수(Memory Leak)를 방지하고 개발자가 로직 구현에만 집중할 수 있도록 돕는다.\n\n예를 들어, 반복문 내에서 다수의 객체를 생성하고 사용 후 버리는 코드가 있다고 가정할 때, GC는 이러한 객체들을 주기적으로 정리해줘서 메모리를 효율적으로 사용할 수 있게 한다.\nGC의 이러한 자동화는 자바뿐만 아니라 파이썬, 자바스크립트, Go 언어 등 다양한 언어에서도 기본적으로 제공되며, 웹 브라우저와 같은 소프트웨어에서도 GC를 활용해 메모리 관리를 자동화한다.\n\n그러나 GC에도 단점이 있다.\nGC가 언제 실행될지 명확히 알 수 없기 때문에 메모리 해제를 개발자가 직접 제어하기 어렵고, GC가 실행되는 동안 모든 애플리케이션 스레드가 멈추는 **Stop-The-World(STW)** 현상이 발생한다.\n이로 인해 GC가 지나치게 자주 실행되면 애플리케이션의 성능이 저하될 수 있으며, 실시간 성능이 중요한 시스템에서는 GC의 동작이 치명적일 수 있다.\n예를 들어, 과거의 웹 브라우저인 인터넷 익스플로러는 GC를 너무 자주 실행해 성능 문제를 야기했던 사례가 있다.\n\n이러한 이유로 GC의 실행을 최소화하고 최적화하는 작업이 중요시하며, 이를 **GC 튜닝**이라고 한다.\n> GC 튜닝은 어플리케이션의 성능을 유지하면서 효율적으로 메모리를 관리하는 방법을 설계하는 과정으로, 애플리케이션의 성능과 안정성을 보장하기 위해 필수적인 기술 중 하나이다.\n\n## 가비지 컬렉션 대상\n가비지 컬렉션(Garbage Collection)의 대상은 객체가 더 이상 프로그램에서 참조되지 않는 경우, 즉 도달 불가능(Unreachable)한 상태로 판단된 객체들이다.\n이를 위해 **도달성(Reachability)**이라는 개념이 사용된다. 객체에 참조가 있으면 해당 객체는 Reachable(도달 가능) 상태로 간주되고, 반대로 참조가 없다면 Unreachable(도달 불가능) 상태로 분류되어 가비지 컬렉션의 대상이 된다.\n\nReachable 상태의 객체는 현재 사용 중인 객체로, JVM의 Method Area나 Stack Area에서 해당 객체의 메모리 주소를 참조하고 있다.\n반면, Unreachable 상태의 객체는 어떤 변수나 메서드에서도 참조되지 않는 상태로, 더 이상 프로그램에서 사용되지 않는 객체다.\n이러한 Unreachable 객체는 힙(Heap) 영역에서만 존재하며, 가비지 컬렉션에 의해 자동으로 제거된다.\n\n<div class=\"mermaid\">\ngraph LR\n    subgraph Heap\n        A1[1 Reachable]\n        A2[2 Unreachable]\n        A3[3 Reachable]\n        A4[4 Reachable]\n        A5[5 Reachable]\n    end\n\n    subgraph Stack\n        B6[6]\n        B7[7]\n    end\n\n    subgraph MethodArea\n        C8[8]\n    end\n\n    B6 --> A1\n    B7 --> A5\n    A5 --> A4\n    C8 --> A3\n</div>\n\n예를 들어, 객체는 주로 힙 영역에서 생성되고, 메서드가 실행되거나 변수가 선언될 때 Method Area나 Stack Area에 객체의 참조 주소를 저장한다.\n하지만 메서드 종료와 같은 특정 이벤트로 인해 참조 변수가 삭제되거나 스코프를 벗어나면, 힙 영역의 해당 객체는 더 이상 참조되지 않게 된다.\n이처럼 도달 불가능한(Unreachable) 상태가 된 객체는 프로그램에서 쓸모없어진 것으로 간주되어 가비지 컬렉터가 주기적으로 수거하여 메모리를 해제한다.\n\n이 과정은 프로그래머가 명시적으로 메모리를 해제하지 않아도 JVM이 자동으로 메모리를 관리하게 해 주는 장점이 있다.\n하지만, 가비지 컬렉션이 언제 실행될지는 명확히 알 수 없으므로, 이를 고려한 메모리 관리 전략이 필요하다.\nUnreachable 객체를 효율적으로 식별하고 제거하는 것이 가비지 컬렉션의 핵심 역할이다.\n\n## 가비지 컬렉션 동작 방식\n\n**가비지 컬렉션의 청소 방식**은 Unreachable 객체를 식별하고 제거하는 과정에서 사용하는 알고리즘에 따라 달라진다.\n가장 기본적인 방식은 **Mark and Sweep** 알고리즘으로, 많은 GC에서 기본으로 사용되는 메모리 정리 방법이다.\n\n<div class=\"mermaid\">\ngraph TD\n    subgraph Mark\n        A1[Object <br> reachable]\n        A2[Object <br> unreachable]\n        A3[Object <br> reachable]\n        A4[Object <br> unreachable]\n        A5[Object <br> reachable]\n    end\n    subgraph Sweep\n        B1[Object <br> reachable]\n        B2[<br>]\n        B3[Object <br> reachable]\n        B4[<br>]\n        B5[Object <br> reachable]\n    end\n    subgraph Compaction\n        C1[Object <br> reachable]\n        C2[Object <br> reachable]\n        C3[Object <br> reachable]\n    end\n\n    Mark --> Sweep\n    Sweep --> Compaction\n</div>\n\n이 방식은 다음 세 단계로 구성된다:\n\n1. **Mark 과정**: GC는 Root Space(루트 공간)에서 시작해 연결된 객체들을 그래프 형태로 순회하며, 참조되고 있는 객체들을 식별하고 마킹한다. Root Space는 힙 메모리를 참조하는 Method Area, Static 변수, JVM Stack, Native Method Stack 등을 포함한다. 이 과정을 통해 Reachable 객체와 Unreachable 객체를 구분한다.\n\n2. **Sweep 과정**: 마킹되지 않은 객체들(Unreachable 객체)을 힙(Heap)에서 제거한다. 이 단계에서는 더 이상 사용되지 않는 메모리를 해제하여 새 객체가 저장될 수 있도록 공간을 확보한다.\n\n3. **Compaction 과정**: Sweep 이후에 메모리 조각화(Fragmentation)를 줄이기 위해 남아있는 객체들을 힙의 시작 주소 쪽으로 압축한다. 이를 통해 연속된 메모리 공간을 확보해 새로운 객체를 할당할 때 메모리 할당 실패를 방지한다. 단, 이 과정은 모든 GC에서 수행되는 것은 아니며, 가비지 컬렉터의 종류에 따라 생략되기도 한다.\n\n이 방식은 **루트 공간(Root Space)** 기준으로 객체의 Reachable 상태를 판단하기 때문에 순환 참조와 같은 문제가 있는 객체도 효과적으로 정리할 수 있다.\nRoot Space는 JVM 메모리 구조에서 중요한 요소로, Method Area, Static 변수, JVM Stack, Native Method Stack이 루트 역할을 한다.\n\nMark and Sweep 방식은 간단하고 효율적이지만, 모든 객체를 순회하고 처리해야 하므로 수행 시간에 따라 애플리케이션의 성능에 영향을 줄 수 있다.\n또한, GC가 실행되는 동안 애플리케이션이 멈추는 **Stop-The-World(STW)** 현상이 발생할 수 있어 최적화된 GC 전략이 필요하다.\nMark and Sweep 알고리즘은 이런 기본 원리를 바탕으로 다양한 GC 최적화 기술의 기반이 되고 있다.\n\n# 가비지 컬렉션 동작 과정\n\n<hr>\n\n<div class=\"mermaid\">\ngraph TB\n    subgraph JVM_Memory [JVM Memory Runtime Data Area]\n        A[Method Area]\n        B[Heap]\n        C[JVM Language Stacks]\n        D[PC Registers]\n        E[Native Method Area]\n    end\n\n    subgraph Heap_Structure [Heap Structure]\n        F[Eden]\n        G[Survivor 1]\n        H[Survivor 2]\n        I[Old Generation]\n        J[Permanent Generation]\n    end\n\n    A --> B\n    B --> F\n    B --> I\n    G --> F\n    H --> G\n    I --> H\n    I --> J\n\n    F -->|Minor GC| G\n    G -->|Minor GC| H\n    H -->|Major GC <br> Full GC| I\n</div>\n\n## Heap 메모리의 구조\n\n**힙(Heap) 메모리의 구조**는 JVM에서 동적으로 생성된 객체와 레퍼런스 데이터를 저장하며, 가비지 컬렉션의 대상이 되는 공간이다.\nJVM의 힙 영역은 객체의 생존 기간과 특성을 기반으로 효율적으로 설계되었으며, 크게 **Young Generation**과 **Old Generation** 두 영역으로 나뉜다. 이러한 설계는 **Weak Generational Hypothesis**에 기반하며, 대부분의 객체는 금방 Unreachable 상태가 되고, 오래된 객체에서 새로운 객체로의 참조는 드물다는 가정을 전제로 한다.\n\n### Young Generation (Young 영역)\n**Young 영역**은 새롭게 생성된 객체가 처음 할당되는 공간이다. 대부분의 객체가 이 영역에서 생성되고 금방 Unreachable 상태가 되어 제거되며, 소규모 가비지 컬렉션인 **Minor GC**가 주로 이 영역에서 수행된다.\nYoung 영역은 다음 세 가지로 더 나뉜다:\n- **Eden**: 새롭게 생성된 객체가 위치하며, 정기적인 Minor GC 수행 후 살아남은 객체가 Survivor 영역으로 이동된다.\n- **Survivor 0 / Survivor 1**: Eden에서 살아남은 객체가 복사되는 영역으로, 최소 한 번 이상 GC를 통과한 객체들이 이곳에 존재한다. Survivor 0과 Survivor 1은 하나가 항상 비어 있어야 하는 규칙이 있다.\n\n### Old Generation (Old 영역)\n**Old 영역**은 Young 영역에서 여러 번의 GC를 거쳐 살아남은 객체가 복사되는 공간이다.\nYoung 영역보다 크며, 오래된 객체들이 위치하기 때문에 가비지 발생률이 상대적으로 낮다.\nOld 영역에서 수행되는 GC는 **Major GC** 또는 **Full GC**로 불리며, Young 영역보다 훨씬 더 큰 메모리를 다룬다.\n\n### 힙 영역 설계의 효율성\nOld 영역이 Young 영역보다 크도록 설계된 이유는, Young 영역의 객체 수명이 짧기 때문에 큰 공간을 필요로 하지 않으며, 대형 객체는 Young 영역을 거치지 않고 바로 Old 영역에 할당되기 때문이다.\n또한, Young 영역을 Eden과 두 개의 Survivor 영역으로 나누어 객체의 생존 기간을 면밀히 추적하고, 불필요한 객체를 효율적으로 제거하도록 가비지 컬렉션의 정확도를 높인다.\n\n### Permanent Generation (Java 7 이전)과 Metaspace (Java 8 이후)\n**Permanent Generation(PermGen)**은 클래스 로더에 의해 로드된 클래스와 메서드의 메타정보가 저장되던 공간으로, Java 7까지 힙 영역에 존재했다.\n그러나 Java 8 이후에는 힙 메모리에서 분리되어 **Metaspace**라는 Native Method Stack 영역에 통합되었다.\n이를 통해 PermGen에서 발생하던 메모리 부족 문제를 해결하고, 보다 유연한 메모리 관리를 가능하게 했다.\n\n## Minor GC 과정\n**Minor GC 과정**은 Young Generation에서 메모리를 효율적으로 관리하기 위해 수행되는 가비지 컬렉션으로, 객체의 생명 주기와 도달 가능성을 기준으로 불필요한 객체를 제거하는 프로세스이다.\nYoung Generation은 Eden 영역과 두 개의 Survivor 영역(Survivor 0, Survivor 1)으로 구성되어 있으며, Minor GC는 주로 Eden 영역에서 발생한다.\n\n주요 과정은 다음과 같다:\n\n1. **객체 생성 및 Eden 영역 할당**: 새로운 객체는 Young Generation의 Eden 영역에 위치하며, Eden 영역이 가득 차기 전까지 계속 저장된다.\n\n2. **Eden 영역 가득참 및 Minor GC 실행**: 객체가 계속 생성되어 Eden 영역이 꽉 차게 되면 Minor GC가 실행된다.\n\n3. **Mark 동작**: GC가 Eden 영역에서 Reachable 객체를 탐색하여 마킹한다. Reachable 객체는 참조되고 있는 상태로, 메모리에서 제거되지 않는다.\n\n4. **Reachable 객체 Survivor 영역 이동**: Eden 영역에서 살아남은 객체는 하나의 Survivor 영역(예: Survivor 0)으로 이동된다.\n\n5. **Unreachable 객체 메모리 해제**: Eden 영역에서 참조되지 않은 Unreachable 객체는 메모리에서 해제(Sweep)된다.\n\n6. **객체의 Age 증가**: Survivor 영역에 남아있는 객체들은 **age** 값이 1씩 증가한다. 이 값은 객체가 Survivor 영역에서 살아남은 횟수를 의미하며, `Object Header`에 기록된다. 특정 임계값(예: HotSpot JVM의 기본값 31)에 도달하면 객체는 Old Generation으로 승격(Promotion)된다.\n\n7. **다시 Eden 영역 할당**: Eden 영역에 신규 객체가 추가로 생성되어 다시 가득 차게 되면, Minor GC가 반복된다.\n\n8. **Survivor 영역 교체**: 마킹된 객체들은 비어있는 다른 Survivor 영역(예: Survivor 1)으로 이동하며, 사용 중인 Survivor 영역은 비워진다.\n\n9. **반복적인 Minor GC**: Eden 영역이 반복적으로 가득 차고, 객체들이 Survivor 영역 간 이동하며 age 값이 증가하는 과정을 계속 반복한다.\n\n10. **Survivor 영역의 제한 조건**: Survivor 영역 중 하나는 항상 비어 있어야 한다. 두 Survivor 영역이 동시에 사용 중이거나 모두 비어 있다면, 이는 시스템이 비정상적으로 작동하고 있음을 의미한다.\n\nMinor GC는 메모리 공간이 상대적으로 작은 Young Generation에서 수행되기 때문에 짧은 시간 내에 완료될 수 있다.\n하지만 Minor GC의 빈도가 지나치게 높아지면 애플리케이션 성능에 영향을 미칠 수 있으므로, 이를 고려한 메모리 관리 전략이 필요하다.\n이 과정을 통해 메모리를 효율적으로 관리하면서 Old Generation으로의 객체 이동을 최소화한다.\n\n## Major GC 과정\n\n**Major GC 과정**은 Old Generation 영역에서 발생하는 가비지 컬렉션으로, 상대적으로 수명이 긴 객체들이 저장된 메모리 공간을 관리하는 역할을 한다. Old Generation에 있는 객체들은 대부분 Young Generation에서 시작되어 Minor GC를 여러 번 통과하며, age 값이 임계값(예: 8)에 도달하면 Promotion 과정을 거쳐 이동된 객체들이다. Major GC는 Old Generation에 더 이상 새로운 객체를 저장할 공간이 부족해질 때 실행되며, Old Generation의 모든 객체를 검사해 참조되지 않은 객체를 제거한다.\n\n### Major GC의 주요 단계\n1. **객체 Promotion**: Young Generation에서 age 값이 임계값에 도달한 객체들은 Old Generation으로 이동된다.\n2. **Old Generation 메모리 부족**: Old Generation 영역에 객체가 계속 Promotion되면, 결국 메모리가 부족해지는 상황이 발생한다.\n3. **Major GC 발생**: Old Generation이 가득 차게 되면 Major GC가 실행된다. 이 과정에서는 Old Generation 내의 모든 객체를 검사하고, Unreachable 객체를 한꺼번에 제거한다.\n\n### Minor GC와 Major GC 비교\n\n| **항목**        | **Minor GC**                       | **Major GC (Full GC)**                |\n|-----------------|-----------------------------------|--------------------------------------|\n| **대상 영역**   | Young Generation                 | Old Generation                      |\n| **발생 빈도**   | 빈번하게 발생                    | 드물게 발생                         |\n| **처리 속도**   | 빠르다 (0.5~1초)                  | 상대적으로 느리다 (10배 이상 소요)    |\n| **영향**        | 애플리케이션 성능에 큰 영향 없음 | Stop-The-World 발생으로 성능 저하    |\n\n### Major GC의 특성과 문제점\nMajor GC는 Old Generation의 메모리를 확보하기 위해 모든 객체를 검사하므로 Minor GC에 비해 처리 시간이 오래 걸린다.\n이 과정에서 애플리케이션의 모든 스레드가 정지하는 **Stop-The-World** 현상이 발생하며, CPU에 부하를 주고 애플리케이션이 일시적으로 멈추거나 느려지는 현상을 유발할 수 있다.\n이로 인해 Major GC는 실시간 성능이 중요한 애플리케이션에서 문제가 될 수 있다.\n\n현재도 Major GC로 인한 성능 저하를 줄이기 위해 다양한 알고리즘을 활용하여 GC의 처리 시간을 최소화하고, Stop-The-World 현상을 줄이는 방향으로 최적화 작업이 이루어지고 있다.\nJDK에서 제공하는 가비지 컬렉션 알고리즘의 종류와 각 버전에 따른 GC 방식의 변화에 대해 알아보고, 이를 통해 애플리케이션의 성능을 최적화할 수 있는 가비지 컬렉션 설정을 이해해보도록 하자.\n\n# JVM의 가비지 컬렉션 알고리즘 종류\n\n<hr>\n\n자바의 가비지 컬렉션(GC)은 메모리 관리 효율성을 극대화하고 애플리케이션 성능을 유지하기 위해 다양한 알고리즘을 제공하며, 각 알고리즘은 특정한 요구와 환경에 맞게 설계되었다. GC 알고리즘은 JVM 옵션을 통해 상황에 따라 설정할 수 있다. 다음은 주요 GC 알고리즘의 특징과 사용 방법에 대한 정리이다.\n\n## Serial GC\nCPU 코어가 1개인 환경에서 적합하며, 일반적인 서버 환경에서는 잘 사용되지 않음.\n- 단일 스레드(Single Thread)로 동작하며 가장 단순한 GC.\n- **Mark-Sweep** 방식으로 Minor GC, **Mark-Sweep-Compact** 방식으로 Major GC 수행.\n- Stop-The-World 시간이 가장 길며, 성능이 낮은 환경에서만 사용.\n\n```bash\njava -XX:+UseSerialGC -jar Application.java\n```\n\n## Parallel GC\n기본적인 멀티 코어 CPU 환경에서 사용.\n- Java 8의 기본 GC.\n- Minor GC를 멀티 스레드로 처리하지만, Old Generation은 싱글 스레드로 처리.\n- Serial GC 대비 Stop-The-World 시간이 줄어듦.\n\n```bash\njava -XX:+UseParallelGC -jar Application.java\njava -XX:ParallelGCThreads=N # 사용할 스레드 개수 지정\n```\n\n## Parallel Old GC\n멀티 코어 환경에서 Old Generation의 GC 성능이 중요한 경우 사용.\n- Parallel GC의 개선 버전.\n- Young Generation과 Old Generation 모두 멀티 스레드로 GC 수행.\n- Mark-Summary-Compact 방식을 사용하여 효율성 증가.\n\n```bash\njava -XX:+UseParallelOldGC -jar Application.java\njava -XX:ParallelGCThreads=N\n```\n\n## CMS GC (Concurrent Mark Sweep)\n실시간 처리가 중요한 애플리케이션에서 사용되었으나 현재는 사용되지 않음.\n- 애플리케이션 스레드와 GC 스레드가 동시에 실행되어 Stop-The-World 시간을 줄임.\n- GC 과정이 복잡하고 CPU 사용량이 높으며, 메모리 파편화 문제가 존재.\n- Java 9에서 deprecated, Java 14에서 제거됨.\n\n```bash\njava -XX:+UseConcMarkSweepGC -jar Application.java\n```\n\n## G1 GC (Garbage First)\n힙 크기가 4GB 이상이며, 실시간 응답성이 중요한 애플리케이션에서 사용.\n- CMS GC를 대체하기 위해 JDK 7에서 도입, Java 9부터 기본 GC.\n- 힙 메모리를 고정된 Young/Old 영역으로 나누지 않고 **Region**이라는 단위로 분할.\n- 메모리가 많이 사용된 Region을 우선적으로 수집하여 효율성 향상.\n- Stop-The-World 시간이 짧고 예측 가능(0.5초).\n\n```bash\njava -XX:+UseG1GC -jar Application.java\n```\n\n## Shenandoah GC\nPause 시간이 중요한 대규모 애플리케이션에서 적합.\n- Java 12에서 도입, Red Hat에서 개발.\n- 강력한 동시성(Concurrency)으로 Stop-The-World 시간을 최소화.\n- CMS의 단편화와 G1의 Pause 이슈를 해결한 GC.\n- 힙 크기에 관계없이 일정한 Pause 시간이 특징.\n\n```bash\njava -XX:+UseShenandoahGC -jar Application.java\n```\n\n## ZGC (Z Garbage Collector)\n매우 낮은 지연 시간과 대규모 메모리 관리가 필요한 애플리케이션에서 사용.\n- Java 15에서 도입.\n- 대규모 메모리(8MB ~ 16TB)를 처리하며 Stop-The-World 시간이 10ms를 넘지 않음.\n- 힙 메모리를 **ZPage**라는 동적 크기의 영역으로 관리.\n\n```bash\njava -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java\n```\n\n## GC 알고리즘 비교 요약\n\n| **알고리즘**       | **특징**                                                  | **장점**                         | **단점**                            |\n|------------------|-------------------------------------------------------|--------------------------------|-----------------------------------|\n| Serial GC        | 단일 스레드, 가장 단순한 GC                             | 구현 간단, CPU가 낮은 환경에 적합 | Stop-The-World 시간이 길다         |\n| Parallel GC      | Young 영역 멀티 스레드 처리                             | 성능 향상, Stop-The-World 감소   | Old Generation은 싱글 스레드 처리 |\n| Parallel Old GC  | Old Generation도 멀티 스레드 처리                       | 더 나은 성능                    | 높은 CPU 사용량                   |\n| CMS GC           | 동시 실행으로 Stop-The-World 최소화                     | 실시간 처리 적합                | 복잡한 과정, 메모리 파편화 문제    |\n| G1 GC            | Region 개념 도입, 메모리 효율성 증가                     | 낮은 지연 시간                  | 설정이 복잡할 수 있음             |\n| Shenandoah GC    | 매우 짧은 Pause 시간                                    | 힙 크기와 상관없는 일정한 Pause | 최신 JVM에서만 사용 가능           |\n| ZGC              | 대규모 메모리와 낮은 지연 시간 처리                     | Stop-The-World 시간 10ms 이하   | 메모리 사용량이 많을 수 있음       |\n\n# GC 모니터링 및 메모리 문제\n\nGC는 JVM 메모리를 효율적으로 관리하기 위해 자동으로 수행되지만, 그 과정에서 예상치 못한 문제가 발생할 수 있다.\nGC가 과도하게 실행되면 CPU 사용량이 증가하고 메모리 자원이 부족해져 애플리케이션의 응답 시간이 길어질 수 있다.\n특히, 클라우드 환경이나 대규모 시스템에서는 리소스 관리가 중요한데, 이런 환경에서 GC가 적절히 작동하지 않으면 서비스 장애로 이어질 수 있다.\n이를 방지하기 위해 **jstat**, **VisualVM**, **Prometheus+Grafana** 같은 도구를 활용하여 GC와 메모리 사용 상태를 실시간으로 모니터링해야 한다.\n이를 통해 GC가 애플리케이션에 미치는 영향을 파악하고 적절한 조치를 취할 수 있다.\n\n### **OutOfMemoryError와 대처 방안**\nGC를 모니터링하던 중 **OutOfMemoryError**가 발생하는 경우, 이는 힙 메모리의 부족 또는 메모리 누수로 인해 발생할 가능성이 높다.\n이를 해결하려면 먼저 원인을 파악하는 것이 중요하다.\n**힙 덤프(Heap Dump)**를 생성한 뒤, **Eclipse MAT(Memory Analyzer Tool)**이나 **VisualVM** 같은 분석 도구를 활용해 메모리 누수 여부와 객체 참조 상태를 분석한다.\n\n1. **메모리 누수의 원인 파악**: 메모리 누수가 원인인 경우, 불필요한 객체 참조가 제거되지 않은 코드를 찾아 수정해야 한다. 일반적인 원인으로는 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션에 남아 있는 객체 등이 있다.\n2. **힙 메모리 크기 조정**: 애플리케이션 데이터 처리량이 메모리 크기를 초과하는 경우, JVM 옵션(`-Xmx`, `-Xms`)으로 힙 크기를 늘리고, 적합한 GC 알고리즘(G1 GC, ZGC 등)을 선택해 GC 튜닝을 수행한다.\n3. **추적과 예방**: 애플리케이션 로깅 및 모니터링 체계를 구축해 메모리 사용량 추이를 관찰하고, OutOfMemoryError가 발생하기 전에 문제를 사전에 탐지하도록 한다.\n\n### **메모리 누수 확인과 방지**\n메모리 누수는 GC가 제거하지 못하는 객체가 메모리를 지속적으로 점유하는 문제로, 힙 메모리를 고갈시킬 수 있다.\n이를 해결하려면 실행 중인 애플리케이션에서 **힙 덤프**를 생성한 후, **객체 그래프**를 분석하여 불필요하게 참조되고 있는 객체를 식별해야 한다.\n\n- **분석 도구 활용**: **Eclipse MAT**이나 **VisualVM**을 사용해 객체의 참조 체인을 추적하고 의도치 않게 유지되고 있는 객체를 찾아낸다.\n- **실시간 모니터링**: **JConsole**, **jstat**, 또는 **APM(Application Performance Monitoring)** 도구를 사용해 메모리 사용량 변화를 실시간으로 모니터링한다. 이를 통해 메모리 사용량이 지속적으로 증가하는 패턴을 확인할 수 있다.\n- **일반적인 누수 원인 해결**: 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션 문제 등이 누수의 일반적인 원인이므로, 이러한 요소들을 면밀히 검토하여 코드 문제를 수정한다.\n\n> 추후 왜 STW(Stop-The-World)가 발생하는지 등에 대한 내용 추가할 예정이다."},{"excerpt":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX 와  그리고  메서드의 공통점은 모두 한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 와  그리고  메서드의 문제점…","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"date":"November 22, 2024","title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX","tags":["Java"]},"rawMarkdownBody":"\n# Vector와 Hashtable 그리고 Collections.SynchronizedXXX\n`Vector`와 `Hashtable` 그리고 `Collections.synchronizedXXX()` 메서드의 공통점은 모두 `Thread-Safe`한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n`Thread-Safe`한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 `Vector`와 `Hashtable` 그리고 `Collections.synchronizedXXX()` 메서드의 문제점에 대해 알아보자.\n\n## Vector와 Hashtable 문제점\n`Vector`와 `Hashtable`은 모두 레거시한 자바 클래스로, 데이터를 저장하고 관리하는 컬렉션 클래스이다.\n근데 왜 레거시한 자바 컬렉션인지 궁금할 수 있다. 이는 `Vector`와 `Hashtable`이 `Thread-Safe`한 컬렉션으로 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있다.\n이로 인해 두 클래스 모두 메서드 단위에서 동기화를 제공하지만, 이로 인해 앞서 언급했듯이 성능이 저하되는 문제가 발생한다.\n이는 필요한 부분만 동기화를 제공하지 않고, 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제이다.\n\n내부 구현이 어떻게 되어있는지 그리고 어떠한 상황에서 이러한 문제가 발생하는지 알아보겠다.\n\n```java\npublic synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n```\n\n위 코드 `Vector` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있는 것을 볼 수 있다.\n`Vector` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있기 때문에 두 스레드가 동시에 `add()` 메서드를 호출하면 한 스레드는 대기하게 된다.\n이로 인해 race condition이 발생하여 성능이 저하되는 문제가 발생한다.\n\n이러한 문제로 현재의 자바에서는 `Vector`와 `Hashtable` 대신 `ArrayList`와 `HashMap`을 사용하는 것을 권장하고 있다.\n`ArrayList` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있지 않기에 두 스레드가 동시에 `add()` 메서드를 호출해도 서로 영향을 주지 않는다.\n그럼 동기화 메서드로 구성된 컬렉션을 사용하고 싶다면 어떻게 해야할까?\n\n## Collections.synchronizedXXX() 메서드\n`Collections.synchronizedXXX()` 메서드는 `Vector`와 `Hashtable`과 같이 동기화된 메서드로 구성된 컬렉션을 반환한다.\n이 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성된 컬렉션을 반환하기 때문에 `Thread-Safe`한 컬렉션을 사용할 수 있다.\n\n내부 구현이 어떻게 되어있는지 알아보겠다.\n\n```java\npublic static <T> List<T> synchronizedList(List<T> list) {\n    return (list instanceof RandomAccess ?\n            new SynchronizedRandomAccessList<>(list) :\n            new SynchronizedList<>(list));\n}\n```\n\n위 코드는 `Collections.synchronizedList()` 메서드의 내부 구현이다.\n이 메서드는 `List` 인터페이스를 구현한 컬렉션을 매개변수로 받아 `SynchronizedList` 클래스를 반환한다.\n이로 인해 `ArrayList`의 모든 메서드에 대해 동기화를 제공받게 된다.\n그러면 이 메서드를 사용하면 안전할까?\n그렇지는 않다. `Collections.synchronizedXXX()` 메서드는 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제가 발생한다.\n이 문제 또한 `Vector`와 `Hashtable`의 문제와 같은 문제이다.\n그럼 이러한 문제를 해결하기 위해 어떻게 해야할까?\n이러한 문제로 현재의 자바에서는 `Collections.synchronizedXXX()` 메서드 대신 `ConcurrentHashMap`과 같은 `Concurrent` 패키지의 컬렉션을 사용하는 것을 권장하고 있다.\n\n## Concurrent\n`Concurrent` 패키지는 멀티 스레드 환경에서 안전하게 사용할 수 있는 컬렉션을 제공한다.\n`ConcurrentHashMap`은 `Hashtable`과 같이 `Thread-Safe`한 컬렉션으로 동기화된 메서드로 구성되어 있지만, `ConcurrentHashMap`은 필요한 부분만 동기화를 제공하기 때문에 성능이 향상된다.\n\n내부 구현이 어떻게 되어있는지 알아보겠다.\n\n```java\npublic class ConcurrentHashMap<K, V> {\n    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) {\n            throw new NullPointerException();\n        }\n        int hash = spread(key.hashCode());\n        return null;\n    }\n}\n```\n\n위 코드는 `ConcurrentHashMap` 클래스의 `put()` 메서드의 일부분이다.\n이 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있지만, 필요한 부분만 동기화를 제공하기 때문에 `Thread-Safe`한 컬렉션을 사용하면서 성능이 향상된다.\n자세한 내용은 [ConcurrentHashMap vs SynchronizedMap](https://023-dev.github.io/2024-11-22/Java-ConcurrentHashMap-SynchronizedMap)을 참고하자.\n\n이렇게 주저리주저리 써봤는데 정리하자면 기존 레거시 자바 버전에서는 `Vector`와 `Hashtable`을 사용했지만 해당 컬레션들의 모든 메서드들이 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있어 과도한 락이 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 `Vector`와 `Hashtable` 대신 `ArrayList`와 `HashMap`을 사용하는 것을 권장하고 있다.\n근데 이 부분에서 동기화 메서드가 필요로 해져서 `Collections.synchronizedXXX()` 메서드를 사용해 해당 컬렉션을 동기화된 형태로 래핑할 수 있게 되었다.\n하지만 이 부분에서도 `Vector`와 `Hashtable`과 같은 문제가 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 결과적으로 현재의 자바에서는 `ArrayList`와 `HashMap`을 `Thread-Safe`하게 사용하기 위한 방법으로 `Concurrent` 패키지의 컬렉션을 사용하는 것을 권장하고 있다."},{"excerpt":"SynchronizedList와 CopyOnWriteArrayList의 차이 SynchronizedList 를 사용해 기존 리스트를 동기화된 형태로 래핑한 클래스다. 특징: 내부적으로 모든 메서드가 동기화()되어 다중 스레드에서 안전하게 사용 가능. 읽기 및 쓰기 작업 모두 락을 사용하여 성능이 저하될 수 있음. 반복(iteration) 작업은 추가로 동…","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"date":"November 22, 2024","title":"SynchronizedList와 CopyOnWriteArrayList의 차이","tags":["Java"]},"rawMarkdownBody":"\n## SynchronizedList와 CopyOnWriteArrayList의 차이\n\n### **SynchronizedList**\n`Collections.synchronizedList`를 사용해 기존 리스트를 동기화된 형태로 래핑한 클래스다.\n- **특징**:\n    1. 내부적으로 **모든 메서드가 동기화**(`synchronized`)되어 다중 스레드에서 안전하게 사용 가능.\n    2. 읽기 및 쓰기 작업 모두 락을 사용하여 성능이 저하될 수 있음.\n    3. 반복(iteration) 작업은 추가로 동기화가 필요.\n       ```java\n       List<String> list = Collections.synchronizedList(new ArrayList<>());\n  \n       synchronized (list) { // 반복 작업 시 동기화 필요\n           for (String item : list) {\n               System.out.println(item);\n            }\n       }\n       ```\n\n- **장점**:\n    - 간단한 동기화 구현.\n    - 기존 `ArrayList` 또는 `LinkedList`를 동기화된 형태로 변환 가능.\n\n- **단점**:\n    - 읽기 작업과 쓰기 작업 간의 **불필요한 락 경쟁**으로 인해 성능 저하.\n    - 반복 작업 시 동기화 코드를 추가해야 함.\n\n---\n\n### CopyOnWriteArrayList\nJava Concurrency API(`java.util.concurrent`)에서 제공하는 동기화 리스트 구현체다.\n- **특징**:\n    1. 쓰기 작업 시, 내부 배열을 **복사(Copy)**하여 새로 작성.\n    2. **읽기 작업은 락 없이** 수행 가능.\n    3. 반복 작업 중에도 쓰기 작업이 가능하며, **ConcurrentModificationException**이 발생하지 않음.\n\n- **장점**:\n    - 읽기 작업이 많고 쓰기 작업이 적은 환경에서 성능이 우수.\n    - 반복 작업 중에도 안정적이며 동기화 필요 없음.\n\n- **단점**:\n    - 쓰기 작업 시 배열을 복사하므로 **메모리 사용량** 증가.\n    - 쓰기 작업이 많으면 성능 저하.\n\n**예제 코드**:\n```java\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class CopyOnWriteExample {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        list.add(\"A\");\n        list.add(\"B\");\n\n        for (String item : list) {\n            list.add(\"C\"); // 반복 중 추가 가능\n            System.out.println(item);\n        }\n    }\n}\n```\n\n### **사용 시 선택 기준**\n- **SynchronizedList**:\n    - 간단히 동기화를 구현해야 할 때.\n    - 읽기와 쓰기 작업이 균등하게 발생하는 환경.\n\n- **CopyOnWriteArrayList**:\n    - 읽기 작업이 대부분이고, 쓰기 작업이 드문 환경.\n    - 반복 작업 중에도 안전한 동기화가 필요한 경우.\n"},{"excerpt":"SynchronizedMap와 ConcurrentHashMap 과 은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다. SynchronizedMap 은  메소드를 통해 생성할 수 있…","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"date":"November 22, 2024","title":"SynchronizedMap vs ConcurrentHashMap","tags":["Java"]},"rawMarkdownBody":"\n# SynchronizedMap와 ConcurrentHashMap\n`SynchronizedMap`과 `ConcurrentHashMap`은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다.\n\n## SynchronizedMap\n`SynchronizedMap`은 `Collections.synchronizedMap()` 메소드를 통해 생성할 수 있다.\n이 클래스는 내부적으로 `synchronized` 키워드를 사용하여 동기화를 제공한다.\n`Collections.synchronizedxxx`의 초기화 코드는 다음과 같다.\n\n```java\nMap<String, String> map = Collections.synchronizedMap(new HashMap<>());\n```\n\n앞서 생성한 `HashMap`을 `Collections.synchronizedMap()` 메소드에 넘겨주면, 래핑 된 `SynchronizedMap`이 생성된다.\n하지만 이렇게 생성한 `SynchronizedMap`은 단순히 `synchronized` 키워드를 사용하여 객체 레벨의 잠금을 제공하여 동기화를 제공하기 때문에,\nput 및 get 메소드 호출 시 동일한 작업을 수행하기 위해 락을 선점해야 한다.\n이처럼 컬렉션 전체에 대한 락을 사용하면 오버 헤드가 발생하며, 한 스레드가 맵을 수정하는 동안 다른 스레드는 대기해야 하는 과도한 락 문제가 발생할 수 있다.\n또한 이는 성능 저하를 야기할 수 있으며, `ConcurrentModificationException`이 발생할 수 있다.\n\n## ConcurrentHashMap\n`ConcurrentHashMap`은 `SynchronizedMap`과 달리 락을 사용하여 동기화를 제공하지 않는다.\n이 클래스는 `synchronized` 키워드를 사용하지 않고, 내부적으로 락을 사용하여 동기화를 제공한다.\n\n`ConcurrentHashMap`은 다음과 같이 생성할 수 있다.\n\n```java\nMap<String, String> map = new ConcurrentHashMap<>();\n```\n\n`ConcurrentHashMap`은 `SynchronizedMap`과 달리 `synchronized` 키워드를 사용하지 않기 때문에, 객체 레벨의 락이 아닌 좀 더 세분화된\n버킷 레벨의 락을 사용하여 동기화를 제공한다.\n여기서 버킷 레벨의 락이란 맵의 각 버킷에 대해 락을 제공하는 것을 의미한다.\n배열, 연결 리스트 그리고 트리 등의 자료구조를 사용하여 버킷을 구성하며, 각 버킷은 독립적으로 락을 가지고 있다.\n보통 해시 충돌이 얼마나 발생하는지에 따라 버킷의 수가 결정되며, 해시 충돌이 많이 발생할수록 버킷의 수가 많아진다.\n또한 자료구조도 해시 충돌을 줄이기 위해 변경되는데 만약 해쉬 충돌이 적으면 배열과 연결 리스트를 사용하고, 해시 충돌이 많으면 Red-Black Tree를 사용한다.\n이를 통해 여러 스레드가 동시에 맵을 수정할 수 있으며, 더 많은 확정성을 지니게 된다.\n기본적으로 `ConcurrentHashMap`은 16개의 버킷을 가지고 있으며, 각 버킷은 독립적으로 락을 가지고 있다.\n이론적으로 봤을 때 16개의 버킷이 있기 때문에 16개의 스레드가 동시에 맵을 수정할 수 있다.\n필요하다면 `ConcurrentHashMap`의 크기를 늘릴 수 있으며, 이는 생성자에 전달할 수 있는 초기 용량을 조정하여 가능하다.\n\n## null 허용 여부\n`SynchronizedMap`과 `ConcurrentHashMap`은 null 키와 null 값을 다른 방식으로 처리한다.\n기본적으로 `SynchronizedMap`은 null 키와 null 값을 모두 허용한다.\n\n```java\nMap<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());\nsynchronizedMap.put(null, \"value\"); // null 키 허용\nsynchronizedMap.put(\"key\", null); // null 값 허용\n```\n\n하지만, `ConcurrentHashMap`은 null 키와 null 값을 모두 허용하지 않는다.\n따라서 `ConcurrentHashMap`을 사용할 때는 null 키와 null 값을 사용하지 않도록 주의해야 한다.\n\n```java\nMap<String, String> concurrentHashMap = new ConcurrentHashMap<>();\nconcurrentHashMap.put(null, \"value\"); // null 키 불허\nconcurrentHashMap.put(\"key\", null); // null 값 불허\n```\n\n```java\nException in thread \"main\" java.lang.NullPointerException\n    at java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1011)\n    at java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)\n    at com.example.demo.DemoApplication.main(DemoApplication.java:13)\n```\n\n그래도 `ConcurrentHashMap`을 사용하고 싶은데 null 키와 null 값을 사용해야 하는 경우에는,\n`ConcurrentHashMap` 대신 `ConcurrentHashMap`을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.\n\n```java\npublic class MyConcurrentHashMap<K, V> extends ConcurrentHashMap<K, V> {\n    @Override\n    public V put(K key, V value) {\n        if (key == null) {\n            throw new NullPointerException(\"null key\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null value\");\n        }\n        return super.put(key, value);\n    }\n}\n```\n\n`SynchronizedMap`과 `ConcurrentHashMap`은 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n`SynchronizedMap`은 `synchronized` 키워드를 사용하여 객체 레벨의 락을 제공하며, `ConcurrentHashMap`은 버킷 레벨의 락을 사용하여 동기화를 제공한다.\n따라서 `ConcurrentHashMap`이 `SynchronizedMap`보다 더 좋은 성능을 제공한다.\n또한 `ConcurrentHashMap`은 null 키와 null 값을 허용하지 않는다.\n따라서 null 키와 null 값을 사용해야 하는 경우에는 `ConcurrentHashMap`을 사용할 수 없다.\n이러한 경우에는 `ConcurrentHashMap`을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.\n"},{"excerpt":"CAS와 ABA CAS(Compare-And-Swap)와 ABA 문제에 대해 알아보기에 앞서 동기화와 Lock-Based 알고리즘, Lock-Free 알고리즘에 대해 알아보자. 동시성(Concurrency)과 병렬성(Parallelism) 동시성과 병렬성은 비슷한 개념이지만, 다르다.\n동시성은 여러 작업을 동시에 처리하는 것이고, 병렬성은 여러 작업을 동…","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"date":"November 21, 2024","title":"CAS(Compare-And-Swap)와 ABA 문제","tags":["Java"]},"rawMarkdownBody":"\n# CAS와 ABA\nCAS(Compare-And-Swap)와 ABA 문제에 대해 알아보기에 앞서 동기화와 Lock-Based 알고리즘, Lock-Free 알고리즘에 대해 알아보자.\n\n## 동시성(Concurrency)과 병렬성(Parallelism)\n동시성과 병렬성은 비슷한 개념이지만, 다르다.\n동시성은 여러 작업을 동시에 처리하는 것이고, 병렬성은 여러 작업을 동시에 처리하는 것이다.\n동시성은 하나의 코어에서 여러 작업을 번갈아가며 처리하는 것이고, 병렬성은 여러 코어에서 여러 작업을 동시에 처리하는 것이다.\n\n## 동기화(Synchronization)\n동기화는 동시성 프로그래밍에서 여러 스레드가 공유 자원에 접근할 때, 데이터 일관성을 유지하기 위해 사용하는 기법이다.\n이를 통해 스레드 간의 경합을 방지하고, 데이터 일관성을 유지할 수 있다.\nLock-Based 알고리즘과 Lock-Free 알고리즘이 동기화를 위한 방법에 속한다.\n\n## Lock-Based 알고리즘\nLock-Based 알고리즘은 락을 사용하여 동기화하는 방식으로, 락을 획득한 스레드만 작업을 수행하고, 다른 스레드는 대기하게 된다.\n하지만 락을 사용하면 경합이 발생하여 성능이 저하되는 문제가 발생한다.\n\n## Lock-Free 알고리즘\nLock-Free 알고리즘은 락을 사용하지 않고 동기화하는 방식으로, CAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\nLock-Based 알고리즘과 달리 락을 사용하지 않아 경합이 발생하지 않아 성능이 향상되는 장점이 있다.\n\n## CAS(Compare-And-Swap) 알고리즘\nCAS(Compare-And-Swap) 알고리즘은 락을 사용하지 않고 동기화하는 방식이다.\n값을 읽고, 비교하고, 교체하는 연산을 원자적으로 수행하는 방식으로 락을 사용하지 않아 경합이 발생하지 않아 성능이 향상된다.\n하지만 단점 또한 존재하는데, ABA 문제가 발생할 수 있다.\n\n## ABA 문제\nABA 문제는 CAS 알고리즘에서 발생하는 문제로, 스레드 A가 값을 읽고, 스레드 B가 값을 변경하고, 스레드 A가 다시 값을 변경할 때, 스레드 A는 값이 변경되지 않았다고 판단하여 문제가 발생한다.\n이를 해결하기 위해 AtomicStampedReference, AtomicMarkableReference 클래스들과 같은 스탬프 기반의 클래스를 사용하여 해결할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        AtomicReference<Integer> atomicReference = new AtomicReference<>(100);\n\n        Thread thread1 = new Thread(() -> {\n            atomicReference.compareAndSet(100, 200);\n            atomicReference.compareAndSet(200, 100);\n        });\n\n        Thread thread2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean result = atomicReference.compareAndSet(100, 300);\n            System.out.println(result); // true\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n위 코드에서 스레드 1은 100을 200으로 변경하고, 200을 100으로 변경한다.\n스레드 2는 1초를 대기한 후 100을 300으로 변경한다.\n하지만 스레드 2는 100을 200으로 변경한 후 200을 100으로 변경한 것을 알지 못하기 때문에 100을 300으로 변경할 수 있다.\n\n이러한 ABA 문제를 해결하기 위해 AtomicStampedReference, AtomicMarkableReference 클래스들을 사용하여 해결할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 0);\n\n        Thread thread1 = new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp();\n            atomicStampedReference.compareAndSet(100, 200, stamp, stamp + 1);\n            stamp = atomicStampedReference.getStamp();\n            atomicStampedReference.compareAndSet(200, 100, stamp, stamp + 1);\n        });\n\n        Thread thread2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            int stamp = atomicStampedReference.getStamp();\n            boolean result = atomicStampedReference.compareAndSet(100, 300, stamp, stamp + 1);\n            System.out.println(result); // false\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n위 코드에서 AtomicStampedReference 클래스를 사용하여 스탬프를 사용하여 ABA 문제를 해결할 수 있다.\n스레드 1은 100을 200으로 변경하고, 200을 100으로 변경한다.\n스레드 2는 1초를 대기한 후 100을 300으로 변경한다.\n하지만 스레드 2는 100을 200으로 변경한 후 200을 100으로 변경한 것을 알기 때문에 100을 300으로 변경할 수 없다.\n\n이러한 방식으로 ABA 문제를 해결할 수 있다.\n"},{"excerpt":"자바의 멀티 스레딩 이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다. 동시성과 병렬성의 차이점 동시성()과 병렬성()은 다중 작업을 처리하는 방식에서 차이가 있다. 동시성(): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다. 병렬성(): 여러 작업이 물리적으로 동시에 실행됩니다. 멀…","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"date":"November 20, 2024","title":"자바 멀티 스레딩","tags":["Java"]},"rawMarkdownBody":"\n# 자바의 멀티 스레딩\n\n<hr>\n\n이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다.\n\n## 동시성과 병렬성의 차이점\n동시성(`Concurrency`)과 병렬성(`Parallelism`)은 다중 작업을 처리하는 방식에서 차이가 있다.\n- 동시성(`Concurrency`): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다.\n- 병렬성(`Parallelism`): 여러 작업이 물리적으로 동시에 실행됩니다. 멀티코어 CPU에서 서로 다른 코어가 각각의 작업을 실행한다.\n\n## Thread-Safe하다는 것의 의미\n`Thread-Safe`는 다중 스레드 환경에서 동시 접근이 발생해도 데이터의 일관성을 유지하고 예측 가능한 결과를 보장하는 것을 의미한다.\n\n## Thread-Safe를 구현하는 방법\n\n다음은 자바에서 `Thread-Safe`를 구현하는 방법들을 정리한다.\n### Mutual Exclusion (상호 배제)\n\n`synchronized` 키워드를 사용하여 한 번에 하나의 스레드만 특정 코드 블록에 접근하도록 하여 제한하는 방식이다.\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n```\n\n### 불변 객체 사용\n\n객체의 상태를 변경하지 않음으로써 스레드 간의 충돌을 방지하여 동기화가 필요성을 소거하는 방식이다.\n\n```java\npublic class ImmutableCounter {\n    private final int count;\n\n    public ImmutableCounter(int count) {\n        this.count = count;\n    }\n\n    public ImmutableCounter increment() {\n        return new ImmutableCounter(this.count + 1);\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n### Thread-Local Storage\n\n`ThreadLocal` 클래스 사용해서 각 스레드가 고유한 메모리를 할당하여 독립적인 데이터를 가질 수 있도록 설정하는 방식이다.\n\n```java\npublic class ThreadLocalExample {\n    private static ThreadLocal<Integer> threadLocalCount = ThreadLocal.withInitial(() -> 0);\n\n    public void increment() {\n        threadLocalCount.set(threadLocalCount.get() + 1);\n    }\n\n    public int getCount() {\n        return threadLocalCount.get();\n    }\n}\n\n```\n\n### Concurrent 패키지 사용\n`java.util.concurrent` 패키지에서 제공하는 `Thread-Safe` 자료구조와 API 사용하는 방식으로 `ConcurrentHashMap`와 `CopyOnWriteArrayList`가 주로 사용된다.\n\n### Lock-Free Programming\n\n`AtomicInteger` 같은 CAS(Compare-And-Swap) 알고리즘을 사용하여 스레드 경합을 줄이고 성능을 개선하는 방식이다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Thread-Safe 구현에서의 고려 사항\n\n- 성능 문제\n   - `Thread-Safe`를 보장하는 방식은 대개 비용이 든다. 예를들어, `synchronized` 블록은 락을 사용하는데 이때 경합(Contension) 발생 시 성능 저하를 초래한다.\n- 데드락(`Deadlock`)\n   - 두 개 이상의 스레드가 서로의 락을 기다리면서 무한 대기 상태에 빠질 위험이 있다.\n- 락 경합 문제\n   - 여러 스레드가 동시에 동일한 리소스에 접근하려고 시도하면 경합으로 인해 처리 속도 저하의 원인이 된다.\n- 비효율적 동기화\n   - 불필요하게 동기화가 과도하게 사용되면 작업 처리 속도가 크게 떨어질 수 있다.\n\n### Thread-Safe하지 않은 경우 야기되는 문제\n두 개 이상의 스레드가 동시에 동일한 데이터에 접근 및 수정하여 일관되지 않은 결과를 초래하는 데이터 레이스(Data Race)현상을 야기한다.\n\n```java\npublic class NotThreadSafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// 여러 스레드에서 increment() 호출 시\n// count 값이 의도한 값보다 작게 나올 가능성.\n```\n\n### Thread-Safe를 구현하는 가장 성능이 좋은 방법\n동기화 비용을 줄이기 위해 CAS 알고리즘 기반의 Atomic 클래스를 사용하는 것이 일반적으로 더 효율적이다. 읽기 작업이 많은 경우, CopyOnWriteArrayList와 같은 데이터 구조 사용하면 된다.\n\n## 가시성 문제와 원자성 문제\n\n### 가시성 문제\n가시성 문제는 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이지 않는 현상을 의미한다.\n보통 가시성 문제의 원인은 다음과 같다.\n- 각 스레드는 메인 메모리 대신 CPU 캐시에 데이터를 저장하고 읽음으로 인해 메모리 불일치 발생한다.\n- 코드 실행 순서가 재배열되어 예상과 다른 동작한다.\n- 데이터의 일관성을 보장하는 메모리 배리어가 없어 업데이트가 다른 스레드에 전파되지 않음로 인해 발생한다.\n\n예를들면 아래 코드에서 `stop = true`로 값을 변경해도, 다른 스레드에서 `stop`의 변경 사항을 보지 못해 무한 루프가 발생할 수 있다.\n```java\npublic class VisibilityExample {\n    private static boolean stop = false;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            while (!stop) {\n                // 작업 수행\n            }\n            System.out.println(\"Stopped!\");\n        });\n        thread.start();\n\n        // stop 값을 변경\n        stop = true;\n    }\n}\n```\n\n#### 원자성 문제\n원자성 문제는 작업이 중간에 끼어들기 없이 완료되지 않는 현상을 의미한다.\n주로 특정 작업 단위가 나뉘어 실행될 경우, 다른 스레드가 작업 중간에 간섭하여 데이터 불일치 발생하게 된다.\n\n아래 코드는 count++는 Read, Modify, Write 세 단계로 나뉘어 실행되는데 이때 다른 스레드가 중간에 간섭 가능해서 count 값이 예상보다 작을 수 있다.\n\n```java\npublic class AtomicityExample {\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Count: \" + count); // 기대값: 2000, 실제값: 불확실\n    }\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            count++; // Read-Modify-Write\n        }\n    }\n}\n```\n\n### 자바의 동시성 이슈 해결 방법\n이러한 자바의 동시성 이슈를 해결하기 위해 다음과 같은 방법이 있다.\n- 변수의 변경 사항을 메인 메모리에 즉시 반영시켜 가시성을 보장하는 `volatile` 키워드를 사용한다.\n- 메모리의 일관성(원자성)을 보장하는 `synchronized` 키워드를 사용한다\n- `AtomicInteger` 클래스를 사용해 `CAS(Compare-And-Swap)` 알고리즘 기반으로 원자성 보장하는 방식이 주가된다.\n- Lock 객체를 사용하여 `ReentrantLock` 사용한다.\n\n\n### volatile 키워드\nCPU 캐시가 아닌 메인 메모리에서 값을 읽고 씀으로 변수의 값을 모든 스레드에서 즉시 읽을 수 있도록하여 컴파일러와 CPU의 재정렬 방지를 보장한다. 대신 원자성을 보장하지 않는다는 단점이 있다.\n\n```java\npublic class VolatileExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false; // 다른 스레드에서도 즉시 반영\n    }\n\n    public void doWork() {\n        while (running) {\n            // 작업 실행\n        }\n    }\n}\n```\n\n## synchronized 키워드\n\nsynchronized는 동기화를 통해 한 번에 하나의 스레드만 특정 코드 블록 또는 메서드에 접근할 수 있도록 제한하여 스레드 간 상호 배제(Mutual Exclusion)와 가시성(Visibility)을 보장하는 키워드다.\n\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n### synchronized의 내부 동작 원리\n`synchronized`는 JVM의 모니터 락(Monitor Lock)을 기반으로 바이트코드 레벨에서 동작한다.\n`monitorenter`로 락을 획득하거나 `monitorexit`으로 락을 해제 할 수 있고, 이때 객체 헤더(Object Header)에 있는 Monitor 필드에 락 상태가 기록된다.\n\n\n```java\npublic void synchronizedBlockExample() {\n    synchronized (this) {\n        count++;\n    }\n}\n\n//0: aload_0\n//1: dup\n//2: monitorenter // 락 획득\n//3: aload_0\n//4: dup\n//5: getfield \n// #2 // count 읽기\n//8: iconst_1\n//9: iadd\n//10: putfield \n//#2 // count 쓰기 \n//13: monitorexit // 락 해제 \n//14: return\n```\n\n### synchronized의 단점\n물론 이렇게 synchronized을 사용함으로써 단점도 존재한다.\n- 성능 저하\n   - 락 경쟁이 발생할 경우 스레드가 대기 상태에 머물러 성능 저하 발생한다.\n- 데드락(Deadlock)\n   - 여러 스레드가 서로의 락을 기다리며 무한 대기 상태가 발생한다.\n- Fine-Grained Locking 부족\n   - 동기화 범위가 크면, 불필요한 락 경쟁이 발생한다.\n\n ```java\n public class DeadlockExample {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            synchronized (lock2) {\n                System.out.println(\"Method1\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            synchronized (lock1) {\n                System.out.println(\"Method2\");\n            }\n        }\n    }\n}\n```\n\n\n## Atomic\nAtomic은 작업 중간에 다른 스레드가 개입할 수 없고, 작업이 완전히 수행되거나 아예 수행되지 않는 상태를 보장되어 분할되지 않는 작업 단위를 의미한다.\n이 개념의 핵심은 원자성을 보장하여 작업이 중간에 끼어든다거나 일관성이 침해되는 것을 방지하는 것이다.\n- **Atomic 타입**: `AtomicInteger`, `AtomicLong`, `AtomicReference` 등이 있음.\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 연산\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Java에서 원자성을 보장하는 방법\n\n#### synchronized 키워드: 동기화 블록을 사용하여 작업 단위를 원자적으로 처리.\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++; // synchronized로 원자성 보장\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n#### Atomic 클래스 사용해 CAS(Compare-And-Swap) 알고리즘을 기반으로 성능과 원자성을 모두 보장하는 방법.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 증가\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n\n```\n\n#### 불변 객체(Immutable Object)\n\nString, Integer 같은 클래스는 불변 객체로 설계되어 Thread-Safe하다.\n\n#### Lock-Free 알고리즘\nCAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\n\n## CAS(Compare-And-Swap) 알고리즘\n\nCAS(비교 및 교환)는 Lock-Free 동기화 기법으로, 데이터를 직접 락 없이 원자적으로 작업을 수행한다.\n동작 원리는 현재 메모리 값을 읽어서 예상 값과 현재 메모리 값을 비교하고 예상 값과 일치하면 새로운 값으로 변경, 그렇지 않으면 재시도하는 방식으로 동작하는 알고리즘이다.\n이로 인해 락을 사용하지 않아 스레드 경합이 줄어들어 성능이 향상되는 효과를 얻을 수 있다.\n\n하지만 단점도 존재한다.\n예상 값이 변경되었다가 다시 원래 값으로 돌아온 경우, CAS는 이를 감지하지 못하는 ABA문제가 발생할 수 있다.\n이를 해결하기 위해 AtomicStampedReference와 같은 스탬프(버전) 기반의 데이터 구조를 사용하면 된다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CASExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        while (true) {\n            int current = count.get();\n            int next = current + 1;\n            if (count.compareAndSet(current, next)) {\n                break;\n            }\n        }\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### ABA 문제\nABA 문제는 CAS(Compare-And-Swap) 알고리즘에서 발생하는 문제로, 메모리의 값이 변경되었다가 다시 원래 값으로 돌아왔을 때, CAS는 이를 감지하지 못해 값이 변경되지 않은 것으로 잘못 판단하는 현상이다.\n예를 들어, 값이 A → B → A로 변경되었더라도 CAS는 단순히 값이 A인지 여부만 확인하므로 중간 변경을 인식하지 못한다.\n\n### ABA 문제 해결 방법\n그럼 CAS가 더 효율적이라 사용하고 싶은데 ABA 문제가 발생한다고 하면 도대체 어떻게 사용을 하라는 걸까?\n당연히 그런 해결책도 존재했다.\n\n#### AtomicStampedReference\n`AtomicStampedReference`와 같은 버전 성질의 데이터 구조를 사용하는 것이다.\n`AtomicStampedReference`는 값과 함께 버전 정보(Stamp)를 저장하여 값이 중간에 변경되었는지 확인한다.\n내부 동작 과정은 값과 스탬프(버전)를 함께 저장하고, CAS 비교 시, 값뿐만 아니라 스탬프도 비교해서 값은 동일하더라도 스탬프가 다르면 중간 변경이 있었음을 탐지하는 방법으로 ABA문제를 해결할 수 있다.\n\n```java\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class ABAExample {\nprivate static AtomicStampedReference<Integer> atomicStampedRef =\nnew AtomicStampedReference<>(100, 0); // 초기 값 100, 초기 스탬프 0\n\n    public static void main(String[] args) {\n        int initialStamp = atomicStampedRef.getStamp(); // 현재 스탬프\n        Integer initialValue = atomicStampedRef.getReference(); // 현재 값\n\n        // 스레드 1: 값 변경 (100 -> 200 -> 100)\n        new Thread(() -> {\n            atomicStampedRef.compareAndSet(100, 200, initialStamp, initialStamp + 1); // 스탬프 증가\n            atomicStampedRef.compareAndSet(200, 100, initialStamp + 1, initialStamp + 2); // 다시 100으로 변경\n        }).start();\n\n        // 스레드 2: 값과 스탬프 확인 후 CAS 시도\n        new Thread(() -> {\n            try {\n                Thread.sleep(500); // 스레드 1이 변경하는 동안 대기\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            boolean success = atomicStampedRef.compareAndSet(\n                100, 300, initialStamp, initialStamp + 1 // 초기 스탬프를 사용\n            );\n\n            System.out.println(\"Update Success: \" + success); // false: 스탬프가 변경됨\n        }).start();\n    }\n}\n```"},{"excerpt":"HashMap 컬렉션 HashMap의 동작 원리 ****은 키-값() 쌍을 저장하는 데 사용되는 자바의 컬렉션으로, 내부적으로 해시 테이블(Hash Table) 자료구조를 사용합니다. 데이터를 저장, 검색, 삭제하는 데 효율적이며, 다음과 같은 방식으로 동작한다. 저장 구조 은 내부적으로 배열과 연결 리스트(또는 트리)를 조합하여 데이터를 저장한다. 배열…","fields":{"slug":"/java-hashmap/"},"frontmatter":{"date":"November 18, 2024","title":"HashMap 컬렉션","tags":["Java"]},"rawMarkdownBody":"\n\n# HashMap 컬렉션\n\n<hr>\n\n## HashMap의 동작 원리\n\n**`HashMap`**은 키-값(`Key-Value`) 쌍을 저장하는 데 사용되는 자바의 컬렉션으로, 내부적으로 **해시 테이블(Hash Table)** 자료구조를 사용합니다. 데이터를 저장, 검색, 삭제하는 데 효율적이며, 다음과 같은 방식으로 동작한다.\n\n### 저장 구조\n\n`HashMap`은 내부적으로 배열과 연결 리스트(또는 트리)를 조합하여 데이터를 저장한다.\n\n- **배열**  \n  해시 테이블의 주요 저장 공간으로, 각 요소는 **버킷(Bucket)** 역할을 한다.\n\n- **버킷**  \n  동일한 해시 값을 가진 키들이 저장되는 공간으로, 연결 리스트(또는 트리)로 구현된다.\n\n### 데이터 저장 (`put` 메서드)\n\n- **해시 함수 계산**\n    - 키(`Key`) 객체의 `hashCode()` 메서드를 호출하여 해시 값을 계산한다.\n    - 계산된 해시 값은 배열 인덱스로 변환된다.\n- **버킷에 데이터 저장**\n    - 계산된 인덱스를 기준으로 해당 버킷에 데이터를 저장한다.\n    - 동일한 인덱스에 여러 키가 저장될 경우, 연결 리스트 또는 트리 구조로 관리된다.\n\n```java\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(\"apple\", 1); // \"apple\"의 해시값을 계산해 저장\nhashMap.put(\"banana\", 2); // \"banana\"의 해시값을 계산해 저장\n```\n\n### 데이터 검색 (`get` 메서드)\n\n1. **해시 함수 계산**\n- 검색하려는 키의 `hashCode()`를 계산하여 배열의 인덱스를 얻는다.\n\n2. **버킷 탐색**\n- 해당 버킷의 연결 리스트(또는 트리)에서 키를 비교(`equals`)하여 값을 찾는다.\n\n```java\nint value = hashMap.get(\"apple\"); // \"apple\"의 해시값을 계산해 값 검색\nSystem.out.println(value); // 출력: 1\n```\n\n### 해시 충돌\n\n**해시 충돌**은 서로 다른 키가 동일한 해시 값을 가지는 경우 발생한다.  \n이 문제를 해결하기 위해 `HashMap`은 **체이닝(Chaining)**과 **트리화(Treeification)**를 사용한다.\n\n- **체이닝**  \n  동일한 해시 값을 가진 데이터를 연결 리스트로 저장.\n\n- **트리화**  \n  연결 리스트의 크기가 일정 수준을 초과하면, **이진 검색 트리**로 변환하여 성능을 개선.\n\n**JDK 8 이후 HashMap 내부 동작**\n\n```java\nif (bucketSize >= TREEIFY_THRESHOLD) {\n    // 연결 리스트를 트리로 변환\n    bucket = treeify(bucket);\n}\n```\n\n### 최악의 시간 복잡도\n\n**최적의 경우**\n- 해시 함수가 균등하게 동작하여 충돌이 발생하지 않을 경우,  \n  데이터 접근, 삽입, 삭제 모두 **O(1)**.\n\n**최악의 경우**\n- 모든 키가 동일한 해시 값을 가지는 경우(심각한 해시 충돌),  \n  연결 리스트 전체를 순회해야 하므로 **O(n)**.\n- JDK 8 이후에는 연결 리스트가 트리로 변환되므로, 최악의 시간 복잡도는 **O(log n)**로 개선.\n\n#### 시간 복잡도\n\n| **작업**         | **최적 시간 복잡도** | **최악 시간 복잡도**       |\n|------------------|----------------------|---------------------------|\n| **삽입 (`put`)** | O(1)                | O(log n) (JDK 8 이후)     |\n| **검색 (`get`)** | O(1)                | O(log n) (JDK 8 이후)     |\n| **삭제 (`remove`)** | O(1)              | O(log n) (JDK 8 이후)     |\n\n\n```java\nimport java.util.HashMap;\n\npublic class HashMapCollisionTest {\n    public static void main(String[] args) {\n        // 해시 충돌을 유발하는 키 생성\n        HashMap<Key, Integer> hashMap = new HashMap<>();\n        for (int i = 0; i < 10000; i++) {\n            hashMap.put(new Key(\"key\" + i), i);\n        }\n\n        long startTime = System.nanoTime();\n        System.out.println(hashMap.get(new Key(\"key9999\"))); // 값 검색\n        long endTime = System.nanoTime();\n\n        System.out.println(\"검색 시간: \" + (endTime - startTime) + \"ns\");\n    }\n\n    static class Key {\n        String key;\n\n        Key(String key) {\n            this.key = key;\n        }\n\n        @Override\n        public int hashCode() {\n            return 42; // 모든 키가 동일한 해시 값을 가지도록 설정\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Key && this.key.equals(((Key) obj).key);\n        }\n    }\n}\n```\n"},{"excerpt":"자바의 멀티 스레딩 이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다. 동시성과 병렬성의 차이점 동시성()과 병렬성()은 다중 작업을 처리하는 방식에서 차이가 있다. 동시성(): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다. 병렬성(): 여러 작업이 물리적으로 동시에 실행됩니다. 멀…","fields":{"slug":"/java-atomic/"},"frontmatter":{"date":"November 17, 2024","title":"멀티 스레드 환경에서 동시성 프로그래밍","tags":["Java"]},"rawMarkdownBody":"\n# 자바의 멀티 스레딩\n\n<hr>\n\n이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다.\n\n## 동시성과 병렬성의 차이점\n동시성(`Concurrency`)과 병렬성(`Parallelism`)은 다중 작업을 처리하는 방식에서 차이가 있다.\n- 동시성(`Concurrency`): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다.\n- 병렬성(`Parallelism`): 여러 작업이 물리적으로 동시에 실행됩니다. 멀티코어 CPU에서 서로 다른 코어가 각각의 작업을 실행한다.\n\n## Thread-Safe하다는 것의 의미\n`Thread-Safe`는 다중 스레드 환경에서 동시 접근이 발생해도 데이터의 일관성을 유지하고 예측 가능한 결과를 보장하는 것을 의미한다.\n\n## Thread-Safe를 구현하는 방법\n\n다음은 자바에서 `Thread-Safe`를 구현하는 방법들을 정리한다.\n### Mutual Exclusion (상호 배제)\n\n`synchronized` 키워드를 사용하여 한 번에 하나의 스레드만 특정 코드 블록에 접근하도록 하여 제한하는 방식이다.\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n```\n\n### 불변 객체 사용\n\n객체의 상태를 변경하지 않음으로써 스레드 간의 충돌을 방지하여 동기화가 필요성을 소거하는 방식이다.\n\n```java\npublic class ImmutableCounter {\n    private final int count;\n\n    public ImmutableCounter(int count) {\n        this.count = count;\n    }\n\n    public ImmutableCounter increment() {\n        return new ImmutableCounter(this.count + 1);\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n### Thread-Local Storage\n\n`ThreadLocal` 클래스 사용해서 각 스레드가 고유한 메모리를 할당하여 독립적인 데이터를 가질 수 있도록 설정하는 방식이다.\n\n```java\npublic class ThreadLocalExample {\n    private static ThreadLocal<Integer> threadLocalCount = ThreadLocal.withInitial(() -> 0);\n\n    public void increment() {\n        threadLocalCount.set(threadLocalCount.get() + 1);\n    }\n\n    public int getCount() {\n        return threadLocalCount.get();\n    }\n}\n\n```\n\n### Concurrent 패키지 사용\n`java.util.concurrent` 패키지에서 제공하는 `Thread-Safe` 자료구조와 API 사용하는 방식으로 `ConcurrentHashMap`와 `CopyOnWriteArrayList`가 주로 사용된다.\n\n### Lock-Free Programming\n\n`AtomicInteger` 같은 CAS(Compare-And-Swap) 알고리즘을 사용하여 스레드 경합을 줄이고 성능을 개선하는 방식이다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Thread-Safe 구현에서의 고려 사항\n\n- 성능 문제\n  - `Thread-Safe`를 보장하는 방식은 대개 비용이 든다. 예를들어, `synchronized` 블록은 락을 사용하는데 이때 경합(Contension) 발생 시 성능 저하를 초래한다.\n- 데드락(`Deadlock`)\n  - 두 개 이상의 스레드가 서로의 락을 기다리면서 무한 대기 상태에 빠질 위험이 있다.\n- 락 경합 문제\n  - 여러 스레드가 동시에 동일한 리소스에 접근하려고 시도하면 경합으로 인해 처리 속도 저하의 원인이 된다.\n- 비효율적 동기화\n  - 불필요하게 동기화가 과도하게 사용되면 작업 처리 속도가 크게 떨어질 수 있다.\n\n### Thread-Safe하지 않은 경우 야기되는 문제\n두 개 이상의 스레드가 동시에 동일한 데이터에 접근 및 수정하여 일관되지 않은 결과를 초래하는 데이터 레이스(Data Race)현상을 야기한다.\n\n```java\npublic class NotThreadSafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// 여러 스레드에서 increment() 호출 시\n// count 값이 의도한 값보다 작게 나올 가능성.\n```\n\n### Thread-Safe를 구현하는 가장 성능이 좋은 방법\n동기화 비용을 줄이기 위해 CAS 알고리즘 기반의 Atomic 클래스를 사용하는 것이 일반적으로 더 효율적이다. 읽기 작업이 많은 경우, CopyOnWriteArrayList와 같은 데이터 구조 사용하면 된다.\n\n## 가시성 문제와 원자성 문제\n\n### 가시성 문제\n가시성 문제는 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이지 않는 현상을 의미한다.\n보통 가시성 문제의 원인은 다음과 같다.\n- 각 스레드는 메인 메모리 대신 CPU 캐시에 데이터를 저장하고 읽음으로 인해 메모리 불일치 발생한다.\n- 코드 실행 순서가 재배열되어 예상과 다른 동작한다.\n- 데이터의 일관성을 보장하는 메모리 배리어가 없어 업데이트가 다른 스레드에 전파되지 않음로 인해 발생한다.\n\n예를들면 아래 코드에서 `stop = true`로 값을 변경해도, 다른 스레드에서 `stop`의 변경 사항을 보지 못해 무한 루프가 발생할 수 있다.\n```java\npublic class VisibilityExample {\n    private static boolean stop = false;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            while (!stop) {\n                // 작업 수행\n            }\n            System.out.println(\"Stopped!\");\n        });\n        thread.start();\n\n        // stop 값을 변경\n        stop = true;\n    }\n}\n```\n\n#### 원자성 문제\n원자성 문제는 작업이 중간에 끼어들기 없이 완료되지 않는 현상을 의미한다.\n주로 특정 작업 단위가 나뉘어 실행될 경우, 다른 스레드가 작업 중간에 간섭하여 데이터 불일치 발생하게 된다.\n\n아래 코드는 count++는 Read, Modify, Write 세 단계로 나뉘어 실행되는데 이때 다른 스레드가 중간에 간섭 가능해서 count 값이 예상보다 작을 수 있다.\n\n```java\npublic class AtomicityExample {\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Count: \" + count); // 기대값: 2000, 실제값: 불확실\n    }\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            count++; // Read-Modify-Write\n        }\n    }\n}\n```\n\n### 자바의 동시성 이슈 해결 방법\n이러한 자바의 동시성 이슈를 해결하기 위해 다음과 같은 방법이 있다.\n- 변수의 변경 사항을 메인 메모리에 즉시 반영시켜 가시성을 보장하는 `volatile` 키워드를 사용한다.\n- 메모리의 일관성(원자성)을 보장하는 `synchronized` 키워드를 사용한다\n- `AtomicInteger` 클래스를 사용해 `CAS(Compare-And-Swap)` 알고리즘 기반으로 원자성 보장하는 방식이 주가된다.\n- Lock 객체를 사용하여 `ReentrantLock` 사용한다.\n\n\n### volatile 키워드\nCPU 캐시가 아닌 메인 메모리에서 값을 읽고 씀으로 변수의 값을 모든 스레드에서 즉시 읽을 수 있도록하여 컴파일러와 CPU의 재정렬 방지를 보장한다. 대신 원자성을 보장하지 않는다는 단점이 있다.\n\n```java\npublic class VolatileExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false; // 다른 스레드에서도 즉시 반영\n    }\n\n    public void doWork() {\n        while (running) {\n            // 작업 실행\n        }\n    }\n}\n```\n\n## synchronized 키워드\n\nsynchronized는 동기화를 통해 한 번에 하나의 스레드만 특정 코드 블록 또는 메서드에 접근할 수 있도록 제한하여 스레드 간 상호 배제(Mutual Exclusion)와 가시성(Visibility)을 보장하는 키워드다.\n\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n### synchronized의 내부 동작 원리\n`synchronized`는 JVM의 모니터 락(Monitor Lock)을 기반으로 바이트코드 레벨에서 동작한다.\n`monitorenter`로 락을 획득하거나 `monitorexit`으로 락을 해제 할 수 있고, 이때 객체 헤더(Object Header)에 있는 Monitor 필드에 락 상태가 기록된다.\n\n\n```java\npublic void synchronizedBlockExample() {\n    synchronized (this) {\n        count++;\n    }\n}\n\n//0: aload_0\n//1: dup\n//2: monitorenter // 락 획득\n//3: aload_0\n//4: dup\n//5: getfield \n// #2 // count 읽기\n//8: iconst_1\n//9: iadd\n//10: putfield \n//#2 // count 쓰기 \n//13: monitorexit // 락 해제 \n//14: return\n```\n\n### synchronized의 단점\n물론 이렇게 synchronized을 사용함으로써 단점도 존재한다.\n- 성능 저하\n  - 락 경쟁이 발생할 경우 스레드가 대기 상태에 머물러 성능 저하 발생한다.\n- 데드락(Deadlock)\n  - 여러 스레드가 서로의 락을 기다리며 무한 대기 상태가 발생한다.\n- Fine-Grained Locking 부족\n  - 동기화 범위가 크면, 불필요한 락 경쟁이 발생한다.\n\n ```java\n public class DeadlockExample {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            synchronized (lock2) {\n                System.out.println(\"Method1\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            synchronized (lock1) {\n                System.out.println(\"Method2\");\n            }\n        }\n    }\n}\n```\n\n\n## Atomic\nAtomic은 작업 중간에 다른 스레드가 개입할 수 없고, 작업이 완전히 수행되거나 아예 수행되지 않는 상태를 보장되어 분할되지 않는 작업 단위를 의미한다.\n이 개념의 핵심은 원자성을 보장하여 작업이 중간에 끼어든다거나 일관성이 침해되는 것을 방지하는 것이다.\n- **Atomic 타입**: `AtomicInteger`, `AtomicLong`, `AtomicReference` 등이 있음.\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 연산\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Java에서 원자성을 보장하는 방법\n\n#### synchronized 키워드: 동기화 블록을 사용하여 작업 단위를 원자적으로 처리.\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++; // synchronized로 원자성 보장\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n#### Atomic 클래스 사용해 CAS(Compare-And-Swap) 알고리즘을 기반으로 성능과 원자성을 모두 보장하는 방법.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 증가\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n\n```\n\n#### 불변 객체(Immutable Object)\n\nString, Integer 같은 클래스는 불변 객체로 설계되어 Thread-Safe하다.\n\n#### Lock-Free 알고리즘\nCAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\n\n## CAS(Compare-And-Swap) 알고리즘\n\nCAS(비교 및 교환)는 Lock-Free 동기화 기법으로, 데이터를 직접 락 없이 원자적으로 작업을 수행한다.\n동작 원리는 현재 메모리 값을 읽어서 예상 값과 현재 메모리 값을 비교하고 예상 값과 일치하면 새로운 값으로 변경, 그렇지 않으면 재시도하는 방식으로 동작하는 알고리즘이다.\n이로 인해 락을 사용하지 않아 스레드 경합이 줄어들어 성능이 향상되는 효과를 얻을 수 있다.\n\n하지만 단점도 존재한다.\n예상 값이 변경되었다가 다시 원래 값으로 돌아온 경우, CAS는 이를 감지하지 못하는 ABA문제가 발생할 수 있다.\n이를 해결하기 위해 AtomicStampedReference와 같은 스탬프(버전) 기반의 데이터 구조를 사용하면 된다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CASExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        while (true) {\n            int current = count.get();\n            int next = current + 1;\n            if (count.compareAndSet(current, next)) {\n                break;\n            }\n        }\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### ABA 문제\nABA 문제는 CAS(Compare-And-Swap) 알고리즘에서 발생하는 문제로, 메모리의 값이 변경되었다가 다시 원래 값으로 돌아왔을 때, CAS는 이를 감지하지 못해 값이 변경되지 않은 것으로 잘못 판단하는 현상이다.\n예를 들어, 값이 A → B → A로 변경되었더라도 CAS는 단순히 값이 A인지 여부만 확인하므로 중간 변경을 인식하지 못한다.\n\n### ABA 문제 해결 방법\n그럼 CAS가 더 효율적이라 사용하고 싶은데 ABA 문제가 발생한다고 하면 도대체 어떻게 사용을 하라는 걸까?\n당연히 그런 해결책도 존재했다.\n\n#### AtomicStampedReference\n`AtomicStampedReference`와 같은 버전 성질의 데이터 구조를 사용하는 것이다.\n`AtomicStampedReference`는 값과 함께 버전 정보(Stamp)를 저장하여 값이 중간에 변경되었는지 확인한다.\n내부 동작 과정은 값과 스탬프(버전)를 함께 저장하고, CAS 비교 시, 값뿐만 아니라 스탬프도 비교해서 값은 동일하더라도 스탬프가 다르면 중간 변경이 있었음을 탐지하는 방법으로 ABA문제를 해결할 수 있다.\n\n```java\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class ABAExample {\nprivate static AtomicStampedReference<Integer> atomicStampedRef =\nnew AtomicStampedReference<>(100, 0); // 초기 값 100, 초기 스탬프 0\n\n    public static void main(String[] args) {\n        int initialStamp = atomicStampedRef.getStamp(); // 현재 스탬프\n        Integer initialValue = atomicStampedRef.getReference(); // 현재 값\n\n        // 스레드 1: 값 변경 (100 -> 200 -> 100)\n        new Thread(() -> {\n            atomicStampedRef.compareAndSet(100, 200, initialStamp, initialStamp + 1); // 스탬프 증가\n            atomicStampedRef.compareAndSet(200, 100, initialStamp + 1, initialStamp + 2); // 다시 100으로 변경\n        }).start();\n\n        // 스레드 2: 값과 스탬프 확인 후 CAS 시도\n        new Thread(() -> {\n            try {\n                Thread.sleep(500); // 스레드 1이 변경하는 동안 대기\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            boolean success = atomicStampedRef.compareAndSet(\n                100, 300, initialStamp, initialStamp + 1 // 초기 스탬프를 사용\n            );\n\n            System.out.println(\"Update Success: \" + success); // false: 스탬프가 변경됨\n        }).start();\n    }\n}\n```\n"},{"excerpt":"ArrayList 컬렉션 는 자바의 컬렉션 프레임워크에서 배열 기반으로 동작하는  인터페이스의 구현체 중 하나로 가장 많이 사용되는 컬렉션에 속한다.\n이 글에서는 자바의  컬렉션에 대해 다른 컬렉션들과 비교를 하며 알아보겠다. ArrayList 특징 먼저 의 특징에 대해서 알아보자. 연속적인 데이터 저장 데이터는 연속적으로 저장되며, 리스트 중간에 빈 공…","fields":{"slug":"/java-arraylist/"},"frontmatter":{"date":"November 17, 2024","title":"ArrayList 컬렉션","tags":["Java"]},"rawMarkdownBody":"\n# ArrayList 컬렉션\n\n<hr>\n\n`ArrayList`는 자바의 컬렉션 프레임워크에서 배열 기반으로 동작하는 `List` 인터페이스의 구현체 중 하나로 가장 많이 사용되는 컬렉션에 속한다.\n이 글에서는 자바의 `ArrayList` 컬렉션에 대해 다른 컬렉션들과 비교를 하며 알아보겠다.\n\n## ArrayList 특징\n\n먼저 `ArrayList`의 특징에 대해서 알아보자.\n\n- 연속적인 데이터 저장\n    - 데이터는 연속적으로 저장되며, 리스트 중간에 빈 공간이 생기지 않는다.\n- 내부 구조\n    - 내부적으로 `Object[]` 배열을 사용하여 데이터를 저장한다.\n- 빠른 접근성\n    - 배열 기반이기 때문에 인덱스를 이용해 요소에 빠르게 접근할 수 있다.\n- 가변적인 크기\n    - 배열과 달리, `ArrayList`는 데이터 적재량에 따라 크기를 동적으로 늘리거나 줄일 수 있다.\n    - 단, 배열 공간이 꽉 찰 때마다 새로운 배열을 생성하고 기존 데이터를 **복사(`copy`)**하는 방식으로 크기를 확장하므로,\n    - 이 과정에서 성능 지연이 발생할 수 있다.\n- 삽입/삭제 성능\n    - 리스트 중간에 데이터를 삽입/삭제할 경우, 중간의 빈 공간을 방지하기 위해 요소들을 자동으로 이동시킨다.\n    - 이로 인해 삽입/삭제 성능이 낮다.\n\n이러한 특징으로 `ArrayList`는 데이터 조회가 빈번한 경우에 사용하기 적합하다.\n\n# 다른 컬렉션과 비교를 통해 이해하기\n\n<hr>\n\n## ArrayList vs 배열 비교\n\n위에서 `ArrayList`는 배열을 기반으로 설계되었다고 나왔는데 그러면 배열과 어떠한 차이점이 있어 사용되는지 알아보도록하자.\n\n### 선언 및 초기화\n\n- 배열: 크기를 명시적으로 지정하며, 크기가 고정된다.\n\n```java\n// 배열 선언 및 초기화\nint[] arr = new int[5]; // 크기 고정\narr[0] = 10; // 데이터 추가\nSystem.out.println(arr[0]); // 출력: 10\n```\n\n- `ArrayList`: 크기를 초기화하지 않아도 사용 가능하며, 데이터가 추가되면 크기가 동적으로 조정된다.\n\n```java\n// ArrayList 선언 및 초기화\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10); // 데이터 추가\nSystem.out.println(arrayList.get(0)); // 출력: 10\n```\n\n### 용량 가변성\n\n- **배열**:\n    - 크기가 고정되어 생성 후 변경할 수 없다.\n    - 크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 한다.\n\n```java\nint[] arr = {1, 2, 3};\nint[] newArr = new int[5]; // 새로운 배열 생성\nSystem.arraycopy(arr, 0, newArr, 0, arr.length); // 데이터 복사\nnewArr[3] = 4; // 추가 데이터\nSystem.out.println(Arrays.toString(newArr)); // 출력: [1, 2, 3, 4, 0]\n```\n\n- **`ArrayList`**:\n    - 크기가 동적으로 조정된다.\n    - 내부적으로 배열을 사용하며, 배열 공간이 부족하면 새로운 배열을 생성하고 데이터를 복사한다.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(1);\narrayList.add(2);\narrayList.add(3);\n// 동적 크기 조정\narrayList.add(4);\nSystem.out.println(arrayList); // 출력: [1, 2, 3, 4]\n```\n\n### 데이터 접근\n\n- **배열**:\n    - 인덱스를 통해 데이터를 직접 접근할 수 있다.\n    - 접근 속도는 **O(1)**.\n\n```java\nint[] arr = {10, 20, 30};\nSystem.out.println(arr[1]); // 출력: 20\n```\n\n- **`ArrayList`**:\n    - 배열과 동일하게 인덱스를 통해 데이터를 접근할 수 있다.\n    - 내부적으로 배열을 사용하므로 접근 속도는 **O(1)**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(arrayList.get(1)); // 출력: 20\n```\n\n### 데이터 삽입/삭제\n\n- **배열**:\n    - 특정 위치에 데이터를 삽입하거나 삭제할 때 모든 요소를 이동해야 한다.\n    - 삽입/삭제 속도는 **O(n)**.\n\n```java\nint[] arr = {1, 2, 4, 5};\nint[] newArr = new int[5]; // 새로운 배열 생성\nSystem.arraycopy(arr, 0, newArr, 0, 2); // 기존 데이터 복사\nnewArr[2] = 3; // 삽입\nSystem.arraycopy(arr, 2, newArr, 3, 2); // 나머지 데이터 복사\nSystem.out.println(Arrays.toString(newArr)); // 출력: [1, 2, 3, 4, 5]\n```\n\n- **`ArrayList`**:\n    - 배열과 마찬가지로 삽입/삭제 시 요소를 이동시켜야 하지만, 추가 메서드(`add`, `remove`)로 쉽게 처리할 수 있다.\n    - 삽입/삭제 속도는 **`O(n)`**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(1, 2, 4, 5));\narrayList.add(2, 3); // 2번 인덱스에 삽입\nSystem.out.println(arrayList); // 출력: [1, 2, 3, 4, 5]\narrayList.remove(2); // 2번 인덱스 삭제\nSystem.out.println(arrayList); // 출력: [1, 2, 4, 5]\n```\n\n### 메모리 사용 및 성능\n\n- **배열**:\n    - 고정 크기이므로 메모리를 미리 할당한다.\n    - 메모리 사용 효율이 높고, 복사 비용이 없다.\n\n- **`ArrayList`**:\n    - 크기가 동적으로 변경되므로 내부적으로 더 많은 메모리를 할당한다.\n    - 크기가 부족할 때 새로운 배열을 생성하고 기존 데이터를 복사하는 비용이 발생한다.\n    - 디폴트로 1.5배 크기로 확장된다.\n\n**`ArrayList` 내부 동작 코드 예시** (JDK 8):\n\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 기존 크기의 1.5배\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n## ArrayList vs LinkedList 비교\n\n`ArrayList`와 `LinkedList`는 모두 **리스트** 인터페이스를 구현한 컬렉션으로, 데이터 저장 및 관리에 사용된다.  \n그러나 내부 구조와 동작 방식에서 큰 차이가 있어, 사용 목적과 상황에 따라 선택해야 한다.\n\n### 내부 구조\n\n- **`ArrayList`**\n    - 내부적으로 **배열**을 사용하여 데이터를 저장한다.\n    - 요소들은 배열의 인덱스로 접근하며, 연속적인 메모리 공간에 저장된다.\n\n```java\n// ArrayList 내부 구조 예제\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10); // 배열의 끝에 추가\nSystem.out.println(arrayList.get(0)); // 인덱스를 통해 접근\n```\n\n- **`LinkedList`**\n    - **이중 연결 리스트**(`Doubly Linked List`)로 구현된다.\n    - 각 요소는 데이터와 함께 다음 요소 및 이전 요소를 가리키는 포인터를 가진 노드로 구성된다.\n\n```java\n// LinkedList 내부 구조 예제\nLinkedList<Integer> linkedList = new LinkedList<>();\nlinkedList.add(10); // 노드로 데이터 추가\nSystem.out.println(linkedList.get(0)); // 순차적으로 접근\n```\n\n### 데이터 접근\n\n- **`ArrayList`**\n    - 배열 기반이므로 **임의 요소 접근**이 빠르다.\n    - 시간 복잡도: **`O(1)`**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(arrayList.get(1)); // 출력: 20\n```\n\n- **`LinkedList`**\n    - 노드를 따라가며 순차적으로 접근해야 하므로, **임의 요소 접근**이 느리다.\n    - 시간 복잡도: **`O(n)`**.\n\n```java\nLinkedList<Integer> linkedList = new LinkedList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(linkedList.get(1)); // 출력: 20 (노드를 순차적으로 탐색)\n```\n\n### 데이터 삽입/삭제\n\n- **`ArrayList`**\n    - 중간 삽입/삭제 시, 나머지 요소들을 **이동**해야 하므로 속도가 느리다.\n    - 시간 복잡도: **O(n)** (중간 삽입/삭제), **O(1)** (끝에 추가).\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\narrayList.add(1, 15); // 1번 인덱스에 삽입\nSystem.out.println(arrayList); // 출력: [10, 15, 20, 30]\n```\n\n- **`LinkedList`**\n    - 연결 리스트 구조 덕분에 중간 삽입/삭제 시 노드 포인터만 변경하면 되므로 속도가 빠르다.\n    - 시간 복잡도: **O(1)** (노드 참조 후 삽입/삭제).\n\n```java\nLinkedList<Integer> linkedList = new LinkedList<>(Arrays.asList(10, 20, 30));\nlinkedList.add(1, 15); // 1번 인덱스에 삽입\nSystem.out.println(linkedList); // 출력: [10, 15, 20, 30]\n```\n\n### 메모리 사용\n\n- **`ArrayList`**\n    - 연속적인 메모리 공간을 사용하며, 크기가 부족할 경우 기존 데이터를 새로운 배열로 복사해야 한다.\n    - 배열의 크기는 기본적으로 1.5배씩 증가한다.\n\n```java\n// ArrayList 동적 크기 증가 코드 (JDK 8 내부 구현)\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 기존 크기의 1.5배\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n- **`LinkedList`**\n    - 각 노드가 데이터와 함께 두 개의 포인터(다음 및 이전 노드 참조)를 저장하므로, 메모리 사용량이 더 많다.\n\n\n## 성능 비교 요약\n\n| **기능**             | **ArrayList**                           | **LinkedList**                         |\n|---------------------|----------------------------------------|---------------------------------------|\n| **임의 요소 접근**    | 빠름 (**O(1)**)                         | 느림 (**O(n)**)                        |\n| **중간 삽입/삭제**    | 느림 (**O(n)**, 데이터 이동 필요)          | 빠름 (**O(1)**, 포인터 변경만 필요)      |\n| **순차 접근**         | 빠름 (**O(n)**)                         | 빠름 (**O(n)**)                        |\n| **메모리 사용**       | 적음 (배열만 저장)                        | 많음 (노드와 포인터 저장)                |\n| **크기 조정**         | 동적 크기 조정 (복사 비용 발생)             | 필요 없음                               |\n\n---\n\n### 사용 사례\n\n| **상황**                                 | **ArrayList** 추천                           | **LinkedList** 추천                     |\n|-----------------------------------------|--------------------------------------------|----------------------------------------|\n| **조회 작업이 많은 경우**                 | 빠른 접근 속도로 적합                         | 적합하지 않음                           |\n| **삽입/삭제 작업이 많은 경우**             | 삽입/삭제가 적은 경우 적합                    | 삽입/삭제가 많은 경우 적합               |\n| **데이터 크기가 자주 변경되는 경우**        | 동적 크기 조정이 자동으로 이루어짐             | 데이터 크기 변경 시 적합하지 않음          |\n| **메모리 효율성이 중요한 경우**            | 적합 (메모리 사용량이 낮음)                   | 비적합 (메모리 사용량이 높음)             |\n\n---\n\n- **ArrayList**는 데이터 조회가 많고 삽입/삭제가 적은 작업에 적합하다.\n- **LinkedList**는 데이터 삽입/삭제가 빈번한 작업에 적합하다.\n\n### 조회와 삽입/삭제 비교\n\n```java\nimport java.util.*;\n\npublic class ListComparison {\n    public static void main(String[] args) {\n        int n = 100000; // 데이터 개수\n\n        // ArrayList 테스트\n        List<Integer> arrayList = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            arrayList.add(i); // 데이터 추가\n        }\n        long start = System.nanoTime();\n        arrayList.get(n / 2); // 중간 요소 접근\n        long end = System.nanoTime();\n        System.out.println(\"ArrayList 조회 시간: \" + (end - start) + \"ns\");\n\n        start = System.nanoTime();\n        arrayList.add(n / 2, -1); // 중간에 삽입\n        end = System.nanoTime();\n        System.out.println(\"ArrayList 삽입 시간: \" + (end - start) + \"ns\");\n\n        // LinkedList 테스트\n        List<Integer> linkedList = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            linkedList.add(i); // 데이터 추가\n        }\n        start = System.nanoTime();\n        linkedList.get(n / 2); // 중간 요소 접근\n        end = System.nanoTime();\n        System.out.println(\"LinkedList 조회 시간: \" + (end - start) + \"ns\");\n\n        start = System.nanoTime();\n        linkedList.add(n / 2, -1); // 중간에 삽입\n        end = System.nanoTime();\n        System.out.println(\"LinkedList 삽입 시간: \" + (end - start) + \"ns\");\n    }\n}\n```\n\n\n## ArrayList vs Vector 비교\n\n`ArrayList`와 `Vector`는 모두 **리스트 인터페이스**를 구현한 컬렉션으로, 내부적으로 배열을 기반으로 데이터를 관리합니다.  \n하지만, 동작 방식과 사용 목적에서 몇 가지 차이점이 있습니다.\n\n\n### 내부 구조 및 동작\n\n- **`ArrayList`**\n    - 내부적으로 **비동기적**으로 동작합니다.\n    - 멀티스레드 환경에서 동기화가 지원되지 않으므로 동시성 문제를 처리하려면 별도의 동기화 작업이 필요합니다.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10);\narrayList.add(20);\nSystem.out.println(arrayList); // 출력: [10, 20]\n```\n\n- **`Vector`**\n    - 내부적으로 **동기화**된 메서드가 사용되므로 `Thread-Safe`합니다.\n    - 멀티스레드 환경에서 안전하게 사용할 수 있지만, 단일 스레드 환경에서는 불필요한 성능 오버헤드가 발생합니다.\n\n```java\nVector<Integer> vector = new Vector<>();\nvector.add(10);\nvector.add(20);\nSystem.out.println(vector); // 출력: [10, 20]\n```\n\n### 동기화 (Thread-Safety)\n\n- **`ArrayList`**\n    - 동기화를 지원하지 않으므로 단일 스레드 환경에서 사용이 적합합니다.\n    - 멀티스레드 환경에서 동기화를 적용하려면 `Collections.synchronizedList()`를 사용해야 합니다.\n\n```java\nList<Integer> synchronizedArrayList = Collections.synchronizedList(new ArrayList<>());\nsynchronizedArrayList.add(10);\nsynchronizedArrayList.add(20);\nSystem.out.println(synchronizedArrayList); // 출력: [10, 20]\n```\n\n- **`Vector`**\n    - 메서드 자체에 동기화가 적용되어 있으므로 멀티스레드 환경에서 안전하게 사용할 수 있습니다.\n    - 하지만 동기화로 인해 단일 스레드 환경에서는 성능이 떨어집니다.\n\n```java\nVector<Integer> vector = new Vector<>();\nvector.add(10);\nvector.add(20);\nSystem.out.println(vector); // 출력: [10, 20]\n```\n\n### 크기 조정\n\n- **`ArrayList`**\n    - 배열의 크기가 부족할 때 **기본적으로 1.5배**로 크기를 늘립니다.\n    - 동적 크기 조정이 효율적이며 메모리 사용을 최적화합니다.\n\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5배 크기 증가\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n- **`Vector`**\n- 배열의 크기가 부족할 때 **기본적으로 2배**로 크기를 늘립니다.\n- 메모리 낭비가 발생할 가능성이 높습니다.\n\n```java\nprivate void ensureCapacityHelper(int minCapacity) {\n    if (elementData.length - minCapacity < 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    int newCapacity = elementData.length * 2; // 2배 크기 증가\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n### 성능 비교\n\n| **기능**                | **ArrayList**                      | **Vector**                         |\n|------------------------|----------------------------------|-----------------------------------|\n| **Thread-Safe 여부**    | 비동기적 (Thread-Safe 아님)          | 동기적 (Thread-Safe 지원)           |\n| **멀티스레드 환경**      | 추가 동기화가 필요 (`synchronizedList`) | 멀티스레드 환경에 적합               |\n| **단일 스레드 환경**      | 적합 (불필요한 동기화 없음)            | 부적합 (불필요한 동기화로 성능 저하)   |\n| **동적 크기 조정**        | 1.5배씩 크기 증가                    | 2배씩 크기 증가                     |\n| **삽입/삭제 성능**        | 빠름 (단일 스레드 환경)               | 느림 (동기화 오버헤드)                |\n| **메모리 효율성**         | 메모리 사용 효율적                    | 메모리 낭비 가능성 있음                |\n\n\n### 사용 사례\n\n| **상황**                                   | **ArrayList** 추천                           | **Vector** 추천                           |\n|-------------------------------------------|--------------------------------------------|------------------------------------------|\n| **단일 스레드 환경**                       | 적합                                       | 부적합                                   |\n| **멀티스레드 환경**                         | `Collections.synchronizedList`로 동기화 필요 | 기본적으로 `Thread-Safe`라 적합            |\n| **메모리 효율성이 중요한 경우**              | 효율적 (1.5배 동적 증가)                     | 비효율적 (2배 동적 증가)                   |\n| **성능이 중요한 경우**                      | 성능에 민감한 작업에서 적합                  | 성능 저하가 발생하므로 비적합               |\n\n### ArrayList와 Vector의 성능 비교\n\n```java\nimport java.util.ArrayList;\nimport java.util.Vector;\n\npublic class ListPerformanceComparison {\n    public static void main(String[] args) {\n        int n = 100000; // 데이터 개수\n\n        // ArrayList 테스트\n        ArrayList<Integer> arrayList = new ArrayList<>();\n        long start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            arrayList.add(i);\n        }\n        long end = System.nanoTime();\n        System.out.println(\"ArrayList 데이터 추가 시간: \" + (end - start) + \"ns\");\n\n        // Vector 테스트\n        Vector<Integer> vector = new Vector<>();\n        start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            vector.add(i);\n        }\n        end = System.nanoTime();\n        System.out.println(\"Vector 데이터 추가 시간: \" + (end - start) + \"ns\");\n    }\n}\n```"},{"excerpt":"프로세스와 스레드 이 글에서는 자바의 스레드()를 이해하기에 앞서 운영체제를 공부하게 되면 접하게 되는 프로세스와 스레드를 알아간다.\n간단히 설명을 달아보면 프로세스는 운영체제로부터 필요한 자원을 할당받은 작업의 단위로 보면 되고, 스레드는 이러한 프로세스의 자원을 활용해 실제 작업을 수행하는 단위라고 알고 가면 된다. 프로세스 프로세스에 이해하기에 앞서…","fields":{"slug":"/java-thread/"},"frontmatter":{"date":"November 14, 2024","title":"프로세스(Process)와 스레드(Thread)","tags":["Java"]},"rawMarkdownBody":"\n# 프로세스와 스레드\n\n<hr>\n\n이 글에서는 자바의 스레드(`Thread`)를 이해하기에 앞서 운영체제를 공부하게 되면 접하게 되는 프로세스와 스레드를 알아간다.\n간단히 설명을 달아보면 프로세스는 운영체제로부터 필요한 자원을 할당받은 작업의 단위로 보면 되고, 스레드는 이러한 프로세스의 자원을 활용해 실제 작업을 수행하는 단위라고 알고 가면 된다.\n\n## 프로세스\n프로세스에 이해하기에 앞서 프로세스와 프로그램의 차이를 명확히 짚어볼 필요가 있다.\n프로그램은 컴퓨터에서 실행 가능한 파일을 의미한다.\n하지만 이 파일이 아직 실행되지 않은 상태라면, 이를 정적 프로그램(`Static Program`) 또는 줄여서 프로그램(`Program`)이라고 부른다.\n이를 다르게 해석하면 자바같은 프로그래밍 언어로 작성된 코드의 집합이라고 볼 수 있다.\n그리고 프로세스란 프로그램이 실행된 상태를 말한다.\n즉, 정적인 프로그램이 동적으로 변하여 실행 중인 상태를 나타내는 개념이다.\n프로그램은 코드의 집합이고, 프로세스는 그 코드를 실행한 결과라고 이해하면 된다.\n\n> 모든 프로그램이 실행되려면 운영체제가 메모리 공간을 할당해 주어야 한다.\n> 프로그램을 실행하는 순간, 파일은 컴퓨터의 메모리에 올라가고, 운영체제로부터 시스템 자원(CPU 등)을 할당받아 프로그램 코드가 실행된다.\n> 이를 통해 사용자는 서비스를 이용할 수 있다.\n> 즉, 프로그램 → 프로세스의 과정을 거치게 된다.\n\n## 스레드\n\n과거에는 프로그램을 실행할 때 하나의 프로세스만을 사용하여 작업을 처리했지만, 기술이 발전하고 프로그램이 복잡해지면서 단일 프로세스로는 멀티태스킹과 자원 효율성을 충족하기 어려운 한계가 있었다.\n동일한 프로그램을 여러 프로세스로 실행하면 각 프로세스가 독립적인 메모리를 점유해 자원이 낭비되었고, 성능 저하를 초래했다.\n또한, 프로세스 생성과 전환에는 높은 오버헤드가 발생해 실시간 처리가 어려웠다.\n이러한 문제를 해결하기 위해 스레드라는 개념이 등장하게 됐다.\n\n### 스레드 개념\n\n스레드는 하나의 프로세스 내에서 동시에 실행되는 작업 흐름의 단위를 의미한다.\n설명을 돕자면, 브라우저를 실행하면 하나의 프로세스가 생성된다.\n이때, 유튜브를 재생하면서 웹 서핑을 하는 등의 작업을 동시에 할 수 있다.\n이처럼 하나의 프로세스 내부에서 여러 작업이 동시에 진행될 수 있는 이유는 바로 스레드 덕분이다.\n설명을 덧붙이자면 이러한 스레드를 다중으로 실행하는 경우를 멀티스레드라고 한다.\n\n### 스레드와 프로세스의 관계\n\n일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고,\n하나의 프로세스는 반드시 하나 이상의 스레드를 포함한다.\n즉, 프로세스를 생성하면 기본적으로 하나의 **메인 스레드(main thread)**가 생성된다.\n\n"},{"excerpt":"자바에서는 컬렉션 프레임워크(Java Collection Framework)을 제공한다. 이는 자바 프로그래밍을 하면서 없어서는 안되는 필수적인 요소이다.\n이 글에서는 자바의 컬렉션 프레임워크에 대해 알아본다. 자바 컬렉션 프레임워크 자바 컬렉션 프레임워크에서 컬렉션()이란 무엇인지 부터 알아보자.\n컬렉션은 다수의 요소를 하나의 그룹으로 묶어 효율적으로 …","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"date":"November 14, 2024","title":"자바 컬렉션 프레임워크(Collection Framework)","tags":["Java"]},"rawMarkdownBody":"\n자바에서는 컬렉션 프레임워크(Java Collection Framework)을 제공한다. 이는 자바 프로그래밍을 하면서 없어서는 안되는 필수적인 요소이다.\n이 글에서는 자바의 컬렉션 프레임워크에 대해 알아본다.\n\n# 자바 컬렉션 프레임워크\n\n<hr>\n\n자바 컬렉션 프레임워크에서 컬렉션(`Collection`)이란 무엇인지 부터 알아보자.\n컬렉션은 다수의 요소를 하나의 그룹으로 묶어 효율적으로 저장하고 관리할 수 있는 기능을 제공하는 일종의 **컨테이너(`Container`)**라고 이해할 수 있다.\n그렇다면 컬렉션 프레임워크를 사용하면 어떤 이점이 있는지 살펴보자.\n\n## 컬렉션 프레임워크의 장점\n\n컬렉션 프레임워크는 아래와 같은 장점을 제공한다.\n\n\n- 가변적인 저장 공간을 제공하여 고정된 크기의 배열보다 유연하다.\n- 컬렉션 프레임워크는 인터페이스와 다형성을 이용한 객체지향적 설계를 기반으로 다양한 클래스에서 일관된 방식으로 데이터를 다룰 수 있다.\n- 다양한 자료구조와 최적화된 효율적인 알고리즘이 구현된 채로 제공되어 직접 작성할 필요가 없다.\n\n> 자바의 컬렉션 프레임워크는 객체(`Object`)만 저장할 수 있다.\n> 원시 타입(`int`, `double`, etc.)은 컬렉션에 직접 저장할 수 없으며, 이를 **래퍼 클래스(`Wrapper Class`)로 변환하는 박싱(Boxing) 과정**을 거쳐야 한다.\n> 컬렉션은 객체의 참조값(주소값)을 저장하므로, 특별한 값인 `null`도 저장이 가능하다.\n> `null`을 저장한다는 것은 아무 객체도 참조하지 않는다는 의미이다.\n\n# 컬렉션 프레임워크의 계층구조\n\n<hr>\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n    Collection --> List\n    Collection --> Queue\n    Collection --> Set\n    List --> ArrayList\n    List --> LinkedList\n    List --> Vector\n    List --> Stack\n    Queue --> PriorityQueue\n    Queue --> Deque\n    Deque --> LinkedList\n    Deque --> ArrayDeque\n    Set --> HashSet\n    Set --> LinkedHashSet\n    Set --> SortedSet\n    SortedSet --> TreeSet\n    Map --> HashMap\n    Map --> HashTable\n    Map --> SortedMap\n    SortedMap --> TreeMap\n</div>\n\n컬렉션 프레임 워크는 크게 `Collection` 인터페이스와 `Map` 인터페이스로 나뉜다.\n- `Collection` 인터페이스는 `List`, `Set`, `Queue`의 공통 부분을 정의하고 있다.\n- `Map` 인터페이스는 키(`Key`)-값(`Value`) 쌍을 다루며, `Collection` 인터페이스와는 별도로 설계되었다.\n\n\n> 대부분의 컬렉션 클래스는 List, Set, Map 중 하나의 인터페이스를 구현하며, 구현한 인터페이스의 이름이 클래스 이름에 포함된다.\n> (e.g., ArrayList, HashSet, HashMap, etc.)<br>\n> 하지만 Vector, Stack, Hashtable과 같은 클래스는 컬렉션 프레임워크가 도입되기 이전에 만들어진 클래스들로, 컬렉션 프레임워크의 명명 규칙을 따르지 않는다.\n> 이들 클래스는 호환성을 위해 남아 있는 것으로, 가급적 사용하지 않는 것이 권장된다.\n\n## Iterable 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n</div>\n\n`Iterable` 인터페이스는 자바 컬렉션 인터페이스 계층 구조에서 가장 최상위에 위치한 인터페이스이다.\n컬렉션을 다룰 때 자료를 순회하기 위해 사용하는 이터레이터(`iterator`) 객체를 관리하는 역할을 한다고 볼 수 있다.\n\n- 컬렉션의 최상위 인터페이스로 모든 컬렉션 클래스가 Iterable 인터페이스를 상속받아 구현된다.\n- 컬렉션을 순회하는 데 필요한 이터레이터 객체를 반환하는 메서드를 제공한다\n\n### 메서드\n\n- `default void forEach(Consumer<? super T> action)`: 함수형 프로그래밍을 지원하는 메서드로, 주어진 람다식을 사용해 컬렉션 요소를 순회할 수 있다.\n- `Iterator<T> iterator()`: 컬렉션에 저장된 요소들을 순회할 수 있는 이터레이터 객체를 반환한다.\n- `default Spliterator<T> spliterator()`: 병렬 처리를 위한 파이프라이닝 관련 메서드로, 데이터를 분할하여 처리하는 데 사용된다.\n\n> `Map`은 `Iterable` 인터페이스를 상속받지 않으므로 `iterator()`와 `spliterator()` 메서드가 구현되어 있지 않다.\n> 따라서 `Map` 컬렉션을 직접 순회할 수 없으며, 다음과 같은 간접적인 방법을 사용해야 한다\n> - 키(`key`) 또는 값(`value`)를 별도의 컬렉션으로 변환하여 순회하는 방법\n    >   - e.g., `map.keySet()`, `map.values()`\n> - `Stream` API를 사용해 순회하는 방법\n    >   - e.g., `map.entrySet().stream()`\n\n## Collection 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n    Collection --> List\n    Collection --> Queue\n    Collection --> Set\n</div>\n\nCollection 인터페이스는 `List`, `Set`, `Queue` 인터페이스의 공통된 기능을 정의한 최상위 컬렉션 타입이다.\n\n- 다형성을 지원하여 업캐스팅을 사용해 여러 컬렉션 타입(`List`, `Set`, `Queue`)을 동일한 방식으로 처리할 수 있다.\n- 공통 작업(삽입, 탐색, 삭제, 변환, etc.) 을 수행하는 데 필요한 메서드를 정의한다.\n\n### 메소드\n\n- `boolean add(Object o)`: 지정된 객체를 컬렉션에 추가한다.\n- `boolean addAll(Collection c)`: 지정된 컬렉션에 포함된 객체들을 컬렉션에 추가한다.\n- `boolean contains(Object o)`: 지정된 객체가 컬렉션에 포함되어 있는지 확인한다.\n- `boolean containsAll(Collection c)`: 지정된 컬렉션의 모든 객체가 현재 컬렉션에 포함되어 있는지 확인한다.\n- `boolean remove(Object o)`: 지정된 객체를 컬렉션에서 삭제한다.\n- `boolean removeAll(Collection c)`: 지정된 컬렉션에 포함된 객체들을 모두 삭제한다.\n- `boolean retainAll(Collection c)`: 지정된 컬렉션에 포함된 객체만 남기고 나머지는 삭제한다. (교집합 연산과 유사)\n- `void clear()`: 컬렉션의 모든 객체를 삭제한다.\n- `boolean isEmpty()`: 컬렉션이 비어 있는지 확인한다.\n- `int size()`: 컬렉션에 저장된 객체의 개수를 반환한다.\n- `boolean equals(Object o)`: 두 컬렉션이 동일한지 비교한다.\n- `int hashCode()`: 컬렉션의 해시 코드를 반환한다.\n- `Iterator iterator()`: 컬렉션을 순회할 수 있는 이터레이터를 반환한다.\n- `Object[] toArray()`: 컬렉션의 객체를 객체 배열(`Object[]`)로 반환한다.\n- `<T> T[] toArray(T[] a)`: 지정된 배열에 컬렉션의 객체를 저장하여 반환한다.\n- `default Stream stream()`: 컬렉션 데이터를 스트림으로 반환한다.\n- `default Stream parallelStream()`: 병렬 스트림 반환한다.\n- `default boolean removeIf(Predicate<? super E> filter)`: 조건에 맞는 요소를 컬렉션에서 제거한다.\n- `default void forEach(Consumer<? super T> action)`: 람다식을 이용한 요소 순회한다.\n\n```java\nCollection<Number> col1 = new ArrayList<>();\ncol1.add(1);\n\nCollection<Number> col2 = new HashSet<>();\ncol1.add(1);\n\nCollection<Number> col3 = new LinkedList<>();\ncol1.add(1);\n```\n\n> `Collection` 인터페이스를 보면 요소(객체)에 대한 추가, 삭제, 탐색은 가능하지만, 데이터를 직접 **조회(get)**하는 메서드는 포함되어 있지 않다.\n> 이는 각 컬렉션이 사용하는 자료 구조가 다르기 때문에, 최상위 타입에서 통일된 방식으로 데이터를 조회하기가 어렵기 때문이다.\n\n## List 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    List --> ArrayList\n    List --> LinkedList\n    List --> Vector\n    List --> Stack\n</div>\n\n- 요소가 추가된 순서대로 저장된다.\n- 동일한 값을 가진 요소를 여러 번 저장할 수 있다.\n- 배열과 달리 크기가 고정되지 않으며 데이터 양에 따라 동적으로 늘어나거나 줄어든다.\n- 요소 간 빈 공간을 허용하지 않으므로 삽입/삭제 시 배열 이동이 발생한다.\n- 요소 사이에 빈공간을 허용하지 않아 삽입/삭제 할때마다 배열 이동이 일어난다\n\n### 메서드\n\n- `void add(int index, Object element)`: 지정된 위치(`index`)에 객체(`element`)를 추가한다.\n- `boolean addAll(int index, Collection c)`: 지정된 위치에 컬렉션의 모든 객체를 추가한다.\n- `Object remove(int index)`: 지정된 위치의 객체를 삭제하고 반환한다.\n- `Object get(int index)`: 지정된 위치의 객체를 반환한다.\n- `Object set(int index, Object element)`: 지정된 위치의 객체를 새로운 객체로 대체한다.\n- `int indexOf(Object o)`: 지정된 객체의 첫 번째 위치(`index`)를 반환한다.\n- `int lastIndexOf(Object o)`: 지정된 객체의 마지막 위치를 반환한다.\n- `List subList(int fromIndex, int toIndex)`: 지정된 범위의 객체들을 포함하는 서브 리스트를 반환한다.\n- `void sort(Comparator c)`: 지정된 비교자를 사용하여 리스트를 정렬한다.\n- `ListIterator listIterator()`: 리스트를 순회할 수 있는 `ListIterator` 객체를 반환한다.\n- `ListIterator listIterator(int index)`: 지정된 위치부터 순회할 수 있는 `ListIterator`를 반환한다.\n\n### ArrayList\n\n- 배열 기반 리스트\n    - 내부적으로 배열을 사용하여 데이터를 저장한다.\n- 장점\n    - 저장 순서가 유지된다.\n    - 중복 요소를 허용한다.\n    - 데이터 양에 따라 용량(`capacity`)이 동적으로 조정된다.\n    - **순차적 데이터 접근에 강점이 있어 조회 속도가 빠르다.**\n- 단점\n    - 삽입/삭제 속도가 느리다. (단, 맨 끝에 추가하거나 삭제하는 경우는 빠르다.)\n\n```java\nList<String> arrayList = new ArrayList<>();\n\narrayList.add(\"a\");\narrayList.add(\"b\");\narrayList.add(\"c\");\n\narrayList.get(0);// \"a\"\n```\n\n### LinkedList\n\n- 노드 기반 리스트\n    - 배열이 아닌 노드를 연결하여 데이터를 저장한다.\n- 장점\n    - **중간 위치에 데이터를 삽입하거나 삭제할 때 성능이 우수하다.**\n    - `LinkedList`는 양방향 연결 리스트(`Doubly LinkedList`)로 구성되어 있어 양쪽에서 접근이 가능하다.\n- 단점\n    - 임의 위치의 요소에 대한 접근 속도가 느리다.\n- 다목적 활용 가능\n    - `LinkedList`는 리스트 외에도 자료구조(스택, 큐, 덱, 트리, etc.)를 구현하는 데 사용된다.\n\n```java\nList<String> linkedList = new LinkedList<>();\n\nlinkedList.add(\"a\");\nlinkedList.add(\"b\");\nlinkedList.add(\"c\");\n\nlinkedList.get(0); // \"a\"\n```\n\n### Vector 클래스\n\n- `ArrayList`의 레거시 버전으로 내부 구현이 거의 동일하다.\n- 차이점\n    - 모든 메서드가 `synchronized`로 처리되어 `Thread-Safe`하다.\n- 현재는 사용하지 않는 것을 권장\n    - 구버전 자바와의 호환성을 위해 남겨두었으나, 잘 사용되지 않는다.\n\n> 동기화가 필요하면 `Collections.synchronizedList()`를 사용해 `ArrayList`를 동기화 처리하는 것이 좋다.\n\n```java\nList<String> vector = new Vector<>();\n\nvector.add(\"a\");\nvector.add(\"b\");\nvector.add(\"c\");\n\nvector.get(0); // \"a\"\n```\n\n### Stack 클래스\n\n- 후입선출 (`LIFO`) 자료구조로, 마지막에 추가된 요소가 가장 먼저 제거된다.\n- 기본 연산\n    - `push`: 데이터를 추가.\n    - `pop`: 데이터를 제거하고 반환.\n- 문제점\n    - `Stack`은 `Vector`를 상속하고 있어 레거시 문제점이 많아 사용이 권장되지 않는다.\n      <br> 대신 **ArrayDeque**를 사용하는 것이 좋다.\n\n```java\nStack<String> stack = new Stack<>();\n\nstack.push(\"a\");\nstack.push(\"b\");\n\nstack.pop(); // \"a\"\nstack.pop(); // \"b\"\n```\n\n## Queue 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Queue --> LinkedList\n    Queue --> PriorityQueue\n    Queue --> ArrayDeque\n</div>\n\n`Queue` 인터페이스는 선입선출(`FIFO`: `First-In-First-Out`) 구조를 기반으로 한 자료구조를 구현하는 데 사용된다.\n첫 번째로 들어온 데이터가 가장 먼저 나가는 방식으로 동작하며, 자바에서는 `Queue`가 인터페이스로 제공되므로 구현체를 필요에 따라 선택해 사용할 수 있다.\n\n- 선입선출 `FIFO(First-In-First-Out)` 구조\n- 처음 들어온 원소가 가장 먼저 나간다\n- 자바에서는 `Queue` 는 인터페이스이고 필요에 따라 큐 컬렉션을 골라 사용할 수 있다.\n\n### 메서드\n\n- `boolean add(Object o)`: 지정된 객체를 큐에 추가. 저장 공간 부족 시 `IllegalStateException`을 발생시킨다.\n- `boolean offer(Object o)`: 지정된 객체를 큐에 추가. 저장 공간 부족 시 `false`를 반환한다.\n- `Object remove()`: 큐의 첫 번째 객체를 삭제 후 반환. 비어 있을 경우 `NoSuchElementException`을 발생시킨다.\n- `Object poll()`: 큐의 첫 번째 객체를 삭제 후 반환. 비어 있을 경우 `null`를 반환.\n- `Object element()`: 큐의 첫 번째 객체를 삭제 없이 반환. 비어 있을 경우 `NoSuchElementException`을 발생시킨다.\n- `Object peek()`: 큐의 첫 번째 객체를 삭제 없이 반환. 비어 있을 경우 `null`를 반환한다.\n\n### PriorityQueue 클래스\n\n우선순위 큐는 일반적인 큐와 달리 원소의 우선순위에 따라 정렬되고 처리되는 큐다.\n\n- 우선순위 기반 동작\n    - 원소는 우선순위(`priority`)가 높은 순으로 처리된다.\n      <br> e.g., 우선순위가 중요한 작업(네트워크 제어, 작업 스케줄링, etc.)에서 사용.\n- 정렬 기준\n    - 저장할 객체는 반드시 `Comparable` 인터페이스를 구현하거나, `Comparator`를 사용해 정렬 기준을 명시해야 한다.\n- 내부 구현\n  <br> 배열을 사용하며, 각 요소는 힙(`heap`) 자료구조로 관리된다.\n    - 힙은 이진 트리의 한 형태로, 루트 노드에 가장 우선순위가 높은 값이 위치한다.\n    - 이를 통해 최댓값이나 최솟값을 빠르게 찾을 수 있다.\n- 제약사항\n    - `null` 값은 저장할 수 없다.\n\n> 힙은 이진 트리의 한 종류로 우선순위가 가장 높은 자료를 루트 노드로 갱신한다는 점으로, 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있다는 특징이 있다.\n\n```java\nimport java.util.Queue;\n\n// 우선순위 큐에 저장할 객체는 필수적으로 Comparable를 구현\nclass Person implements Comparable<Student> {\n  String name; // 원소 값\n  int priority; // 우선순위 값\n\n  public Person(String name, int priority) {\n    this.name = name;\n    this.priority = priority;\n  }\n\n  @Override\n  public int compareTo(Person other) {\n    // Student의 priority 필드값을 비교하여 우선순위를 결정하여 정렬\n    return Integer.compare(this.priority, other.priority);\n  }\n\n  @Override\n  public String toString() {\n    return \"Person{name='\" + name + \"', priority=\" + priority + '}';\n  }\n}\n\npublic static void main(String[] args) {\n    Queue<Person> priorityQueue = new PriorityQueue<>();\n\n    priorityQueue.add(new Person(\"John\", 1));\n    priorityQueue.add(new Person(\"Daniel\", 2));\n    priorityQueue.add(new Person(\"Alex\", 5));\n    priorityQueue.add(new Person(\"Adam\", 9));\n  \n    System.out.println(priorityQueue.peek()); // 가장 낮은 우선순위: John\n    while (!priorityQueue.isEmpty()) {\n      System.out.println(priorityQueue.poll()); // 우선순위 순으로 출력\n    }\n}\n```\n\n### Deque 인터페이스\n\nDeque (Double-Ended Queue)**는 양쪽에서 삽입과 삭제가 가능한 큐다\n\n- 스택 및 큐 동작 지원\n    - 큐처럼 사용: FIFO(선입선출) 방식.\n    - 스택처럼 사용: LIFO(후입선출) 방식.\n- 구현체\n    - ArrayDeque\n    - LinkedList\n\n### ArrayDeque 클래스\n\n`ArrayDeque`는 `Deque` 인터페이스의 구현체로, 다음과 같은 특징이 있다\n\n- 빠른 성능\n    - 스택으로 사용할 때 `Stack` 클래스보다 빠르다.\n    - 큐로 사용할 때 `LinkedList` 보다 빠르다.\n- 제약사항\n    - `null` 요소는 저장할 수 없다.\n    - 크기는 동적으로 조정되며, 제한이 없다.\n\n```java\nDeque<String> deque = new ArrayDeque<>();\n\ndeque.offerLast(\"a\"); // [\"a\"]\ndeque.offerFirst(\"b\"); // [\"b\", \"a\"]\ndeque.offerFirst(\"c\"); // [\"c\", \"b\", \"a\"]\n\ndeque.pollFirst(); // \"c\" <- [\"b\", \"a\"]\ndeque.pollLast(); // [\"b\"] -> \"a\" \ndeque.pollLast(); // [] -> \"b\"\n```\n\n### LinkedList 클래스\n\n`LinkedList`는 `List`와 `Queue` 인터페이스를 동시에 구현하며, 다음과 같은 특징이 있다\n\n- 다목적 활용\n    - 리스트, 스택, 큐로 모두 사용할 수 있다.\n- 큐 관련 메서드 지원\n    - 큐의 기본 동작(`offer`, `poll`, `peek`, etc.)을 제공한다.\n\n```java\nQueue<String> linkedList = new LinkedList<>(); // Queue 타입으로 받음\n\nlinkedList.offer(\"a\");\nlinkedList.offer(\"b\");\nlinkedList.offer(\"c\");\n\nlinkedList.poll(); // \"a\" - 선입선출\n\nSystem.out.println(linkedList); // [b, c]\n```\n\n> 큐(`queue`)는 큐는 데이터를 꺼낼 때 항상 첫 번째 요소를 삭제하므로 배열 기반의 `ArrayList`를 사용하면 요소 이동/복사가 발생해 비효율적이다.\n> <br> 따라서 LinkedList를 사용하여 큐를 구현하는 것이 적합하다.\n\n## Set 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Set --> HashSet\n    Set --> LinkedSet\n    Set --> TreeSet\n</div>\n\n`Set` 인터페이스는 데이터의 중복을 허용하지 않으며, 저장된 데이터의 순서를 유지하지 않는 집합 구조를 구현한다.\n\n- 중복 저장 불가\n  <br> 동일한 객체는 한 번만 저장되며, null 값도 최대 하나만 저장 가능하다.\n- 순서 없음\n  <br> 데이터가 저장된 순서를 보장하지 않으므로, 인덱스를 이용한 객체 검색(get(index))은 지원되지 않는다.\n\n\n\n### 메서드\n\n- `boolean add(E e)`: 지정된 객체를 저장. 성공 시 `true`, 중복 객체일 경우 `false`를 반환한다.\n- `boolean contains(Object o)`: 지정된 객체가 저장되어 있는지 확인한다.\n- `Iterator<E> iterator()`: 저장된 객체를 순회할 수 있는 반복자를 반환한다.\n- `boolean isEmpty()`: 컬렉션이 비어 있는지 확인한다.\n- `int size()`: 저장된 객체의 개수를 반환한다.\n- `void clear()`: 모든 객체를 삭제한다.\n- `boolean remove(Object o)`: 지정된 객체를 삭제한다.\n\n### HashSet 클래스\n\n`HashSet`은 배열과 연결 노드의 결합 구조를 사용하는 `Set` 구현체다.\n\n- 빠른 데이터 접근\n  <br> 추가, 삭제, 검색, 접근 속도가 빠르다.\n- 순서 보장 없음\n  <br> 저장된 데이터의 순서는 예측할 수 없다.\n\n```java\nSet<String> hashSet = new HashSet<>();\n\nhashSet.add(\"a\");\nhashSet.add(\"b\");\nhashSet.add(\"c\");\nhashSet.add(\"a\"); // 중복된 요소는 저장되지 않음\n\nSystem.out.println(hashSet.size()); // 3\nSystem.out.println(hashSet); // 출력 순서는 예측할 수 없음 (e.g., [\"b\", \"a\", \"c\"])\n```\n\n### LinkedHashSet 클래스\n\n`LinkedHashSet`은 추가된 순서를 유지하는 `HashSet`이다.\n\n- 순서 유지\n  <br> 데이터가 추가된 순서 또는 가장 최근에 접근된 순서대로 데이터 접근이 가능하다.\n- 중복 제거와 순서 유지\n  <br> 중복을 제거하면서도 데이터의 저장 순서를 유지하고 싶을 때 적합하다.\n\n```java\nSet<String> linkedHashSet = new LinkedHashSet<>();\n\nlinkedHashSet.add(\"a\");\nlinkedHashSet.add(\"b\");\nlinkedHashSet.add(\"c\");\nlinkedHashSet.add(\"a\"); // 중복된 요소는 저장되지 않음\n\nSystem.out.println(linkedHashSet.size()); // 3\nSystem.out.println(linkedHashSet); // [\"a\", \"b\", \"c\"]\n```\n\n### TreeSet 클래스\n\n`TreeSet`은 이진 검색 트리(`Binary Search Tree`) 기반의 `Set` 구현체다.\n\n- 정렬된 데이터 저장\n  <br> 데이터를 저장할 때 자동으로 정렬한다. (기본적으로 오름차순)\n\n- 중복 제거와 정렬\n  <br> 중복 없는 정렬된 데이터가 필요할 때 적합하다.\n\n- 높은 검색 성능\n  <br> 정렬된 구조로 인해 검색 및 범위 검색에서 높은 성능을 제공한다.\n\n```java\nSet<String> treeSet = new TreeSet<>();\n\ntreeSet.add(\"a\");\ntreeSet.add(\"d\");\ntreeSet.add(\"b\");\ntreeSet.add(\"c\");\ntreeSet.add(\"e\");\n\nSystem.out.println(treeSet); // [a, b, c, d, e]\n```\n\n### EnumSet 추상 클래스\n\n`EnumSet`은 `Enum` 타입과 함께 사용되는 `Set` 구현체다.\n\n- 효율성\n  <br> 산술 비트 연산을 기반으로 구현되어 `HashSet` 보다 빠르고 적은 메모리를 사용한다.\n- 제약사항\n    - `Enum` 타입의 값만 저장이 가능하다.\n    - 모든 요소는 동일한 `Enum` 타입에 소속되어야 한다.\n- 내부 구현\n    - 요소가 64개 이하인 경우 `RegularEnumSet`을 사용한다.\n    - 64개 초과 시 `JumboEnumSet`을 사용한다.\n\n```java\nenum Alphabet {\n  A, B, C, D, E, F\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    EnumSet<Alphabet> enumSet = EnumSet.allOf(Alphabet.class);\n\n    System.out.println(enumSet.size()); // 6\n    System.out.println(enumSet); // [A, B, C, D, E, F]\n  }\n}\n```\n\n## Map 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Map --> HashMap\n    Map --> LinkedHashMap\n    Map --> HashTable\n    HashTable --> Properties\n    Map --> SortedMap\n    SortedMap --> TreeMap\n</div>\n\nMap 인터페이스는 데이터를 `Key`와 `Value`의 쌍으로 저장하는 자료구조를 구현한다.\n\n- 키와 값의 유일성\n    - ``Key``는 중복될 수 없으며, 고유해야 한다.\n    - Value는 중복 저장이 가능하다.\n- 키-값 덮어쓰기\n  <br> 동일한 `Key`로 새로운 값을 저장하면, 기존 값은 덮어쓰여 사라진다.\n- 순서 없음\n  <br> 대부분의 `Map` 구현체는 저장 순서를 보장하지 않는다. (예외: `LinkedHashMap`)\n\n### 메서드\n\n- `Object put(Object key, Object value)`: 지정된 `Key`와 `Value`를 맵에 저장. 기존에 동일한 `Key`가 있으면 덮어쓴다.\n- `void putAll(Map t)`: 지정된 `Map`의 모든 데이터를 추가.\n- `Object get(Object key)`: 지정된 `Key`에 해당하는 `Value`를 반환.\n- `boolean containsKey(Object key)`: 지정된 `Key`가 존재하는지 확인.\n- `boolean containsValue(Object value)`: 지정된 `Value`가 존재하는지 확인.\n- `Object remove(Object key)`: 지정된 `Key`에 해당하는 데이터를 삭제.\n- `void clear()`: 모든 데이터를 삭제.\n- `boolean isEmpty()`: 맵이 비어 있는지 확인.\n- `int size()`: 맵에 저장된 `Key-Value` 쌍의 개수를 반환.\n- `Set keySet()`: 맵에 저장된 모든 `Key`를 `Set` 형태로 반환.\n- `Collection values()`: 맵에 저장된 모든 `Value`를 `Collection` 형태로 반환.\n- `Set<Map.Entry<K, V>> entrySet()`: 모든 `Key-Value` 쌍을 `Map.Entry` 객체 형태로 반환.\n\n> `Key`는 중복을 허용하지 않으므로 `Set` 타입으로 반환되고, `Value`는 중복을 허용하므로 `Collection` 타입으로 반환된다.\n\n### Map.Entry 인터페이스\n\n`Map.Entry`는 `Map` 인터페이스 내부의 내부 인터페이스로, `Key-Value` 쌍을 표현한다.\n이 인터페이스를 통해 맵의 각 데이터를 객체지향적으로 관리할 수 있다.\n\n```java\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 1);\nmap.put(\"b\", 2);\nmap.put(\"c\", 3);\n\nSet<Map.Entry<String, Integer>> entrySet = map.entrySet();\n\nfor (Map.Entry<String, Integer> entry : entrySet) {\n    System.out.printf(\"{ %s : %d }\\n\", entry.getKey(), entry.getValue());\n}\n// 출력:\n// { a : 1 }\n// { b : 2 }\n// { c : 3 }\n```\n\n### HashMap 클래스\n\n- 핵심 특징\n    - `HashTable`을 개선한 비동기 `Map`의 구현체다.\n    - 배열과 연결 노드를 결합한 `Hashing` 자료구조로 동작한다.\n    - 순서를 보장하지 않으며, 키와 값 모두 `null` 저장 가능하다.\n- 장점\n    - 빠른 추가, 삭제, 검색 성능을 가지고 있다.\n- 단점\n    - 멀티스레드 환경에서는 동기화가 지원되지 않으므로 `ConcurrentHashMap`의 사용을 권장한다.\n\n```java\nMap<Integer, String> hashMap = new HashMap<>();\n\nhashMap.put(1, \"a\");\nhashMap.put(2, \"b\");\nhashMap.put(3, \"c\");\n\nfor (Integer key : hashMap.keySet()) {\n    System.out.println(key + \" => \" + hashMap.get(key));\n}\n// 출력:\n// 1 => a\n// 3 => c\n// 2 => b\n```\n\n### LinkedHashMap 클래스\n\n- 순서 보장\n    - `HashMap`과 달리, 데이터 입력 순서를 유지한다.\n- 활용 사례\n    - 입력 순서가 중요한 경우 사용한다.\n\n```java\nMap<Integer, String> linkedHashMap = new LinkedHashMap<>();\nlinkedHashMap.put(1, \"a\");\nlinkedHashMap.put(2, \"b\");\nlinkedHashMap.put(3, \"c\");\n\nfor (Integer key : linkedHashMap.keySet()) {\n        System.out.println(key + \" => \" + linkedHashMap.get(key));\n        }\n// 출력:\n// 1 => a\n// 2 => b\n// 3 => c\n```\n\n### TreeMap 클래스\n\n- 이진 검색 트리 기반\n    - 데이터를 자동으로 정렬하여 저장한다.\n    - `Key`를 기준으로 오름차순으로 정렬한다.\n- 장점\n    - 빠른 검색 및 범위 검색이 가능하다.\n- 단점\n    - 삽입 시 정렬 비용으로 인해 성능이 다소 낮다.\n\n```java\nMap<Integer, String> treeMap = new TreeMap<>();\ntreeMap.put(3, \"c\");\ntreeMap.put(1, \"a\");\ntreeMap.put(2, \"b\");\n\nfor (Integer key : treeMap.keySet()) {\n        System.out.println(key + \" => \" + treeMap.get(key));\n        }\n// 출력:\n// 1 => a\n// 2 => b\n// 3 => c\n```\n\n### HashTable 클래스\n\n- 레거시 클래스\n    - 동기화가 기본 지원되지만, `HashMap`에 비해 느리다.\n    - `Key`와 `Value` 모두 `null` 저장이 불가하다.\n\n### Properties 클래스\n\n- 주요 특징\n    - `Key`와 `Value`가 모두 String 타입이다.\n    - 애플리케이션 설정 파일(`.properties`) 관리에 사용한다.\n\n```java\nProperties properties = new Properties();\nproperties.setProperty(\"AppVersion\", \"1.0.0\");\nproperties.setProperty(\"Theme\", \"Github\");\n\nSystem.out.println(properties.getProperty(\"AppVersion\")); // 1.0.0\n```\n\n\n# 컬렉션 프레임워크 선택 시점\n\n<hr>\n\n<div class=\"mermaid\"> \ngraph LR\n    A[ArrayList<br>Vector] -- 추가,삭제기능향상 --> B[LinkedList]\n    A -- 검색 기능 향상 --> C[HaspMap<br>HashTable]\n    A --> D[Stack]\n    B --> E[Queue]\n    B --> C\n    B -- 검색, 정렬 기능 향상 --> F[TreeMap]\n    F --> G[TreeSet]\n    C --> H[Properties]\n    C -- 순서 유지 기능 향상 --> I[LinkedHashMap]\n    C --> J[HashSet]\n    I -- 순서 유지 기능 향상 --> K[LinkedHashSet]\n</div>\n\n아래는 상황별로 적합한 컬렉션 구현체를 정리한 내용이다.\n\n## ArrayList\n\n- 기본 선택\n    - 리스트 자료구조를 사용하는 경우 가장 일반적인 선택이다.\n- 장점\n    - 임의 요소에 대한 빠른 접근성 제공한다.\n    - 순차적인 데이터 추가/삭제가 가장 빠르다.\n- 단점\n    - 중간 요소의 삽입/삭제 성능이 떨어진다.\n\n## LinkedList\n\n- 장점\n    - 중간 요소의 삽입/삭제이 강점이다.\n- 단점\n    - 임의 요소에 대한 접근 성능이 낮다.\n    - 순차 접근이 필요할 때 적합하다.\n\n## HashMap / HashSet\n\n- 장점\n    - 해싱을 이용한 빠른 추가/삭제/검색/접근성이 좋다.\n    - get 메서드의 시간 복잡도는 `O(1)`이다.\n    - 데이터 순서에 상관없는 작업에 적합하다.\n- 단점\n    - 데이터 정렬이 필요할 경우 부적합하다.\n\n## TreeMap / TreeSet\n\n- 사용 시점\n    - 요소를 정렬해야 하는 경우에 사용한다.\n    - 범위 검색이 필요한 경우에 사용한다.\n- 장점\n    - 자동으로 정렬된 상태로 데이터를 저장한다.\n    - 범위 검색에 높은 성능을 제공한다.\n- 단점\n    - 검색 성능이 `HashMap`/`HashSet`보다 낮다.\n\n## LinkedHashMap / LinkedHashSet\n\n- 사용 시점\n    - 저장된 순서를 유지해야 하는 경우에 사용한다.\n- 특징\n    - `HashMap`/`HashSet`과 동일한 성능에 순서 유지 기능이 추가된거다.\n\n## Queue\n\n- 사용 시점\n    - 스택(`LIFO`) 또는 큐(`FIFO`) 자료구조가 필요한 경우에 사용한다.\n- 추천 구현체\n    - ArrayDeque: 빠르고 유연한 동작을 지원한다.\n\n## Stack, Hashtable\n- 사용 지양\n    - 레거시 컬렉션으로, 현재는 `deprecated` 상태이다.\n    - 스택의 경우 `ArrayDeque`를 대체 구현체로 사용하는 것이 권장된다."},{"excerpt":"자바에서 예외처리는 오류를 예측하고 이에 대응하여 프로그램의 안정성을 높일 뿐만 아니라, 상황에 따라서 단순히 발생한 오류를 잡아내는 것을 넘어, 필요에 따라 예외를 발생시키거나 떠넘기고,\n예외를 다른 예외로 감싸 처리하는 등 다양한 방법을 유현하게 활용하여 코드의 가독성과 유지보수성을 높일 수 있다. 이 글에서는 자바의 예외처리 핵심 개념인 와  그리고…","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"date":"November 06, 2024","title":"throw와 throws 그리고 Chained Exception","tags":["Java"]},"rawMarkdownBody":"\n자바에서 예외처리는 오류를 예측하고 이에 대응하여 프로그램의 안정성을 높일 뿐만 아니라, 상황에 따라서 단순히 발생한 오류를 잡아내는 것을 넘어, 필요에 따라 예외를 발생시키거나 떠넘기고,\n예외를 다른 예외로 감싸 처리하는 등 다양한 방법을 유현하게 활용하여 코드의 가독성과 유지보수성을 높일 수 있다.\n\n이 글에서는 자바의 예외처리 핵심 개념인 `throw`와 `throws` 그리고 `Chained Exception`에 대해 알아본다.\n\n# 예외 던지기\n\n<hr>\n\n## 예외 발생시키기\n\n일반적으로 프로그램은 실행 중 예외가 발생하면 시스템이 자동으로 오류를 탐지하고 이를 처리하도록 되어 있다.\n하지만 특정 상황에서는 개발자가 의도적으로 `throw`를 사용해 예외를 발생시키고 `catch`에서 이를 처리하는 경우도 있다.\n\n`throw`는 `new` 연산자로 예외 클래스의 객체를 초기화하여 사용하며, 생성자에 메시지를 전달하면 `catch`에서 `getMessage()` 메서드를 통해 해당 메시지를 출력할 수 있다.\n\n아래 코드에서는 사용자가 음수를 입력한 경우, `IllegalArgumentException` 예외가 발생하도록 설정하였다. `throw` 키워드를 통해 예외를 발생시키고, `catch`에서 이를 받아 오류 메시지를 출력한다.\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Scanner scanner = new Scanner(System.in);\n            System.out.print(\"양수를 입력하세요: \");\n            int number = scanner.nextInt();\n            \n            if (number < 0) {\n                // 사용자가 음수를 입력한 경우, 의도적으로 예외 발생\n                throw new IllegalArgumentException(\"양수만 입력할 수 있습니다.\"); // 예외 메시지를 설정하여 catch 블록으로 전달\n            }\n            \n            System.out.println(\"정상적인 입력을 받았습니다.\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        } finally {\n            System.out.println(\"프로그램이 종료됩니다.\");\n        }\n    }\n}\n```\n\n## 예외 떠넘기기\n\n예외가 발생할 수 있는 코드를 작성할 때는 `try-catch`를 통해 예외를 처리하는 것이 일반적이다.\n하지만 경우에 따라 예외 처리를 호출한 메서드로 넘겨 다른 곳에서 처리하도록 할 수 있다.\n이를 위해 사용하는 키워드다 `throws`다.\n`throws`는 메서들 선언부 끝에 작성되며, 해당 메서드에서 발생할 수 있는 예외를 직접 처리(`catch`)하지 않고 호출한 곳으로 떠넘긴다.\n\n> throw는 예외를 발생시키는, throws는 예외를 메서드에 선언하는 키워드이다.\n\n아래 코드에서는 `method1()`, `method2()`, `method3()` 세 메서드가 각각 예외 처리를 위해 `try-catch`로 감싸져 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        method1();\n        method2();\n        method3();\n    }\n\n    public static void method1() {\n        try {\n            throw new ClassNotFoundException(\"에러 발생: 클래스 찾기 실패\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void method2() {\n        try {\n            throw new ArithmeticException(\"에러 발생: 수학적 오류\");\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void method3() {\n        try {\n            throw new NullPointerException(\"에러 발생: Null 참조\");\n        } catch (NullPointerException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n이 경우 코드가 길어지고 가독성이 떨어질 수 있다.\n위와 같은 코드에서 각 메서드에 `throws` 키워드를 사용해 예외를 떠넘기면, 예외가 발생해도 호출한 메서드에서 한꺼번에 처리할 수 있다.\n이렇게 하면 중복된 `try-catch`를 줄여 코드가 간결해지고 가독성이 향상된다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            method1();\n            method2();\n            method3();\n        } catch (ClassNotFoundException | ArithmeticException | NullPointerException e) {\n            System.out.println(\"오류: \" + e.getMessage());\n        }\n    }\n\n    public static void method1() throws ClassNotFoundException {\n        throw new ClassNotFoundException(\"에러 발생: 클래스 찾기 실패\");\n    }\n\n    public static void method2() throws ArithmeticException {\n        throw new ArithmeticException(\"에러 발생: 수학적 오류\");\n    }\n\n    public static void method3() throws NullPointerException {\n        throw new NullPointerException(\"에러 발생: Null 참조\");\n    }\n}\n```\n\n이렇게 메서드 선언부에 예외 클래스를 `throws`로 명시하면, 해당 메서드에서 예외를 처리하지 않고 호출한 상위 메서드로 떠넘기게 된다.\n`throws`를 사용해 예외를 던진 메서드는 자신이 예외를 직접 처리하지 않고, 예외를 호출한 메서드에게 전달해 처리하게끔 할 수 있다.\n\n이 예외는 호출 스택을 따라 상위 메서드로 계속 전달될 수 있으며, 최종적으로 `main` 메서드까지 떠넘겨질 수 있다.\n만약 `main` 메서드도 `throws`로 예외를 던진다면, 마지막에는 JVM에서 처리하게 된다.\n\n# 연결된 예외\n\n<hr>\n\n## 예외를 다른 예외로 감싸 던지기\n\n연결된 예외(Chained Exception)는 원인 예외를 다른 예외로 감싸서 던지는 기법이다.\n\n`Throwable` 클래스에서는 연결된 예외를 처리할 수 있도록 다음과 같은 메서드를 제공한다.\n\n- `Throwable initCause(Throwable caues)`: 원인 예외를 등록하는 메서ㅡㄷ\n- `Throwable getCause()`: 원인 예외를 반환하는 메서드\n\n이 메서드들을 통해 발생한 예외를 다른 예외로 감싸 던질 수 있으며, `Exception` 클래스의 상위 클래스인 `Throwable`에 정의되어 있기 때문에 모든 예외에서 사용할 수 있다.\n\n아래 코드는 `FileNotFountException`을 원인 예외로 감싸 `IOException`으로 던지는 방식이다.\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\nclass FileProcessingException extends IOException {\n    public FileProcessingException(String message) {\n        super(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            processFile();\n        } catch (FileProcessingException e) {\n            System.out.println(\"원인 예외: \" + e.getCause()); // 원인 예외 출력\n            e.printStackTrace();\n        }\n    }\n\n    public static void processFile() throws FileProcessingException {\n        try {\n            throw new FileNotFoundException(\"파일을 찾을 수 없습니다.\"); // 원인 예외 발생\n        } catch (FileNotFoundException e) {\n            FileProcessingException fileProcessingException = new FileProcessingException(\"파일 처리 중 오류 발생\"); // 새로운 예외 생성\n            fileProcessingException.initCause(e); // FileProcessingException의 원인 예외를 FileNotFoundException으로 지정\n            throw fileProcessingException; // FileProcessingException을 던져 상위 메서드로 전달\n        }\n    }\n}\n```\n\n코드에 대한 부가 설명을 하겠다.\n\n1. `processFile()` 메서드에서 `FileNotFoundException`이 발생한다.\n2. `catch`에서 `FileProcessingException` 예외 객체를 생성한다.\n3. 그리고 `FileProcessingException`의 `initCause()` 메서드를 통해 원인 예외를 `FileNotFoundException`으로 지정한다.\n4. `FileProcessingException`을 상위 메서드로 던지며, `main()` 메서드에서 `catch`가 이를 처리한다.\n5. `getCause()` 메서드를 사용해 원인 예외(`FileNotFoundException`)를 `catch`하고 `getCause()` 메서드를 통해 원인 예외 로르글 출력한다.\n\n이렇게 연결된 예외를 사용하는 이유는 여러 예외를 하나의 큰 범주의 예외로 묶어서 처리하기 위함이다.\n예외를 감싸는 방식은 다형성을확장하여 다양한 예외를 한 번에 처리하는 방법을 제공하며, 복잡한 예외 처리를 간소화 할 수 있다.\n또한, 특정 예외에 대한 명확한 에러 메시지를 제공하는 대신, 단계별로 문제의 원인과 발생 과정을 추적할 수 있게 해준다.\n\n## Checked Exception를 Unckecked Exception으로 변환하기\n\n연결된 예외(`Chained Exception`)를 사용하는 또 다른 이유는 `Checked Exception`을 `Unchecked Exception`으로 변환하여 컴파일러가 예외 처리를 강제하지 않도록 하는 것이다.\n\n자바에서 `Checked Exception`을 도입한 이유는 프로그래밍 경험이 적은 개발자도 안정적인 프로그래밍을 하도록 돕기 위함이다.\n하지만 런타임 예외로 처리해도 무방한 예외들이 `Checked Exception`으로 등록되어 있는 경우가 많다.\n이때 연결된 예외를 사용해 `Checked Exception`을 `Unchecked Exception`으로 감싸 변환하면, 컴파일러의 예외 처리 강제성을 회피할 수 있다.\n이렇게 함으로써 예외처리가 선택사항이 되어 코드가 더 간결해지고, 개발자는 필수적인 부분에서만 예외를 다루는 선택을 할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n            install();\n    }\n\n    public static void install() {\n        throw new RuntimeException(new IOException(\"설치할 공간이 부족합니다.\"));\n        // Checked 예외인 IOException을 Unchecked 예외인 RuntimeException으로 감싸 Unchecked 예외로 변환\n    }\n}\n```"},{"excerpt":"이 글은 예외 처리를 알아보는 글이다. 앞서 에러와 예외의 구분, 컴파일에러와 런타임에러의 차이, 과 에 대한 기본적인 이해가 필요하다. 자바의 Error와 Exception 이해하기\n자바의 throw와 throws 그리고 Chained Exception 이해하기 예외 처리하기(Exception Handling) 예외 처리란 프로그램이 실행 중 발생할 수…","fields":{"slug":"/java-try-catch/"},"frontmatter":{"date":"November 05, 2024","title":"자바 예외 처리하기(Exception Handling)","tags":["Java"]},"rawMarkdownBody":"\n이 글은 예외 처리를 알아보는 글이다.\n\n앞서 에러와 예외의 구분, 컴파일에러와 런타임에러의 차이, `Checked Exception`과 `Unchecked Exception`에 대한 기본적인 이해가 필요하다.\n\n<br>[자바의 Error와 Exception 이해하기](https://023-dev.github.io/2024-11-05/java-exception-error)\n<br>[자바의 throw와 throws 그리고 Chained Exception 이해하기](https://023-dev.github.io/2024-11-06/java-throw-chained-exception)\n\n# 예외 처리하기(Exception Handling)\n\n<hr>\n\n예외 처리란 프로그램이 실행 중 발생할 수 있는 예기치 못한 상황에 대비해 코드를 작성하여 프로그램의 비정상적인 동작을 막는 것이다.\n예외처리를 통해 오류가 발생했을 때 복구를 시도하거나 오류를 회피함으로써 프로그램이 정상적인 실행 상태를 유지하도록 할 수 있다.\n\n## try-catch 문\n\n예외 처리를 위해 사용하는 `try-catch`의 기본 구조는 다음과 같다.\n`try` 부분에는 예외가 발생할 가능성이 있는 코드가 위치하며, 예외가 발생하면 `catch`로 넘어가 해당 예외를 처리한다.\n만약 `try` 내에서 예외가 발생하지 않으면 `catch`은 실행되지 않는다.\n\n`catch`에서는 예외 클래스의 타입과 변수명을 선언하여, 발생한 예외를 특정 클래스의 인스턴스로 받아 처리한다.\n이렇게 함으로써 프로그램의 비정상적인 동작이 발생할 때 오류를 복구하거나 대안을 마련할 수 있다.\n\n아래 코드는 `ArithmeticException`이 발생하면 `catch`가 실행되어 예외 처리를 수행한다.\n예외 발생 시 `result` 값을 -1로 초기화함으로써, 예외 상황을 회피하여 이후의 정상 동작을 유지할 수 있게 한다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        int x, y, result;\n        try {\n            x = 10;\n            y = 0;\n            result = x / y; // 10 나누기 0 → 산술 오류 발생 (ArithmeticException)\n        } catch (ArithmeticException e) {\n            result = -1;  // 예외 발생 시 기본값으로 초기화\n            System.out.println(\"산술 오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n코드를 작성하면서 모든 오류를 예측하기 어렵다. 그래서 다양한 예외 상황에 대비해 여러 개의 `catch`를 사용할 수 있다.\n아래 코드는 각 `catch`가 특성 예외 상황에 맞게 적절한 메시지를 출력하도록 구성되어 있다.\n그러나 예외 클래스의 종류가 많이 때문에, 모든 예외를 일일 작성하기에는 비효율적일 수 있다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        try {\n            // 예외가 발생할 가능성이 있는 코드들\n            \n        } catch (NumberFormatException e) {\n            System.out.println(\"숫자로 변환할 수 없습니다.\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"클래스를 찾을 수 없습니다.\");\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"배열 인덱스 범위를 초과했습니다.\");\n        } catch (IOException e) {\n            System.out.println(\"입출력 오류가 발생했습니다.\");\n        } catch (NullPointerException e) {\n            System.out.println(\"NULL 참조 오류입니다.\");\n        }\n    }\n}\n```\n\n자바에서는 클래스의 상속관계를 이용해 특정 예외를 포괄하는 상위 클래스인 `Exception` 클래스를 사용하여, 이 상황을 타개할 수 있다.\n아래 코드 처럼 `catch`에서 세세한 예외 구분 없이 모든 예외를 포괄적으로 처리할 수 있다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        try {\n            // 예외가 발생할 가능성이 있는 코드들\n            \n        } catch (NumberFormatException e) {\n            System.out.println(\"숫자로 변환할 수 없습니다.\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"클래스를 찾을 수 없습니다.\");\n        } catch (Exception e) { // 상위 클래스 예외로 처리\n            System.out.println(\"알 수 없는 오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n다만, 위 코드와 같은 방법을 사용하면 코드 간결성을 유지할 수 있는 장점이 있지만, 예외가 발생한 원인을 정확하게 파악하기 어려울 수 있다.\n이때 `printStackTrace()` 메서드를 사용하면 예외의 발생 원인을 추적할 수 있다.\n\n## try-catch-finally 문\n\n위에서 설명한 것처럼, 프로그램 실행 도중 예외가 발생하면 프로그램이 중단되거나 `catch`로 예외가 전달되어 예외 처리가 이루어진다.\n그러나 예외 발생 여부와 상관없이 반드시 실행해야 할 코드가 있는 경우, `finally`을 사용하여 해당 코드를 지정할 수 있다.\n\n```java\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            //만일 이 부분에서 오류 발생 시\n            //이후 코드는 실행되지 않음\n        } catch (Exception e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n위 코드에서 실행 중 오류가 발생하면 `catch`로 넘어가기 때문에 다음 코드가 실행되지 않는다.\n이처럼 예외가 발생하더라도 특정 코드가 반드시 실행되어야 하는 경우가 있는데, 이때 `finally`를 사용하면 예외 발생 여부와 관계없이 `finally` 내의 코드가 무조건 실행된다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            //만일 이 부분에서 오류 발생 시\n            //이후 코드는 실행되지 않음\n        } catch (Exception e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        } finally {\n            // 예외 발생 여부에 관계없이 항상 실행됨\n        }\n    }\n}\n```\n\n이렇게 `finally`를 사용하면 `try` 내에서 오류가 발생 여부에 상관없이 `finally` 내의 코드가 실행된다.\n또한, 메서드에 `return`이  있는 경우에도 `finally`가 우선적으로 실행된다.\n예외를 발생하면 `try-catch-finally` 순서로 실행되고, 예외가 발생하지 않는 경우에는 `try-finally` 순으로 실행된다.\n\n## multi-catch 문\n\n여러 예외를 `|`를 사용해서 하나의 `catch`에서 처리할 수 있는 `multi-catch` 기법도 있다.\n이를 통해, 동일한 방식으로 처리할 여러 예외를 하나의 `catch` 블록으로 묶어 코드를 간결하게 만들 수 있으며, 연결할 수 있는 예외 클래스의 개수에는 제한이 없다.\n\n아래 코드에서는 `multi-catch` 기법을 사용하여 `NullPointerException`과 `ArrayIndexOutOfBoundsException`이 발생하면 동일한 방식으로 처리되게 작성했다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            // 예외 발생 가능 코드\n        } catch (NullPointerException | ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"널 참조 또는 배열 인덱스 초과 오류 발생\");\n        }\n    }\n}\n```\n\n다만 `multi-catch`는 여러 예외를 하나로 처리한다는 특성상, 예외마다 세밀한 제어가 필요한 경우에는 `if`문과 `instanceof` 연산자를 사용해 각각의 예외를 분기 처리해야 한다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            // 예외 발생 가능 코드\n        } catch (NullPointerException | ArrayIndexOutOfBoundsException e) {\n            if (e instanceof NullPointerException) {\n                System.out.println(\"널 참조 오류 발생\");\n            } else if (e instanceof ArrayIndexOutOfBoundsException) {\n                System.out.println(\"배열 인덱스 초과 오류 발생\");\n            }\n        }\n    }\n}\n```\n\n# 예외 메시지 출력하기\n\n<hr>\n\n`catch`의 `(Exception e)` 부분에서 `Exception`은 예외 타입을 나타내는 클래스이고, `e`는 예외 객체를 참조하는 변수다.\n이 변수는 `Exception` 클래스에서 제공하는 다양한 메서드를 사용하여 예외에 대한 정보를 확인할 수 있도록 한다.\n\n- `printStackTrace()`: 예외 발생 당시의 호출 스택(Call Stack)에 있었던 메서드 정보와 예외 메시지를 출력한다.\n- `getMessage()`: 예외 인스턴스에 저장된 기본적인 예외 메시지만을 간략하게 얻을 수 있다.\n\n> 자바에서 오류와 예외는 최상위 클래스인 `Object`를 상속받고, 중간에는 `Throwable` 클래스가 있다. `Throwable` 클래스는 오류나 예외에 대한 메시지를 담는 역할을 하며, `getMessage()`와 `printStackTrace()`가 포함되어 있다. 따라서 `Throwable`을 상속받은 `Error`와 `Exception` 클래스에서도 해당 메서드들이 제공된다.\n\n이 외에도 다양한 메서드가 존재하지만, 주로 예외 메시지를 확인하기 위해서는 위의 두 메서드를 사용한다.\n다만, `printStackTrace`는 호출 스택을 상세하게 출력하기 때문에, 보안 문제를 방지하려면 외부 사용자에게 노출되지 않도록 주의 해야한다.\n\n# 예외를 커스텀하기 (Custom Exception)\n\n<hr>\n\n자바에서는 `Exception`을 상속받아 커스텀 예외(`Custom Exception`)을 구현할 수 있다.\n이렇게 구현된 커스텀 예외는 `throw`를 통해 강제로 발생시키고, `catch`에서 커스텀 예외만의 처리를 할 수 있다.\n\n```java\n// 커스텀 예외 클래스\nclass InvalidValueException extends Exception {\n    private String errorMessage;\n    \n    // 커스텀 예외 클래스 생성자\n    public InvalidValueException(String errorMessage) {\n        super(errorMessage); // 상위 Exception 클래스 생성자 호출\n        this.errorMessage = errorMessage;\n    }\n    \n    // 커스텀 예외 클래스 전용 메시지 출력 메서드\n    public void printCustomMessage() {\n        System.out.println(\"오류: \" + this.errorMessage);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            validateValue(-10); // 유효하지 않은 값으로 예외 발생\n        } catch (InvalidValueException e) {\n            e.printCustomMessage(); // 커스텀 예외 메시지 출력\n            e.printStackTrace(); // 상속받은 부모 클래스의 메서드 실행\n        }\n    }\n    \n    // 값이 유효한지 확인하는 메서드, 유효하지 않으면 커스텀 예외 발생\n    public static void validateValue(int value) throws InvalidValueException {\n        if (value < 0) {\n            throw new InvalidValueException(\"값이 0보다 작을 수 없습니다.\");\n        }\n        System.out.println(\"값이 유효합니다: \" + value);\n    }\n}\n```"},{"excerpt":"프로그래밍을 처음 배우면 와 같이 콘솔에 출력을 시도하게 된다.\n콘솔 창에 \"프로그램이 정상적으로 동작함을 확인하는 과정은 모든 개발자가 겪는 경험일 것이다.\n우리는 원하는 기능을 구현한 후, 값이 제대로 출력되는지 확인하기 위해 종종 을 사용한다. 그러나 을 무차별적으로 사용해서는 안 된다. 그 이유는 무엇인지 아래에서 자세히 알아보자. System.o…","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"date":"November 05, 2024","title":"System.out.println()를 사용한 로깅을 피해야 하는 이유","tags":["Java"]},"rawMarkdownBody":"\n프로그래밍을 처음 배우면 `System.out.println(\"Hello World\");`와 같이 콘솔에 출력을 시도하게 된다.\n콘솔 창에 \"프로그램이 정상적으로 동작함을 확인하는 과정은 모든 개발자가 겪는 경험일 것이다.\n우리는 원하는 기능을 구현한 후, 값이 제대로 출력되는지 확인하기 위해 종종 `System.out.println`을 사용한다.\n\n그러나 `System.out.println`을 무차별적으로 사용해서는 안 된다. 그 이유는 무엇인지 아래에서 자세히 알아보자.\n\n# System.out.println이란 무엇인가?\n\n`System.out.println`은 자바에서 디버깅 용도로 콘솔에 정보를 출력하기 위해 사용하는 메서드이다.\n\n이를 간단히 설명하자면:\n- `System`: 자바의 `java.lang` 패키지에 내장된 `final` 클래스이다.\n- `out`: `System` 클래스의 정적 멤버 필드로, `PrintStream` 객체이다.\n- `println`: `PrintStream` 클래스의 메서드로, 표준 콘솔에 전달된 인자를 출력하며 자동으로 줄바꿈을 추가한다.\n\n이렇게 `System.out.println`을 통해 출력이 이루어지지만, 여러 가지 이유로 인해 이를 사용하지 않는 것이 좋다.\n\n# System.out.println을 사용하면 안 되는 이유\n\n## 성능 문제\n\n`System.out.println`을 사용하는 것은 성능에 악영향을 줄 수 있다.\n그 주요 이유는 블로킹 I/O와 멀티스레드 환경에서의 락 발생이다.\n`System.out.println`이 호출될 때는 메서드 내부의 `synchronized` 블록이 락을 걸기 때문에, 해당 메서드가 끝날 때까지 다른 스레드들은 기다려야 한다.\n이로 인해 불필요한 성능 저하가 발생한다.\n\n아래 코드에서 `System.out.println(\"hello Wor``ld\")`를 사용하는 예시를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"hello World\");\n    }\n}\n\npublic void println(String x) { \n    if (getClass() == PrintStream.class) {\n        writeln(String.valueOf(x));\n     } else {\n        synchronized (this) {\n            print(x);\n            newLine();\n        }\n        s = 33\n    }\n }\n\n```\n\n위 코드에서 `println` 메서드는 `synchronized` 블록을 사용하고 있는데, 이는 여러 스레드가 동시에 접근하지 못하도록 락을 걸기 때문이다.\n이로 인해 `System.out.println`이 콘솔에 출력될 때 성능 저하가 발생할 수 있다.\n\n## 로그 레벨 관리가 어려움\n\n`System.out.println`은 로그 레벨을 지정할 수 없으므로 디버깅 용도로 사용할 때도 로그가 어떤 수준에서 출력되는지 구분하기 어렵다.\n로그 레벨이 제대로 관리되지 않으면, 프로덕션 환경에서도 불필요한 디버깅 정보가 그대로 노출될 수 있다.\n이러한 정보는 시스템의 안정성과 보안에 문제가 생길 수 있는 요인이 된다.\n\n## 유지보수성 저하\n\n출력 메시지가 코드에 하드코딩되어 있으면, 나중에 메시지를 수정하거나 삭제하는 작업이 어렵다.\n특히 큰 프로젝트나 협업 환경에서 유지보수성에 큰 영향을 미친다.\n\n## System.out.println 사용 개선 전후 성능 비교\n\n`System.out.println`을 사용하는 코드와 이를 로거로 대체하거나 제거한 후의 성능을 비교해 보자.\n\n|               | 응답 시간 | 개선율 |\n|---------------|-----------|--------|\n| 변경 전       | 1,242ms   | -      |\n| 변경 1        | 893ms     | 39%    |\n| 변경 2        | 504ms     | 146%   |\n\n- **변경 1**: 로깅 프레임워크를 사용하여 로그 출력을 `false`로 설정\n- **변경 2**: 모든 로깅 코드를 주석 처리하고 `System.out.println`을 제거\n\n변경 1에서 성능이 39% 개선되었고, 변경 2에서 146%까지 개선된 것을 볼 수 있다.\n즉, 로그 메시지를 콘솔에 출력하는 것만으로도 시스템 성능에 상당한 영향을 미칠 수 있음을 알 수 있다.\n\n# 로그를 남기면 안 되는가?\n\n<hr>\n\n그렇다면 로그를 남기는 것은 아예 피해야 할까? 아니다.\n대신 로그를 남길 때는 `System.out.println` 대신 로거(Logger)를 사용하는 것이 좋다.\n로컬 환경에서 간단히 확인하는 용도로 `System.out.println`을 사용할 수 있지만, 실수로 배포 단계에서도 출력이 남지 않도록 로거를 사용하는 습관을 들이는 것이 중요하다.\n\n`logback`이나 `log4j`와 같은 **로깅 프레임워크**를 사용해 로그 레벨을 관리하며 체계적으로 로그를 남기는 방식이 이상적이다.\n\n[참고](https://systemdata.tistory.com/21): "},{"excerpt":"자바에서는 , , 라는 3가지 클래스 자료형을 통해 문자열을 다룰 수 있다. 어떤 상황에 어떤 자료형을 사용하는 것이 성능적인 측면에서 좋은지 알아본다. StringBuffer / StringBuilder 클래스 와  클래스는 문자열을 연결이나 수정하는 연산을 할 때 주로 사용하는 자료형이다. 이 둘의 차이점을 간단하게 하자면 는 멀티 쓰레드 환경에서 안…","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"date":"November 05, 2024","title":"String과 StringBuffer 그리고 StringBuilder","tags":["Java"]},"rawMarkdownBody":"\n\n자바에서는 `String`, `StringBuffer`, `StringBuilder`라는 3가지 클래스 자료형을 통해 문자열을 다룰 수 있다.\n\n어떤 상황에 어떤 자료형을 사용하는 것이 성능적인 측면에서 좋은지 알아본다.\n\n# StringBuffer / StringBuilder 클래스\n\n<hr>\n\n`StringBuffer`와 `StringBuilder` 클래스는 문자열을 연결이나 수정하는 연산을 할 때 주로 사용하는 자료형이다. 이 둘의 차이점을 간단하게 하자면 `StringBuffer`는 멀티 쓰레드 환경에서 안전하다는 장점이 있고, `StringBuilder`는 문자열 파싱 성능이 가장 우수하다는 장점이 있다.\n`String`에서는 `+` 연산이나 `concat()` 메소드를 사용할 수 있지만 `String`의 특성상 **인스턴스의 문자열 값이 바뀌게 되면 새로운 String 인스턴스를 생성**하게 되어,\n이러한 연산을 할수록 메모리랑 성능적인 측면에서 저하 발생된다.\n\n```java\nString str = \"\";\nstr +=  \"Hello\";\nstr +=  \" \";\nstr +=  \"World\";\nSystem.out.println(str);\n```\n\n그래서 자바에서는 이러한 이슈로 인해 연산을 전용으로 하는 자료형을 제공해 주고 있다.\n\n`StringBuffer` 클래스는 내부적으로 **버퍼(Buffer)라고 하는 독립적인 공간을 가지게되어, 문자열 연산을 할 때 버퍼에 적용하여 메모리나 성능적인 측면에서 저하가 발생하는 현상을 방지**한다.\n\n```java\nStringBuffer sb = new String();\nsb.append(\"Hello\");\nsb.append(\" \");\nsb.append(\"World\");\nSystem.out.println(sb.toString());\n```\n\n> `StringBuffer`는 버퍼에 기본적으로 16개의 문자를 저장하는 크기를 지원한다. 이때 한 문자는 2바이트를 차지하므로, 초기 버퍼 크기는 총 32바이트이다. 생성자를 통해 크기를 설정할 수 있고 만일 문자열 연산 중 할당된 버퍼의 크기를 넘게 되면 자동으로 버퍼를 스케일업 해준다.\n\n## StringBuffer 내장 메소드\n`StringBuffer`클래스는 효율적인 문자열 연산을 위한 메소드를 제공하고 이 메서드를은 `StringBuilder` 클래스에서도 동일하게 제공된다.\n- `append(...)`: 문자열을 끝에 추가\n- `insert(int pos, ...)`: 지정 위치에 문자열 삽입\n- `delete(int start, int end)`: 지정 범위의 문자열 삭제\n- `deleteCharAt(int index)`: 특정 인덱스의 문자 삭제\n- `replace(int start, int end, String str)`: 지정 범위의 문자열을 다른 문자열로 대체\n- `reverse()`: 문자열을 뒤집음\n- `substring(int start)`: 시작 위치부터 끝까지의 문자열 반환\n- `substring(int start, int end)`: 지정 범위의 문자열 반환\n- `toString()`: `StringBuffer` 객체를 `String`으로 변환\n- `setCharAt(int index, char ch)`: 특정 인덱스의 문자 변경\n- `setLength(int newLength)`: 문자열의 길이를 지정된 길이로 설정\n- `capacity()`: 버퍼의 용량 반환\n- `length()`: 현재 문자열의 길이 반환\n- `charAt(int index)`: 특정 인덱스의 문자 반환\n- `ensureCapacity(int minimumCapacity)`: 버퍼의 최소 용량 설정\n- `trimToSize()`: 현재 문자열 길이에 맞게 버퍼 크기 조정\n\n\n# Stinrg과 StringBuffer/StringBuilder 비교\n\n<hr>\n\n## 문자열 자료형의 불변성과 가변성\n\n### String은 불변\n자바에서는 `String`은 **불변(Immutable) 자료형**이다. 그래서 초기 값과 다른 값에 대한 연산에 많은 추가 자원을 사용하게 된다는 특징이 있다.\n\n실제로 String 객체의 내부 구조를 보면 다음과 같이 되어 있다.\n\n```java\npublic final class String implements java.io.Serializable, Comparable {\n\tprivate final byte[] value;\n}\n```\n\n인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 이 `value`라는 인스턴스 변수에 문자형 배열로 저장되게 된다. 이 `value`는 상수형인 `final`이니 값을 바꾸지 못하는 것이다.\n\n아래 코드를 보면 변수 `str`이 참조하는 메모리의 \"Hello\"라는 값에 \" World\"라는 문자열을 더해서 `String` 객체의 자체의 값을 업데이트 시킨 것으로 볼 수 있지만 실제로는 메모리에 새로 \"Hello World\"라는 값을 저장한 영역을 만들고 `str`이 다시 참조하는 방식으로 작동한다.\n\n```java\nString str = \"Hello\";\nstr += \" World\";\n\nSystem.out.println(str);\n```\n\n![String](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_1.png)\n\n이외에도 문자열을 다루는데 있어 가장 많이 사용하는 `trim`이나 `toUpperCase`, `toLowerCase` 같은 메소드 사용 형태를 보면, 문자열이 변경되는 것 처럼 보일 수 있지만 해당 메소드 수행 시 새로운 `String` 객체를 생성해서 반환할 뿐이다.\n\n```java\nString str = \"abc\";  // \"abc\"\nstr.toUpperCase();  // \"ABC\"\n\nSystem.out.println(str); // \"abc\"\n```\n\n자바에서 `String`을 불변으로 설정한 이유는 다음 글에서 볼 수 있다.\n[자바의 String 이해하기](https://023-dev.github.io/2024-11-05/java-string#:~:text=%ED%98%84%EC%83%81%EC%9D%B4%20%EC%83%9D%EA%B8%B0%EB%8A%94%20%EA%B2%83%EC%9D%B4%EB%8B%A4.-,%EC%99%9C%20%EB%B6%88%EB%B3%80%EC%9C%BC%EB%A1%9C%20%EC%84%A4%EA%B3%84%20%EB%90%98%EC%97%88%EB%8A%94%EA%B0%80%3F,-%EC%9D%B4%EC%B2%98%EB%9F%BC%20String%EC%9D%B4)\n\n`String`은 문자열이 변할 때마다 계속해서 새로운 메모리를 잡게 되고, 변하기 전의 값이 있던 메모리는 가비지 컬렉션(Garbage Collector, GC) 대상이 되어 `Minor GC`을 빈번히 발생시킨다. 이러한 `Minor GC`의 잦은 발생은 `Full GC(Major GC)`으로 이어질 수 있다.\n\n> `Minor GC`는 자바 메모리의 작은 영역에서 불필요한 메모리를 빠르게 정리하는 작업이며, `Full GC`는 전체 메모리를 대상으로 하는 더 큰 정리 작업이다. 이때 `Minor GC`가 빈번히 발생하면, 시스템은 `Full GC`를 시작한다. `Full GC`는 전체 메모리를 검사하고 불필요한 객체를 모두 제거하므로 시간이 오래 걸리고 CPU 자원을 많이 사용해 성능저하와 지연을 초래할 수 있다.\n\n### StringBuffer/StringBuilder는 가변\n`StringBuffer`와 `StringBuilder는`의 경우 문자열 데이터를 다룬다는 점에서 `String` 객체와 같지만, 객체의 공간이 부족해지는 경우 버퍼를 스케일업 해주어 가변적이라는 차이점이 있다.\n\n실제 `StringBuffer` 객체의 내부 구조를 보면 `String`과 달리 `final`이 없다.\n\n```java\npublic final class StringBuffer implements java.io.Serializable {\n\tprivate byte[] value;\n}\n```\n\n두 클래스는 내부적으로 데이터를 임시로 저장할 수 있는 메모리인 버퍼을 가지고 있어 버퍼에 문자열을 저장해두고 필요한 연산 작업을 추가적인 메모리 없이 작업을 할 수 있도록 설계되어 있다.\n\n```java\nStringBuffer sb = new StringBuffer(\"Hello\");\nsb.append(\" World\");\nSystem.out.println(sb.toString());\n```\n\n![StringBuffer](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_2.png)\n\n따라서 값이 변함에 따라 새로운 객체를 생성하는 불변적인 `String` 보다 메모리와 성능적인 측면에서 좋기 때문에, 문자열 연산이 빈번하게 발생하는 경우에는 `String`가 아닌 `StringBuffer/StringBuilder`를 사용하는 것이 이상적이다.\n\n## 문자열 자료형의 값 비교\n\n### String 값 동등 비교\n`String`은 `equals()`을 사용해 동등 비교가 가능하다.\n\n```java\nString str1 = \"Hello\";\nString str2 = new String(\"Hello\");\n\nSystem.out.println(str1 == str2; // false\nSystem.out.println(str2.equals(str1)); //true\n```\n\n### StringBuffer/StringBuilder 값 동등 비교\n`StringBuffer`와 `StringBuilder`는 `String`와 달리 `equals()` 메서드를 오버라이딩하지 않아 `==`로 비교한 것과 같은 결과를 얻게 되어 버린다.\n\n```java\nStringBuffer sb1 = new StringBuffer(\"Hello\");\nStringBuffer sb2 = new StringBuffer(\"Hello\");\n\nSystem.out.println(sb1 == sb2); // false\nSystem.out.println(sb2.equals(sb1)); // false\n```\n\n그래서 `toString()`으로 `StringBuffer`와 `StringBuilder`을 `String`으로 변환 후 `equals()`로 비교를 한다.\n\n```java\nString sb1_tmp = sb1.toString();\nString sb2_tmp = sb2.toString();\nSystem.out.println(sb1_tmp.equals(sb2_tmp)); // true\n```\n\n## 문자열 자료형의 성능 비교\n위에서 설명했듯이, `String`을 `+`으로 연산하면 불필요한 객체들이 힙(Heap) 메모리에 추가되어 안좋기 때문에 `StringBuffer`이나 `StringBuilder`의 `append()`를 통해 문자열 연산을 수행하는 것이 좋다.\n\n하지만 이런 연산 작업 빈도 수가 적으면 `String`의 `+` 연산이랑 `StringBuffer`이나 `StringBuilder`의 `append()`가 차이가 없어 보일 수 도 있다.\n\n```java\nString str = \"Hello\" + \" World\";\n// 컴파일 전 내부적으로 StringBuilder 클래스를 만든 후 아래와 같은 작업을 수행한다.\nString str = new StringBuilder(\"Hello\").append(\" World\").toString();\n```\n\n이처럼 겉으로는 보기에는 문자열 리터럴(String Literal)로 `+` 연산하거나, `StringBuilder`를 사용하거나 어차피 자동 변환해줘서 차이가 없어 보일지도 모른다.\n\n하지만 다음과 같이 문자열을 합치는 일이 많을 경우 단순히 `+`연산을 쓰면 성능과 메모리 효율이 떨어지게 된다.\n\n```java\nString str = \"\";\n\nfor(int i = 0; i < 10000; i++) {\n    str += i;\n}\n\n// 반복 횟수 만큼 new StringBuilder() 메모리를 생성하고 다시 변수에 대입하는 하는 것을 알 수 있다.\nString str = \"\";\n\nfor(int i = 0; i < 10000; i++) {\n    str = new StringBuilder(\"\").append(i).toString();\n}\n```\n\n위 코드에서 문자열 값을 변경하는 작업이 많을수록 성능저하를 유발하는 원인이 될 수 있다는 것을 느낄 수 있다.\n\n그래서 만일 문자열 연산이 빈번하게 수행 될 경우 초기부터 `StringBuidler`을 사용해서 문자열을 관리하는게 이상적이다.\n\n```java\nStringBuilder sb = new StringBuilder();\n\nfor(int i = 0; i < 10000; i++) {\n        sb.append(i);\n}\n```\n\n![+ 연산자 성능 비교](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_3.png)\n\n정리하자면, 문자열 연산 작업이 잦을 경우에는 `StringBuffer/StringBuilder`를, 문자열 변경 작업이 거의 없는 경우에는 `String`을 사용하는 것만 이상적이다.\n\n# StringBuffer와 StringBuilder 차이점\n\n<hr>\n\n`StringBuffer`와 `StringBuilder`는 공통적으로 가변성을 가지고 있고, 제공하는 메서드도 같고, 사용법도 동일하다.\n\n하지만 멀티 쓰레드 환경(Tread)에서 안정성(Safety)에 대한 차이가 난다.\n\n## 쓰레드 안전성\n\n`StringBuffer`와 `StringBuilder`는 동기화(Synchronization)에서의 지원 측면에서 보면 차이가 명확해진다.\n\n`StringBuffer`는 동기화를 지원하는 반면,  `StringBuilder`는 동기화를 지원하지 않는다. 이로 인해 `StringBuffer`는 멀티 쓰레드 환경에서도 안전하게 동작할 수 있다.\n그 이유는 `StringBuffer`의 모든 메서드에 `synchronized` 키워드가 붙어 있기때문이다.\n\n> 자바에서 `synchronized` 키워드는 한 번에 하나의 스레드만 접근할 수 있도록 잠금을 걸어, 다른 스레드는 현재 작업이 끝날 때까지 기다리게 해서 여러 스레드가 동시에 하나의 자원에 접근할 때 발생할 수 있는 데이터 불일치 문제를 방지한다.\n\n\n아래 코드는 `StringBuffer`와 `StringBuilder`을 생성해서 멀티 쓰레드 환경에서의 `synchronized` 키워드의 유무차이와 필요성을 보여준다.\n```java\npublic class StringBufferVsStringBuilderTest {\n    public static void main(String[] args) throws InterruptedException {\n        StringBuffer stringBuffer = new StringBuffer();\n        StringBuilder stringBuilder = new StringBuilder();\n\n        // StringBuffer에 문자열 추가하는 두 스레드\n        Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuffer.append(\"A\"); });\n        Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuffer.append(\"A\"); });\n\n        // StringBuilder에 문자열 추가하는 두 스레드\n        Thread t3 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuilder.append(\"B\"); });\n        Thread t4 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuilder.append(\"B\"); });\n\n        // 스레드 실행 및 완료 대기\n        t1.start(); t2.start(); t3.start(); t4.start();\n        t1.join(); t2.join(); t3.join(); t4.join();\n\n        // 결과 출력\n        System.out.println(\"StringBuffer length: \" + stringBuffer.length());   // 20000\n        System.out.println(\"StringBuilder length: \" + stringBuilder.length()); // 18957\n    }\n}\n```\n\n위 코드에서 볼 수 있듯이 `StringBuilder`의 값이 더 작은 것을 확인 할 수 있는데, 이는 쓰레드 안전성이 없어 충돌이 발생한 결과이다.\n반면, `StringBuffer`는 쓰레드 안전성을 보장해주어 정상적인 결과값이 출력되는 것을 볼 수 있다.\n\n그래서 웹이나 소켓같은 비동기로 동작하는 환경에서는 `StringBuffer`을 사용하는 것이 안전하다.\n\n## 성능 비교\n그럼 멀티 쓰레드 환경이 아니라 쓰레드 안정을 생각하지 않고 사용하는 상황일 때 어떤 것을 사용하는 것이 좋을까?\n아래코드는 `StringBuffer`와 `StringBuilder`의 성능을 비교하는 코드이다.\n\n```java\npublic class StringBufferVsStringBuilderPerformanceTest {\n    public static void main(String[] args) {\n        final int loopCount = 100_000;\n\n        // StringBuffer 성능 테스트\n        long startTimeBuffer = System.nanoTime();\n        StringBuffer stringBuffer = new StringBuffer();\n        for (int i = 0; i < loopCount; i++) {\n            stringBuffer.append(\"*\");\n        }\n        long endTimeBuffer = System.nanoTime();\n        System.out.println(\"StringBuffer time: \" + (endTimeBuffer - startTimeBuffer) + \" ns\");// StringBuffer time: 123456789 ns\n\n        // StringBuilder 성능 테스트\n        long startTimeBuilder = System.nanoTime();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < loopCount; i++) {\n            stringBuilder.append(\"*\");\n        }\n        long endTimeBuilder = System.nanoTime();\n        System.out.println(\"StringBuilder time: \" + (endTimeBuilder - startTimeBuilder) + \" ns\");// StringBuilder time: 98765432 ns\n\n    }\n}\n```\n\n결과를 보면, 순수 성능은 `StringBuilder`가 우월한 것을 알 수 있다. 그 이유는 위에서 설명한 `+`연산 시 컴파일 전에 `StringBuilder`로 변환하는 이유와 같다.\n\n`StringBuffer`와 `StringBuilder` 차이는 `synchronized`의 키워드 유무로 인한 쓰레드 안전성인데, 이때 `StringBuffer`는 `synchronized` 키워드를 사용하면서 동기화 오버헤드가 발생하기 때문에 이러한 결과가 나온다.\n\n![String StringBuffer StringBuilder 속도 비교](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_4.png)\n\n위 그래프를 보면 10만번 이상의 연산 작업 수행 시 `String`의 수행시간이 기하급수적으로 늘어나지만, `StringBuffer`와 `StringBuilder`는 1000만번까지 준수하다가, 그 후로는 `StringBuilder`가 더 좋다는 것을 볼 수 있다.\n\n그래서 멀티 쓰레드 환경이 아니고선 `StringBuilder`을 사용하는 것이 이상적이다.\n\n정리하자면 `String`은 불변 객체로 문자열을 변경할 수 없으며, 문자열 연산이 적고 스레드 안전성이 중요한 경우에 적합하다.\n반면, `StringBuffer`와 `StringBuilder`는 가변 객체로, 동일 객체 내에서 문자열을 수정할 수 있다.\n`StringBuffer`는 모든 메서드가 `synchronized`되어 쓰레드 안전성을 보장해 멀티 쓰레드 환경에서 안전하게 사용할 수 있지만, 이로 인해 `StringBuilder`보다 약간 느리다.\n`StringBuilder`는 쓰레드 안전성을 제공하지 않지만 가장 빠른 성능을 제공하므로, 단일 스레드 환경에서 빈번한 문자열 조작이 필요할 때 사용하는 것이 적합하다."},{"excerpt":"리플렉션(Reflection) 리플렉션은 런타임 중에 클래스의 속성, 메서드, 타입 등을 조사하고 수정할 수 있는 자바 API입니다. 리플렉션을 사용하면 컴파일 시간에는 알 수 없던 클래스 정보에 접근하거나, 동적으로 객체를 생성하고 메서드를 호출할 수 있습니다.\n프로그램이 실행 중 경로에 존재하는 코드들을 하나하나 확인하는 것 왜 사용할까? 주석처럼 코…","fields":{"slug":"/java-reflection/"},"frontmatter":{"date":"November 05, 2024","title":"자바 리플렉션(Reflection)","tags":["Java"]},"rawMarkdownBody":"\n# 리플렉션(Reflection)\n\n<hr>\n\n리플렉션은 런타임 중에 클래스의 속성, 메서드, 타입 등을 조사하고 수정할 수 있는 자바 API입니다. 리플렉션을 사용하면 컴파일 시간에는 알 수 없던 클래스 정보에 접근하거나, 동적으로 객체를 생성하고 메서드를 호출할 수 있습니다.\n프로그램이 실행 중 경로에 존재하는 코드들을 하나하나 확인하는 것\n\n## 왜 사용할까?\n주석처럼 코드를 설명하는 것 이상의 구체적인 메타 정보를 제공하여, 프레임워크나 API에서 설정 및 구성을 단순화하고, 런타임 시 동작을 제어하기 위해 사용합니다.\n\n# 어노테이션(Annotation)\n\n<hr>\n\n어노테이션은 코드에 추가 정보를 제공하는 방법으로, 리플렉션을 사용하여 런타임에 해석될 수 있습니다. 어노테이션은 코드의 의도를 명확히 하고, 프레임워크가 코드를 자동으로 처리하는 데 도움을 줄 수 있습니다.\n리플렉션을 효율적으로 하게 해주는 것\n\n# 리플렉션을 활용한 어노테이션 메타 데이터 가져오기 경험\n<hr>\n\n실제로 리플렉션을 활용해 커스텀 어노테이션의 메타 데이터를 추출하고, 자동 주입 로직을 구현한 경험이 있습니다."},{"excerpt":"String 자바에서 문자를 다루는 대표적인 타입은 와  이렇게 2가지가 있다.\n기본형인 는 문자 하나를 다루는데 사용되고, 를 사용해서 여러 문자 즉 문자열을 다루기 위해선 을 사용해야 한다.\n하지만 이렇게 을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 이라는 클래스를 제공한다. String 내부 구조  클래스는 대략 다음과 같은 구조로 이루…","fields":{"slug":"/java-string/"},"frontmatter":{"date":"November 05, 2024","title":"자바 문자열(String)","tags":["Java"]},"rawMarkdownBody":"\n# String\n<hr>\n\n자바에서 문자를 다루는 대표적인 타입은 `char`와 `String` 이렇게 2가지가 있다.\n기본형인 `char`는 문자 하나를 다루는데 사용되고, `char`를 사용해서 여러 문자 즉 문자열을 다루기 위해선 `char[]`을 사용해야 한다.\n하지만 이렇게 `char[]`을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 `String`이라는 클래스를 제공한다.\n\n## String 내부 구조\n`String` 클래스는 대략 다음과 같은 구조로 이루어져 있다.\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    private final char value[]; //자바 9이전\n    private final byte value[];//자바 9이후\n    private final int offset;\n    \n    private final int count;\n    private int hash; // Default to 0\n    \n    public String concat(String str) {...}\n    public int length() {...}\n}\n```\n\n클래스이므로 필드와 메소드로 구성되어 있다.\n\n### 필드(속성)\n\n```java\nprivate final char value[];\n```\n\n`String`은 `char`형 배열을 필드로 가지고 있고, 여기에는 `String`이 가지고 있는 실제 문자열을 저장하는 배열이다.\n이 말의 뜻은 문자 데이터 자체는 `char`형 배열에 저장되어 있고, `String` 객체는 이 배열을 참조하고 있다는 것이다.\n그러면 `char[]`가 불편해서 `String`을 사용하는 거 아닌가? 근데 `String`도 결국 `char[]`를 참조하고 있으니 똑같은 거 아닌가? 라는 의문이 들 수 있다.\n하지만 `String` 클래스는 `char[]`를 참조하고 있지만, 개발자가 직접 다루기 힘든 `char[]`를 내부에 숨겨놓고, `String` 클래스의 메소드를 통해 문자열을 다룰 수 있게 해준다.\n\n> 참고\n> 자바 9부터는 `String` 클래스 내부에 `byte[]`를 사용하는 방식으로 변경되었다.\n> 자바에서 문자 하나를 표현하는데 `char` 타입을 사용하면 `2byte`가 필요하다.\n> 여기서 영어, 숫자는 보통 `1byte`로 표현하고(정확히는 Latin-1 인코딩의 경우 1byte로 표현 가능),\n> 그렇지 않은 다른 언어는 `2byte`인 `UTF-16` 인코딩으로 표현해야 한다.\n> 때문에 `char` 타입을 사용하면 메모리 낭비가 발생할 수 있다.\n> 그래서 자바 9부터는 `byte[]`를 사용하여 문자열을 저장하고,\n> `String` 클래스의 메소드를 통해 `byte[]`를 `char[]`로 변환하여 사용함으로써 메모리를 더 효율적으로 사용할 수 있게 되었다.\n\n## String은 클래스\n자바에서 `String`은 위에 보다시피 클래스로 `int`,`char`와 달리 기본형(Primitive Type) 변수가 아닌 참조형(Reference Type) 변수로 분류 된다.\n참조형은 변수에 실제 값이 아닌 주소값을 가지고 있기에, 원칙적으로 `+`와 같은 연산을 할 수 없다.\n자바에서 `String`은 클래스이지만, 문자열을 다루기 쉽게 하기 위해 `+`연산자를 사용할 수 있게 오버로딩 되어 있다.\n\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\n\nString str3 = str1 + str2;\n\nSystem.out.println(str3); // HelloWorld\n```\n\n또한 `String`는 참조형이므로 변수에 문자열을 대입하면 실제 문자열은 메모리의 힙(Heap) 영역에 생성되고, `String` 변수는 이 문자열을 참조하게 된다.\n\n\n## String은 불변(Immutable)\n기본적으로 자바에서는 `String`의 값을 변경할 수 없다.\n\n`String`의 내부 구조를 위에서 보여줬듯이 `char[]` 혹은 `byte[]`를 가지고 있지만, 이 배열은 `final`로 선언되어 있어서 한 번 생성되면 변경할 수 없다.\n\n하지만 `String`의 값을 변경하는 것 처럼 보이는 연산을 할 수 있다.\n\n```java\nString str = \"Hello\";\n\nstr = str + \" World\";\n\nSystem.out.println(str); // Hello World\n```\n\n위의 코드를 보면 `str` 변수에 `Hello`라는 문자열을 대입하고, `str` 변수에 `World`라는 문자열을 더해서 다시 대입했다.\n이렇게 보면 `String`의 값을 변경한 것 처럼 보이지만, 실제로는 새로운 문자열 데이터 객체를 생성하고, 이를 `str` 변수가 참조하게 된다.\n\n즉, `String`은 불변(Immutable)하다는 것은 **한 번 생성된 문자열은 변경할 수 없다는 것**을 의미한다.\n\n`hashCode()` 메소드를 이용해 실제로 변수가 가지고 있는 주소값을 찍어보면 알 수 있다.\n> `hashCode()` 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하는 메소드이다.\n\n```java\nString str = \"Hello\";\n\nSystem.out.println(str.hashCode()); // 69609650\n\nstr = str + \" World\";\n\nSystem.out.println(str.hashCode()); // -862545276\n```\n똑같은 변수 str 의 해시코드(주소값)을 출력했음에도 **가지고 있는 값이 바뀜에 따라 아예 주소값이 달라짐**을 알 수 있다.\n즉, **문자열 값 자체는 불변이라 변경할수 없기 때문에 새로운 문자열 데이터 객체를 대입하는 식으로 값을 대체 하기 때문에** 이러한 현상이 생기는 것이다.\n\n### 왜 불변으로 설계 되었는가?\n이처럼 `String`이 불변적인 특성을 가지는 이유는 크게 3가지로 꼽을 수 있다.\n첫번째는 JVM(자바 가싱 머신) 에서는 따로 String Constant Pool 이라는 독립적인 영역을 만들고 문자열들을 Constant 화 하여 다른 변수 혹은 객체들과 공유하게 되는데, 이 과정에서 **데이터 캐싱**이 일어나고 그 만큼 성능적 이득을 취할 수 있기 때문이다.\n두번째는 데이터가 불변(immutable) 하다면 Multi-Thread 환경에서 동기화 문제가 발생하지 않기 때문에 더욱 safe 한 결과를 낼 수 있기 때문이다.\n세번째는 보안(Security) 적인 측면을 들 수 있다.\n예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데,\n만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.\n\n### 불변인 String 클래스의 단점\n하지만 불변(Immutable)한 `String` 클래스는 메모리 사용량이 많아지는 단점이 있다.\n불변인 `String` 클래스는 문자열을 변경할 때마다 새로운 문자열 객체를 생성해야 한다는 점이다.\n문자를 변경하는 상황이 자주 발생하는 상황이라면 `String` 객체를 만들고 GC가 빈번히 발생한다.\n결과적으로 CPU와 메모리를 많이 사용하게 되어 성능에 영향을 미칠 수 있다.\n그리고 문자열의 크기가 클수록, 문자열을 더 자주 변경할수록 이러한 단점이 더욱 부각된다.\n\n이러한 단점을 보완하기 위해 `StringBuffer`와 `StringBuilder` 클래스가 존재한다.\n`StringBuffer`와 `StringBuilder`는 `String`과 달리 가변적인 특성을 가지고 있어 문자열을 변경할 때 새로운 객체를 생성하지 않고 기존 객체를 변경한다.\n이러한 특성 때문에 문자열을 변경하는 작업이 많은 상황에서는 `StringBuffer`와 `StringBuilder`를 사용하는 것이 성능상 이점이 있다.\n\n자세한 내용은 [자바의 String, StringBuffer, StringBuilder 차이 알아보기](https://023-dev.github.io/2024-11-05/java-string-stringbuffer-stringbuilder)를 참고하자.\n\n## String의 주소 할당 방식\n<hr>\n\nString을 통해 문자열을 생성하는 방법은 대표적으로 두가지 방식이 있다.\n\n1. `String Literal`을 이용한 방식\n2. `new String(\"\")`을 이용한 방식\n\n```java\nString str1 = \"Hello\"; // String Literal\n\nString str2 = new String(\"Hello\"); // new String(\"\")\n```\n이 둘은 `\"Hello\"`라는 같은 문자열 값을 저장한지만, JVM 메모리 할당에서 차이가 존재한다.\n\n### String Contstant Pool\n`String`의 주소 할당을 어떠한 방식으로 하는지에 따라 메모리에서 형태가 다르게 된다.\n\n`String Literal`을 변수에 저장하게 되면 이 값은 `String Constant Pool`이라는 영역에 존재하게 되고, `new` 연산자를 통해 `String`을 생성하면 이 값은 `Heap` 영역에 존재하게 된다.\n\n```java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\n\nString str3 = new String(\"Hello\");\nString str4 = new String(\"Hello\");\n```\n\n위의 코드를 실행하면 문자열 리터럴 값으로 두 변수 `str1`, `str2`가 같은 메모리 주소를 가리킨다.\n\n그 이유는 `String`이 불변(immutable)하다는 특성 덕분에, 동일한 `String Literal`은 `String Constant Pool`이라는 메모리 영역에서 재사용되어 같은 문자열 가리킨다.\n\n이러한 이유로 `str1`과 `str2`는 동일한 메모리 주소를 참조하게 된다.\n\n정리하면, `String Constant Pool`은 동일한 문자열 리터럴을 캐싱하여 불필요한 객체 생성을 줄여 메모리를 사용을 최적화하고 성능을 향상시킨다.\n이러한 이유로 new String() 방식보다 문자열 리터럴 할당이 선호된다.\n\n> 참고\n> 풀(Pool)은 자원이 모여있는 곳을 의미한다.\n> 프로그래밍에서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻한다.\n> 여러 곳에서 함께 사용할 수 있는 객체를 필요할 때마다 생성하고, 제거하는 것은 비효율적이다.\n> 대신 이렇게 문자열 리터럴을 `String Constant Pool`에 저장해두고, 필요할 때마다 참조하는 방식으로 메모리를 효율적으로 사용할 수 있다.\n> 참고로 앞서 언급했듯이 `String Constant Pool`은 `Heap` 영역에 존재한다.\n> 그리고 `String Constant Pool`에서 문자열을 찾을 때는 해시 알고리즘을 사용하는데,\n> 이 떄문에 빠른 속도로 원하는 `String` 인스턴스를 찾을 수 있다.\n\n## String 비교\n\n`String` 클래스를 비교할 때는 `==` 비교가 아니라 `equals()` 메소드를 사용해야 한다.\n\n- 동일성(Idnetity): `==` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인.\n- 동등성(Equality): `equals()` 메소드를 사용해서 두 객체의 값이 같은지 확인.\n\n간단히 정리하자면 `==` 연산자와 `equals()` 메소드의 차이는 `주소값을 비교하냐`, `대상의 값 자체를 비교하냐`의 차이다.\n그래서 `String Literal`의 비교는 `==` 연산자를 사용해도 `String Constant Pool`에서 같은 객체 값을 참조하고 있기 때문에 주소값이 같아 `true`가 반환된다.\n\n하지만 `new Stirng(\"\")`의 비교는 힙 메모리에서 다른 주소 값을 참조하고 있어서 `==` 연산자를 사용하면 `false`가 반환된다. 따라서 `new Stirng(\"\")`은 주소 값이 아닌 그 안에 값 자체를 비교해야 하고 이 역할을 `equals()` 메소드가 한다.\n```java\nString str1 = \"Hello\"; // String Literal\nString str2 = \"Hello\";\n\nString str3 = new String(\"Hello\"); // new String(\"\")\nString str4 = new String(\"Hello\");\n\n// String Literal 비교\nSystem.out.println(str1 == str2); // true\n\n// new String(\"\") 비교\nSystem.out.println(str3 == str4); // false\nSystem.out.println(str3.equals(str4)); // true\n\n// 리터럴과 객체 문자열 비교\nSystem.out.println(str1 == str3); // false\nSystem.out.println(str3.equals(str1)); // true\n```\n\n## String의 메소드\n\n### 문자열 정보 조회\n- `length()`: 문자열의 길이를 반환한다.\n- `charAt(int index)`: 문자열의 특정 인덱스에 위치한 문자를 반환한다.\n- `isEmpty()`: 문자열이 비어있는지 확인한다.(길이가 0인 경우)\n- `isBlank()`: 문자열이 공백 문자로만 이루어져 있는지 확인한다.(길이가 0인 경우 || 공백(witespace)만 있는 경우), 자바 11부터 지원\n\n### 문자열 비교\n- `equals(Object obj)`: 문자열이 주어진 객체와 동일한지 비교한다.\n- `equalsIgnoreCase(String str)`: 대소문자를 무시하고 문자열이 같은지 비교한다.\n- `compareTo(String str)`: 문자열을 사전 순으로 비교한다.\n- `compareToIgnoreCase(String str)`: 대소문자를 무시하고 문자열을 사전 순으로 비교한다.\n- `startsWith(String prefix)`: 문자열이 특정 문자열로 시작하는지 확인한다.\n- `endsWith(String suffix)`: 문자열이 특정 문자열로 끝나는지 확인한다.\n\n\n### 문자열 검색\n- `contains(CharSequence s)`: 문자열이 특정 문자열을 포함하는지 확인한다.\n- `indexOf(String str)`: 문자열에서 특정 문자열이 처음으로 등장하는 인덱스를 반환한다.\n- `lastIndexOf(String str)`: 문자열에서 특정 문자열이 마지막으로 등장하는 인덱스를 반환한다.\n\n### 문자열 조작 및 변환\n- `concat(String str)`: 문자열을 연결한다.\n- `substring(int beginIndex)`: 문자열의 특정 인덱스부터 끝까지의 부분 문자열을 반환한다.\n- `replace(CharSequence target, CharSequence replacement)`: 문자열에서 특정 문자열을 다른 문자열로 대체한다.\n- `replaceAll(String regex, String replacement)`: 문자열에서 특정 정규 표현식과 일치하는 문자열을 다른 문자열로 대체한다.\n- `replaceFirst(String regex, String replacement)`: 문자열에서 특정 정규 표현식과 일치하는 첫 번째 문자열을 다른 문자열로 대체한다.\n- `toLowerCase()`: 문자열을 소문자로 변환한다.\n- `toUpperCase()`: 문자열을 대문자로 변환한다.\n- `trim()`: 문자열의 앞뒤 공백을 제거한다.\n- `strip()`: 문자열의 앞뒤 공백을 제거한다. 자바 11부터 지원\n\n### 문자열 분할 및 결합\n- `split(String regex)`: 문자열을 특정 정규 표현식을 기준으로 나누어 배열로 반환한다.\n- `join(CharSequence delimiter, CharSequence... elements)`: 문자열을 결합한다.\n\n### 기타 유틸리티\n- `format(String format, Object... args)`: 지정된 형식 문자열을 사용하여 문자열을 생성한다.\n- `valueOf(Object obj)`: 지정된 값을 문자열로 변환한다.\n- `toCharArray()`: 문자열을 문자 배열로 변환한다.\n- `matches(String regex)`: 문자열이 특정 정규 표현식과 일치하는지 확인한다.\n\n> 참고\n> `CharSequence`는 `String`, `StringBuffer`, `StringBuilder` 클래스의 부모 인터페이스이다.\n> 문자열을 처리하는 다양한 클래스를 사용할 때, `CharSequence`를 사용하면 유연하게 문자열을 다룰 수 있다."},{"excerpt":"람다 표현식(Lambda Expression) 람다 표현식(Lambda Expression)은 함수형 프로그래밍을 위해 자바에서 제공하는 간결한 함수식으로, 자바의 메서드를 간단하게 표현할 수 있는 방법이다.\n기존 자바에서는 메서드를 표현하려면 별도의 클래스를 정의해야 했지만, 람다 표현식을 사용하면 메서드의 이름과 반환값을 생략하여 코드가 간결해지게 할…","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"date":"November 05, 2024","title":"자바 람다(Lambda)와 스트림(Stream)","tags":["Java"]},"rawMarkdownBody":"\n# 람다 표현식(Lambda Expression)\n\n<hr>\n\n람다 표현식(Lambda Expression)은 함수형 프로그래밍을 위해 자바에서 제공하는 간결한 함수식으로, 자바의 메서드를 간단하게 표현할 수 있는 방법이다.\n기존 자바에서는 메서드를 표현하려면 별도의 클래스를 정의해야 했지만, 람다 표현식을 사용하면 메서드의 이름과 반환값을 생략하여 코드가 간결해지게 할 수 있다.\n\n`int add(int x, int y) { return x  + y; }`와 같은 메서드 표현식을 아래 코드처럼 람다식을 사용하면 간결하게 작성할 수 있다.\n이처럼 람다식은 이름없는 함수다 해서 익명함수(anonymous function)라고도 불린다.\n\n```java\n// 기존 메서드 표현\nint add(int x, int y) {\n    return x + y;\n}\n\n// 람다 표현식을 사용한 간결한 표현 (메서드 반환 타입과 이름 생략)\n(int x, int y) -> {\n        return x + y;\n};\n\n// 매개변수 타입까지 생략\n        (x, y) -> {\n        return x + y;\n};\n\n// 리턴문 한 줄만 있을 때는 중괄호와 return까지 생략\n(x, y) -> x + y;\n```\n\n> 위 코드에서 타입을 생략해도 컴파일러가 오류를 발생시키지 않는 이유는, 컴파일러가 생략된 타입을 추론할 수 있기 때문이다.\n\n람다식은 특히 컬렉션의 요소를 필터링하거나 매핑할 때 사용하면 원하는 결과를 코드의 가독성을 살리면서 얻을 수 있다.\n\n## 람다식의 화살표 함수\n\n자바의 화살표 함수는 자바스크립트의 화살표함수와 구조와 개념이 유사하다.\n자바스크립트는 약타입 언어로 타입 선언 없이 자유롭게 변수를 받을 수 있지만, 자바는 강타입 언어이므로 람다식을 사용하기 위해 함수형 인터페이스를 통해 타입을 선언해야 한다.\n하지만, 자바에는 함수 타입을 직접 표현할 자료형이 없기 때문에, 인터페이스를 사용하여 람다식을 표현할 수 있도록 설계되어 있다.\n\n```javascript\n// JavaScript - 화살표 함수 사용\nconst MyFunction = {\n    print: (str) => console.log(str)\n};\nMyFunction.print(\"Hello World\");\n\n```\n\n```java\n// Java - 람다 표현식 사용\ninterface MyFunction {\n    void print(String str);\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyFunction myfunc = (str) -> System.out.println(str);\n        myfunc.print(\"Hello World\");\n    }\n}\n```\n\n## 람다식과 함수형 인터페이스\n람다식은 마치 메서드를 변수로 선언하는 것처럼 보이지만, 사실 자바에서는 메서드를 단독으로 표현할 수 없다.\n때문에 람다식은 함수형 인터페이스를 구현하는 익명 클래스로 간략하게 표현된 객체라고 할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IAdd lambda = (x, y) -> x + y; // 익명 클래스로 람다식 사용\n        int result = lambda.add(1, 2);\n        System.out.println(result);\n    }\n}\n```\n이때 람다식 객체를 콘솔에 출력해보면 `외부클래스명$$Lambda$번호`와 같은 형식으로 출력되며, 이는 익명 구현 객체로 표현되는 것을 의미합니다.\n단, 람다 표현은 함수형 인터페이스의 추상 메서드를 구현할 때만 가능하며, 익명 클래스의 모든 메서드를 람다식으로 줄일 수는 없다.\n\n### 함수형 인터페이스\n함수형 인터페이스란 딱 하나의 추상 메더스가 있는 인터페이스를 의미한다.\n람다식은 이와 같은 함수형 인터페이스의 추상메서드를 간단하게 표현할 수 있도록 고안되었다.\n\n람다식은 하나의 메서드를 한 줄로 정의하기 때문에, 함수형 인터페이스에 추상 메서드가 두 개 이상 존재하면 람다식으로 표현할 방법이 없으므로 람다 표현의 대상이 될 수 없다.\n단, 자바 8부터 함수형 인터페이스에는 `default`, `static`, `private` 메서드를 추가할 수 있는데 이러한 메서드들은 추상 메서드가 아니기 때문에 인터페이스 내에 존재하더라도 람다식을 사용할 수 있다.\n\n```java\n// 함수형 인터페이스 - 하나의 추상 메서드만 존재\ninterface IAdd {\n    int add(int x, int y);\n}\n\n// 함수형 인터페이스가 아닌 경우 - 두 개의 추상 메서드 존재\ninterface ICalculate {\n    int add(int x, int y);\n    int subtract(int x, int y);\n}\n\n// 다양한 구성요소를 포함해도 추상 메서드가 하나면 함수형 인터페이스\ninterface IAdd {\n    int add(int x, int y);\n\n    final boolean isNumber = true; // 상수 필드\n    default void print() {}; // 디폴트 메서드\n    static void printStatic() {}; // 정적 메서드\n}\n```\n\n### @FunctionalInterface\n\n함수형 인터페이스를 정의할 때, @FunctionalInterface 어노테이션을 추가하면 추상 메서드가 하나만 존재해야 함을 컴파일러가 확인해준다.\n이 어노테이션을 붙임으로써 실수로 두 개 이상의 추상 메서드를 정의하는 경우 컴파일 오류가 발생하게 되어, 함수형 인터페이스 규칙을 명확히 준수할 수 있다.\n\n```java\n@FunctionalInterface\npublic interface MyFunctionalInterface {\n    void method();\n    // void anotherMethod(); // 추가 시 컴파일 오류 발생\n}\n```\n\n## 람다식의 타입 추론\n\n람다식은 리턴 타입이나 파라미터 타입을 명시하지 ㅇ낳는 점에서 컴파일러가 이 함수의 타입을 어떻게 인식하는지 궁금할 수 있다.\n사실, 컴파일러는 람다식을 보고 해당 함수의 타입을 스스로 추론하는데, 이 타입 추론은 사람이 미리 정의해놓은 타입 정보와 정의문을 보고 이루어진다.\n대부분의 함수형 인터페이스는 제네릭을 사용하기에 컴파일러가 타입을 추론하는데 필요한 타입 정보 대부분을 제네릭에서 판별해서 얻을 수 있다.\n\n아래 코드에서는 List<String> 타입의 리스트를 생성하고 Collections 클래스의 sort 메서드를 호출한다.\nsort 메서드는 첫 번째 인자로 리스트 객체를 받고, 두 번째 인자로는 람다식을 사용하여 문자열 길이를 기준으로 리스트를 정렬한다.\n\n```java\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n        // 문자열 길이를 기준으로 정렬\n        Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n    }\n}\n```\n\n여기서 컴파일러의 타입 추론 과정은 다음과 같다.\n\n1. `sort` 메서드의 첫 번째 매개변수로 `List<String>` 객체가 전달된다.\n2. 첫 번째 매개변수 타입으로 인해 `sort` 메서드의 제네릭 타입 매개변수는 `String`으로 지정된다.\n3. `Comparator` 인터페이스의 제네릭 타입 `T`도 `String`으로 지정된다.\n    - `Integer.compare(s1.length(), s2.length())`는 `Comparator` 함수형 인터페이스를 구현한 것이다.\n4. 최종적으로 람다식의 매개변수 s1과 s2는 String 타입으로, 리턴 타입은 `int`로 추론된다.\n\n따라서 위 코드와 같은 람다식에서 파라미터 타입을 명시하지 않더라도, 컴파일러는 제네릭 정보로 인해 String 타입 파라미터와 int 타입 리턴 타입을 자동으로 추론할 수 있다.\n\n### 명시적 타입 지정\n하지만, 상황에 따라 파라미터 타입을 명시적으로 작성하는 것이 유리할 때도 있다.\n특히, 복잡한 람다식에서는 타입을 명시하는 것이 코드의 카독성을 향상 시켜준다.\n이 부분은 상황에 따라 개발자가 트레이드 오프를 해야한다.\n```java\n// 람다식 파라미터 타입 명시\nCollections.sort(words, (String s1, String s2) -> Integer.compare(s1.length(), s2.length()));\n```\n\n## 람다 표현식의 한계\n\n람다 표현식은 자바 코드를 간결하게 만들지만, 모든 상황에 적합한 것은 아니다.\n람다 표현식이 갖는 몇 가지 한계점과 사용 시 주의사항을 살펴보겠다.\n\n### 람다는 문서화할 수 없다\n\n람다는 이름 없는 함수이기 때문에 메서드나 클래스와 다르게 문서화를 할 수 없다.\n코드 자체로 동작이 명확하게 설명되지 않거나, 람다가 길거나 읽기 어려운 경우에는 코드의 가독성과 유지보수를 고려해 람다를 쓰지 않는 방향으로 리팩토링하는 것이 좋다.\n\n### 람다는 디버깅이 어렵다\n\n람다식은 기본적으로 익명 구현 객체 기반으로 동작하여, 콜 스택(call stack) 추적이 어렵다.\n예를 들어, 0으로 나누는 오류가 발생하는 코드를 `for` 문과 람다식을 사용한 코드로 각각 구현했을 때, 오류 메시지에 표시되는 줄이 다르다.\n\n```java\n// 일반 for문 사용\npublic static void main(String[] args) {\n    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n    for (Integer i : list) {\n        for (int j = 0; j < i; j++) {\n            System.out.println(i / j); // 0으로 나누는 예외 발생\n        }\n    }\n}\n```\n\n```java\n// 람다 표현식 사용\npublic static void main(String[] args) {\n    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n    list.forEach(i -> {\n        IntStream.range(0, i).forEach(j -> {\n            System.out.println(i / j); // 0으로 나누는 예외 발생\n        });\n    });\n}\n```\n\n### Stream의 람다 사용은 `for` 문보다 성능이 떨어진다\n\n성능에 민감한 환경에서는 람다 표현식과 `Stream`이 일반 `for` 문보다 성능이 낮을 수 있다.\n아래 코드는 0부터 10,000까지 단순 순회하는 코드를 `Stream`의 람다와 `for` 문으로 각각 구성하여 실행 시간을 비교한다.\n\n```java\npublic static void main(String[] args) {\n    // 람다식 stream 순회\n    long startTime = System.nanoTime();\n    IntStream.range(0, 10000).forEach(value -> {});\n    long endTime = System.nanoTime();\n    System.out.println(\"람다식 stream 순회: \" + (endTime - startTime) + \"ns\");//13870700ns\n\n    // 일반 for문 순회\n    startTime = System.nanoTime();\n    for (int i = 0; i < 10000; i++) {}\n    endTime = System.nanoTime();\n    System.out.println(\"일반 for문 순회: \" + (endTime - startTime) + \"ns\");//43900ns\n}\n```\n\n### 람다를 남발하면 코드가 지저분해질 수 있다\n\n람다식은 실행부에서 직접 동작을 지정하기 때문에, 남발하면 비슷한 형태의 람다식이 반복되어 코드가 지저분해질 수 있다.\n예를 들어, 아래 코드와 같이 여러 연산을 위한 람다식을 매번 작성하면 코드가 반복적으로 길어질 수 있다.\n\n```java\ninterface OperationStrategy {\n    int calculate(int x, int y);\n}\n\n// 템플릿 클래스\nclass OperationTemplate {\n    int calculate(int x, int y, OperationStrategy cal) {\n        return cal.calculate(x, y);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int x = 100;\n        int y = 30;\n\n        OperationTemplate template = new OperationTemplate();\n\n        // 각 연산을 위한 람다식\n        System.out.println(template.calculate(x, y, (a, b) -> a + b)); // 덧셈\n        System.out.println(template.calculate(x, y, (a, b) -> a - b)); // 뺄셈\n        System.out.println(template.calculate(x, y, (a, b) -> a * b)); // 곱셈\n        System.out.println(template.calculate(x, y, (a, b) -> a / b)); // 나눗셈\n    }\n}\n```\n\n### 람다식은 재귀 호출에 부적합하다\n\n람다식은 재귀 함수를 작성하는 데 적합하지 않다.\n특히, 재귀 람다식을 사용하려고 하면 컴파일 오류가 발생할 수도 있다.\n예를 들어, 팩토리얼 함수를 람다식으로 작성하려 하면 다음과 같은 오류가 발생한다.\n\n```java\npublic static void main(String[] args) {\n    UnaryOperator<Long> factorial = (x) -> {\n        return x == 0 ? 1 : x * factorial.apply(x - 1); // 컴파일 오류 발생\n    };\n\n    System.out.println(factorial.apply(5L));\n}\n```\n\n이처럼, 람다식은 내부에서 자기 자신을 참조하는 재귀 호출이 불가능하며, 이는 함수형 인터페이스의 제한으로 인해 발생하는 문제다.\n\n\n## 스트림(Stream)\n\n이처럼 람다 표현식은 개별 연산을 간단히 표현하기에 탁월하지만, 컬렉션 전체에 걸친 데이터 흐름을 나타내기에는 제한적이다.\n람다식으로는 단일 동작만 표현할 수 있고, 복잡한 데이터를 다룰 때에는 여전히 반복문과 조건문이 필요했다.\n때문에 전체 데이터 흐름을 선언적으로 표현하기에는 한계가 있었다.\n이러한 부분들을 보완하고자 자바 8에서 람다와 같이 스트림(Stream)이 함께 출시되게 되었다.\n\n스트림은 컬렉션과 배열의 데이터를 람다처럼 간결하고 효율적으로 처리하기 위한 연속 데이터 처리 프레임워크다.\n스트림을 통해 데이터를 필터링, 매핑, 정렬 등 다양한 연산을 선언적으로 수행할 수 있고, 이로 인해 복잡한 반복문 대신 가독성이 높은 코드로 데이터 처리 흐름을 구성할 수 있다.\n\n스트림의 주요 특징으로는 다음과 같다.\n- 지연 연산: 스트림은 필요할 때에만 연산을 수행한다. 최종 연산이 호출되기 전까지는 실제 연산이 수행되지 않고, 설정한 모든 연산이 최종 연산 시점에 한꺼번에 처리된다.\n- 병렬 처리: `parallelStream`을 사용해 병렬 처리를 수행할 수 있어서 대용량 데이터 처리에 적합하다.\n\n### 스트림 수행 과정\n\n스트림은 다음과 같은 과정들을 통해 수행되어진다.\n\n#### 스트림 생성\n\n스트림을 이용하기 위해서는 먼저 스트림을 생성해야한다.\n`Stream Collection.stream()` 을 이용하여 원하는 타입의 컬렉션을 기반으로 스트림을 생성할 수 있다.\n\n#### 중간 연산\n\n데이터의 유형 변환 혹은 필터링, 정렬 등 스트림을 활용하기 전 데이터를 필요에 따라 가공하는 작업이 필요하다.\n이를 위해서 사용되는 메소드를은 다음과 같다.\n\n- map(변환)\n- sorted(정렬)\n- skip(스트림 자르기)\n- limit(스트림 자르기)\n\n#### 최종 연산\n\n스트림이 한번 결과를 반환하면, 이후에는 닫혀서 재사용이 불가능하다.\n최종 연산 결과 값은 하나의 값이거나, 배열 혹은 다른 유형의 컬렉션 데이터일 수 있다.\n그러므로 필요에 따라, 결과값의 데이터 타입을 변환하거나 결과값을 가지고 원하는 형태로 바꾸는 추가적인 최종 연산이 필요할 수 있다.\n예를 들어 `collect()` 매서드를 활용해 다른 컬렉션 유형으로 변환하거나 `reduce` 를 활용하여 특정한 수 만큼 일정하게 값이 증가하는 증분연산(Incremental Calculation)을 할 수도 있다.\n필요에 따라서 다양한 형태의 연산이 가능하다.\n\n```java\nList<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n// 스트림을 사용하여 데이터 필터링, 매핑, 정렬, 출력\nwords.stream()\n   .filter(word -> word.length() > 4)    // 길이가 4보다 큰 단어만 남김\n   .map(String::toUpperCase)             // 대문자로 변환\n   .sorted()                             // 정렬\n   .forEach(System.out::println);        // 출력\n```\n"},{"excerpt":"제네릭(Generics)이란? 자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정할 수 있는 기법을 의미한다.\n제네릭을 통해 각 객체가 서로 다른 타입의 데이터를 다룰 수 있게 되어, 객체 지향 프로그래밍의 다형성을 더욱 유연하게 활용할 수 있다. 예를 들어, 자주 사용되는 와 같은 컬렉션 클래스에서 과 같은 꺾쇠 괄호…","fields":{"slug":"/java-generic/"},"frontmatter":{"date":"November 05, 2024","title":"자바 제네릭(Generics)","tags":["Java"]},"rawMarkdownBody":"\n# 제네릭(Generics)이란?\n\n<hr>\n\n자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정할 수 있는 기법을 의미한다.\n제네릭을 통해 각 객체가 서로 다른 타입의 데이터를 다룰 수 있게 되어, 객체 지향 프로그래밍의 다형성을 더욱 유연하게 활용할 수 있다.\n\n예를 들어, 자주 사용되는 `List`와 같은 컬렉션 클래스에서 `<String>`과 같은 꺾쇠 괄호(`<>`)를 보았을 것이다.\n\n```java\nArrayList<String> list = new ArrayList<>();\n```\n\n위 코드에서 `<String>`이 바로 제네릭 타입이다.\n`ArrayList`가 `String` 타입으로 지정되면, 이 리스트는 오직 문자열만을 저장할 수 있게 된다.\n배열과 리스트의 선언문 형태를 비교해 보면, 배열처럼 컬렉션 자료형의 타입을 외부에서 지정해주는 방식이라고 생각할 수 있다.\n\n이처럼 제네릭은 컬렉션 클래스나 메서드에서 사용할 내부 데이터 타입을 파라미터처럼 외부에서 지정하여, 유연한 타입 변수를 사용하는 기능이라고 볼 수 있다.\n\n> 제네릭을 통해 객체에 타입을 지정하는 것은 변수를 선언할 때 타입을 지정하는 것과 비슷한 개념이다.\n\n## 제네릭 타입 매개변수\n\n제네릭은 `<>` 꺾쇠 괄호를 사용해 타입을 지정한다.\n이 괄호는 다이아몬드 연산자라고 불리며, 괄호 안의 기호는 타입 매개변수(type parameter)를 의미한다.\n\n### 타입 파라미터 정의\n\n제네릭 타입은 주로 클래스나 메서드를 설계할 때 사용된다.\n다음은 제네릭을 사용하여 정의된 클래스 예제이다.\n\n```java\nclass FruitBox<T> {\n    List<T> fruits = new ArrayList<>();\n\n    public void add(T fruit) {\n        fruits.add(fruit);\n    }\n}\n```\n\n위에서 `<T>` 기호를 통해 `FruitBox` 클래스가 제네릭 타입을 사용함을 볼 수 있다.\n인스턴스를 생성할 때 타입을 명시하면, 해당 타입이 `T`로 지정되어 클래스 내부에서 사용된다.\n\n```java\n// 정수 타입\nFruitBox<Integer> intBox = new FruitBox<>();\n\n// 실수 타입\nFruitBox<Double> doubleBox = new FruitBox<>();\n\n// 문자열 타입\nFruitBox<String> strBox = new FruitBox<>();\n\n// 클래스 타입 (예: Apple 클래스)\nFruitBox<Apple> appleBox = new FruitBox<>();\n```\n\n이처럼 실행 시 지정한 타입이 `T`로 전파되어 타입이 구체화되는 과정을 구체화(Specialization)라 한다.\n\n### 타입 파라미터 생략\n\nJDK 1.7 이후부터는 생성자 부분의 제네릭 타입은 생략할 수 있다. 컴파일러가 타입을 자동으로 추론하기 때문이다.\n\n```java\nFruitBox<Apple> appleBox = new FruitBox<>();\n```\n\n## 제네릭 타입 제한\n\n제네릭 타입으로 원시 타입(Primitive Type)은 사용할 수 없다.\n즉, `int`, `double`과 같은 기본 타입을 제네릭 타입 파라미터로 사용할 수 없고, 대신 `Integer`, `Double`과 같은 Wrapper 클래스를 사용해야 한다.\n\n```java\n// 기본 타입 int 사용 불가\nList<int> intList = new ArrayList<>(); // 오류 발생\n\n// Wrapper 클래스 사용\nList<Integer> integerList = new ArrayList<>();\n```\n\n제네릭을 통해 클래스 간 상속 관계를 활용한 다형성도 적용할 수 있다.\n\n```java\nclass Fruit { }\nclass Apple extends Fruit { }\nclass Banana extends Fruit { }\n\nclass FruitBox<T> {\n    List<T> fruits = new ArrayList<>();\n\n    public void add(T fruit) {\n        fruits.add(fruit);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FruitBox<Fruit> box = new FruitBox<>();\n\n        box.add(new Fruit());\n        box.add(new Apple()); // 업캐스팅 적용\n        box.add(new Banana()); // 업캐스팅 적용\n    }\n}\n```\n\n## 복수 타입 파라미터\n\n제네릭 타입은 하나 이상 지정할 수 있다.\n여러 타입이 필요할 경우 `<T, U>`와 같이 쉼표로 구분해 여러 타입 파라미터를 지정할 수 있다.\n\n```java\nclass Apple {}\nclass Banana {}\n\nclass FruitBox<T, U> {\n    List<T> apples = new ArrayList<>();\n    List<U> bananas = new ArrayList<>();\n\n    public void add(T apple, U banana) {\n        apples.add(apple);\n        bananas.add(banana);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FruitBox<Apple, Banana> box = new FruitBox<>();\n        box.add(new Apple(), new Banana());\n    }\n}\n```\n\n## 중첩 타입 파라미터\n\n제네릭 객체를 제네릭 타입 파라미터로 사용하는 중첩 형식도 가능하다.\n\n```java\npublic static void main(String[] args) {\n    // LinkedList<String>을 원소로 가지는 ArrayList\n    ArrayList<LinkedList<String>> list = new ArrayList<>();\n\n    LinkedList<String> node1 = new LinkedList<>();\n    node1.add(\"apple\");\n    node1.add(\"banana\");\n\n    LinkedList<String> node2 = new LinkedList<>();\n    node2.add(\"cherry\");\n    node2.add(\"date\");\n\n    list.add(node1);\n    list.add(node2);\n    System.out.println(list);\n}\n```\n\n## 타입 파라미터 네이밍 규칙\n\n제네릭 기호는 보통 `<T>`와 같이 표현되지만, 통상적인 명명 규칙이 존재한다.\n이러한 관례는 가독성을 높이고 코드 이해를 돕는다.\n\n- `<T>`: 타입(Type)\n- `<E>`: 요소(Element), 주로 `List`에서 사용\n- `<K>`: 키(Key), 주로 `Map<K, V>`에서 사용\n- `<V>`: 값(Value), 매핑된 값\n- `<N>`: 숫자(Number)\n- `<S, U, V>`: 2번째, 3번째, 4번째 타입\n\n## 제네릭 사용 이유와 이점\n\n### 컴파일 타임에 타입 검사 가능\n\n제네릭은 컴파일 타임에 타입을 검사하여 타입 안전성을 보장한다.\n예를 들어, JDK 1.5 이전에는 `Object` 타입을 인수나 반환값으로 사용했지만, 타입 변환 시 런타임 오류가 발생할 위험이 있었다.\n\n```java\nclass Apple {}\nclass Banana {}\n\nclass FruitBox {\n    private Object[] fruits;\n\n    public FruitBox(Object[] fruits) {\n        this.fruits = fruits;\n    }\n\n    public Object getFruit(int index) {\n        return fruits[index];\n    }\n}\n```\n\n위와 같은 코드에서는 `FruitBox`가 `Object` 타입을 사용해 모든 타입을 저장할 수 있지만, 형변환 오류를 컴파일 시점에 감지하지 못해 런타임 에러가 발생할 수 있다.\n제네릭을 사용하면 이 문제를 해결할 수 있다.\n\n```java\nclass FruitBox<T> {\n    private T[] fruits;\n\n    public FruitBox(T[] fruits) {\n        this.fruits = fruits;\n    }\n\n    public T getFruit(int index) {\n        return fruits[index];\n    }\n}\n\npublic static void main(String[] args) {\n    Apple[] apples = { new Apple(), new Apple() };\n    FruitBox<Apple> box = new FruitBox<>(apples);\n\n    Apple apple = box.getFruit(0); // 안전한 형변환\n}\n```\n\n### 불필요한 형변환 제거로 성능 향상\n\n제네릭을 사용하면 형변환이 필요 없어 성능이 향상된다.\n\n```java\n// 형변환이 필요 없음\nFruitBox<Apple> box = new FruitBox<>(apples);\n\nApple apple1 = box.getFruit(0);\nApple apple2 = box.getFruit(1);\n```\n\n형변환이 없어짐에 따라 코드의 가독성이 높아지고, 형변환으로 인한 오버헤드가 줄어들어 성능이 개선된다.\n\n## 제네릭 사용 시 주의사항\n\n### 제네릭 타입의 객체 생성 불가\n\n제네릭 타입 자체로 객체를 생성할 수 없다.\n즉, `new` 연산자 뒤에 제네릭 타입 파라미터를 사용할 수 없다.\n\n```java\nclass Sample<T> {\n    public void someMethod() {\n        T t = new T(); // 컴파일 오류\n    }\n}\n```\n\n### static 멤버에 제네릭 타입 사용 불가\n\n`static` 변수나 메서드에서는 제네릭 타입 파라미터를 사용할 수 없다.\n`static` 멤버는 클래스가 공통으로 사용하는 변수이기 때문에, 제네릭 객체 생성 전에 타입이 결정되어야 하기 때문이다.\n\n```java\nclass Student<T> {\n    private String name;\n\n    // static 메서드의 반환 타입\n\n에 제네릭 타입 사용 불가\n    public static T getInstance() {  // 오류 발생\n        return new T();\n    }\n}\n```\n\n### 제네릭으로 배열 선언 주의점\n\n제네릭 타입의 배열은 만들 수 없지만, 제네릭 배열 선언은 허용된다.\n\n```java\nclass Sample<T> {}\n\npublic class Main {\n    public static void main(String[] args) {\n        // 제네릭 배열 선언 허용\n        Sample<Integer>[] arr = new Sample[10];\n        \n        // 제네릭 타입을 생략해도 위에서 Integer로 지정된 제네릭 타입을 추론\n        arr[0] = new Sample<>();\n    }\n}\n```"},{"excerpt":"프로그램에서 오류가 발생하면 시스템 레벨에서 문제를 일으켜 원치 않는 버그를 유발하거나, 심각한 경우 프로그램을 강제로 종료시키기도 한다.\n이러한 오류의 원인은 다양하며, 내부적으로 프로그램 설계 로직의 허점에서 비롯될 수 있고, 외부적으로는 프로그램 자체가 아닌 하드웨어 문제로 인해 발생할 수도 있다. 이 글에서는 자바 이것들을 어떻게 처리하는 알아본다…","fields":{"slug":"/java-exception-error/"},"frontmatter":{"date":"November 05, 2024","title":"자바 에러(Error)와 예외처리(Exception)","tags":["Java"]},"rawMarkdownBody":"\n프로그램에서 오류가 발생하면 시스템 레벨에서 문제를 일으켜 원치 않는 버그를 유발하거나, 심각한 경우 프로그램을 강제로 종료시키기도 한다.\n이러한 오류의 원인은 다양하며, 내부적으로 프로그램 설계 로직의 허점에서 비롯될 수 있고, 외부적으로는 프로그램 자체가 아닌 하드웨어 문제로 인해 발생할 수도 있다.\n\n이 글에서는 자바 이것들을 어떻게 처리하는 알아본다.\n\n# 프로그래밍의 오류 종류\n\n<hr>\n\n프로그래밍을 하다 보면 단순한 오타부터 해서 파일이 존재하지 않는 문제, 또는 메모리 누수와 같은 오류까지 다양한 종류의 오류를 경험하게 된다.\n이러한 오류는 발생 시점에 따라 크게 세 가지로 구분할 수 있다.\n\n- 논리적 에러(Logical Error): 코드가 실행은 되지만, 의도한 대로 동작하지 않는 오류로, 프로그램이 예상과 다른 결과를 반환할 때 발생한다.\n- 컴파일 에러(Compile-time Error): 코드가 컴파일될 때 발생하는 오류로, 주로 문법 오류나 잘못된 타입 사용 등이 원인이다.\n- 런타임 에러(Runtime Error): 프로그램이 실행되는 도중 발생하는 오류로, 주로 NullPointerException이나 ArrayIndexOutOfBoundsException과 같은 예외가 이에 해당한다.\n\n## 논리적 에러\n\n논리적 에러(Logical Error)는 흔히 버그로 알려져 있으며, 프로그램이 정상적으로 실행되고 있는 것처럼 보여도 예상한 결과가 나오지 않음으로써 문제를 일으킬 수 있다.\n이러한 오류는 사용자가 의도한 작업이 제대로 수행되지 않게 하여 서비스 이용에 지장이 될 수 있다.\n\n논리적 오류는 프로그램 입장에서는 아무런 문제 없이 실행되기 때문에 에러 메시지를 출력하지 않는다. 따라서 개발자가 직접 프로그램의 전반적인 로직과 알고리즘을 검토해야 한다.\n\n## 컴파일 에러\n\n컴파일 에러(Compilation Error)는 프로그램을 컴파일하는 과정에서 발생하는 오류로, 대표적인 원인으로는 문법 오류(syntax error)가 있다.\n\n컴파일에러는 IDE(Integrated Development Environment)에서 일정 주기로 소스를 자동으로 컴파일하여 오류를 미리 표시함으로써 즉시 알려주는 경우가 많아, 비교적 해결하기 쉬운 오류다.\n컴파일에 성공하지 않으면 프로그램이 생성되지 않아 실행 자체가 불가능하므로, 개발자는 컴파일러가 표시하는 오류를 수정하여 해결하면 된다.\n\n## 런타임 에러\n\n런타임 에러(Runtime Error)는 컴파일 과정에서 문제없이 통과해 프로그램이 실행되더라도 실행 중에 발생하는 오류로, 프로그램이 비정상적으로 종료되거나 예상치 못한 결과를 초래할 수 있으며, 메모리 부족같은 외부요인으로 인해 발생하기도 한다.\n\n이것이 이 글에서 중점으로 생각해보는 내용이다. 이러한 런타임 에러는 주로 설계 미숙에서 기인하며, 발생 시 역추적하여 원인을 파악해야 한다.\n이를 방지하기 위해서는 다양한 예외 상황을 미리 고려하고 대비해야 한다.\n\n## 오류와 예외\n자바에서는 **실행 시(Runtime) 발생할 수 있는 문제를 에러(Error)와 예외(Exception)로 구분**한다.\n\n![Error Exception](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_1.png)\n\n에러는 메모리 부족(`OutOfMemoryError`)이나 스택 오버플로우(`StackOverflowError`)처럼, 프로그램 코드로 해결할 수 없는 심각한 오류다.\n에러는 예측이 어려우며 발생 시 복구가 거의 불가능하다. 시스템이나 JVM 레벨에서 발생하는 경우가 개발자가 대처하기도 힘들다.\n\n예외는 잘못된 로직, 잘못된 입력값, 예상 외의 입력 패턴 등으로 인해 발생하는 오류다.\n그래서 예외는 에러와 달리 발생하더라도 대비 코드를 작성해, 예상치 못한 상황에서도 프로그램이 비정상적으로 종료 혹은 동작이 수행되지 않도록 방지할 수 있다.\n이러한 예외에 대한 대비 코드가 예외 처리 문법인 `try-catch`다.\n\n# 자바의 예외 클래스\n\n<hr>\n\n## 예외 클래스의 계층구조\n\n자바는 프로그램 실행 중 예외가 발생하면 해당 예외에 맞는 객체를 생성하고, 예외처리 코드에서 이 객체를 이용해 오류를 파악하고 해결할 수 있게 도와준다.\n자바에서는 오류를 `Error`와 `Exception`라는 클래스로 계층적으로 구조를 나누어 관리한다.\n\n![Throwable Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_2.png)\n\n`Error` 클래스는 주로 시스템 레벨의 심각한 오류를 나타내며, 개발자가 해결할 수 없는 외부적인 문제로 간주된다.\n반면, `Exception` 클래스는 애플리케이션 레벨에서 발생하는 오류를 관리하기 때문에, 우리가 주로 다루어야 할 대상이다.\n\n> `Throwable` 클래스는 최상위 클래스인 `Object`를 상속받는다. 예외와 오류 메시지를 담는 역할을 하며, 대표적으로 `getMessage()`와 `printStackTrace()` 메서드를 제공하여 예외의 원인과 발생 위치를 추적할 수 있게 한다.\n\n자바에서 다루는 모든 예외는 `Exception` 클래스로 처리하는데 컴파일 시점에서 체크되는 `Checked Exception`과 런타임에 발생하는 `RuntimeException`으로 나누어 관리한다.\n\n![Exception Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_3.png)\n\n### 컴파일 타임 예외 클래스\n\n`Checked Exception`은 프로그램 외부 요인으로 인해 발생하는 예외로, 컴파일러가 예외처리를 강제한다.\n\n- `FileNotFoundException`: 파일을 찾을 수 없을 때 발생한다.\n- `ClassNotFoundException`: 클래스가 로드되지 않았을 때 발생한다.\n- `IOException`: 입출력 작업 중 문제가 발생할 때 발생한다.\n- `SQLException`: 데이터베이스 접근 오류 발생 시 발생한다.\n\n### 런타임 예외 클래스\n\n반면, `RuntimeException`은 개발자의 실수로 인해 발생하는 예외로, 주로 코드의 논리적 오류에서 비롯된다.\n예외처리를 강제하지 않는다.\n\n- `IndexOutOfBoundsException`: 배열이나 리스트의 범위를 벗어났을 때 발생한다.\n- `NullPointerException`: null인 객체에 접근할 때 발생한다.\n- `ArithmeticException`: 숫자를 0으로 나누려 할 때 발생한다.\n- `ClassCastException`: 잘못된 타입 변환 시 발생한다.\n- `ArrayIndexOutOfBoundsException`: 배열의 범위를 넘어선 인덱스를 참조할 때 발생한다.\n- `NumberFormatException`: 정수가 아닌 문자열을 정수로 변환할 때 발생한다.\n\n# Checked Exception과 Unchecked Exception\n\n<hr>\n\n`Exception`은 예외를 처리할지 여부를 강제할지에 따라 `Checked Exception`과 `Unchecked Exception`으로 나눈다.\n간단히 정리하자면 `Checked Exception`은 컴파일 단계에서 검출되는 예외이고, `Unchecked Exception`은 런타임 중에 발생하는 예외를 말한다.\n\n![Exception Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_4.png)\n\n## 코드에서 명시적 예외 처리 유무\n\nChecked Exception와 Unchecked Exception의 차이점은 명시적 예외 처리의 의무 여부이다.\n`Checked Exception`은 컴파일 단계에서 체크하기 때문에 예외처리를 하지 않았다면 컴파일이 진행되지 않는다.\n따라서 `Checked Exception`을 발생시킬 가능성이 있는 메서드라면 반드시 `try-catch`로 감싸거나 `throws`로 예외를 처리해야 한다.\n\n```java\n// try - catch로 예외 처리\npublic static void fileOpen() {\n    try {\n        FileWriter file = new FileWriter(\"data.txt\");\n        file.write(\"Hello World\");\n        file.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n// throws로 예외 처리\npublic static void fileOpen() throws IOException {\n    FileWriter file = new FileWriter(\"data.txt\");\n    file.write(\"Hello World\");\n    file.close();\n}\n```\n\n반면, `Unchecked Exception`는 개발자가 충분히 예방할 수 있는 경우로 명시적인 예외처리가 강제되지 않는다.\n즉, 런타임 시 예외가 발생하더라도, 개발자가 사전에 주의를 기울여 방지할 수 있기 때문에 자바 컴파일러는 예외처리를 필수로 요구하지 않는다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        while (true) {\n            String s = null;\n            s.length(); // NullPointerException 발생 (Unchecked Exception이므로 예외 처리 의무 없음)\n        }\n    }\n}\n```\n\n위 코드는 `NullPointerException`을 발생시키지만, `Unchecked Exception`이기 때문에 `try-catch`로 감싸지 않아도 컴파일 시 오류가 발생하지 않는다.\n프로그램은 예외가 발생해도 오류 로그만 쌓일 뿐, 프로그램 전체가 즉각 종료되는 상황을 초래하지 않는다.\n\n## Checked Exception를 Unchecked Exception로 변환하기\n\n`Checked Exception`은 반드시 `try-catch`로 감싸거나 `throws`로 처리해야 하지만, 모든 코드에서 예외 처리를 강제하는 것은 번거롭고 가독성을 해칠 수 있다.\n이때 `Chained Exception` 기법을 사용해 `Checked Exception`을 `Unchecked Exception`으로 변환하면, 예외 처리를 선택적으로 할 수 있다.\n\n예를 들어, `IOException` 같은 `Checked Exception`을 `RuntimeException`으로 감싸면 `Unchecked Exception`으로 전환되어 컴파일러가 예외 처리를 강제하지 않는다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        install();\n    }\n\n    public static void install() {\n        throw new RuntimeException(new IOException(\"설치할 공간이 부족합니다.\"));\n    }\n}\n```"},{"excerpt":"Spring Data JPA의 Slice & Page 참고 Spring Data JPA의 Slice & Page","fields":{"slug":"/spring-data-jpa-paging/"},"frontmatter":{"date":"October 24, 2024","title":"Spring Data JPA의 Slice & Page","tags":["Java","Spring"]},"rawMarkdownBody":"\n## Spring Data JPA의 Slice & Page\n\n## 참고\n\n- [Spring Data JPA의 Slice & Page](https://dallog.github.io/data-jpa-slice-page/)"},{"excerpt":"면접 체크 객관적이고 정량적 스펙 쌓기? → 하지만 직무와 관련된 경험이 더 중시 된다. 면접 기업에서 신입 채용 단계별 중요 평가요소 응답으로 입사지원서 평가 단계에서는 , ,  이 가장 높았다. 면접 단계에서는 , ,  가 가장 높았다. 여기서 직무 관련 경험이라 함은 고용노동부에서 다음과 같은 활동으로 명시하고 있다. 향후 수행할 직무와 관련한 모든…","fields":{"slug":"/interview/"},"frontmatter":{"date":"October 20, 2024","title":"면접관 사로잡기","tags":["Interview"]},"rawMarkdownBody":"\n## 면접 체크\n\n객관적이고 정량적 스펙 쌓기? → 하지만 직무와 관련된 경험이 더 중시 된다.\n\n면접 기업에서 신입 채용 단계별 중요 평가요소 응답으로 입사지원서 평가 단계에서는 `직무 관련 근무 경험`, `전공의 직무 관련성`, `최종학력` 이 가장 높았다. 면접 단계에서는 `직무 관련 근무 경험`, `인성/예의`, `업무이해도` 가 가장 높았다.\n\n> 여기서 직무 관련 경험이라 함은 고용노동부에서 다음과 같은 활동으로 명시하고 있다.\n>\n> - 향후 수행할 직무와 관련한 모든 경험\n> - 프로젝트 및 실습 경험, 스터디, 교육, 연수 등 포함\n\n반면, 신입 채용 시 우선순위가 낮은 평가요소는 `봉사활동`, `아르바이트`, `공모전`, `어학연수` 가 있었다.\n\n## 면접의 중요성\n\n- 취업을 위해 넘어야 할 최종 관문\n- 면접 비중이 점점 높아지고 있음\n- 면접관은 지원자의 역량을 확인할 수 있는 기회\n- 지원자는 자신의 역량을 보여줄 수 있는 기회\n\n면접은 자신의 직무상 감정을 드러내는 것이 중요하다. 이는 대기업과 중소기업에 차이가 있다. 보통 대기업은 지원자의 자질 및 능력을 중시하고, 중소기업은 지원자의 장기 근속 의지를 중요하게 본다.\n\n## 역량면접의 이해\n\n역량 면접은 지원자가 이전의 경험에서 수행한 행동을 구체적으로 파악하고 이를 통해 직무에서 요구하는 역량을 갖추고 있는지 평가 면접 방법이다. 이로 인해 역량 면접은 지원자의 의견 및 주장 보다는 과거의 행동에 대해 질문을 한다. 즉 한마디로 지원자의 행동을 평가하는 행동중심주의 면접이다. 이를 성공하기 위해서는 지원하는 직무와 회사에 적합한 역량을 구체적으로 제시하는 것이 중요하다. 역량 면접의 방법으로는 경험면접, 상황면접, 발표면접, 토론면접이 있고, AI면접도 일부 기업에서 활용하고 있다.\n\n먼저 직무역량 중심 면접은 회사의 입장에서 생각해야한다. 나의 장점을 직무 내 역량에 어떻게 활용할 수 있는지 스토리 텔링 해야한다. 이를 위해서는 나의 경험에서 내가 수행한 행동을 구체적으로 도출 및 설명 해야한다. 이는 곧 설득력을 가지는 역량의 근거라고 할 수 있다. 취업 준비생의 모든 답변은 주장이다. 하지만 중요한 건 이를 뒷받침하는 근거 즉 경험이다. 단순한 주장 보다는 실제 경험을 직무와 연결하여 내 주장을 펼치는 것이 더 좋을 것이고 이를 위해선 직무에 대한 깊은 이해를 필요로 한다.\n\n## 역량(경험)의 구조화\n\n역량을 명확하고 구체적으로 전달하는 방법은 역량을 구조화해야 한다. 먼저 이를 위해서는 경험의 구조화가 필요하다. 주장한 내용에 대한 해당 경험에 대해 문제 상황에 어떻게 행동하고 결과를 얻었는지 언급함으로써 주장에 대한 근거를 구체적으로 제시할 수 있다. 이후 해당 경험에 대한 느낀 점 및 입사 후 활용 방법에 대해 답하고 마무리 한다. 경험에 대한 답변을 구조화 할 때 STAR 기법을 사용할 수 있다. 이를 사용한 답변은 두괄식으로 시작하여 어떤 경험을 통해 어떤 역량을 형성하고 발휘했는지 주장하는 것이다.\n\n### STAR 기법을 활용한 답변 구조화\n\n경험을 이야기 하는 경우\n\n- 주장\n    - 두괄식 시작 [관련 상황]-[성과]\n- 근거(S+T+A+R)\n    - 어떤 상황, 목표, 문제가 무엇이고 자신의 역할이 무엇인지\n        - Situation(상황)\n            - 어떠한 일을 하게 된 배경과 계기를 설명\n        - Task(직무, 과제)\n            - 목표, 역할, 당면 과제를 설명\n        - Action(행동)\n            - 문제를 해결하기 위해 어떻게 생각하고 행동했는지 설명\n        - Result(결과)\n            - 성과를 이루어 냈는지 설명\n        - Realization(느낀 점)\n            - 어떤 기여를 할 것인지 언급\n    - 목표를 이루고 문제를 해결해 나가는 과정\n\n결론(R+R)\n\n- 자신의 행동을 통해 이루어 낸 성과 및 느낀 점\n\n## AI 면접\n\n기업에서 비대면 면접은 화상면접과 AI면접으로 나눈다. AI면접은 인공지능이 빅데이터를 기반으로 하여 면접자의 답변 내용, 인성 및 적성, 음성, 표정, 어휘 등을 분석하고 평가하는 방식이다. 화상 면접은 장비를 통해 영상으로 지원자가 원하는 장소에서 면접을 진행하고 면접관은 실시간으로 지원자의 역량을 판단할 수 있다. AI면접에서 회사가 파악하고자 하는 요소는 다음과 같다.\n\n- 직무 적합도(73.9%)\n- 인재상(39.1%)\n- 현 재직자의 우수 인재 특성(34.8%)\n- 경영이념(13%)\n- 성장역량(4.3%)\n\nAI 면접 점수가 높은 구직자 특징은 다음과 같다.\n\n- 논리적임(48%)\n- 긴장하지 않음(24%)\n- 정확한 발음(34.8%)\n- 특정 단어를 많이 사용함(4%)\n- 높은 답변 신뢰성(12%)\n- 기타(12%)\n\n→ 대면면접과 동일한 요소를 평가하는 것을 알 수 있다. 즉, 기본에 충실해야 한다.\n\n## 정리 및 요약\n\n역량 면접\n\n- 지원자가 이전의 경험에서 수행한 행동을 구체적으로 파악\n\n  → 직무에서 요구하는 역량을 갖추고 있는지 평가\n\n- 행동중심주의 방식의 면접\n\n  → 직무역량 중심의 면접은 회사의 입장에서 생각하라!\n\n  → 지원자가 해당 직무를 수행하는 데 있어 직무역량을 잘 발휘할 수 있는가?\n\n  → 나의 ‘경험’, 설득력을 가지는 근거는 자신의 역량을 어필하기 위해 중요\n\n- 역량을 명확하고 구체적으로 전달하는 방법\n    - 경험 구조화 → 역량 구조화\n\n      → STAR 기법\n\n- AI 면접\n\n  → 인공지능을 기반으로 하여 면접자의 답변 내용, 인성 및 적성, 음성, 표정 등을 분석하고 평가하는 방식\n\n- 화상 면접\n\n  → 노트북이나 태블릿 PC, 스마트폰 등의 장비를 통해 영상으로 지원자가 원하는 장소에서 일대일 또는 다수의 면접관과 질의응답하는 면접\n\n\n---\n\n# 면접답변 전략\n\n- 면접에서의 주요 질문과 의도를 이해하고 면접 관련 주요 질문에 대해 논리적이고 효과적으로 답변하여 역량면접에서 자신의 경험과 역량을 도출하여 답변능력을 강화할 수 있어야 한다.\n\n## 면접 빈출 질문 및 가이드\n\n### 면접관의 고민\n\n- 기업의 인재상과 직무의 특성에 적합한 인재선발을 위해 어떤 질문을 던질 것인가?\n\n### 지원 기업(산업)에 관련된 질문 : 지원동기 및 입사 후 포부\n\n- 회사에 지원한 동기는 무엇인가요?\n- 직무에 지원한 이유가 무엇인가요?\n- 우리 회사의 인재상 중 본인에게 부합한다고 생각하는 점은 무엇인가요?\n- 입사 후 본인이 이루고 싶은 꿈은 무엇인가요?\n- 입사 후 10년 뒤의 모습을 설명해 보세요\n- 해당 산업의 성장성에 대한 의견을 이야기해 보세요\n- 우리 회사 제품에 대해 아는 대로 이야기해 보세요\n- 우리 회사의 사업분야에 대해 아는대로 설명해 보세요\n\n→ 지원 기업 또는 직무에 대한 이해도나 열정을 보기 위한 질문\n\n→ 회사에 대하 알고 있는 것\n\n→ 기업 및 산업분석을 통해 조사했던 내용\n\n→ 회사에 대한 관심 및 충성심 어필을 하고 관련 경험 혹은 기업/산업분석을 활용하여 회사에 기여할 점을 어필해야 한다. 또한 기업/산업/직무분석 활용을 하여 산업에 대한 이슈 트렌드를 파악해서 답변해야 한다.\n\n### 직무 적합도 및 관심도\n\n- 지원한 직무에서 가장 필요한 것 (역량)이 무엇이라고 생각합니까?\n- 본인은 해당분야에 지원하기 위해 어떠한 노력을 하셨나요?\n- 직무를 수행하기 위한 남다른 본인의 강점이 있다면 무엇입니까?\n- 직무를 수행하는데 있어서 예상되는 어려움은 무엇이라고 생각하나요?\n\n→ 직무에 대한 이해 및 직무에 적합한 주요 역량 보유 여부 확인\n\n→ 그러므로 채용공고, 현직자 인터뷰, 기업의 홈페이지 등을 활용하여 지원 분야의 직무/역량 분석을 명확히 해야한다.\n\n→ 산업/회사/직무에 대한 이해 및 통찰력을 어필, 산업/기업/직무 분석활용, 뉴스. 관련 통계 등 학습 등을 하여 요구 역량에 대한 경험을 포함한 답변을 준비해야 한다.\n\n### 지원자 특성 : 경험질문(BEI)\n\n- 본인의 장단점을 이야기해 보세요\n- 본인의 가치관에 대해 말해보고, 그 가치관이 당사에 어떻게 발휘 될 것인지 설명해 보세요.\n- 새로운 아이디어를 적용해 문제해결을 한 경험을 이야기해 보세요.\n- 집단의 공동목표 달성을 위해 기여한 경험을 이야기해 보세요.\n- 본인이 학교, 전 직장에서 동료 간의 갈등을 해결한 경험이 있나요?\n\n→ 이는 업무에 대한 이해도, 이와 연관된 개인의 특성을 묻는 질문이다.\n\n→ 본인의 성격, 역량, 가치관의 활용 방안 준비\n\n→ 직무/조직 역량을 어필하고 과거 실행한 구체적인 행동지표를 제시하여 경험정리를 통해 도출된 역량 어필해야 한다.\n\n→ 기업이 요구하는 주여 역량은 문제해결 능력, 의사소통 능력, 목표달성 능력, 갈등관리 능력, 협업능력이 있다.\n\n→ “마지막으로 하고 싶은 말을 해보세요.”, “마지막으로 질문을 해보세요.” 같은 마지막 말에서는 직무/조직 역량 어필 그리고 중요 강점 재강조 혹은 부족했던 부분 보충을 하고 산업/회사/직무에 대한 통찰력을 어필 할 수 있다.\n\n→ 이러한 질문 의도는 지원자에게 회사 및 직무에 대한 적합한 역량이 있는지 그리고 우리 회사에 대한 입사 의지 및 기여할 역량이 있는지 파악하기 위한 질문이다.\n\n→ 따라서 지원한 기업의 주요 산업분야가 무엇인지 그리고 해당 직무에서는 어떤 일을 하고 있는지 이해해야하고 이를 통해 산업/회사직무 분석을 통한 필요 역량에 대한 구체적이고 명확한 답변을 해야한다.\n\n→ 최근에는 기업의 홈페이지나 블로그, 유튜브등을 활용하는 방안이 있다.\n\n## 면접 답변 전략\n\n### 1분 자기소개\n\n1분 자기소개는 면접관과 마주하는 첫 시간으로 대체로 가장 처음 받게 되는 질문이며, 면접의 첫인상을 결정한다.\n\n→ 긍정적이고 호감가는 이미지 구축을 필요로 한다.\n\n1분 자기소개 내용구성은 자기소개서 기반으로 전공 어필 및 조직 적합성을 나타내는 스토리나 행동 등 여러가지가 있다.\n\n- 자기소개서를 기반\n- 나만의 스토리나 표현, 행동력을 반영\n- 기업의 인재상과 핵심가치를 나의 가치관과 연결\n- 직무역량 중심 소개\n\n### 1분 자기소개 작성 방법 예시\n\n인사말\n\n- 본인소개(자기만의 캐릭터 생성)\n- 지원직무와 관련된 강점 제시\n- 1~2개 단어로 역량 어필\n\n근거(직무관련 강점에 대한 근거)\n\n- 직무역량을 키우기 위한 나의 노력 및 성과, 전공역량, 직무경험\n- 너무 길지 않아야 한다.\n\n마무리 인사말\n\n- 회사에 어떻게 기여할 것인지\n- 포부\n- 감사인사말\n\n> 인사말\n>\n>\n> <aside>\n>\n> 안녕하십니까. 홍보마케팅 지원자 한고용입니다. 저는 다양한 디지털 식품업계 홍보 콘텐츠를 제작하면서 홍보팀에 필요한 전문성을 키웠습니다. 콘텐츠 인턴시절, 보도자료를 기반으로 식품 기사를 매일 작성하고 제품 홍보 카드뉴스를 만들었습니다.\n>\n> </aside>\n>\n> 근거\n>\n> <aside>\n>\n> 그 중 도라지건강제품을 개발한 청년 농부 인터뷰 기사는 네이버 FARM판에 노출된 날, 하루에 약 450만 원의 매출을 거뒀습니다. 여기서 더 나아가 마케팅 팀에 이벤트를 제안하고, 도라지에 대한 정보성 카드뉴스도 만들어 매출을 추가로 올렸습니다. 또한 미식 지식과 재미를 모두 잡은 식품 홍보 영상을 기획해 FARM TV 채널을활성화 했습니다.\n>\n> </aside>\n>\n> 마무리 인사\n>\n> <aside>\n>\n> 최근 SNS의 활성화에 따라 전통적인 매체 위주의 홍보 보다는 디지털 마케팅 기반의 홍보가 중요해지고 있습니다. 기사작성, 카드뉴스 제작외에 영상 제작능력도 갖춘 저는, 디지털 홍보 컨텐츠의 풀을 확장하는데 기여하겠습니다. 감사합니다.\n>\n> </aside>\n>\n\n### 스스로 높은 목표를 세워 시도했던 경험\n\n스스로 높은 목표를 세워 시도했던 경험에 대해 질문을 할 수 도 있다. 이때 질문의 의도는 지원자가 극복하기 위해 끊임없는 노력을 하는지, 적극적이고 주체적으로 상황을 해결 하는지에 대한 역량을 파악하고자 하는 의도이다.\n\n답변가이드는 다음과 같다.\n\n| 주장 | 도전 경험 / 열정 경험 | 대학교 3학년 때 9개월 간 취업관련 유튜브 채널을 개설해 3개월 만에 약 5만 분 이상의 영상을 제작한 경험이 있습니다.”\n→ 이떄 두괄식으로 전달하고자 하는 역량 제시를 해야한다. |\n| --- | --- | --- |\n| 근거 | 도전했던 상황과 장애 요인을 극복한 행동, 행동에 따른 결과\n→ S 도전목표\n→ T 장애극복 : 장애를 극복하기 위한\n→ A 행동 : 행동(Action)을 구체적으로 설명\n→ R 결과 | `시청시간 5천 분 이상의 영상제작목표를 가지고(높은 목표)`, 기획부터 운영까지 매 단계에서의 매뉴얼을 스스로 만들고, 또 그 과정에서 발생한 모든 시행착오에 대해 직접 대처를 해야 했습니다.\n\n저는 대다수의 다른 유튜브 채널처럼 자극적이고 단순히 재미만 추구하는 콘텐츠 대신, 기업의 CSV 활동처럼 다른 사람에게 도움이 되는 콘텐츠를 제작하고 싶었습니다. `그래서 저는 커리어를 주제로 유튜브 채널을 개설했습니다. 하지만 유튜브 채널은 기대만큼 빠르게 성장하지 않았고(어려움 발생)` 그래서 저는 `000의 실패의 원인을 분석했습니다. 분석을 포스트를 추가로 운영해 홍보에 힘썼습니다.(어려움 극복을 위한 행동)`\n\n그 결과, 저는 유튜브 채널을 개설한 지 3개월 만에 약 5만분 이상의 시간 영상을 다수 제작했습니다.\n\n→ 자신의 행동에서 열정, 끈기, 문제해결의 역량 등을 제시 |\n| 강조 | 배운 점 | 이를 통해 저는 000 한다는 점을 배웠습니다.\n\n→ 지원 직무에 대한 목표달성 능력 발휘 방법 |\n\n### 본인의 강점은 무엇인가요?\n\n- 질문의 의도는 입사 후 주어진 업무를 잘 해낼 수 있는 적합한 장점(강점 or 성격)인지 파악하는 질문이다.\n\n답변 가이드는 다음과 같다.\n\n| 주장\n→ 주어진 주제에 대한 주장 | 지원하는 산업(기업)의 직무에 적합한 강점에 대한 주장 | 저의 장점은 어떤 일이든 솔선수범합니다. |\n| --- | --- | --- |\n| 근거\n→ 뒷받침 하는 구체적인 근거 | 본인의 강점이 발휘된 경험들(실제 사례) | 영화관에서 아르바이트를 할 때에 일정관리의 경우는 매니저 님께서 관리하셨는데 신입 매니저 님이 오셔서 미처 아르바이트생들의 스케줄 관리 부분을 꼼꼼히 해주지 못했습니다.\n`이때 제가 먼저 매니저님을 도와 동료 아르바이트생들의 스케줄 관리를 맡아 업무 일정에 차질이 없도록 했습니다.(직무에 맞는 강점 어필)` 그 덕분에 매니저 님도 업무에 빨리 적응 할 수 있었고, 동료들도 저의 솔선수범에 고마워 하는 마음을 전해주어 뿌듯하기도 했습니다. |\n| 강조 | 입사 후 포부 | `입사 후 저의 장점을 더 살려서 000을 하는데 기여하겠습니다.(포부 제시)` |\n\n### 우리회사를 지원한 동기가 무엇인가요?\n\n- 질문의 의도는 그동안 우리 회사에 관심을 가지고 입사를 위해 노력해 왔는지 그리고 우리회사에 얼마나 오래 다닐 수 있는 끈기가 있는지, 지원한 직무를 잘 수행할 수 있는지에 대해 판단할 수 있는 질문이다.\n\n답변 가이드는 다음과 같다.\n\n| 주장\n→ 지원동기 | - 직무 목표이자 기여점 제시\n- 하고 싶은 일, 관심을 가지게 된 계기\n- 산업 및 기업분석을 활용한 회사 지원동기 | `00기업이 00분야의 해외진출에 가장 앞서가는 기업이라고 생각했기 때문에 지원했습니다.(지원동기 제시)` |\n  | --- | --- | --- |\n  | 근거\n  → 뒷받침하는 구체적인 근거 | - 노력의 근거 및 관련 경험 제시\n- 구체적인 업무 전문성을 키우기 위한 노력\n- 잘 할 수 있는 이유(KSA), 준비한 내용과 근거 제시 | 저는 00분야에서의 전문가를 꿈꾸고 있고, 00분야는 특히 해외시장에서 비전이 있다고 생각하고 있습니다. `그래서 저는 이 직무에 대한 전문성을 갖추고 해외에 대한 이해를 넓혀가기 위해 관련 분야에 대한 스크랩을 꾸준히 하고 있습니다.(기여점 제시)` 00기업은 다른 기업에 비해 00분야에 대한 해외진출에 큰 관심을 갖고 투자하고 있는 것을 알고 있어 00기업에 곡 입사하고 싶었습니다.\n  -중략- |\n  | 강조 | 자신이 기업에 기여할 수 있는 역량(앞으로의 다짐) | 000 하는데 기여하는 인재가 되겠습니다. |\n\n## 면접 질문의 구조화\n\n### 입사지원서 정보의 면접에서의 활용\n\n- 지원 부문 → 해당 부문 및 직무 지원 이유\n- 학력 및 교육사항 → 전공과 직무와의 관련성 → 직무에 필요한 직무성 → 전공 지식 질문\n- 학점 → 전공역량 및 성실도 등과 같은 조직력 판단 → 학업기간이 길거나 공백잉 있는 경우 그 기간에 대한 이유와 활동에 대한 질문\n- 자격증 → 자격증을 취득한 이유 및 자격증 활용도 → 자격증이 없거나 지원직무와 연관성이 없을 경우 압박 질문이 주어지는 경우도 많음\n- 어학 점수 → 영어질문을 통해 회화 실력 검증 → 어학 실력에 따른 관련 역량들에 대한 추가 질문\n- 경력 및 경험 → 지원자의 직무 적합성과 조직 적합성을 판단하기 위한 질문\n\n### 면접 예상 질문 도출 및 답변 작성\n\n- 질문리스트 준비 → 답변 키워드 정리 → 대표경험 구체화(유사경험 정리) → 꼬리물기 질문 준비하기\n- 질문리스트 준비\n\n  → 1분 자기소개, 이력서+자소서 내용을 바탕으로 부정적인 질문과 긍정적인 질문(압박질문)으로 구분하여 준비합니다. 다음으로 답변 키워드를 정리\n\n- 답변 키워드 정리\n\n  → 키워드를 문장으로 정리하는데, 결론 키워드와 자신의 구체적인 행동에 기반한 근거 관련 키워드로 정리\n\n- 대표경험 구체화(유사경험 정리)\n\n  → 대표경험을 구체화하여 질문에 맞게 답변을 하는 데 이 때에는 반드시 키워드를 포함시켜야 한다\n\n  → 이러한 경험들을 구체화시켜 유사한 질문을 받았을 때 대표경험을 활용할 수 있다\n\n- 꼬리물기 질문 준비하기\n\n  → 꼬리물기 질문은 직무관점과 인성관점의 꼬리물기 질문으로 구분하여 준비\n\n  > `면접관`: 서비스 계열 쪽 알바를 많이 했는데 이 중 가장 어려웠던 것은 무엇입니까?\n  `지원자`: 가장 처음에 했던 예식장 아르바이트였습니다. 고객분들을 상대하면서 가장 어려움을 느꼈습니다. 일례로 고객분들이 원래 규정과 어긋나는 부탁을 하시는 경우들이 종종 있습니다. 이런 것들을 잘 대처하는 것이 가장 어려웠던 것 같습니다.\n  `면접관`: 고객이라고 하면 하객을 말하는지? 신랑 신부를 말하는 건지?\n  `지원자`: 하객분들도 부탁을 하는 경우가 많지만 신랑신부 측에서 오는 부탁들도 많았습니다.\n  `면접관`: 그럴 때는 어떻게 하십니까?\n  `지원자`: 처음에는 안된다고 하지만 어느정도 타협이 가능한 선에서 해드리는 경우도 있습니다. 예를들어 화환이 있어야 하는 정해진 장소가 있는데 이를 원하는 장소로 옮겨달라는 요구 같은 경우에는 규정상 원래 안된다는 것을 먼저 알려드린 다음 해드렸습니다. 어느정도 선에서 맞춰 드릴 수 있는 건 해드리지만 아르바이트생 입장에서 관여 못하는 것들이 예를들어 금전적인 것들이나 연회장 관련 요구들은 정중히 들어드릴 수 없어 죄송하다고 말씀드렸습니다.\n  `면접관`: 그럼에도 계속해서 무리한 부탁을 하는 경우가 있었나요? 그런 경우는 어떻게 하셨습니까?\n  `지원자`: 그럴 경우 직원분들께 어떻게 하면 좋을지 여쭤보거나 아니면 고객 분께 우리가 해결 해드릴 수 있는 일이 아니니 금전적인 사항은 예약실 직원분들께 문의 부탁드린다고 말씀드렸습니다.\n>\n\n### 인사담당자 입장에서의 면접 평가요소\n\n- 회사가 지향하는 핵심가치/인재상에 부합한 인재인가?\n- 지원동기, 입사 후 포부 등으로 볼 때 우리 회사에 애정이 있고, 꼭 들어오고 싶어 하는가?\n- 지원자가 입사 후 회사에 기여할 수 있는 인재인가?\n- 역경을 이겨내고 주도적/창의적으로 성과를 이뤄낼 수 있는 인재인가?\n- 조직에서 함께 일하는데 문제가 없고 협업을 통해 성과를 낼 수 있는 인재인가?\n\n## 정리 및 요약\n\n### 지원 기업(산업)에 관련된 질문\n\n지원자의 지원 기업 또는 직무에 대한 이해도나 열정을 보기 위한 질문\n\n- 회사에 대한 관심 및 충성심 어필\n- 기업/산업/직무 분석 활용\n- 산업에 대한 이슈 트렌드 파악\n\n### 직무 적합도 및 관심도에 관한 질문\n\n면접관은 지원자의 직무에 대한 이해도 및 직무에 적합한 역량 보유 유무를 확인하고자 함\n\n- 채용공고, 현직자 인터뷰, 기업의 홈페이지 등을 활용\n- 뉴스, 관련 통계 등 학습\n\n### 지원자 특성: 경험질문(BEI)\n\n지원자의 업무에 대한 이해도와 이와 연관된 개인의 특성을 묻는 질문\n\n→ 본인의 성격, 역량, 가치관의 활용 방법의 인지 필요\n\n- 직무/조직 역량 어필\n- 과거 실행한 구체적인 행동지표 제시\n    - 문제해결능력, 의사소통능력, 목표달성능력, 갈등관리능력, 협업능력 등\n\n### 1분 자기소개 답변 전략\n\n인사말(본인소개) → 근거(직무관련 강점소개에 대한 근거) → 마무리 인사말(회사에 기여 및 포부)\n\n### 스스로 높은 목표를 세워 시도했던 경험\n\n지원자가 목표 달성을 위해 끊임없이 노력하는지, 이때 적극적/주체적으로 대응하는지에 대한 역량 파악\n\n- 주장: 도전경험 및 열정경험을 두괄식으로 작성\n- 근거: 주장에 대한 근거로 행동을 구체적으로 설명\n- 강조: 경험을 통해 배운 점\n\n### 본인의 강점은 무엇인가요?\n\n입사 후 주어진 업무를 잘 해낼 수 있는 적합한 장점(강점 or 성격) 여부 파악\n\n- 주장: 지원하는 산업(기업)의 직무에 적합한 강점에 대한 주장\n- 근거: 주장에 대한 근거 즉 본인의 강점이 발휘된 경험들(실제 사례)\n- 강조: 강점을 발휘한 입사 후 포부\n\n### 우리회사를 지원한 동기가 무엇인가요?\n\n지원하는 기업에 대한 지원자의 관심도 파악\n\n- 주장: 직무 목표 및 기여점을 제시하고 싶은 일, 관심을 가지게 된 계기, 산업 및 기업분석을 활용한 회사 지원동기\n- 근거: 주장에 대한 근거로 노력의 근거 및 관련 실제 경험 제시\n- 강조: 자신이 기업에 기여할 수 있는 역량\n\n### 채용자의 관점에서 어떻게 질문을 만들 것인가?\n\n- 입사지원서 및 자기소개서 바탕의 면접질문 작성 및 예상 답변 마련\n- 입사지원서에 작성된 정보는 서류 및 면접전형에서 중요한 자료로 활용\n\n## 면접 사례를 통해 알아보는 답변 전략 Q＆A\n\n### 면접 Q&A를 통해 알아보는 답변가이드\n\n재지원의 이유로 지원자에게 불이익을 주지는 않음 → 오히려 긍정적\n\n→ 입사의 의지가 강하고 오래 다닐 것 같다는 생각을 준다\n\n→ 소신있는 태도로 보일 수 있다\n\n→ 지난번 불합격한 요인을 분석하고 부족한 점을 개선했겠다라는 기대를 줄 수 있다.\n\n→ 명확하게 개선된 부분 강조 필요\n\n재지원 관련 면접 질문 대비\n\n- 소신있는 재지원 사유\n- 재지원 시 스펙업된 내용\n    - 불합격 이후 개선사항\n    - 경험 및 준비사항\n- 자격증 취득 사항\n- 불합격 이후 개선을 위한 노력\n- 해당 직무와의 정합성\n\n생각보다 지원자의 공백기에 대해 큰 관심을 기울이지 않는다. 다만 왜 공백기를 가지게 되었고, 공백기 동안의 무슨 활동을 했는지 질문을 할 수 있다.\n\n- 공백기간에 따라 다른 답변 전략이 있다.\n    - 1년 미만의 공백기 → 크게 문제되지 않음 → 부족한 점을 보완하기 위한 노력을 답할 순 있어야한다.\n        - 영업지원 또는 영업직 직원 → 아르바이트 경험과 직무연결\n        - 대형마트 판매 아르바이트 경험 → 손님응대 시, 돌발상황에 대처한 경험 어필\n        - 한 분야에서 장기간 아르바이트를 한 경우 → 책임감과 끈기 어필\n    - 1년 이상의 공백기\n        - 단순 입사 지원과 불합격의 반복으로 설명하기 어려우므로 철저한 답변 준비 필요\n        - 해당 기간 동안 공부한 것들\n        - 공백을 가질 수 밖에 없었던 특별한 사정\n        - 경험 및 경험 분석을 통해 얻은 점\n        - 지원 직무에 도움이 되는 부분\n    - 공백 사유를 잘 정리하여 현명하게 답변하기\n    - 지원자를 압박하거나 약점을 잡기 위한 것이 아니라 대부분 호기심에 의한 질문임을 기억하기\n- 직무 관련 경험\n    - 직무 성격에 따라 준비가 필요한 직무도 있음\n        - 회계직무 → 회계재무 기본과목 수강\n        - 엔지니어 기술직 → 전공 지식\n        - 디자이너 직무 → 포트폴리오 등\n\n      → 직무에 따른 역량 필요\n\n- 직무에 대한 단계적/지속적인 학습이 필요\n    - 지원 직무에 대한 기본적인 업무내용\n    - 각 업무의 기능과 역할\n    - 여러 업무들 간의 연관성\n    - 여러 업무들 간의 연관성\n    - 업무 관련 실제 사례\n    - 관련 분야의 주요 이슈와 발전 방향\n    - 업무 방식, 목표, 고객, 동료가 될 사람들의 특성, 기술 등\n\n  → 전문가로서 성장 가능성 인정\n\n- 직무 관련 경험이 없는 경우 `인턴과 같은 직무경험은 없지만 시켜만 주신다면 무엇이든 잘해 낼 자신 있습니다` 나 `무조건 열심히 하겠습니다` 같은 추상적인 답변을 절대 하면 안된다.\n\n### 10년 후의 모습에 대한 질문을 통해 확인하고자 하는 상황\n\n- 지원자가 꿈꾸는 목표가 발전적, 구체적인가?\n- 회사의 추구 방향과 지원자의 미래가 매칭되는가?\n- 얼마나 우리 회사에 관심이 있는가?\n\n→ 기업에 대한 `관심 및 직무 이해도, 열정`을 파악하기 위한 질문\n\n좋지 않은 답변\n\n- `입사 후 1년간 적응하고, 신입사원으로서 하나씩 배워나가겠습니다. 입사 후 5년째에는 해당직무에 전문가가 되어...`\n\n  → 연도별 나열 또는 직책을 언급하는 경우\n\n- `입사하면 업무를 배움과 동시에 영어 공부를 게을리하지 않겠습니다. 꾸준한 영어 공부를 통해 회사의 해외진출에 도움이 되겠습니다. 이후에는 자격증을 공부하고 대학원까지 진학하여 해당분야의 전문가가 되겠습니다.`\n\n  → 공부하겠다는 답변\n\n\n→ 입사 후 포부 예시(직무: 네트웍스 UI/UX)\n\n<aside>\n\n입사 후 저는 플랫폼에서 발견되는 문제점을 개선해가며 회사 발전에 기여하고 싶습니다. 우선 모바일 앱 내 정보구조를 재설계하고자 합니다. 저는 경영학회에서 활동하면서 리서치를 통해 고객의 특성, 니즈를 파악하고 문제점을 분석하여, 이를 토대로 인사이트를 도출하거나 고객 맞춤 경영 전략을 기획하는 일련의 활동을 한 경험이 있습니다. 이러한 경험을 토대로 고객 행동 데이터에 기반하여 논리적인 UI/UX 디자인을 설계하는 데에 기여하고자 합니다.\n\n또한 디자인 분야의 감각적인 센스와 서비스를 바라보는 비즈니스 관점을 토대로 빠르게 회사 업무에 적응하여 고객의 성공을 견인하고 사회의 행복을 선도하는 00네트웍스를 만들어 가는데 기여하고 싶습니다.\n\n</aside>\n\n→ 면접 시 단점을 물어보면 뭐라고 답변\n\n치명적인 답변을 하지 말라고 하는데 그럼 평범한 단점은 어떤 것이 있나요? 자신의 단점을 객관적인 시각으로 파악하고 있는지 알아보기 위한 질문이다\n\n→ 이를 통해 취약한 상황에 처했을 때 어떻게 극복해 나갈 것인지에 대해 검증할 수 있다.\n\n→ 두루뭉술한 단점 대신, 솔직하게 단점 하나를 인정하고 이를 극복했던 경험을 어필\n\n→ 단점을 듣고 면접관은 때때로 ”진짜 단점 맞아요?“, ”이런 거 말고 진짜 단점을 말해보세요.“라고 꼬리질문을 하기도 한다.\n\n→ 지원자 입장에서는 난처한 질문이기 때문에 많은 지원자들은 최대한 자신의 단점을 포장하여 스스로 변호하는 방법을 선택하게 된다.\n\n→ 이렇게 스스로의 단점을 포장하는 방법으로 흔히 하는 실수는 단점을 장점처럼 포장해서 결론을 맺는 것입니다.\n\n→ 충분히 이해할 수 있는 단점 제시\n\n→ 단점을 극복한 실제 사례와 실천 노력 소개\n\n단점을 찾아 극복할 수 있는 성실성과 적극성 어필이 필요\n\n- 지원 분야에서 피해야 할 치명적 단점을 언급해서는 안된다\n    - 사람을 많이 만나는 경우\n        - 저는 낯을 많이 가린다는 것이 단점입니다.\n\n### **모르는 질문에 대한 대처**\n\n모르는 질문이 나왔을 때는 내용을 추측하고 만들어 답변하기보다 솔직히 인정하는 것이 필요하다\n\n- **즉흥적인 추측은 금물**: 모르는 질문이 나왔을 때 억지로 답변을 만들어내거나 추측하는 것은 피해야 한다. 면접관은 지원자의 솔직함과 판단력을 중요하게 평가한다.\n- **부족함을 인정하되 성장을 다짐**: “모르는 부분입니다”라고 단순하게 답변을 끝내는 대신, 부족한 부분을 솔직하게 인정하면서도 관련된 공부나 경험을 통해 더 나아가고자 하는 의지를 보여줘야 한다. 예를 들어, **“저는 이 부분에 대해서는 아직 깊게 공부하지 못했지만, 앞으로 더 깊이 배우고 싶습니다”** 같은 답변이 적절하다.\n- **면접 준비의 과정 언급**: 이 질문과 관련된 준비 과정을 언급하면서, 단순한 무지가 아니라 어느 정도 기초 지식이 있다는 것을 표현할 수 있다. 예를 들어, **“이와 관련된 자료는 공부했지만, 그 세부 사항에 대해서는 아직 숙지하지 못했습니다”**라고 말할 수 있다.\n- **시간 요청**: 답변이 바로 떠오르지 않을 경우, 면접관에게 잠시 시간을 달라고 요청하는 것도 좋은 방법이다. “면접관님, 잠깐 생각할 시간을 주실 수 있겠습니까?”라고 정중하게 말하면, 면접관도 성급한 답변을 피하고 차분히 생각하는 지원자의 성숙한 태도를 평가할 수 있다.\n- **질문 명확히 하기**: 질문을 이해하지 못했을 경우, 바로 포기하거나 혼란스러워하는 대신, 질문을 명확하게 다시 물어보는 것이 중요하다. 예를 들어, **“죄송하지만, 그 부분에 대해 조금 더 설명해 주실 수 있을까요?”**라고 요청하는 것이 좋다. 하지만 **“뭐라고요?”** 같은 표현은 피해야 하며, 정중한 태도를 유지해야 한다.\n\n### **면접에서 흔히 하는 실수와 그에 대한 대처법**\n\n면접에서 지원자들이 자주 범하는 실수를 피하는 것이 중요하다:\n\n- **전문적이지 못한 말투**: “네, 잘 모르겠어요”와 같은 비격식적인 말투는 피하고, **“이 부분에 대해 좀 더 공부해 보겠습니다”**처럼 격식 있는 표현을 사용하는 것이 좋다.\n- **회사와 직무에 대한 이해 부족**: 단순히 자신의 경험을 나열하기보다는, 그 경험이 지원하는 직무에 어떻게 연결되는지를 명확히 설명해야 한다. 예를 들어, **“저의 이전 프로젝트 경험이 귀사의 [직무명]에 어떻게 도움이 될 수 있는지 설명드리겠습니다”**라고 말하며 경험을 직무에 맞게 어필해야 한다.\n- **‘예/아니오’ 대답과 수동적 태도**: 질문에 단순히 “예” 또는 “아니오”로 답변하고 더 이상 부연 설명을 하지 않는 것은 소극적인 태도로 보일 수 있다. 질문에 대한 자신의 견해를 덧붙여 적극적인 태도를 보여야 한다. **“네, 그 부분에 동의하며, 제가 했던 경험 중 하나는...”**처럼 답변을 이어가는 방식이 좋다.\n- **단순히 배우고 싶다는 답변**: 면접에서 “배우고 싶다”는 답변만으로는 부족하다. 구체적으로 **어떤 부분에서 어떤 성과를 내고 싶은지**를 언급해야 한다. **“이 직무에서 저는 [특정 기술]을 활용하여 [목표]를 달성하고자 합니다”**와 같이 구체적인 목표를 제시하는 것이 좋다.\n- **외운 답변처럼 보이는 답변**: 외운 듯한 답변은 오히려 준비가 덜 된 인상을 줄 수 있다. 질문에 맞추어 자연스럽게 답변을 구조화하는 것이 중요하다. 질문에 맞추어 적절한 예시와 경험을 끌어와 유연하게 대답하는 연습이 필요하다.\n\n### **면접을 잘 봤다고 느꼈는데 결과가 좋지 않은 경우**\n\n면접을 잘 본 것 같은데 결과가 좋지 않다면, 몇 가지 요소를 다시 고려해 봐야 한다:\n\n- **질문에 대한 답변 방식**: 면접관이 원하는 것은 단순한 경험 나열이 아니라 **직무와의 연결성이**다. 지원 직무에 대한 이해 없이 자신의 경험을 나열하기만 했다면, 충분한 어필이 되지 않았을 수 있다. **경험이 직무에 어떻게 기여할 수 있는지**를 연결하는 것이 중요하다.\n- **면접 대기 중의 태도**: 면접 대기실에서의 행동도 중요한 평가 요소가 될 수 있다. 면접 전후의 행동이 면접관이나 다른 직원에게 부정적인 인상을 주었다면, 그것이 탈락의 이유가 될 수도 있다.\n- **복기와 피드백**: 면접을 본 후에는 **자신의 답변과 태도에 대한 복기**가 필요하다. 스스로 질문에 대해 얼마나 적절히 답변했는지, 지나치게 자기 주장만 내세우지 않았는지 등을 점검해야 한다. 또한, 면접관의 질문 의도를 정확히 파악하고 답변했는지 돌아보는 것도 중요하다.\n\n### **서류 준비와 면접의 연계성**\n\n- **서류와 면접은 분리되지 않는다**: 서류에서 면접을 염두에 두고 작성하는 것이 중요하다. 서류에 적은 내용에 대해 면접에서 질문을 받을 가능성이 크기 때문에, 서류를 다시 꼼꼼히 읽어보며 예상 질문을 준비해야 한다. 특히, **서류에 적힌 경험이 직무와 어떻게 연결되는지**를 미리 정리해 두면, 면접에서 당황하지 않고 답변할 수 있다.\n\n### **적극적인 자세**\n\n- 면접에서는 질문에 대해 적극적으로 답변하려는 태도가 중요하다. 모르는 질문이나 준비되지 않은 질문이라도 **성실하게 답변하려는 자세**를 보여야 한다. 또한, 면접관의 질문에 맞추어 답변을 유연하게 전개하는 능력도 필요로 한다. 면접의 핵심은 **나의 강점이 직무에 어떻게 기여할 수 있는지를 어필하는 것이**다.\n\n## 정리 및 요약\n\n### 불합격한 기업에 재지원 시\n\n- 우리회사에 재지원한 이유는?\n- 불합격 이후 현재, 개선된 점은?\n- 그동안 경험하고 준비한 것은?\n    - 재지원 시 스펙업된 내용과 경험, 자격증 취득사항 등을 어필하는 것이 중요\n    - 소신 있는 재지원 사유, 불합격 이후 개선을 위한 노력, 해당 직무와의 적합성 등 적극 어필\n\n### 공백기에 관한 질문\n\n- 직무 관련 준비\n- 자기개발 경험\n\n  → 공백기 중 해당 부분에 대해 잘 설명하는 것이 중요하다\n\n\n### 직무경험이 없는 경우\n\n- 직무를 수행하기 위한 능력을 검증할 수 있는 경험이면 충분함\n    - 기업이 가장 중요하게 평가하는 요인은 직무 관련성이다\n\n### 예상치 못한 질문이나 모르는 질문\n\n모르는것은 솔직하게 인정하는 것이 중요\n\n### 면접에서 왜 불합격했는지 모를 경우\n\n면접 후 면접 복기가 중요함\n\n- 질문에 대한 대답은 적절했는가?\n- 너무 내 입장에서만 이야기한 것은 아닌가?\n- 맞지 않는 나의 주장을 너무 강하게 어필한 것은 아닌가?\n\n→ 면접 질문, 나의 답변 등을 정리하고 수정 방안을 찾는 것이 다음 면접을 위해 중요하다."},{"excerpt":"협업 프로젝트를 진행하면서 항상 처음 고민하는 것 중 하나가 Git 컨벤션일 것이다.\n이 글에서는 협업을 하면서 굳혀진 컨벤션들을 공유하며 이 부분에 대해서 고민하는 개발자들에게 도움이 되길 바란다.\n참고로 이 글은 개인적인 경험과 다른 개발자들의 컨벤션을 참고하여 작성되었다.\n또한 지라의 티켓팅 방식을 사용하지 않는 다는 가정하에 작성했다. Git br…","fields":{"slug":"/git-conventions/"},"frontmatter":{"date":"October 15, 2024","title":"협업을 위한 Git 컨벤션","tags":["Git"]},"rawMarkdownBody":"\n협업 프로젝트를 진행하면서 항상 처음 고민하는 것 중 하나가 Git 컨벤션일 것이다.\n이 글에서는 협업을 하면서 굳혀진 컨벤션들을 공유하며 이 부분에 대해서 고민하는 개발자들에게 도움이 되길 바란다.\n참고로 이 글은 개인적인 경험과 다른 개발자들의 컨벤션을 참고하여 작성되었다.\n또한 지라의 티켓팅 방식을 사용하지 않는 다는 가정하에 작성했다.\n\n## Git branching model\n\n깃 브랜칭 전략은 다양한 방법이 있지만, \n아래 링크는 유명한 깃 브랜칭 전략 중 하나인 `git-flow` 전략이다.\n많은 프로젝트에서 사용되는 전략이므로 참고하면 좋을 것이다.\n\n[Successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)\n\n## Git commit convention\n\n```markdown\n<type>(<issue number>): <short summary>\n\n<optional detailed description>\n```\n\n- `type`은 아래와 같이 정의할 수 있다.\n  - `feat`: 새로운 기능 추가\n  - `fix`: 버그 수정\n  - `docs`: 문서 수정\n  - `refactor`: 리팩토링 (기능 변경 없이 코드 개선)\n  - `test`: 테스트 코드 추가/수정\n  - `chore`: 빌드 관련 수정\n  - `ci`: CI/CD 관련 수정\n  - `revert`: 커밋 되돌리기\n\n- `issue number`는 이슈 번호로 깃허브에서 이슈를 생성할 때 부여되는 번호를 의미한다.\n\n- `short summary`는 커밋의 간단한 요약이다. 커밋 메시지의 첫 줄은 50자 이내로 작성하는 것이 좋다.\n\n- `optional detailed description`은 커밋의 상세한 내용을 작성한다.\n\n참고한 링크들은 아래와 같다.\n더 자세한 내용을 알고 싶다면 맨 아래 링크를 참고하면 좋을 것이다.\n다음 섹션들에 대한 참고 링크도 같은 위치해 있으니 참고하길 바란다.\n\n## Git branch convention\n\n```markdown\n<type>/<issue-number>-<short-description>\n```\n\n브랜치 이름에 `issue-number`를 넣은 이유는 어떤 이슈에 대한 작업인지 명확하게 표현하는 것이 좋다고 생각해서 추가했지만,\n이 또한 입맛대로 수정해도 되는 부분일 것이다.\n\n- type\n    - `feature/`: 새로운 기능 개발\n    - `fix/`: 버그 수정\n    - `hotfix/`: 긴급 수정\n    - `test/`: 테스트 관련\n    - `chore/`: 기타 작업\n    - `docs/`: 문서 작업\n\n## Label\n\n![img.png](img.png)\n\n라벨은 위의 이미지처럼 해도 되고 현재 프로젝트 상황에 맞는 라벨 전략을 도입하면 좋을 것이다. \n\n```markdown\n<type><status><priority>\n```\n\n- type\n    - `bug`: 버그 수정\n    - `hotfix`: 긴급 수정\n    - `chore`: 빌드 설정\n    - `refactor`: 코드 개선\n    - `test`: 테스트 코드\n    - `documentation`: 문서 변경\n    - `feature`: 기능 추가\n    - `enhancement`: 기능 개선\n\n- status\n    - `status: done`: 완료됨\n    - `status: review`: 코드 리뷰 중\n    - `status: in progress`: 진행 중\n    - `status: backlog`: 대기 중\n\n- priority\n    - `priority: high`: 높은 우선 순위\n    - `priority: medium`: 보통 우선 순위\n    - `priority: low`: 낮은 우선 순위\n\n## Issue template\n\n```markdown\n[<type>] <short-description>\n```\n\n- type\n    - `Bug`: 버그 수정\n    - `Feature`: 기능 추가\n    - `Fix`: 기존 기능의 오류 수정\n    - `Refactor`: 리팩토링\n    - `Docs`: 문서 변경\n    - `Chore`: CI/CD, 빌드 수정\n    - `Test`: 테스트 코드\n\n본문은 아래와 같다.\n\n```markdown\n## 개요\n<!-- 내용을 간략하게 설명 -->\n\n## 상세 설명\n<!-- 작업한 내용을 설명 -->\n\n## 작업 내용\n- [ ] TODO\n- [ ] TODO\n- [ ] TODO\n\n## 참고 사항(선택)\n<!-- 추가적으로 공유할 내용 -->\n```\n\n## Pull request template\n\n```markdown\n[<type>] <issue-number>-<short-description>\n```\n\n- type\n  - `Bug`: 버그 수정\n  - `Feature`: 기능 추가\n  - `Fix`: 기존 기능의 오류 수정\n  - `Refactor`: 리팩토링\n  - `Docs`: 문서 변경\n  - `Chore`: CI/CD, 빌드 수정\n  - `Test`: 테스트 코드\n\n본문은 아래와 같다.\n\n```markdown\n## 개요\n<!-- 내용을 간략하게 설명 -->\n\n## 작업 내용\n<!-- 작업한 내용을 간략하게 설명 -->\n\n## 관련 이슈\n<!-- 해당 PR이 해결하는 이슈 번호: `#1` -->\n<!-- ex) `#200 (로그인 관련 Issue)` -->\n\n## 참고 사항(선택)\n<!-- 리뷰어가 참고해야 할 사항 -->\n\n<type> <issue-number>, <issue-number>\n-> closes #10\n\n```\n\n마지막에 `Closes #10`과 같이 작성하면 해당 PR이 이슈를 해결했을 때 자동으로 이슈를 닫을 수 있다.\n이 외에도 아래와 같은 키워드를 사용할 수 있다.\n\n- type\n  - `close`\n  - `closes`\n  - `closed`\n  - `fix`\n  - `fixes`\n  - `fixed`\n  - `resolve`\n  - `resolves`\n  - `resolved`\n\n## Bug report template\n\n버그 리포트 템플릿은 이슈 템플릿과 비슷하지만 버그 리포트에 특화된 템플릿을 따로 관리하는 것이 좋다고 생각한다.\n\n```markdown\n[Bug] <short-description>\n```\n\n```markdown\n## 버그 설명\n<!-- 어떤 문제가 발생했는지 간략하게 설명 -->\n\n## 재현 방법\n<!-- Given-When-Then으로 설명 -->\n\n## 예상되는 동작\n<!-- 정상적으로 작동해야 할 동작을 설명 -->\n\n## 관련 이슈\n<!-- 해당 PR이 해결하는 이슈 번호: `#1` -->\n\n## 참고 사항(선택)\n<!-- 추가적으로 공유할 내용 -->\n```\n\n## 참고\n\n[Github PR merge](https://yeoonjae.tistory.com/entry/Project-Github-PR-merge-%EC%8B%9C-issue-%EC%9E%90%EB%8F%99-close-%EB%B0%A9%EB%B2%95)\n\n[Joel Parker Henderson, Git commit message](https://github.com/joelparkerhenderson/git-commit-message/blob/main/README.md)\n\n[Joel Parker Henderson, Git commit template](https://github.com/joelparkerhenderson/git-commit-template/blob/main/git-commit-template.txt)\n\n[Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/)\n\n[qoomon, conventional commits cheatsheet](https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13)\n\n[digitaljhelms, Git/GitHub branching standards & conventions](https://gist.github.com/digitaljhelms/4287848)\n\n[Abhay Amin, Naming conventions for Git Branches — a Cheatsheet](https://medium.com/@abhay.pixolo/naming-conventions-for-git-branches-a-cheatsheet-8549feca2534)\n\n[jpolete, Git Branching Strategy](https://gist.github.com/jpolete/aa31b9043e8e90f8a47c7738669555fa)\n\n[Jack Pritom Soren, GitHub Branching Name Best Practices](https://dev.to/jps27cse/github-branching-name-best-practices-49ei)\n\n[In-Jun Hwang, Git Branch Naming: For Effective Collaboration](https://blog.injun.dev/posts/git-branch-naming-conventions/)\n\n[GitHub Docs, Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels)\n\n[all contributors, Labels](https://github.com/all-contributors/all-contributors/labels?sort=count-desc)\n\n[kentcdodds, Issue Template](https://github.com/kentcdodds/issue-template)\n\n[stevemao, GitHub issue templates](https://github.com/stevemao/github-issue-templates)\n\n[GitHub Docs, Creating a pull request template for your repository](https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/creating-a-pull-request-template-for-your-repository)\n\n[amaran-th, Github Issue & PR Template](https://amaran-th.github.io/Github/%5BGithub%5D%20Issue%20&%20PR%20Template%20%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/)\n\n[GitHub Docs, Linking a pull request to an issue](https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue)\n\n[GitHub Docs, Configuring the template chooser](https://docs.github.com/articles/configuring-issue-templates-for-your-repository#configuring-the-template-chooser)\n\n[lisawolderiksen, Using Git Commit Message Templates to Write Better Commit Messages](https://gist.github.com/lisawolderiksen/a7b99d94c92c6671181611be1641c733)"},{"excerpt":"왜 Nginx를 사용하는가? 먼저, Nginx를 사용하는 이유에 대해 알아보면, SSL 설정, 간단한 응답 체크나, 파일 다운로드, 반환 URL을 Proxy Pass 요구하는 경우,\n이 요청을 자바로 녹여내려면 복잡한 로직이 추가된다.\n하지만 Nginx는 이러한 설정을 간단하게 해준다.\n실제 프록시 패스를 수행할 때 Nginx를 사용하면, 있는 듯 없는 …","fields":{"slug":"/nginx-config/"},"frontmatter":{"date":"July 17, 2024","title":"Nginx 설정하기","tags":["Nginx"]},"rawMarkdownBody":"\n## 왜 Nginx를 사용하는가?\n\n먼저, Nginx를 사용하는 이유에 대해 알아보면, SSL 설정, 간단한 응답 체크나, 파일 다운로드, 반환 URL을 Proxy Pass 요구하는 경우,\n이 요청을 자바로 녹여내려면 복잡한 로직이 추가된다. \n하지만 Nginx는 이러한 설정을 간단하게 해준다.\n실제 프록시 패스를 수행할 때 Nginx를 사용하면, 있는 듯 없는 듯한 속도 차이를 느낄 수 있다.\nNginx를 사용하면 물론 오버헤드가 발생하지만, 이는 Nginx가 주는 편리함을 생각하면 무시할 정도로 성능이 우수하다.\n이정도로 Nginx를 사용하는 이유에 대해 알아보고 이제 Nginx 설정에 대해 알아보자.\n\n## 트렌디한 최신 Nginx 설치\n\n우선, Nginx를 설치해야 한다. Nginx는 다양한 운영체제에서 사용할 수 있지만, 여기서는 Red Hat 기반 Linux를 기준으로 설명한다.\n패키지 설정할 때는 `sudo -u root -i`로 root 권한을 획득하고 진행하는게 좋다.\nRed Hat 기반 Linux 배포판에는 패키지 매니지먼트 툴인 dnf와 yum가 있다.\n여기서는 필자에게 익숙한 yum을 사용한다.\n바로 `yum install nginx`로 Nginx를 설치할 수 있지만, 기존 yum에서 지원하는 패키지 라이브러리는 하위 버전일 가능성이 있다.\n물론 개인 공부나 테스트 목적으로는 문제가 없지만, 실제 서비스에 사용하기에는 고려해봐야한다.\n아무튼 어떻게 설치해야 하냐면 방법이 꽤 있는데, 먼저 Fedora Linux에서 지원하는 `yum install epel-release`를 하면, `yum install nginx`로 Nginx를 설치하면 최신 버전일 가능성이 높아진다.\n다른 방법으로는 [Nginx yum 저장소](https://nginx.org/en/linux_packages.html)를 추가하는 방법이 있다.\n이 방법으로 할 경우 `vi /etc/yum.repos.d/nginx.repo`로 저장소를 추가하고, 아래 내용을 넣어주면 된다.\n\n```bash\n[nginx-stable]\nname=nginx stable repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=1\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n```\n\n이렇게 저장소를 추가하고 `yum install nginx`로 Nginx를 설치하면 위 설정을 참고해서 최신 버전으로 설치한다.\n\n## Nginx 설정\n\n이제 Nginx를 설치했으니, Nginx를 다루는 방법에 대해 알아보자.\n\n### Nginx의 설정 파일\n\n먼저 Nginx 설정 파일에 대해 이해가 필요한데 꽤 복잡하다.\nNginx 설정 파일을 알아보자면, 우선 경로는 `/etc/nginx`에 있다.\n\n- mime.types: Nginx 서버가 처리할 MIME 타입 목록\n- upstream.conf: 로드밸런싱 사용을 위한 여러 서버 그룹을 정의한 설정 파일\n- header.conf: 요청을 다른 서버로 프록시할 때 전달할 헤더 설정 파일\n- ssl.conf: SSL 설정 파일, SSL 인증서 경로 지정\n- ssl-server.conf: SSL 요청(443 포트)에 대한 서버 블록 설정 파일\n- http-server.conf: HTTP 요청(80 포트)에 대한 서버 블록 설정 파일\n- nginx.conf: 모든 설정 파일을 포함하는 Nginx의 메인 설정 파일\n\n#### mime.types\n\nmime.types 파일은 Nginx가 처리할 수 있는 파일 형식(MIME 타입)을 정의한다. \n기본적으로 HTML, CSS, 이미지 파일, JavaScript 등 여러 파일 형식에 대한 MIME 타입을 지정하고 있다.\n전체 파일 형식은 [Nginx mime.types](https://hg.nginx.org/nginx/file/tip/conf/mime.types)에서 확인할 수 있다.\n\n```bash\ntypes {\n    text/html                                        html htm shtml;\n    text/css                                         css;\n    text/xml                                         xml;\n    image/gif                                        gif;\n    image/jpeg                                       jpeg jpg;\n    application/javascript                           js;\n    application/atom+xml                             atom;\n    application/rss+xml                              rss;\n\n    ...\n}\n```\n\n#### upstream.conf\n\nNginx가 요청을 전달할 서버 그룹을 정의하는 파일이다. \n`upstream` 지시어를 사용하여 여러 백엔드 서버를 묶어 로드 밸런싱을 할 수 있고, `keepalive`를 사용하여 연결을 재활용할 수 있다.\n\n```bash\n# upstream -> backend server group \n# keepalive -> upstream connection pool\n  \nupstream tomcat {\n    server 127.0.0.1:8080;\n    keepalive 10;\n}\n\nupstream jp1 {\n    server jp1.com;\n    keepalive 10;\n}\n```\n\n#### header.conf\n\n요청을 다른 서버로 프록시할 때, 전달할 헤더 설정을 정의하는 파일이다. \nNginx는 기본적으로 Host 헤더를 전달하는데, 이때 필요에 따라 추가적인 헤더를 설정할 수 있다.\n\n```bash\nproxy_pass_header Server;                # Server 헤더를 프록시할 때 전달\nproxy_set_header Host $http_host;        # Host 헤더를 전달\nproxy_set_header X-Real-IP $remote_addr; # 클라이언트 IP 주소를 전달\n```\n\n#### ssl.conf\n\nSSL 설정 파일로, SSL 인증서와 키 파일의 경로를 지정하고 SSL 버전 및 암호화 설정을 정의할 수 있다.\n\n```bash\nlisten 443 ssl http2;\n\nssl_certificate       ./ssl/cert.pem;\nssl_certificate_key   ./ssl/key.pem;\n\nssl_protocols  TLSv1.2 TLSv1.3;\nssl_ciphers    AES128:RC4:AES256:!ADH:!aNULL:!DH:!EDH:!eNULL:!LOW:!SSLv2:!EXP:!NULL;\nssl_prefer_server_ciphers   on;\n```\n\n#### ssl-server.conf\n\nHTTPS(443 포트) 요청을 처리하는 서버 블록을 정의한다.\nSSL 설정 파일을 포함시키고, 도메인과 관련된 로그 및 오류 로그를 설정하고, 특정 경로(/actuator)로의 접근을 제한하거나, 다른 서버로의 프록시를 설정할 수 있다.\n\n```bash\n# https 443 요청에 대한 proxy pass\nserver {\n    listen       443 ssl http2;  \t           \n    server_name github.023-dev.com 023-dev.github.io;\n    access_log  ./logs/nginx/access_023.log  main;     # HTTPS 로그 기록\n\n    ssl_certificate       ./ssl/cert.pem;\n    ssl_certificate_key   ./ssl/key.pem;\n\n    ssl_protocols  TLSv1.2 TLSv1.3;\n    ssl_ciphers    AES128:RC4:AES256:!ADH:!aNULL:!DH:!EDH:!eNULL:!LOW:!SSLv2:!EXP:!NULL;\n    ssl_prefer_server_ciphers   on;\n\n    location ^~ /actuator {\n        return 404; # 보안상 외부에서 /actuator 경로에 접근을 차단\n    }\n\n    location / {\n        proxy_pass http://tomcat; # / 경로로 들어온 요청을 tomcat 서버로 프록시\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n\n    error_page 400 401 403 404 405 /404.html;\n    location = /404.html {\n    }\n    \n    error_page 500 502 503 504 /50x.html;\n   \t\tlocation = /50x.html {\n   \t}\n\n}\n```\n\n#### http-server.conf\n\nHTTP(80 포트) 요청을 처리하는 서버 블록을 정의한다. \n이 파일에서는 SSL이 아닌 일반 HTTP 요청을 처리하고, 특정 경로(/api)에 대해 HTTPS로 리디렉션하는 설정할 수 있다.\n\n```bash\n# http 80 요청에 따른 proxy pass\nserver {\n    listen       80;  \t           \n    server_name github.023-dev.com 023-dev.github.io;\n    access_log  ./logs/nginx/access_023.log  main;     # HTTP 로그 기록\n\n    location ^~ /actuator {\n        return 404; # 보안상 외부에서 /actuator 경로에 접근을 차단\n    }\n\n    location ~* ^/(api/) {\n        rewrite ^(.*) https://$http_host$1 permanent; # /api 경로를 HTTPS로 리디렉션\n    }\n\n    location / {\n        return 404; # 그 외의 경로로 접근한 경우, 404 반환\n        break;\n    }\n    \n    error_page 400 401 403 404 405 /404.html;\n    location = /404.html {\n    }\n    \n    error_page 500 502 503 504 /50x.html;\n   \t\tlocation = /50x.html {\n   \t}\n\n}\n```\n\n#### nginx.conf\n\nNginx의 메인 설정 파일로, 다른 설정 파일들을 `include`하여 불러온다. \n이 파일에서는 시스템의 CPU 코어 수에 맞게 `worker_processes`를 설정하고, 요청 처리에 필요한 다양한 설정들을 포함시킬 수 있다.\n\n```bash\nuser  nginx;\n  \nworker_processes auto; # CPU 코어 수에 맞게 worker_processes 설정\n\nevents {\n    worker_connections 1024; # worker_connections 설정 -> process당 maximum connection 수\n}\n\nhttp {\n    include       mime.types;               # MIME 타입 설정 파일\n    default_type  application/octet-stream; # 기본 MIME 타입 설정\n\n    include       upstream.conf;            # upstream 설정 파일\n    include       header.conf;              # header 설정 파일\n    include       ssl.conf;                 # SSL 설정 파일\n    include       ssl-server.conf;          # HTTPS 서버 블록 설정 파일\n    include       http-server.conf;         # HTTP 서버 블록 설정 파일\n\n    sendfile        on;                      # sendfile 설정\n    tcp_nopush     on;                      # tcp_nopush 설정\n    \n    keepalive_timeout  65;                  # keepalive_timeout -> 클라이언트와 서버 사이의 연결 유지 시간\n    keepalive_requests 100;                 # keepalive_requests -> keepalive 연결 요청 수\n    \n    gzip  on;                               # gzip 압축 설정\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n    \n    large_client_header_buffers 4 16k;      # large_client_header_buffers 설정 -> 클라이언트 헤더 버퍼 크기\n    client_max_body_size 100m;              # client_max_body_size 설정 -> 클라이언트 요청 바디 최대 크기\n}\n```\n\n### Nginx 설정 파일 예시\n\n최근에 사용한 Nginx 설정 파일에 형식을 공유하겠다.\n이렇게만 해도 일반적인 어플리케이션 서버를 운영하는데 충분하다.\n\n```bash\nupstream backend {#연결했던 커넥션을 nginx가 캐시해서 재활용 할 수 있음\n\t\t\t\tserver 127.0.0.1:8080;# 같은 서버에 있어서 local로 매핑\n\t\t\t\tkeepalive 5;\n}\n\nserver {\n        listen: 80; #default_server 붙이는 방법도 있음\n        server_name: {탄력적 IP or DNS} # ex) 43.200.98.236;\n        \n        #location /hello { # 이렇게 할 수도 있음\n        #        return 200 'Hello World';\n        #        add_header Content-Type \"text/plain\";\n        #}\n        \n        location / {\n\t\t\t\t        proxy_pass http://backend; \n\t\t\t\t        proxy_connect_timeout 5;\n\t\t\t\t        proxy_read_timeout 15;\n        }\n        \n}\n```\n\n작성 후 `nginx -t`로 설정 파일을 검사하고 `nginx -s reload`로 설정을 적용할 수 있다.\n`nginx -t`를 통해 검사하는 것을 습관화 하는 것이 좋다. \n\n## Nginx 설정 시 주의해야 하는 부분\n\nNginx 설정 시 주의해야 하는 부분 또한 꽤 있다.\n주의하길 바란다.\n\n### server_name\n\nNginx는 요청이 들어오면 어떤 서버 블록이 해당 요청을 처리할지 결정하는데, 이 때 중요한 역할을 하는 것이 바로 `server_name`이다. \n여러 개의 서버 블록이 동일한 포트를 리슨하고 있을 때, 요청은 `server_name`에 설정된 값을 기준으로 적합한 서버 블록으로 라우팅된다.\n예를 들어, 80번 포트를 리슨하는 3개의 서버 블록이 있을 경우, 각 서버 블록은 `server_name`에 설정된 값에 따라 다르게 동작한다.\n\n```bash\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    ...\n}\n\nserver {\n    listen 80;\n    server_name example.net www.example.net;\n    ...\n}\n\nserver {\n    listen 80;\n    server_name example.org www.example.org;\n    ...\n}\n```\n\n이와 같은 설정에서는, Nginx가 요청을 처리할 때 요청 헤더의 Host 값을 바탕으로 서버를 선택한다.\n만약 `server_name`에 설정된 도메인 이름이 매칭되지 않으면, `default_server`로 설정된 서버 블록이 요청을 처리하게 된다.\n특히, Host 헤더가 없는 요청을 처리하려면 아래와 같이 설정하여 444 상태 코드를 반환해 요청을 drop 시킬 수 있다\n\n```bash\nserver {\n    listen 80 default_server;\n    server_name _;\n    return 444;\n}\n```\n\n하나의 서버에 여러 DNS가 매핑되는 상황에서 설정하다 보면 원하지 원하지 않는 서버 블록이 요청을 처리할 수 있다.\n이러한 경우에는 원하는 `server_name`이 올바르게 매핑되고 있는지 확인하고 잘 설정해야 한다.\n\n### proxy_set_header\n\nNginx에서 `proxy_pass`를 사용하여 다른 서버로 요청을 전달할 때, 특정 헤더를 전달하기 위해 `proxy_set_header`를 설정할 수 있다. \n기본적으로 `proxy_set_header`는 상위 블록에서 설정된 값을 하위 블록에서 상속받는데, 예를 들어 http 또는 server 블록에서 정의된 `proxy_set_header`는 location 블록에서도 적용이 된다.\n그러나 location 블록에서 별도의 proxy_set_header 설정이 있다면, 상위 블록에서 정의된 설정은 무시되고 하위 블록에서 설정된 값만 사용된다.\n\n```bash\nserver {\n    listen 80;\n    server_name localhost;\n    \n    # 상위 블록에서 설정된 \"Hello\" 헤더\n    proxy_set_header Hello \"Hello\";\n    \n    location / {\n        # 하위 블록에서 설정된 \"Bye\" 헤더\n        proxy_set_header Bye \"Bye\";\n        proxy_pass http://localhost:8080;\n    }\n}\n```\n\n이 경우, 하위 블록인 `location`에서 설정된 `proxy_set_header`가 상위 블록의 설정을 덮어쓰기 때문에 `proxy_pass`로 전달되는 헤더는 \"Bye\" 만 전달된다. \n따라서 `proxy_set_header`를 설정할 때, 상위 블록과 하위 블록에서 충돌이 일어나지 않도록 주의해야 한다.\n\n## Nginx 로그\n\n서버 운영을 하게 되면 로그는 필수이다.\nNginx에도 로그가 있는데, Nginx 로그는 크게 두 가지로 나뉜다.\n\n- error.log: Nginx 서버에서 발생한 오류에 대한 로그\n- access.log: 클라이언트 요청에 대한 로그\n\n이 로그는 `vi /etc/nginx/nginx.conf` Nginx 설정 파일에 기본 `log_format`으로 있다.\n기본 `log_format`은 이렇게 돼있다.\n\n```bash\nlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n                 '$status $body_bytes_sent \"$http_referer\" '\n                 '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n```\n\n이는 경우에 따라서 서비스 마다 `config` 파일을 만들어 `log` 관리를 할 수 있다.\n\n```bash\nhttp {\n\t\tlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n\t\t\t\t\t\t\t\t\t\t'$status $body_bytes_sent \"$http_referer\" '\n\t\t\t\t\t\t\t\t\t\t'\"$http_user_agent\" \"$http_x_forwarded_for\"'\n\t\t\t\t\t\t\t\t\t\t'\"$request_time\" \"$upsteam_connect_time\" \"$upstream_header_time\" \"$upstream_response_time\"';\n\t\t\t\t\t\t\t\t\t\t\n\t\taccess_log /var/log/nginx/access.log main;\n}\n```\n\n여기서 `$request_time`, `$upsteam_connect_time`, `$upstream_header_time`, `$upstream_response_time`은 Nginx에서 제공하는 변수로, 각각 요청 처리 시간, 서버 연결 시간, 서버 응답 헤더 수신 시간, 서버 응답 시간을 의미한다.\n필요로 한다면, 다른 로그 매니지먼트 툴에서 로그 파싱을 위해 json 형식으로 지정하여 사용할 수 있다.\n이제 이렇게 설정한 로그를 `nginx.conf`에 적용하면 된다.\n\n```bash\nserver {\n        ...\n        \n        access_log /var/log/nginx/{application}-access.log main;# ex) app-access.log, log_format 지정 가능(ex. main)\n        error_log /var/log/nginx/{application}-error.log;# ex) app-error.log\n        \n        ...       \n}\n```\n\n## 참고\n\n- [Nginx: Linux packages](https://nginx.org/en/linux_packages.html)\n\n- [Kandaurov, S. (2025, February 5). Nginx-1.27.4-RELEASE.](https://hg.nginx.org/nginx/file/tip/conf/mime.types)\n\n"},{"excerpt":"작성 중.. 참고 Nginx: Linux packages Kandaurov, S. (2025, February 5). Nginx-1.27.4-RELEASE. SSL을 통한 HTTPS통신 과정 Nginx란?","fields":{"slug":"/ssl-protocol/"},"frontmatter":{"date":"March 15, 2024","title":"SSL Protocol","tags":["Nginx"]},"rawMarkdownBody":"\n작성 중..\n\n## 참고\n\n- [Nginx: Linux packages](https://nginx.org/en/linux_packages.html)\n\n- [Kandaurov, S. (2025, February 5). Nginx-1.27.4-RELEASE.](https://hg.nginx.org/nginx/file/tip/conf/mime.types)\n\n- [SSL을 통한 HTTPS통신 과정](https://dallog.github.io/ssl_protocol/)\n\n- [Nginx란?](https://dallog.github.io/what_is_nginx/)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}