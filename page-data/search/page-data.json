{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"기타 레슨 백준 2343번 기타 레슨 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 41659 14728 10194 33.343% 문제 강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다.\n블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다.\n순서가 뒤바뀌는 경우에는…","fields":{"slug":"/boj-2343/"},"frontmatter":{"date":"January 16, 2025","title":"2343 기타 레슨","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 기타 레슨\n[백준 2343번 기타 레슨](https://www.acmicpc.net/problem/2343)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 128 MB | 41659 | 14728 | 10194 | 33.343% |\n\n### 문제\n\n강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다. \n블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. \n순서가 뒤바뀌는 경우에는 강의의 흐름이 끊겨, 학생들이 대혼란에 빠질 수 있기 때문이다. \n즉, i번 강의와 j번 강의를 같은 블루레이에 녹화하려면 i와 j 사이의 모든 강의도 같은 블루레이에 녹화해야 한다.<br>\n\n강토는 이 블루레이가 얼마나 팔릴지 아직 알 수 없기 때문에, 블루레이의 개수를 가급적 줄이려고 한다. \n오랜 고민 끝에 강토는 M개의 블루레이에 모든 기타 강의 동영상을 녹화하기로 했다. \n이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다. \n단, M개의 블루레이는 모두 같은 크기이어야 한다.<br>\n\n강토의 각 강의의 길이가 분 단위(자연수)로 주어진다. \n이때, 가능한 블루레이의 크기 중 최소를 구하는 프로그램을 작성하시오.<br>\n\n### 입력\n\n첫째 줄에 강의의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. \n다음 줄에는 강토의 기타 강의의 길이가 강의 순서대로 분 단위로(자연수)로 주어진다. \n각 강의의 길이는 10,000분을 넘지 않는다.\n\n### 출력\n\n첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 이분 탐색(Binary Search)을 활용하여 최적의 블루레이 크기를 찾는 방식으로 해결할 수 있었다.\n여기서 핵심은 강의는 순서를 바꿀 수 없으며, 강의 길이의 합을 기준으로 블루레이 크기를 최소화해야 한다는 것이다. \n가장 긴 강의가 들어가야하므로 블루레이 크기의 최소값은 가장 긴 강의의 길이이며, 최대값은 모든 강의 길이의 합으로 설정했다. \n그리고 이분 탐색을 통해 블루레이 크기를 조정하며, \n각 중간값(`mid`)을 블루레이 크기로 설정하고 M개의 블루레이에 강의를 나눌 수 있는지 확인한다. \n현재 블루레이 크기(`mid`)로 강의를 순서대로 배치하다가 크기를 초과하면 새로운 블루레이를 사용하며, \n사용된 블루레이 개수가 M개를 초과하면 `min` 값을 `mid+1`로 하여 더 큰 크기를 탐색하고, \nM개 이하로 나눌 수 있다면 크기를 줄이는 방향으로 탐색한다. \n`getMinDuration` 메서드는 이 과정을 통해 최소 블루레이 크기를 계산하며, \n`canDivide` 메서드는 특정 크기에서 M개의 블루레이로 나눌 수 있는지 여부를 판단한다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass BlueRayMaker {\n    private int[] lectures;\n    private int maxDuration;\n    private int sumDuration;\n    private int blueRayCount;\n\n    private BlueRayMaker(int[] lectures, int blueRayCount) {\n        this.lectures = lectures;\n        this.maxDuration = Arrays.stream(lectures).max().orElse(0);\n        this.sumDuration = Arrays.stream(lectures).sum();\n        this.blueRayCount = blueRayCount;\n    }\n\n    public static BlueRayMaker from(int[] lectures, int blueRayCount) {\n        return new BlueRayMaker(lectures, blueRayCount);\n    }\n\n    private int getMinDuration() {\n        int min = maxDuration;\n        int max = sumDuration;\n        int result = max;\n\n        while (min <= max) {\n            int mid = (min + max) / 2;\n\n            if (canDivide(mid)) {\n                result = mid;\n                max = mid - 1;\n            } else {\n                min = mid + 1;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean canDivide(int size) {\n        int count = 1;\n        int currentSum = 0;\n\n        for (int lecture : lectures) {\n            if (currentSum + lecture > size) {\n                count++;\n                currentSum = lecture;\n\n                if (count > blueRayCount) {\n                    return false;\n                }\n            }\n            else {\n                currentSum += lecture;\n            }\n        }\n        return true;\n    }\n\n    public void printMinDuration() {\n        System.out.println(getMinDuration());\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int lectureCount = Integer.parseInt(tokenizer.nextToken());\n        int blueRayCount = Integer.parseInt(tokenizer.nextToken());\n        int[] lectures = new int[lectureCount];\n\n        tokenizer = new StringTokenizer(reader.readLine());\n        for (int index = 0; index < lectureCount; index++) {\n            lectures[index] = Integer.parseInt(tokenizer.nextToken());\n        }\n        BlueRayMaker.from(lectures, blueRayCount).printMinDuration();\n    }\n}\n```"},{"excerpt":"나무 자르기 백준 2805번 나무 자르기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 227847 68338 42397 26.636% 문제 상근이는 나무 M미터가 필요하다.\n근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다.\n정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, …","fields":{"slug":"/boj-2805/"},"frontmatter":{"date":"January 16, 2025","title":"2805 나무 자르기","tags":["Algorithm"]},"rawMarkdownBody":"\n## 나무 자르기\n\n[백준 2805번 나무 자르기](https://www.acmicpc.net/problem/2805)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 227847 | 68338 | 42397 | 26.636% |\n\n### 문제\n\n상근이는 나무 M미터가 필요하다. \n근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. \n정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.<br>\n\n목재절단기는 다음과 같이 동작한다. \n먼저, 상근이는 절단기에 높이 H를 지정해야 한다. \n높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. \n그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. \n따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. \n예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. \n상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, \n상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) \n절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.<br>\n\n상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. \n이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. \n(1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)<br>\n\n둘째 줄에는 나무의 높이가 주어진다. \n나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. \n높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.\n\n### 출력\n\n적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.\n\n---\n\n## 풀이\n\n이 문제는 나무의 높이를 기준으로 이분 탐색을 수행하여 필요한 나무 길이 이상을 얻을 수 있는 절단기 높이의 최댓값을 찾는 방식으로 접근한다. \n먼저, 입력으로 주어진 나무의 높이를 정렬하고, 절단기의 최소 높이 `0`과 최대 높이를 설정한 후, 이분 탐색을 시작한다. \n각 중간값(`mid`)에서 나무를 절단했을 때 잘린 나무의 총 길이를 계산하고, 이 길이가 목표 길이 이상이면 절단기 높이를 더 높게 설정하여 탐색 범위를 좁힌다. \n반대로, 목표 길이보다 작으면 절단기 높이를 낮추어 다시 탐색한다. \n탐색이 종료되면 최적의 절단기 높이를 출력하며, 시간 복잡도는 정렬 $(O(N \\log N)$과 이분 탐색 $(O(N \\log H)$을 합쳐 $(O(N \\log N + N \\log H)$로 효율적이다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nclass Tree implements Comparable<Tree> {\n    private long height;\n\n    private Tree(long height) {\n        this.height = height;\n    }\n\n    public static Tree of(long height) {\n        return new Tree(height);\n    }\n\n    public long getHeight() {\n        return height;\n    }\n\n    @Override\n    public int compareTo(Tree other) {\n        return Long.compare(this.height, other.height);\n    }\n\n    public long cutHeight(long other) {\n        return this.height - other;\n    }\n\n    public boolean isCuttable(long midHeight) {\n        return Long.compare(this.height, midHeight) > 0;\n    }\n}\n\nclass Trees {\n    private List<Tree> trees;\n\n    private Trees(List<Tree> trees) {\n        this.trees = trees.stream().sorted().collect(Collectors.toList());\n    }\n\n    public static Trees of(List<Tree> trees) {\n        return new Trees(trees);\n    }\n\n    public List<Tree> getTrees() {\n        return trees;\n    }\n\n    public long getMaxHeight() {\n        return trees.get(trees.size() - 1).getHeight();\n    }\n\n    public int size() {\n        return trees.size();\n    }\n}\n\nclass TreeCutter {\n    private Trees trees;\n    private int target;\n\n    private TreeCutter(Trees trees, int target) {\n        this.trees = trees;\n        this.target = target;\n    }\n\n    public static TreeCutter of(Trees trees, int target) {\n        return new TreeCutter(trees, target);\n    }\n\n    private long cut() {\n        long minHeight = 0;\n        long maxHeight = trees.getMaxHeight();\n        long result = 0;\n        while (minHeight <= maxHeight) {\n            long midHeight = (minHeight + maxHeight) / 2;\n            long sumHeight = 0;\n\n            for (Tree tree : trees.getTrees()) {\n                if(tree.isCuttable(midHeight)) {\n                    sumHeight += tree.cutHeight(midHeight);\n                }\n            }\n\n            if (sumHeight >= target) {\n                result = midHeight;\n                minHeight = midHeight + 1;\n            } else {\n                maxHeight = midHeight - 1;\n            }\n        }\n        return result;\n    }\n\n    public void printResult() {\n        System.out.println(cut());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());// 나무의 수 1 <= N <= 1,000,000\n        int target = Integer.parseInt(tokenizer.nextToken());// 나무의 길이 1 <= target <= 2,000,000,000\n        List<Tree> trees = new ArrayList<>();\n        tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i < N; i++) {\n            long height = Long.parseLong(tokenizer.nextToken());\n            Tree tree = Tree.of(height);\n            trees.add(tree);\n        }\n        TreeCutter.of(Trees.of(trees), target).printResult();\n    }\n}\n```"},{"excerpt":"HDD와 SSD CPU의 처리 속도와 RAM과 같은 전기적인 원리로 동작하는 메모리의 I/O 속도는 지속적으로 빠르게 발전해왔다.\n반면, 디스크와 같은 기계적 장치는 CPU나 RAM에 비해 발전 속도가 상대적으로 제한적이었다.\n특히 HDD는 마치 LP판과 유사한 원리로 동작한다.\n디스크 헤드가 특정 위치로 이동해 플래터(원판)를 회전시키며 데이터를 읽거나…","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"date":"January 16, 2025","title":"저장 매체와 랜덤 I/O, 순차 I/O","tags":["Database","Index"]},"rawMarkdownBody":"\n## HDD와 SSD\n\nCPU의 처리 속도와 RAM과 같은 전기적인 원리로 동작하는 메모리의 I/O 속도는 지속적으로 빠르게 발전해왔다. \n반면, 디스크와 같은 기계적 장치는 CPU나 RAM에 비해 발전 속도가 상대적으로 제한적이었다. \n특히 HDD는 마치 LP판과 유사한 원리로 동작한다. \n디스크 헤드가 특정 위치로 이동해 플래터(원판)를 회전시키며 데이터를 읽거나 쓰는 방식으로 작동하기 때문에 속도가 느릴 수밖에 없다. \n이를 보완하기 위해 플래시 메모리를 활용한 SSD가 등장했으며, SSD는 HDD에 비해 훨씬 빠른 속도를 제공한다.\n\n## 컴퓨터 컴포넌트별 IOPS 비교\n\nHDD와 메모리 간의 I/O 속도 차이는 약 10만 배에 달한다. \n반면, SSD는 플래시 메모리를 사용하여 메모리와의 속도 차이를 약 1,000배 수준으로 줄였다. \n특히 순차 I/O의 경우 SSD는 HDD보다 약간 빠른 수준이지만, 랜덤 I/O에서는 SSD가 HDD에 비해 월등히 우수하다. \n이는 대부분의 DBMS I/O가 랜덤 I/O로 발생하기 때문에 중요하다.\n\n책 *Real MySQL 8.0*에 따르면, HDD와 SSD를 비교했을 때 초당 트랜잭션 처리 성능은 SSD가 HDD 대비 약 7배 높은 성능을 보인다. \n이러한 이유로 최근 DBMS 서버는 대부분 SSD를 채택하고 있다.\n\n## DBMS에서 SSD와 HDD의 성능 차이가 설계 및 운영에 미치는 영향\n\nSSD의 도입은 데이터베이스 설계 및 운영 방식에 큰 변화를 가져왔다. \n과거 HDD 기반 환경에서는 디스크 I/O의 높은 지연 시간 때문에 디스크 접근을 최소화하는 설계가 필수적이었다. \n이를 위해 인덱스 최적화, 데이터 압축, 파티셔닝 등 다양한 기법이 활용되었다. \n반면 SSD는 훨씬 빠른 I/O 성능을 제공하므로, 일부 설계 요소를 단순화하거나, 데이터 중복을 허용하여 읽기 성능을 극대화하는 전략이 가능하다.\n\n또한 SSD는 랜덤 I/O 성능이 뛰어나므로, 데이터 분산 및 샤딩 전략에서 물리적 연속성을 고려할 필요가 적어졌다. \n하지만 SSD도 무한한 성능을 제공하는 것은 아니며, 특히 쓰기 성능 저하와 셀 마모 문제가 있기 때문에 로그 쓰기 또는 캐싱 전략을 통해 SSD 수명을 최적화해야 한다.\n\n## 랜덤 I/O와 순차 I/O\n\n랜덤 I/O는 읽어야 할 데이터가 물리적으로 불연속적인 위치에 있을 때 발생하며, 디스크 헤더를 여러 번 이동시키면서 데이터를 읽는다. \n이 과정에서 디스크 헤더의 이동 시간, 즉 Seek Time이 성능에 큰 영향을 미친다. \n반면, 순차 I/O는 데이터가 물리적으로 연속적으로 저장된 경우에 발생하며, 디스크 헤더를 이동시키지 않고 데이터를 읽을 수 있다. \n따라서 디스크의 성능은 순차적으로 데이터를 저장하고 읽는 능력에 크게 좌우된다.\n\nSSD는 디스크 원판이 없기 때문에 랜덤 I/O와 순차 I/O 간의 성능 차이가 적을 것처럼 보이지만, SSD에서도 랜덤 I/O는 순차 I/O에 비해 처리율(throughput)이 떨어지는 경향이 있다.\n\n## SSD 내부에서 랜덤 I/O 성능이 순차 I/O보다 떨어지는 이유\n\nSSD 내부 구조는 플래시 메모리 셀로 구성되어 있으며, 데이터는 페이지 단위로 읽고 블록 단위로 쓰인다. \n랜덤 I/O가 순차 I/O보다 느린 이유는 크게 두 가지로 나뉜다. \n첫째, SSD의 내부 컨트롤러는 데이터의 위치를 추적하기 위해 논리적 블록 주소(LBA)와 실제 물리적 주소를 매핑하는 작업을 수행해야 한다. \n랜덤 I/O가 많아질수록 이 매핑 테이블의 참조와 갱신 빈도가 증가하면서 컨트롤러의 부하가 커진다.\n\n둘째, SSD는 데이터 쓰기 시 기존 데이터를 직접 덮어쓰지 못하고, 새로운 블록에 데이터를 기록한 뒤 가비지 컬렉션(Garbage Collection)을 통해 이전 블록을 정리하는 방식으로 동작한다. \n랜덤 I/O가 많을수록 이 과정에서 비효율이 발생하며, 특히 여러 블록에 분산된 데이터를 처리할 경우 병목현상이 심화된다.\n\n\n## DBMS에서 I/O 최적화의 중요성\n\nDBMS는 디스크에 데이터를 빈번히 읽고 쓰는 작업을 수행하기 때문에, MySQL 서버는 그룹 커밋, 바이너리 로그, InnoDB 로그 버퍼 등 다양한 최적화 기능을 내장하고 있다. \n쿼리를 튜닝한다고 해서 랜덤 I/O가 순차 I/O로 변하는 일은 흔하지 않다. \n따라서 쿼리 튜닝의 목적은 랜덤 I/O를 줄이고 꼭 필요한 데이터만 읽도록 개선하는 데 있다.\n\n인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용한다. \n큰 테이블에서 많은 데이터를 읽어야 할 경우, 옵티마이저가 인덱스 사용 대신 풀 테이블 스캔을 유도하는 전략을 선택할 수도 있다. \n이러한 상황에서는 쿼리 성능 최적화를 통해 불필요한 랜덤 I/O를 줄이는 것이 중요하다.\n"},{"excerpt":"인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다. 물론 인덱스가 없는 데이터…","fields":{"slug":"/database-index/"},"frontmatter":{"date":"January 16, 2025","title":"인덱스(Index)","tags":["Database","Index"]},"rawMarkdownBody":"\n인덱스는 데이터베이스에서 특정 데이터를 빠르게 조회하기 위해 사용하는 Key-Value 타입의 자료구조이다.\n영어사전의 알파벳순 정렬을 예로 들 수 있다.\n특정 영단어를 영어전전에서 찾으려 할 때 이미 알파벳 순으로 정렬되어 있기에 특정 영단어의 첫 알파벳 페이지로 가면,\n영어사전의 처음부터 뒤지는 것보다 빠르게 찾을 수 있다.\n\n물론 인덱스가 없는 데이터베이스에서도 데이터를 조회할 수 있지만, 데이터베이스의 크기가 크면 클수록 인덱스가 필요해진다.\n인덱스는 데이터베이스의 크기가 커져도 빠르게 데이터를 조회할 수 있도록 도와준다.\n\n> 그럼 모든 컬럼에 인덱스를 걸면 좋을까? 아니다.\n> 인덱스를 효율적으로 사용한다면 매우 빠른 데이터 조회가 가능하고, 쿼리의 부하가 줄어들어 데이터베이스의 성능을 향상시킬 수 있지만,\n> 인덱스 역시 하나의 데이터 덩어리이기 때문에 적절한 인덱스를 사용하지 않으면 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n\n> 그럼 어떤 기준으로 인덱스를 설정해야할까?\n> 검색 조건에 주로 사용되고 카디널리티가 높은 컬럼을 인덱스로 설정하면 좋다.\n> 카디널리티는 인덱스에 해당하는 컬럼 기준으로 테이블에서 유일한 레코드 개수를 의미한다.\n> 카디널리티가 높을 컬럼에 인덱스를 걸면 그만큼 검색 대상이 줄어들기 때문에 빠르게 레코드에 접근할 수 있다.\n\n때문에 인덱스를 효율적으로 사용하기 위해서는 인덱스의 동작 방식과 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.\n\n## 인덱스 알고리즘\n\n인덱스 알고리즘은 B-Tree와 Hash Index으로 분류하여 구분할 수 있다. \n이 중에서도 B-Tree 알고리즘은 Balanced Tree 알고리즘으로, 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.\n인덱스는 이러한 B-Tree 알고리즘을 사용하며 데이터가 정렬된 상태를 유지한다.\n때문에 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다.\n\n> 트리의 높이가 다른 경우 차이가 발생할 수 있지만, 일반적으로 B-Tree는 O(logN)의 시간복잡도를 가진다.\n\n### B-Tree\n\nMySQL에서 사용하는 인덱스 알고리즘으로, 별다른 데이터의 변형을 가하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.\nB-Tree는 최상위에 하나의 루트 노드가 있고, 그 아래에 여러 개의 브랜치 노드가 있으며, 가장 하위에는 리프 노드가 있는 형태이다.\n\n해당 알고리즘의 장점은 어떤 값에 대해서도 같은 시간복잡도로 데이터를 조회할 수 있다는 것이다.\n하지만 어떤 데이터를 조회를 하더라도 루트 노드부터 리프 노드까지 탐색해야하기 때문에,\n데이터가 적은 테이블의 경우에는 인덱스를 사용하지 않는 것이 더 빠를 수 있다.\n\n### B+Tree\n\nB+Tree는 B-Tree의 변형 알고리즘으로, B-Tree와 달리 리프 노드가 연결 리스트로 연결되어 있다.\n또한 리프 노드에만 데이터가 저장되어 있고, 브랜치 노드에는 데이터가 저장되어 있지 않다.\n이러한 구조로 인해 범위 검색에 특화되어 있으며, 데이터베이스에서 범위 검색이 많은 경우에 사용된다.\n\n해당 알고리즘의 장점으로는 범위 검색에 특화되어 있어, 범위 검색이 많은 데이터베이스에서 빠른 검색 속도를 가진다.\n또한 리프 노드가 연결 리스트로 연결되어 있기 때문에 범위 검색을 할 때, 리프 노드를 순회하면 되기 때문에 빠른 검색 속도를 가진다.\n그러나 B-Tree에 비해 높이가 더 높아져서, B-Tree보다 더 많은 블록을 읽어야 한다.\n또한, 리프 노드가 연결 리스트로 연결되어 있기 때문에, 범위 검색이 아닌 동등 비교 검색에는 B-Tree보다 느릴 수 있다.\n\n### Hash Index\n\nHash Index 알고리즘은 데이터를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하는 알고리즘이으로, 특히 동등 비교 검색에 특화되어 있다.\n하지만 값을 해시값으로 변환하기 때문에 범위 검색이나 정렬된 데이터를 조회하는데는 적합하지 않다.\n주로 인메모리 데이터베이스에서 사용되는 인덱스 알고리즘이다.\n\n> 인메모리 데이터베이스는 데이터를 메모리에 저장하고, 디스크에 저장하지 않는 데이터베이스이다. 예를 들어 Redis가 있다.\n\n이러한 해시 인덱스의 장점으로는 실제 키 값과는 관계없이 해시값을 통해 데이터를 저장하기 때문에 데이터의 길이에 상관없이 일정한 시간복잡도를 가진다.\n그래서 타 인덱싱 알고리즘에 비해 빠른 검색 속도를 가진다.\n그러나 해시 인덱스는 각 해쉬값에 주소값을 지정하는 인덱스의 특성상, 범위로 조회하는 쿼리에는 적합하지 않다.\n또한 데이터베이스의 크기가 커질수록 충돌이 발생할 확률이 높아지기 때문에, 충돌을 해결하는 방법이 필요하다.\n\n## 인덱스 타입\n\n인덱스의 타입은 크게 클러스터 인덱스와 세컨더리 인덱스로 나눌 수 있다.\n클러스터 인덱스는 처음부터 정렬된 상태로 데이터가 저장되는 인덱스이며, 세컨더리 인덱스는 정렬되지 않은 상태로 데이터가 저장되는 인덱스이다.\n영어사전을 예로 들면, 영어사전의 알파벳 순으로 정렬된 상태를 클러스터 인덱스라고 할 수 있고,\n영어사전의 단어가 추가되는 순서대로 저장된 상태를 세컨더리 인덱스라고 할 수 있다.\n\n각 인덱스의 특징에 따라 사용하는 경우가 다르다.\n\n### 클러스터 인덱스\n\nMySQL의 InnoDB 엔진은 기본적으로 클러스터 인덱스로 저장되는데,\n클러스터 인덱스는 기본키가 비슷한 레코드끼리 묶어서 인접한 물리적 위치에 저장하는 것을 뜻한다.\n그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬되어 저장되기 때문에, 기본키 기반 검색이 매우 빠르다.\n하지만, 이러한 정렬 방식 때문에 이미 대용량의 데이터가 저장된 상태라면 인덱스 생성은 시스템 부하를 일으킬 수 있다.\n\n클러스터 인덱스는 한 개의 테이블에 하나만 생성할 수 있으며, 기본키에 대해서만 생성할 수 있다.\n\n> MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, \n> 없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지않는 컬럼을 만들어 Clustered Index로 지정한다.\n\n### 세컨더리 인덱스\n\n세컨더리 인덱스는 논 클러스터 인덱스(Non-Clustered Index)라고도 불린다.\n클러스터 인덱스와는 다르게 후보키 기반으로 생성되는 인덱스로, 기본키와는 별개로 생성된다.\n세컨더리 인덱스 생성 시에는 데이터 페이지는 정렬되지 않은 상태에서 별도의 인덱스 페이지에 인덱스가 생성된다.\n별도의 인덱스 페이지에 인덱스가 생성하여 구성하기 때문에 클러스터와는 달리 자동 정렬을 하지 않는다.\n때문에 클러스터형 보다 느리게 검색되지만, 데이터 삽입, 수정, 삭제에 대한 부하가 적다.\n\n> 세컨더리 인덱스는 여러 개 생성할 수 있으나, 이를 남용할 경우 오히려 성능이 저하될 수 있다.\n\n### 클러스터 + 세컨더리 인덱스\n\n클러스터 인덱스와 세컨더리 인덱스를 함께 사용하는 방법도 있다.\n클러스터 인덱스는 기본키 기반 검색에 특화되어 있고, 세컨더리 인덱스는 범위 검색에 특화되어 있기 때문에,\n클러스터 인덱스와 세컨더리 인덱스를 함께 사용하면 더 빠른 검색 속도를 가질 수 있다.\n\n> 클러스터 인덱스와 세컨더리 인덱스를 함께 사용할 경우, 세컨더리 인덱스는 클러스터 인덱스를 참조하는 형태로 사용된다.\n\n\n\n\n"},{"excerpt":"데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다.\n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다. 인덱스 스캔 방식 인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은…","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"date":"January 16, 2025","title":"실행 계획과 쿼리 최적화","tags":["Database","Index"]},"rawMarkdownBody":"\n데이터베이스의 데이터가 커질수록 데이터를 조회하는데 시간이 오래걸리게 된다. \n이를 해결하기 위해 인덱스를 사용하게 되는데, 남용하게 될 경우 오히려 데이터베이스의 성능을 저하시킬 수 있다.\n그래서 인덱스를 효율적으로 사용하기 위해서는 인덱스가 어떻게 동작하는지 알아야한다.\n\n### 인덱스 스캔 방식\n\n인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다.(이 설명은 MySQL을 기준으로 설명하였다).\n\n#### 인덱스 레인지 스캔(Index Range Scan)\n인덱스 레인지 스캔은 특정 범위 내의 데이터를 검색할 때 사용된다.\n이는 일반적으로 `WHERE` 절에 `BETWEEN`, `IN`, `>`, `<` 등의 연산자가 사용될 때 발생한다.\nMySQL은 루트 노드에서 시작하여 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾은 후, \n리프 노드 간의 링크를 따라 검색 종료점 리프 노드 까지 데이터를 스캔한다.\n이때 레코드를 랜덤 엑세스로 읽어 들이게 된다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 레인지 스캔이 발생한다.\n\n```sql\nSELECT * FROM users WHERE age BETWEEN 20 AND 30;\n```\n\n이 쿼리는 `users` 테이블에서 `age` 컬럼에 인덱스가 걸려 있다면, 해당 범위 내의 데이터를 효율적으로 검색할 수 있다. \n\n#### 인덱스 풀 스캔(Index Full Scan)\n인덱스 풀 스캔은 인덱스의 처음부터 끝까지 전체를 스캔하는 방식이다.\n이는 `WHERE` 절에 조건에서 인덱스의 특정 순서를 활용할 필요가 없거나, 범위가 명확하지 않은 조건에서 발생한다.\n인덱스 풀 스캔은 레인지 스캔에 비해 더 많은 블록을 읽어야 하기 때문에, 레인지 스캔보다 느릴 수 있다.\n예를 들어, 다음과 같은 쿼리를 실행할 때 인덱스 풀 스캔이 발생한다.\n\n```sql\nSELECT * FROM users WHERE job = 'developer';\n```\n\n`users` 테이블에서 `job` 컬럼에 인덱스가 존재하지만, 검색 조건이 인덱스의 순서를 활용하지 못하는 경우, 인덱스 풀 스캔이 발생한다.\n\n\n## 인덱스 설계\n\n인덱스의 스캔 방식과에 대해 알아봤다면, 이젠 어떤 기준으로 인덱스를 설정해야하는지 알아야한다.\n\n### 효율적인 인덱스 설계\n\n다음은 효율적인 인덱스 설계를 위한 몇 가지 팁이다.\n\n- `WHERE` 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.\n- `SELECT` 절에 자주 사용되는 컬럼들을 조합해서 인덱스로 만들어 커버링 인덱스를 사용하는 것이 좋다. \n- `JOIN` 절에 자주 사용되는 컬럼에 인덱싱을 하는 것이 좋다.\n- `ORDER` BY 절에 자주 사용되는 컬럼에 클러스터형 인덱스를 사용하는 것이 좋다.\n\n### 지양해야할 인덱스 설계\n\n다음은 지양해야할 인덱스 설계를 위한 몇 가지 팁이다.\n\n- 대용량 데이터가 자주 입력되는 경우 클러스터형 인덱스의 페이징이 빈번하게 발생해 시스템에 부하가 걸릴 수 있다. 때문에 클러스터 대신 세컨더리 인덱스를 사용하는 것이 좋을 수 있다.\n- 데이터 중복도가 높은 컬럼에 인덱싱을 하는 것은 효율적이지 않다. 중복도가 높은 컬럼에 인덱싱을 하게 되면 인덱스의 크기가 커지고, 인덱스를 탐색하는데 시간이 오래걸릴 수 있다.\n- 인덱스를 많이 사용하게 되면 인덱스를 관리하는데 시간이 오래걸리게 되고, 인덱스의 크기가 커지게 된다. 때문에 인덱스를 많이 사용하는 것은 지양해야한다.\n- 자주 사용되지 않는 컬럼에 인덱싱을 하는 것은 효율적이지 않다.\n\n## 커버링 인덱스\n\n- 커버링 인덱스(Covering index)\n\n  **쿼리 조회 결과가 인덱스에 해당하는 컬럼 값으로만 이루어진 것을 커버링 인덱스라고 합니다.**\n\n  **커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 그만큼 랜덤 엑세스가 줄어들고 성능은 빨라집니다.**\n\n- 다중 컬럼 인덱스(Multi-column index, 복합 인덱스)\n\n  **다중 컬럼 인덱스는 2개 이상의 컬럼으로 이루어진 인덱스입니다.**\n\n  **2개의 컬럼으로 이루어진 인덱스가 있을때,**\n\n  **인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다는 특징이 있다는 것을 고려해서 사용해야합니다.**\n\n\n## 인덱스 스캔 방식\n\n인덱스 스캔 방식은 인덱스를 탐색하는 방식을 의미한다. 인덱스 스캔 방식에는 여러가지가 있는데, 그 중에서 대표적인 방식은 다음과 같다.\nB Tree 기준으로 설명하자면, 인덱스 레인지 스캔은 검색 해야할 인덱스의 범위가 결정 됐을때 사용하는 방식이다.\n루트 노드, 브랜치 노드를 거쳐 검색 시작점 리프 노드를 찾고,\n리프 노드간의 링크를 통해 검색 종료점 리프 노드까지 스캔하면서 레코드를 랜덤 엑세스로 읽어 들인다.\n인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 스캔하는 방식이다.\n예를들어 a,b,c 컬럼에 복합 인덱스가 걸려있고 쿼리의 조건절에는 b 또는 c 컬럼이 들어가 있을 경우 인덱스 풀 스캔이 발생한다. \n테이블 풀 스캔보다는 효율적이다.\n\n## 쿼리 실행 계획\n\n쿼리 실행 계획(Query Plan)은 데이터베이스 관리 시스템(DBMS)이 SQL 쿼리를 처리하기 위해 사용하는 실행 계획이다.\n이것은 DBMS에서 쿼리를 처리할 때 데이터베이스에서 데이터를 검색하고 가져오는 방법을 결정하는데 사용된다.\n쿼리 실행에 필요한 단계를 보여주며, 각 단계에서 DBMS가 사용하는 액세스 경로를 보여주고, 쿼리 실행에 필요한 리소스 및 비용 정보를 제공한다.\n즉, SQL을 실행하는데 있어 사용되는 cost와 어떠한 방식이 가장 적절한지 판단하고, 올바른 플랜 중 평가하여 어떠한 순서와 방식으로 처리할 것인지 계획을 세우고 필요에 따라 변경하여 성능을 개선하는데 사용된다.\n이를 통해 DBMS는 쿼리 실행에 필요한 최소한의 리소스를 사용하면서 최적의 성능을 제공할 수 있다.\n\n### 쿼리 실행 계획 확인 방법\n\n쿼리 실행 계획을 확인하는 방법은 DBMS마다 다르지만, 대부분의 DBMS에서는 `EXPLAIN` 명령어를 사용하여 확인할 수 있다.\n`EXPLAIN` 명령어는 쿼리 실행 계획을 확인하는 명령어로, 쿼리를 실행하기 전에 어떠한 방식으로 실행할지에 대한 정보를 제공한다.\n예를 들어, MySQL에서는 다음과 같이 사용할 수 있다.\n\n```sql\nEXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;\n```\n\n위 쿼리를 실행하면, 해당 쿼리의 실행 계획을 확인할 수 있다.\n\n### 쿼리 실행 계획 확인 방법\n\n이러한 쿼리 실행 계획은 옵티마이저가 사용하게 되는데 이때 예상치 못한 문제가 발생할 수 있다.\n이러한 문제를 해결하기 위해 쿼리 힌트를 사용할 수 있다. \n쿼리 힌트는 옵티마이저가 쿼리를 처리하는 방식을 제어하는 방법으로, 쿼리에 힌트를 추가하여 옵티마이저가 쿼리를 처리하는 방식을 변경할 수 있다.\n\n## 인덱스 동작 확인 방법\n\n인덱스 동작을 확인하는 방법은 쿼리에 대한 실행 계획을 보면서 인덱스가 어떻게 걸리는지 확인하여 실제 조회 시 속도와 성능을 확인할 수 있다.\n하지만 가끔씩 인덱스가 제대로 동작하지 않는 경우가 있을 수 있다.\n이런 경우에는 `sys.shema_unused_indexes`를 사용해 인덱스 동작 여부를 확인할 수 있다.\n\n```sql\nSELECT  * FROM sys.shema_unused_indexes;\n```\n\n이렇게 사용되지 않는 인덱스를 확인하고, 필요한 인덱스를 추가하거나 사용되지 않는 인덱스를 삭제하여 성능을 향상시킬 수 있다.\n\n## ORDER BY 와 GROUP BY에 대한 인덱스\n\n인덱스는 WHERE 절에 사용되는 컬럼에 대해서만 동작하는 것이 아니라, ORDER BY와 GROUP BY에도 영향을 줄 수 있다.\n하지만 조건이 있는데 GROUP BY 기준으로 예를 들자면, 복합인덱스를 사용한다고 가정했을 때 GROUP BY (복합인덱스 컬럼들)로 사용해야 인덱스가 동작한다.\nORDER BY의 경우에는 인덱스의 정렬 방식과 일치해야 인덱스가 동작한다."},{"excerpt":"선분 위의 점 백준 11663번 선분 위의 점 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 5062 1883 1406 37.049% 문제 일차원 좌표상의 점 N개와 선분 M개가 주어진다.\n이때, 각각의 선분 위에 입력으로 주어진 점이 몇 개 있는지 구하는 프로그램을 작성하시오. 입력 첫째 줄에 점의 개수 N과 선분의 개수 M…","fields":{"slug":"/boj-11663/"},"frontmatter":{"date":"January 15, 2025","title":"11663 선분 위의 점","tags":["Algorithm"]},"rawMarkdownBody":"\n## 선분 위의 점\n[백준 11663번 선분 위의 점](https://www.acmicpc.net/problem/2776)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 1 초   | 256 MB | 5062 | 1883 | 1406 | 37.049% |\n\n### 문제\n\n일차원 좌표상의 점 N개와 선분 M개가 주어진다. \n이때, 각각의 선분 위에 입력으로 주어진 점이 몇 개 있는지 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에 점의 개수 N과 선분의 개수 M이 주어진다.(1 ≤ N, M ≤ 100,000) \n둘째 줄에는 점의 좌표가 주어진다. \n두 점이 같은 좌표를 가지는 경우는 없다. \n셋째 줄부터 M개의 줄에는 선분의 시작점과 끝점이 주어진다. \n입력으로 주어지는 모든 좌표는 1,000,000,000보다 작거나 같은 자연수이다.\n\n### 출력\n\n입력으로 주어진 각각의 선분 마다, 선분 위에 입력으로 주어진 점이 몇 개 있는지 출력한다.\n\n---\n\n## 풀이\n\n문제의 시간 제한은 1초이다. 입력으로 주어지는 좌표의 개수는 최대 100,000개이다.\n그리고 탐색을 하여 몇개의 점이 선분위에 위치하는지 요구하는 문제인 것을 알 수 있다.\n그래서 이 문제는 이분 탐색 방식을 사용하고자 했다.\n문제 지문을 자세히 보고 생각난 풀이법은 백준 1654번 문제를 해결하기 위한 Upper Bound와 Lower Bound를 사용하는 방법을 사용하는 것을 떠올렸다.\nUpper Bound로 선분의 끝점보다 큰 점의 인덱스를 찾고, Lower Bound로 선분의 시작점보다 크거나 같은 점의 인덱스를 찾아서 두 인덱스의 차이를 구하면 된다.\n그리고 저번 문제에서 실수한 long 타입을 사용하지 않아서 발생한 오류를 방지하기 위해 long 타입을 사용했다.\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Point implements Comparable<Point> {\n    private final long coordinate;\n\n    private Point(long coordinate) {\n        this.coordinate = coordinate;\n    }\n\n    public static Point of(long coordinate) {\n        return new Point(coordinate);\n    }\n\n    public long getCoordinate() {\n        return coordinate;\n    }\n\n    @Override\n    public int compareTo(Point other) {\n        return Long.compare(this.coordinate, other.coordinate);\n    }\n}\n\nclass Segment {\n    private final Point startPoint;\n    private final Point endPoint;\n\n    private Segment(long startPoint, long endPoint) {\n        this.startPoint = Point.of(startPoint);\n        this.endPoint = Point.of(endPoint);\n    }\n\n    public static Segment of(long start, long end) {\n        return new Segment(start, end);\n    }\n\n    public Point getStartPoint() {\n        return startPoint;\n    }\n\n    public Point getEndPoint() {\n        return endPoint;\n    }\n}\n\nclass PointCounter {\n    private final List<Point> points;\n    private final List<Segment> segments;\n\n    private PointCounter(List<Point> points, List<Segment> segments) {\n        this.points = points;\n        this.segments = segments;\n    }\n\n    public static PointCounter of(List<Point> points, List<Segment> segments) {\n        return new PointCounter(points, segments);\n    }\n\n    private List<Long> count() {\n        Collections.sort(points);\n        List<Long> result = new ArrayList<>(segments.size());\n\n        for (Segment segment : segments) {\n            Point startPoint = segment.getStartPoint();\n            Point endPoint = segment.getEndPoint();\n\n            long leftIndex = lowerBound(points, startPoint);\n            long rightIndex = upperBound(points, endPoint);;\n\n            result.add(rightIndex - leftIndex);\n        }\n\n        return result;\n    }\n\n    private int lowerBound(List<Point> points, Point startPoint) {\n        int left = 0;\n        int right = points.size();\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n\n            if (points.get(mid).getCoordinate() >= startPoint.getCoordinate()) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    private int upperBound(List<Point> points, Point endPoint) {\n        int left = 0;\n        int right = points.size();\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n\n            if (points.get(mid).getCoordinate() > endPoint.getCoordinate()) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    public void printResult() {\n        StringBuilder output = new StringBuilder();\n        List<Long> result = count();\n        for (long count : result) {\n            output.append(count).append(\"\\n\");\n        }\n        System.out.print(output);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int N = Integer.parseInt(tokenizer.nextToken());// 점의 개수, 1 <= N <= 100,000\n        int M = Integer.parseInt(tokenizer.nextToken());// 선분의 개수, 1 <= M <= 100,000\n\n        tokenizer = new StringTokenizer(reader.readLine());\n        List<Point> points = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            long point = Long.parseLong(tokenizer.nextToken());\n            Point newPoint = Point.of(point);\n            points.add(newPoint);\n        }\n\n        List<Segment> segments = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            tokenizer = new StringTokenizer(reader.readLine());\n            long start = Long.parseLong(tokenizer.nextToken());\n            long end = Long.parseLong(tokenizer.nextToken());\n            Segment newSegment = Segment.of(start, end);\n            segments.add(newSegment);\n        }\n\n        PointCounter.of(points, segments).printResult();\n    }\n}\n\n```"},{"excerpt":"랜선 자르기 백준 1654번 랜선 자르기 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 254208 61202 41370 21.687% 문제 집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다.\n박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.  이미 오영식은 자체적으로 …","fields":{"slug":"/boj-1654/"},"frontmatter":{"date":"January 14, 2025","title":"1654 랜선 자르기","tags":["Algorithm"]},"rawMarkdownBody":"\n\n## 랜선 자르기\n[백준 1654번 랜선 자르기](https://www.acmicpc.net/problem/1654)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 256 MB | 254208 | 61202 | 41370 | 21.687% |\n\n### 문제\n\n집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. \n박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다. <br>\n\n이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. \n그러나 K개의 랜선은 길이가 제각각이다. \n박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. \n예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.) <br>\n\n편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. \n그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. \nN개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. \n이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.\n\n### 입력\n\n첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. \nK는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. \n그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. \n랜선의 길이는 231-1보다 작거나 같은 자연수이다.\n\n### 출력\n\n첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.\n\n---\n\n## 풀이\n\n랜선 자르기 문제는 탐색 알고리즘을 사용해 해결해야 하는 전형적인 문제다. \n문제를 분석해 보면, 랜선의 최대 길이를 구하기 위해 어떤 탐색 알고리즘을 선택해야 할지 판단해야 한다. \n시간 제한과 탐색해야 할 범위를 고려했을 때, 이 문제는 이분 탐색(Binary Search)을 사용해야 효율적으로 해결할 수 있다.\n\n단순히 순차 탐색(Linear Search)을 사용하는 경우, \n랜선의 개수 $K$는 최대 $10^4$과 필요한 랜선의 개수 $N$이 최대 $10^6$까지 주어질 수 있으므로 \n최악의 경우 $O(K \\times N)$의 시간이 소요된다. \n이는 약 $10^{10}$번의 연산으로, 현실적으로 시간 제한에 걸리게 된다. \n따라서 더 나은 시간 복잡도를 제공하는 이분 탐색을 사용하는 것이 적합합니다. \n이분 탐색은 $O(K \\cdot \\log M)$의 시간 복잡도를 가지며, 여기서 $M$은 가장 긴 랜선의 길이다.\n\n이분 탐색을 적용하기 위해서는 다음과 같은 과정이 필요하다.\n\n### 랜선 길이의 범위 설정\n- 최소 길이는 $1$, 최대 길이는 주어진 랜선 길이 중 가장 긴 값으로 설정한다.\n- 중간값을 기준으로 탐색하며 범위를 점점 좁혀간다.\n\n### 랜선 자르기 개수 계산\n- 현재 중간값으로 랜선을 자를 경우 몇 개의 랜선을 만들 수 있는지 계산한다.\n- 필요한 랜선 개수 $N$ 이상을 만들 수 있는 경우, 더 긴 길이를 탐색한다.\n- 필요한 랜선 개수 $N$ 미만인 경우, 더 짧은 길이를 탐색한다.\n\n### 결과 저장\n- 조건을 만족하는 경우, 중간값을 최적의 값으로 저장하고 탐색이 끝날 때까지 반복한다.\n\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass LanCableCutter {\n    private final int number;\n    private final int target;\n    private final long[] cables;\n\n    private LanCableCutter(int number, int target, long[] cables) {\n        this.number = number;\n        this.target = target;\n        this.cables = cables;\n    }\n\n    public static LanCableCutter from(int number, int target, long[] cables) {\n        return new LanCableCutter(number, target, cables);\n    }\n\n    private long getMax() {\n        return Arrays.stream(cables).max().getAsLong();\n    }\n\n    private long cut() {\n        long min = 1;\n        long max = getMax();\n        long length = 0;\n\n        while(min <= max) {\n            long count = 0;\n            long mid = (min + max ) / 2;\n            for(int i = 0; i < number; i++) {\n                count += cables[i] / mid;\n            }\n            if (count >= target) {\n                length = mid;\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n\n        return length;\n    }\n\n    public void getResult() {\n        System.out.println(cut());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        int number = Integer.parseInt(tokenizer.nextToken());\n        int target = Integer.parseInt(tokenizer.nextToken());\n        long[] array = new long[number];\n        for (int i = 0; i < number; i++){\n            array[i] = Long.parseLong(reader.readLine());\n        }\n        LanCableCutter.from(number, target, array).getResult();\n    }\n}\n```"},{"excerpt":"암기왕 백준 2776번 암기왕 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 34230 11755 7914 32.139% 문제 연종이는 엄청난 기억력을 가지고 있다.\n그래서 하루 동안 본 정수들을 모두 기억 할 수 있다.\n하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다.\n동규는 연종을 따라 다니며, 연종이 …","fields":{"slug":"/boj-2776/"},"frontmatter":{"date":"January 13, 2025","title":"2776 암기왕","tags":["Algorithm"]},"rawMarkdownBody":"\n## 암기왕\n[백준 2776번 암기왕](https://www.acmicpc.net/problem/2776)\n\n| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |\n|:------|:-------|:-------|:------|:------|:--------|\n| 2 초   | 256 MB | 34230 | 11755 | 7914 | 32.139% |\n\n### 문제\n\n연종이는 엄청난 기억력을 가지고 있다. \n그래서 하루 동안 본 정수들을 모두 기억 할 수 있다. \n하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. \n동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다. \n그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. \n질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다. \n연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다. \n집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다. \n동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자.\n\n### 입력\n\n첫째 줄에 테스트케이스의 개수 T가 들어온다. \n다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다. \n그 다음 줄에  ‘수첩 1’에 적혀 있는 정수들이 N개 들어온다. \n그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다. \n모든 정수들의 범위는 int 로 한다.\n\n### 출력\n\n‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다.\n\n---\n\n## 풀이\n\n문제를 보면 해당 문제는 탐색 알고리즘을 사용해서 해결하라는 것을 알 수 있다.\n어떤 탐색 알고리즘을 사용하냐는 시간제한과 실제 탐색해야할 개수를 보고 선택해야 한다.\n내가 생각한 건 2가지 방식이다.\n하나는 순차 탐색하여 해결하는 방식과 나머지 하나는 이분 탐색으로 해결하는 방식이다.\n직접 탐색에 경우는 `N`과 `M`이 각가 최대 $10^6$이므로 단순히 순차 탐색(Linear Search)을 하면 최악의 경우 $O(N \\times M)$의 시간이 소요된다.\n이렇게 하면 $10^6 \\times 10^6(ms) \\approx 166(s)$이므로 시간 제한에 걸린다.\n따라서, 이보다 더 빠른 $O(M \\log N)$ 복잡도를 가진 이분 탐색(Binary Search)로 구현을 필요로 한다.\n\n이분 탐색은 정렬된 배열에서만 사용해야하기에 `수첩1`의 데이터를 정렬하고 `수첩2`의 데이터를 탐색하는 코드를 구현했다.\n\n\n```java\npackage test.code;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Notebook {\n    private final int[] numbers;\n\n    Notebook(int count, String input, boolean shouldSort) {\n        int[] numbers = new int[count];\n        numbers = Arrays.stream(input.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        if (shouldSort) {\n            Arrays.sort(numbers);\n        }\n        this.numbers = numbers;\n    }\n\n    public static Notebook from(int count, String text, boolean shouldSort) {\n        return new Notebook(count, text, shouldSort);\n    }\n\n    public int[] getNumbers() {\n        return numbers;\n    }\n\n    public boolean contains(int number) {\n        return Arrays.binarySearch(numbers, number) >= 0;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int T = Integer.parseInt(br.readLine()); // 테스트케이스 개수\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0; i < T; i++) {\n            int N = Integer.parseInt(br.readLine());\n            Notebook notebook1 = Notebook.from(N, br.readLine(), true);// 수첩 1\n            int M = Integer.parseInt(br.readLine());\n            Notebook notebook2 = Notebook.from(M, br.readLine(), false);// 수첩 2\n\n            StringBuilder sb = new StringBuilder();\n\n            for(int number : notebook2.getNumbers()) {\n                if(notebook1.contains(number)) {\n                    sb.append(1).append(\"\\n\");\n                } else {\n                    sb.append(0).append(\"\\n\");\n                }\n            }\n            result.append(sb);\n        }\n        System.out.println(result);\n    }\n}\n```"},{"excerpt":"LIMIT  절은 쿼리 결과에서 지정한 행 수만 레코드를 제한하여 가져오는데 사용한다. 위의 쿼리는  테이블에서 10개의 레코드만 가져온다.\n이때 MySQL의  절은 항상 쿼리의 마지막에 실행된다.  절은 두 개의 인수를 가질 수 있다.\n첫 번째 인수는 가져올 레코드의 시작 위치를 나타내며, 두 번째 인수는 가져올 레코드의 수를 나타낸다. 위의 쿼리는  …","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"date":"January 11, 2025","title":"MySQL의 Pagination","tags":["Database","MySQL"]},"rawMarkdownBody":"\n\n## LIMIT\n`LIMIT` 절은 쿼리 결과에서 지정한 행 수만 레코드를 제한하여 가져오는데 사용한다.\n\n```sql\nSELECT * FROM table_name LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 10개의 레코드만 가져온다.\n이때 MySQL의 `LIMIT` 절은 항상 쿼리의 마지막에 실행된다.\n\n`LIMIT` 절은 두 개의 인수를 가질 수 있다.\n첫 번째 인수는 가져올 레코드의 시작 위치를 나타내며, 두 번째 인수는 가져올 레코드의 수를 나타낸다.\n\n```sql\nSELECT * FROM table_name LIMIT 5, 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 6번째부터 15번째까지의 레코드를 가져온다.\n\n## OFFSET\n\n`OFFSET` 절은 `LIMIT` 절과 함께 사용되어, 결과에서 지정한 행 수만큼 건너뛴 후 레코드를 가져오는데 사용된다.\n\n```sql\nSELECT * FROM table_name LIMIT 5 OFFSET 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 11번째부터 15번째까지의 레코드를 가져온다.\n\n`OFFSET` 절은 `LIMIT` 절과 함께 사용되어야 하며, `LIMIT` 절보다 먼저 사용될 수 없다.\n\n## Pagination\n\n`LIMIT`과 `OFFSET`을 사용하면 페이지네이션을 구현할 수 있다.\n예를 들어, 한 페이지에 10개의 레코드를 보여주고 싶다면, 다음과 같이 쿼리를 작성할 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 0, 10;\n```\n\n다음 페이지를 보여주고 싶다면, `OFFSET`을 사용하여 다음 페이지의 레코드를 가져올 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 10, 10;\n```\n\n이렇게 `LIMIT`과 `OFFSET`을 사용하면 페이지네이션을 쉽게 구현할 수 있다.\n\n## No OFFSET\n\n`LIMIT`을 사용할 때 주의 해야 할 것이 있는데 `LIMIT` 절의 `OFFSET`이 큰 경우 성능이 저하될 수 있다.\n\n```sql\nSELECT * FROM table_name LIMIT 0, 10; -- 10 rows in 0.0001 seconds\nSELECT * FROM table_name LIMIT 1000000, 10; -- 10 rows in 0.1 seconds\n```\n\n위의 쿼리는 `table_name` 테이블에서 1,000,000번째부터 1,000,010번째까지의 레코드를 가져온다.\n이때 `OFFSET`이 큰 경우 MySQL은 `OFFSET`만큼의 레코드를 건너뛴 후 결과를 가져오기 때문에 성능이 저하될 수 있다.\n\n따라서 `LIMIT`을 사용할 때는 `OFFSET`을 최대한 작게 사용하는 것이 좋다.\n즉, `LIMIT 0, 10`과 같이 `OFFSET`을 0으로 설정하는 것이 좋다.\n\n```sql\nSELECT * FROM table_name WHERE id < 1000000 ORDER BY id DESC LIMIT 10; -- 10 rows in 0.0001 seconds\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 1,000,000보다 작은 레코드를 가져온다.\n이렇게 `WHERE` 절을 사용하여 `OFFSET`을 최대한 작게 사용하면 성능을 향상시킬 수 있다.\n\n## cursor\n\n`LIMIT`과 `OFFSET`을 사용하여 페이지네이션을 구현할 수 있지만, `OFFSET`이 큰 경우 성능이 저하될 수 있다.\n이러한 문제를 해결하기 위해 `cursor`를 사용할 수 있다.\n\n`cursor`는 `LIMIT`과 `OFFSET`을 사용하지 않고 페이지네이션을 구현할 수 있는 방법이다.\n`cursor`는 이전 페이지의 마지막 레코드를 기준으로 다음 페이지의 레코드를 가져오는 방식이다.\n\n```sql\nSELECT * FROM table_name WHERE id > 0 ORDER BY id LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 0보다 큰 레코드를 가져온다.\n이때 `ORDER BY` 절을 사용하여 `id`를 기준으로 정렬하고, `LIMIT`을 사용하여 10개의 레코드를 가져온다.\n\n다음 페이지를 가져오기 위해서는 이전 페이지의 마지막 레코드를 기준으로 `WHERE` 절을 사용하여 다음 페이지의 레코드를 가져올 수 있다.\n\n```sql\nSELECT * FROM table_name WHERE id > 10 ORDER BY id LIMIT 10;\n```\n\n위의 쿼리는 `table_name` 테이블에서 `id`가 10보다 큰 레코드를 가져온다.\n이렇게 `cursor`를 사용하면 `OFFSET`을 사용하지 않고 페이지네이션을 구현할 수 있다.\n\n`cursor`를 사용하면 `OFFSET`을 사용하지 않기 때문에 성능이 향상될 수 있다.\n따라서 `cursor`를 사용하여 페이지네이션을 구현하는 것이 좋다."},{"excerpt":"테이블의 데이터를 삭제 시 , ,  을 사용할 수 있다. 각각의 차이점을 알아보자. DELETE 는 데이터를 하나하나 삭제면서 제거하는 방식이다.\n 절을 사용하여 조건에 맞는 행만 삭제할 수 있다.\n이러한 방식으로 데이터를 삭제해서 다른 삭제 방식보다는 느리지만 을 하지 않으면 으로 데이터는 복구할 수 있다. TRUNCATE 는 테이블의 모든 데이터를 삭…","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"date":"January 10, 2025","title":"MySQL의 DELETE, TRUNCATE, DROP 차이","tags":["Database","MySQL"]},"rawMarkdownBody":"\n\n테이블의 데이터를 삭제 시 `DELETE`, `TRUNCATE`, `DROP` 을 사용할 수 있다. 각각의 차이점을 알아보자.\n\n## DELETE\n`DELETE`는 데이터를 하나하나 삭제면서 제거하는 방식이다.\n`WHERE` 절을 사용하여 조건에 맞는 행만 삭제할 수 있다.\n이러한 방식으로 데이터를 삭제해서 다른 삭제 방식보다는 느리지만 `COMMIT`을 하지 않으면 `ROLLBACK`으로 데이터는 복구할 수 있다.\n\n```sql\nDELETE FROM table_name WHERE condition;\n```\n\n## TRUNCATE\n\n`TRUNCATE`는 테이블의 모든 데이터를 삭제하는 방식이다.\n`DELETE`와 달리 `WHERE` 절을 사용할 수 없다.\n`TRUNCATE`는 `COMMIT`을 자동으로 실행하기에  `ROLLBACK`으로 데이터를 복구할 수 없다.\n\n```sql\nTRUNCATE table_name;\n```\n\n## DROP\n\n`DROP`은 테이블 자체를 삭제하는 방식이다.\n테이블을 삭제하면 테이블의 구조와 데이터 모두 삭제된다.\n`DROP` 또한 `COMMIT`을 자동으로 실행하기에 `ROLLBACK`으로 데이터를 복구할 수 없다.\n\n```sql\nDROP table_name;\n```\n\n[//]: # (SELECT FOR UPDATE 가 배타락인지)"},{"excerpt":"캐시는 데이터를 저장하는 장소로, 데이터를 빠르게 조회할 수 있도록 도와주어 성능 향상과 부하 감소를 목표로 한다.\n이때 캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도 한다.\n따라서, 캐싱 전략을 이해하는 것은 중요하다. Cache Aside(Lazy Loading) Cache Aside 방식은 캐시 히트 시 캐시에서 데이터를 불러오며, 캐시 미스 …","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"date":"January 09, 2025","title":"캐싱 전략(Caching Strategy)","tags":["Database"]},"rawMarkdownBody":"\n캐시는 데이터를 저장하는 장소로, 데이터를 빠르게 조회할 수 있도록 도와주어 성능 향상과 부하 감소를 목표로 한다.\n이때 캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도 한다.\n따라서, 캐싱 전략을 이해하는 것은 중요하다.\n\n## Cache Aside(Lazy Loading)\nCache Aside 방식은 캐시 히트 시 캐시에서 데이터를 불러오며, 캐시 미스 발생 시 원본 데이터베이스에서 조회하여 반환한다.\n애플리케이션은 캐시 미스가 발생하면 해당 데이터를 캐시에 적재한다.\n\n해당 방식은 실제 요청된 데이터만 캐시에 저장되므로 불필요한 데이터 캐싱을 줄일 수 있다.\n또한, 캐시에 문제가 발생해도 애플리케이션은 원본 데이터베이스 직접 접근할 수 있기 때문에 서비스가 계속 작동할 수 있다는 장점이 있다.\n하지만, 캐시 미스가 발생하는 경우에만 데이터를 캐시에 적재하기 때문에 원본 데이터베이스와 같은 데이터가 아닐 수도 있으며,\n초기에는 대량의 캐시 미스로 인한 데이터베이스 부하가 발생할 수 있다.\n\n## 캐시 불일치를 해소할 수 있는 쓰기 전략\n캐시 불일치(Cachge Inconsistency) 란 원본 데이터베이스에 저장된 데이터와 캐시에 저장된 데이터가 서로 다른 상황을 의미한다.\nWrite Through, Cache Invalidation, Write Behind 방식으로 이러한 캐시 불일치를 해소할 수 있다.\n\n### Write Through\nWrite Through 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n매번 캐시에 해당 데이터를 찾아 함께 변경하는 방식이다.\n2번 쓰기가 발생하지만, 캐시는 항상 최신 데이터를 가지고 있다.\n캐시는 다시 조회되는 경우에 빛을 발휘한다.\n무작정 데이터를 갱신하거나 저장하는 방식은 리소스 낭비가 될 수 있으니 해당 방식을 사용하는 경우, 만료 시간을 사용하는 것이 권장된다.\n\n### Cache Invalidation\nCache Invalidation 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n캐시 데이터를 만료시키는 방식이다.\nWrite Through 방식의 단점을 보완한 방식이며 캐시에 데이터가 삭제되니 캐시 불일치에 대한 걱정을 하지 않아도 된다.\n\n### Write Behind(Write Back)\nWrite Behind(Write Back) 방식은 원본 데이터에 대한 변경분이 생긴 경우,\n캐시를 먼저 업데이트한 이후 추후에 원본 데이터를 변경한다.\n디스크 쓰기 작업을 비동기 작업으로 수행하여 성능을 개선할 수 있다.\n원본 데이터와 캐시가 일시적으로 일치하지 않을 수 있있기 때문에\n쓰기 작업이 빈번하며 일시적인 캐시 불일치를 허용하는 서비스에서 유용하게 사용될 수 있다.\n\n## 참고\n- [10분 테코톡 저문, 라온의 Cache & Redis](http://youtube.com/watch?feature=shared&v=tVZ15cCRAyE)\n- [잘못된 캐싱 전략이 당신의 서비스를 망치고 있습니다](https://maily.so/devpill/posts/8do7dxleogq)"},{"excerpt":"제약 조건(Constraints) 제약 조건이란 데이터의 무결성을 보장하기 위해, 데이터베이스에 저장되는 데이터의 논리적인 조건을 의미한다.\n이러한 제약 조건은 문을 사용하여 테이블을 생성할 때나,\n문을 사용하여 테이블을 생성한 후에 제약조건을 지정할 수 있다.\n이와 같은 DDL(Data Definition Language) 문을 사용하여 테이블에 설정할…","fields":{"slug":"/database-constraints/"},"frontmatter":{"date":"January 09, 2025","title":"제약 조건(Constraints)","tags":["Database"]},"rawMarkdownBody":"\n\n## 제약 조건(Constraints)\n제약 조건이란 데이터의 무결성을 보장하기 위해, 데이터베이스에 저장되는 데이터의 논리적인 조건을 의미한다.\n이러한 제약 조건은 `CREATE TABLE`문을 사용하여 테이블을 생성할 때나,\n`ALTER TABLE`문을 사용하여 테이블을 생성한 후에 제약조건을 지정할 수 있다.\n이와 같은 DDL(Data Definition Language) 문을 사용하여 테이블에 설정할 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type CONSTRAINT constraint_name constraint_type\n);\n```\n\n## NOT NULL\n`NOT NULL` 제약 조건은 특정 컬럼에 NULL 값을 허용하지 않도록 설정하는 제약 조건이다.\n테이블의 필드를 `NOT NULL`로 설정하면, 해당 필드에는 `NULL` 값의 저장을 허용하지 않는다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type NOT NULL\n);\n```\n\n```sql\nALTER TABLE table_name ADD CONSTRAINT constraint_name NOT NULL (column_name); -- ALTER TABLE 문을 사용하여 제약 조건 추가\nALTER TABLE table_name MODIFY column_name data_type NOT NULL; -- ALTER TABLE 문을 사용하여 제약 조건 수정\n```\n\n## UNIQUE\n\n`UNIQUE` 제약 조건은 특정 컬럼에 중복된 값을 허용하지 않도록 설정하는 제약 조건이다.\n이 제약 조건은 테이블의 각 행을 고유하게 식별하는데 사용된다.\n즉, 특정 열의 경우 모든 행은 고유한 값을 가져야 한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type UNIQUE -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name UNIQUE (column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type UNIQUE; -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name); -- 이름 설정 가능\n```\n\n`UNIQUE` 제약 조건을 설정하면, 해당 필드는 자동으로 보조 인덱스(INDEX)가 생성된다.\n만일 제약 조건에 이름을 설정하면, 다음과 같은 쿼리로 해당 제약 조건을 삭제할 수 있다.\n\n```sql\nALTER TABLE table_name DROP INDEX constraint_name;\nDROP INDEX constraint_name ON table_name;\n```\n\n## PRIMARY KEY\n`PRIMARY KEY` 제약 조건은 테이블의 각 행을 고유하게 식별하는데 사용되는 제약 조건이다.\n테이블의 필드가 기본 키인 경우 필드는 `NULL` 값을 포함할 수 없으며 모든 행은 이 필드에 대해 고유한 값을 가져야 한다.\n즉, `PRIMARY KEY` 제약 조건은 `UNIQUE` 제약 조건과 `NOT NULL` 제약 조건을 모두 포함한다.\n테이블은 기본 키로 하나의 필드만 가질 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type PRIMARY KEY -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name PRIMARY KEY (column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type PRIMARY KEY; -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name); -- 이름 설정 가능\n```\n\n## FOREIGN KEY\n`FOREIGN KEY` 제약 조건은 참조하는 테이블의 기본 키를 참조하는 필드이다.\n이때 반드시 `UNIQUE`나 `PRIMARY KEY` 제약 조건이 설정되어 있어야 한다.\n일반적으로 이렇게 테이블 간에 일종의 관계를 만든다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name \n    ADD CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name); -- 이름 설정 가능\n```\n\n## CHECK\n`CHECK` 제약 조건은 특정 컬럼에 저장할 수 있는 값의 범위를 제한하는 제약 조건이다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type CHECK (condition) -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name CHECK (condition) -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type CHECK (condition); -- 이름 설정 불가\nALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK (condition); -- 이름 설정 가능\n```\n\n## DEFAULT\n`DEFAULT` 제약 조건은 특정 컬럼에 기본값을 설정하는 제약 조건이다.\n이 제약 조건은 특정 컬럼에 값을 입력하지 않았을 때, 자동으로 설정된 기본값이 입력된다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type DEFAULT default_value -- 테이블 생성 시 제약 조건 추가\n);\n```\n\n```sql\nALTER TABLE table_name ADD column_name data_type DEFAULT default_value; -- 이름 설정 불가\n```\n\n## ON DELETE / ON UPDATE\n`ON DELETE`와 `ON UPDATE` 제약 조건은 외래 키 제약 조건을 설정할 때 사용된다.\n`ON DELETE` 제약 조건은 참조하는 테이블의 행이 삭제될 때, 참조하는 테이블의 행에 대한 처리 방법을 설정한다.\n반면, `ON UPDATE` 제약 조건은 참조하는 테이블의 행이 업데이트될 때, 참조하는 테이블의 행에 대한 처리 방법을 설정한다.\n\n이때 참조한고 있는 테이블의 동작은 다음 키워드를 사용하여 `FOREIGN KEY` 제약 조건을 설정할 때 설정할 수 있다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE action ON UPDATE action -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n```sql\nALTER TABLE table_name \n    ADD CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE action ON UPDATE action; -- 이름 설정 가능\n```\n\n설정할 수 있는 `action`은 다음과 같다.\n\n- `CASCADE`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행도 삭제되거나 업데이트된다.\n- `SET NULL`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행의 외래 키 값을 `NULL`로 설정한다.\n- `SET DEFAULT`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행의 외래 키 값을 기본값으로 설정한다.\n- `RESTRICT`: 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행이 삭제되거나 업데이트되지 않는다.\n- `NO ACTION`: `RESTRICT`와 동일한 동작을 수행한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE CASCADE ON UPDATE CASCADE -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n## CASCADE\n`CASCADE` 제약 조건은 참조하는 테이블의 행이 삭제되거나 업데이트될 때, 참조하는 테이블의 행도 삭제되거나 업데이트 하게 하여 참조 무결성을 유지한다.\n\n```sql\nCREATE TABLE table_name (\n    column_name data_type,\n    CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES another_table_name (another_column_name) ON DELETE CASCADE ON UPDATE CASCADE -- 테이블 생성 시 제약 조건 추가 및 제약 이름 설정\n);\n```\n\n하지만, `CASCADE` 제약 조건은 데이터의 무결성 유지하는데 유용하지만 위협할 수 있으므로 주의해서 사용해야 한다.\n대표적인 예로, 부모 테이블의 행이 삭제되면 자식 테이블의 행도 삭제되는데, 이러한 경우 데이터 손실이 발생할 수 있다."},{"excerpt":"SQL(Structured Query Language) SQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 조작하기 위한 구조화된 질의 언어이다.\n기능에 따라 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 데이터 제어 언어(DCL) 등으로 나뉜다. SQL 동작 과정 SQL은 데이터베이스에 대한 질의를 수행하기…","fields":{"slug":"/database-sql/"},"frontmatter":{"date":"January 08, 2025","title":"SQL(Structured Query Language)","tags":["Database"]},"rawMarkdownBody":"\n## SQL(Structured Query Language)\nSQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 조작하기 위한 구조화된 질의 언어이다.\n기능에 따라 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 데이터 제어 언어(DCL) 등으로 나뉜다.\n\n### SQL 동작 과정\nSQL은 데이터베이스에 대한 질의를 수행하기 위해 다음과 같은 과정을 거친다.(MySQL 기준)\n\n1. 사용자가 작성한 SQL 문장을 데이터베이스로 전송한다.\n2. MySQL 쿼리 파서는 SQL 문장을 토큰으로 분리하여 트리를 생성한다. 이 트리 Parse Tree라고 하는데 이를 통해 문장의 구조를 파악하여 쿼리를 실행한다. 이 과정에서 문법 오류도 검출한다.\n3. 다음으로 전처리기가 Parse Tree를 기반으로 SQL 문장구조에 문제가 없는지 검사한다. 이 과정에서 테이블이나 컬럼이 유효한지, 사용자가 접근권한이 있는지 등을 검사한다.\n4. 옵티마이저가 SQL 실행을 최적화하기 위해 실행 계획을 수립한다.\n5. 마지막으로 쿼리 실행 엔진이 옵티마이저가 수립한 실행 계획을 기반으로 스토리지 엔진을 호출해서 쿼리를 수행하고 결과를 반환한다.\n\n## SQL 문장 종류\n\n### DDL(Data Definition Language)\nDDL(Data Definition Language)은 데이터 정의어로 테이블 생성, 변경, 삭제 등 데이터베이스의 구조를 정의하는 명령어이다.\n주요 DDL 명령어로는 `CREATE`, `ALTER`, `DROP`, `TRUNCATE` 등이 있다.\n\n### DML(Data Manipulation Language)\nDML(Data Manipulation Language)은 데이터 조작어로 데이터베이스에 저장된 데이터를 조회, 삽입, 수정, 삭제하는 명령어이다.\n주요 DML 명령어로는 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 등이 있다.\n\n### DCL(Data Control Language)\nDCL(Data Control Language)은 데이터 제어어로 데이터베이스에 저장된 데이터에 대한 접근 권한을 제어하는 명령어이다.\n주요 DCL 명령어로는 `GRANT`, `REVOKE` 등이 있다.\n\n## CASCADE\nCASCADE는 외래 키 제약 조건을 설정할 때 사용되는 옵션 중 하나로, 참조하는 테이블의 레코드가 변경되거나 삭제될 때 참조하는 테이블의 레코드도 함께 변경되거나 삭제되도록 설정하는 것이다.\n하지만 CASCADE 옵션을 사용할 때는 주의해야 한다.\nCASCADE 옵션을 사용하면 참조하는 테이블의 레코드가 변경되거나 삭제될 때 참조되는 테이블의 레코드도 함께 변경되거나 삭제되므로 데이터 무결성에 영향을 줄 수 있다.\n그래서 실무에서는 CASCADE 옵션을 사용할 때는 신중하게 사용해야 한다.\n\n## VIEW\nVIEW는 하나 이상의 테이블로부터 유도된 가상 테이블로, 실제 데이터를 저장하지 않고 SELECT 문을 통해 필요한 데이터를 동적으로 생성하는 객체이다.\nVIEW는 데이터를 저장하지 않고 SELECT 문을 통해 필요한 데이터를 동적으로 생성하기 때문에 실제 데이터를 변경하지 않고도 데이터를 조회하거나 조작할 수 있다.\n또한 원본 테이블을 노출시키지 않게 함으로 데이터 보안성을 제공할 수 있다.\n\n## 질의 처리 과정\nMySQL에서 SQL 질의 처리 과정은 다음과 같다.\n\n1. FROM 절에서 타겟 테이블이 정해진다. 이때, 테이블을 참조할 때는 테이블에 대한 락을 걸어 다른 사용자가 변경하지 못하도록 한다.\n2. WHERE 절에서 조건에 맞는 투플이 필터링 된다. 이때, 인덱스를 사용하여 검색 속도를 높일 수 있다.\n3. GROUP BY 절에서 지정한 컬럼을 기준으로 그룹핑이 이루어진다.\n4. `DISTINCT`가 사용되면 중복된 투플이 필터링 된다.\n5. HAVING이 사용되어 적용되면 GROUP BY 절에서 그룹핑된 투플에 대한 추가 필터링이 이루어진다.\n6. ORDER BY 절에서 지정한 컬럼을 기준으로 정렬이 이루어진다.\n7. LIMIT이 사용되어 적용되면 결과 튜플의 개수가 제한이 되어 반환된다.\n\n## SELECT FOR UPDATE\n`SELECT FOR UPDATE`를 사용하면 트랜잭션 내에서 특정 행을 읽을 때 해당 행에 대한 락을 걸어 다른 트랜잭션이 해당 행을 변경하지 못하도록 한다.\n\n## GROUP BY\n`GROUP BY`는 특정 컬럼을 기준으로 그룹핑을 하여 그룹별로 집계 함수를 적용할 수 있도록 하는 절이다.\n주로 집계 함수와 함께 사용되며, 집계 함수를 사용하지 않는 경우에는 `DISTINCT`와 비슷한 역할을 한다.\n\n```sql\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE condition\nGROUP BY column_name;\n```\n\n## ORDER BY\n`ORDER BY`절을 사용해서 특정 컬럼을 기준으로 조회 결과를 정렬할 수 있다.\n기본적으로 오름차순(ASC)으로 정렬되며, 내림차순(DESC)으로 정렬하려면 DESC 키워드를 사용한다.\n\n```sql\nSELECT column_name\nFROM table_name\nORDER BY column_name ASC|DESC;\n```\n\n## JOIN\n`JOIN`은 두 개 이상의 테이블을 연결하여 하나의 결과 집합으로 만드는 연산이다.\n```sql\nSELECT column_name(s)\nFROM table1\nJOIN table2\nON table1.column_name = table2.column_name;\n```\n\n### INNER JOIN과 OUTER JOIN\n\nINNER JOIN 을 통해 두 테이블의 교집합을 구할 수 있다.\n```sql\nSELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;\n```\n\nOUTER JOIN은 INNER JOIN과 달리 두 테이블의 합집합을 구할 수 있다.\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n## LEFT OUTER JOIN과 RIGHT OUTER JOIN\nLEFT OUTER JOIN은 왼쪽 테이블의 모든 행과 오른쪽 테이블의 일치하는 행을 반환한다.\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n이떄 왼쪽 테이블의 모든 행을 반환하고 오른쪽 테이블의 일치하는 행이 없는 경우에는 NULL 값을 반환한다.\n\nRIGHT OUTER JOIN은 LEFT OUTER JOIN과 반대로 오른쪽 테이블의 모든 행과 왼쪽 테이블의 일치하는 행을 반환한다.\n```sql\nSELECT column_name(s)\nFROM table1 \nRIGHT JOIN table2\nON table1.column_name = table2.column_name;\n```\n\n## CROSS JOIN\n\nCROSS JOIN을 하면 두 테이블의 가능한 모든 조합 결과를 생성해 반환한다.\n두 테이블의 각 레코드 수를 곱한 개수만큼 결과가 반환된다.\n카테시안 곱이라고도 한다.\n```sql\nSELECT column_name(s)\nFROM table1\nCROSS JOIN table2;\n```\n\n## Subquery\n\n서브쿼리는 쿼리문 안에 또 다른 쿼리문을 사용하는 것이다.\n서브쿼리는 주로 WHERE 절, FROM 절, SELECT 절, HAVING 절에 사용된다.\n\n## DROP, TRUNCATE, DELETE\n\n### TRUNCATE\n`TRUNCATE`는 테이블의 모든 행을 삭제하지만 테이블 스키마는 그대로 남겨둔다.\n수행 시 DELETE처럼 행마다 로그를 남기지 않고 테이블 전체를 한 번에 삭제하기 때문에 속도가 빠르다.\n하지만 ROLLBACK이 불가능하고, 테이블에 대한 LOCK이 걸리기 때문에 다른 사용자가 해당 테이블을 사용하지 못한다.\n또한 AUTO_INCREMENT 값도 초기화 되기도 한다.\n\n### DELETE\n\n`DELETE`는 DML로 테이블의 행을 삭제하는 명령어이다. DELETE는 행마다 로그를 남기기 때문에 ROLLBACK이 가능하다.\n하지만 DELETE는 행마다 로그를 남기기 때문에 TRUNCATE보다 속도가 느리다.\nWHERE 절을 사용하여 특정 행만 삭제할 수 있다.\n\n### DROP\n\n`DROP`은 DDL로 테이블을 삭제하는 명령어이다. 테이블을 삭제하면 테이블 스키마와 데이터 모두 삭제된다.\n데이터를 복구할 수 없으므로 주의해서 사용해야 한다.\n\n## DISTINCT\n\n`DISTINCT`는 중복된 행을 제거하는 명령어이다.\n```sql\nSELECT DISTINCT column_name\nFROM table_name;\n```\n\n## SQL Injection\n\nSQL Injection은 악의적인 사용자가 웹 애플리케이션의 입력 폼에 SQL 쿼리를 삽입하여 데이터베이스를 비정상적으로 조작하는 공격이다.\n\n실행할 SQL 구문을 미리 Prepared Statement로 정해두고, 사용자 입력값에 따라 매핑하여 파라미터로만 전달하는 방식을 사용하면, SQL Injection을 통해 비정상적인 쿼리 수행을 방지할 수 있다.\n\n## SQL Anti Patterns\n\nSQL Anti Patterns는 SQL을 사용할 때 발생할 수 있는 잘못된 사용 방법을 말한다.\n\n1. SELECT *\n2. SELECT DISTINCT\n3. SELECT COUNT(*)\n8. SELECT column FROM table WHERE column LIKE '%value%'\n9. SELECT column FROM table WHERE column = NULL\n10. SELECT column FROM table WHERE column != value\n11. SELECT column FROM table WHERE column = value OR column = value2\n\n특히, SELECT 절에서 LIKE를 사용할 때 와일드 카드를 앞뒤로 사용하는 방식 `%value%`은\n앞의 와일드 카드로 인해 정렬 기준이 없어져서 인덱스를 사용하지 못해서\n테이블을 Full Scan하기 때문에 성능이 떨어진다.\n이러한 안티패턴 사용을 지양 해야 한다.\n\n## Pagination\n\nPagination은 페이지 단위로 데이터를 나누어 보여주는 기능을 말한다.\nPagination을 구현할 때는 `LIMIT`와 `OFFSET`을 사용한다.\n\n```sql\nSELECT column_name\nFROM table_name\nLIMIT 10 OFFSET 10;\n```\n\n페이지 번호는 OFFSET을 통해, 페이지에 보여줄 데이터 수는 LIMIT을 통해 설정한다.\n"},{"excerpt":"관계형 데이터베이스 관리 시스템 관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)은\n관계형 데이터 모델을 기반으로 한 데이터베이스 관리 시스템을 말한다.\n대부분의 데이터베이스 시스템은 RDBMS를 기반으로 설계되어 있으며,\n대표적인 RDBMS로는 Oracle, MySQL, PostgreSQL…","fields":{"slug":"/database-rdbms/"},"frontmatter":{"date":"January 03, 2025","title":"관계형 데이터베이스 관리 시스템(RDBMS)","tags":["Database"]},"rawMarkdownBody":"\n## 관계형 데이터베이스 관리 시스템\n\n관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)은\n관계형 데이터 모델을 기반으로 한 데이터베이스 관리 시스템을 말한다.\n대부분의 데이터베이스 시스템은 RDBMS를 기반으로 설계되어 있으며,\n대표적인 RDBMS로는 Oracle, MySQL, PostgreSQL, SQL Server 등이 있다.\n\n## 관계형 데이터 모델\n\n관계형 데이터 모델은 데이터를 테이블 형태로 구조화하여 저장하는 데이터 모델이다.\n하나의 개체에 대한 데이터를 릴레이션에 저장하고, 릴레이션 간의 관계를 통해 데이터를 관리한다.\n그럼 릴레이션이란 무엇일까? 관계형 데이터 모델을 이해하기 위해서는 릴레이션에 대한 이해가 필요하다.\n릴레이션에 대해 알아보자.\n\n## 릴레이션\n릴레이션은 행과 열로 구성된 테이블을 말한다.\n관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이기도 하다.\n여기서 행은 레코드(Record)라고도 하며, 열은 속성(Attribute)이라고 한다.\n\n## 릴레이션 스키마와 릴레이션 인스턴스\n릴레이션은 스키마와 인스턴스로 구분된다.\n릴레이션 스키마(Relation Schema)는 릴레이션의 구조를 정의한 것으로,\n속성의 이름과 도메인을 정의한다.\n릴레이션 인스턴스(Relation Instance)는 릴레이션 스키마에 따라 실제 저장된 데이터를 말한다.\n\n### 릴레이션 스키마\n릴레이션 스키마는 릴레이션의 구조를 정의한 것으로, 속성의 이름과 도메인을 정의한다.\n속성의 이름은 속성을 식별하기 위한 이름인 건 알겠는데, 도메인은 무엇일까?\n도메인은 속성이 가질 수 있는 값의 범위를 정의한 것으로, 속성의 타입을 정의한다.\n컴퓨터는 속성만으로 어떤 타입의 값인지 알 수 없기 때문에, 속성의 도메인을 정의하여 속성의 타입을 명시한다.\n참고로 이런 속성 집합의 개수를 차수(Degree)라고 한다.\n\n예를 들어 만약 상품 릴레이션은 상품명, 가격, 수량의 속성을 가진다면,\n상품명은 문자열, 가격은 숫자, 수량은 정수와 같이 속성의 도메인을 정의할 수 있다.\n\n### 릴레이션 인스턴스\n릴레이션 인스턴스는 릴레이션 스키마에 따라 어느 한 시점에 실제 저장된 데이터의 집합을 의미한다.\n즉, 릴레이션 스키마에 따라 정의된 속성에 실제 데이터가 저장된 것이 릴레이션 인스턴스이다.\n\n예를 들어 상품 릴레이션의 릴레이션 스키마가 상품명, 가격, 수량의 속성을 가지고 있다면,\n상품 릴레이션의 릴레이션 인스턴스는 상품명이 '사과', 가격이 1000원, 수량이 10개인 데이터가 저장된 것이다.\n\n이러한 릴레이션 인스턴스에서 각각의 행을 튜플이라고 하는데, 같은 릴레이션에서의 모든 튜플은 릴레이션 스키마에 따라 같은 속성을 가진다.\n여기서 튜플은 릴레이션 안에서 서로 중복되지 않아야 하는 특성을 가진다.\n릴레이션에서는 이러한 튜플의 개수를 카디널리티(Cardinality)라고 하며, 카디널리티는 투플의 연산 과정에서 수시로 변한다.\n\n### 릴레이션 특징\n위에 설명한 릴레이션의 특성은 다음과 같다.\n\n- 튜플의 유실성: 릴레이션에서는 튜플의 중복이 없어야 한다.\n- 튜플의 무순서: 릴레이션에서는 튜플의 순서가 중요하지 않다.\n- 속성의 무순서: 릴레이션에서는 속성의 순서가 중요하지 않다.\n- 속성의 원자성: 속성 값은 원자 값이어야 한다.\n\n## 키\n\n키는 릴레이션에서 튜플들을 식별하는 역할을 하는 속성 또는 속성들의 집합이라고 할 수 있다.\n튜플을 식별하기 위해서 키는 릴레이션에서 유일한 값을 가져야하는 유일성을 가져야하고,\n최소한의 속성으로 구성되어야 하는 최소성을 가져야 한다.\n키의 종류에는 슈퍼키, 후보키, 기본키, 대체키, 대리키, 외래키 등이 있다.\n\n### 슈퍼키\n슈퍼키는 튜플을 고유하게 식별할 수 있는 속성 또는 속성의 집합을 말한다.\n대상관계의 모든 속성이 함수 종속하는 속성의 집합으로도 정의된다.\n\n후보키와의 차이는, 슈퍼 키는 '고유하게 식별하는 모든 조합'을 뜻하는 점이다.\n즉, 후보 키에 불필요한 속성을 덧붙여 장황하게 한 것은 후보 키는 아니지만 여전히 슈퍼 키이다.\n더 줄일 수 없는 슈퍼 키, 즉 속성의 중복이 없는 슈퍼 키는 후보 키이기도 하다.\n\n### 후보키\n후보키는 슈퍼키 중 더 이상 줄일 수 없는 최소성의 형태을 가진 키를 말한다.\n더 이상 줄일 수 없다는 것은 수퍼 키를 구성하는 속성 중 어느 하나라도 제외될 경우 유일성을 확보할 수 없게 되는 것을 말한다.\n이를 최소성을 만족한다라고도 한다.\n즉, 튜플의 식별을 위해 필요한 특성 또는 그 집합이 후보 키이다.\n후보 키는 튜플의 식별자라고 할 수도 있다.\n후보 키라는 이름은 그것이 기본 키로 선정될 수 있는 후보이기 때문에 유래했다.\n\n하나의 릴레이션에서 관계를 정의할 때, 적어도 하나의 후보 키가 존재한다.\n물론 하나의 릴레이션에 후보 키가 두 개 이상 존재할 수 있다.\n\n### 기본키\n기본 키(primary key)는  \n튜플의 식별자로 이용하기에 가장 적합한 것을 릴레이션마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다.\n유일 키는 0~1개 이상의 속성의 집합으로 볼 수 있다.\n즉, 릴레이션에 저장된 튜플를 고유하게 식별하는 후보 키의 집합 중, 설계자가 일반적으로 이용되어야한다고 정해 놓은 것을 가리킨다.\n\n반드시 기본 키를 사용해야만 하는 경우가 아니면, 다른 후보 키로 대체되어도 기능 수행에는 문제가 없다.\n따라서 기본 키의 이론적 의의는 크지 않지만 실무에서 널리 사용되고 있는 개념이다.\n그러나 기본 키는 NULL의 존재가 허용되지 않지만, 후보 키에 허용이 되는 차이가 있다.  \n릴레이션에 있는 후보 키가 하나인 때에는 그 후보 키가 당연히 기본 키가 된다.\n\n### 대체키\n대체키(Surrogate key)란 자연키에 대한 대체용으로 인공적이거나 합성적인 키를 말하며,\n주로 주민등록번호 같은 중요한 자료를 숨기기 위해 대체키로 사용하거나,\n여러 개의 컬럼을 합성하여 검색 시 속도 향상을 위해 사용한다.\n\n### 대리키\n대리키는 식별자가 너무 길거나 여러 개의 속성으로 구성되어 있는 경우 인위적으로 추가하는 식별자로, 인공키라고도 부른다.\n한 실체에서 식별자가 여러 속성으로 구성된 경우는 데이터를 수정하거나 검색을 하는데 수행 속도가 떨어질 수 있다.\n실체간에 관계가 생길 때 부모의 기본키가 자식의 외부키로 공유 되는데, 외부키가 단일해지기 때문에 조인의 속도를 향상시키기 위해 많이 사용한다.\n\n### 외래키\n외래 키는 참조하는 테이블에서 1개의 키(속성 또는 속성의 집합)에 해당하고,\n참조하는 측의 관계 변수는 참조되는 측의 테이블의 키를 가리킨다.\n참조하는 테이블의 속성의 행 1개의 값은,\n참조되는 측 테이블의 행 값에 대응된다.\n이 때문에 참조하는 테이블의 행에는, 참조되는 테이블에 나타나지 않는 값을 포함할 수 없다.\n이러한 참조 관계는 2개의 테이블을 연관시키기 위한 관계 정규화의 본질적인 부분이다.\n참조하는 테이블의 행 여러 개가, 참조되는 테이블의 동일한 행을 참조할 수 있다.\n참조하는 테이블과 참조되는 테이블이 동일할 수도 있다. 이 경우는 외래 키가 자기 자신을 참조하는 것이다.\n\n## 무결성 제약 조건\n무결성 제약 조건은 데이터를 정확하고 유효하게 유지하는 무결성을 보장하기 위해 설정하는 제약 조건이다.\n위와 같은 키를 통해 데이터의 무결성을 보장하고, 무결성 제약 조건을 통해 데이터의 정확성을 유지할 수 있다.\n무결성 제약 조건에는 개체 무결성, 참조 무결성, 도메인 무결성, 사용자 정의 무결성 등이 있다.\n\n### 개체 무결성\n개체 무결성(Entity integrity)은 고유 키(유일 키)의 개념과 관련된다.\n개체 무결성은 모든 테이블이 기본 키(primary key)를 가져야 하며 기본 키로 선택된 열은 고유하여야 하며 빈 값은 허용치 않음을 규정한다.\n\n### 참조 무결성\n참조 무결성(referential integrity)은 2개의 관련 있던 릴레이션 간의 일관성(데이터 무결성)을 말한다.\n참조 무결성은 종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다.\n참조 무결성이 강제 적용되면 외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다.\n예를 들어, 다른 관계 변수의 외래 키에 의해 참조되는 쌍(dupe 행)을 제거하는 것은 참조 무결성을 파괴해 버리게 되기 때문에 관계 데이터베이스 관리 시스템(RDBMS) 참조 무결성을 유지하도록 일반적으로 삭제를 방지한다.\n예외적으로 참조하는 외래 키를 포함하는 쌍을 연결하고 제거하는 것이 수반되어 삭제를 수행할 수 있으며,이 경우 참조 무결성이 유지된다.\n외부 키에 의해 참조되는 듀프를 제거할 수 있는 지 여부는 데이터 정의 언어(DDL)에 의한 참조 무결성 제약 조건(constraint)에 의해 정의된다.\n\n### 도메인 무결성\n도메인 무결성(Domain integrity)은 정의된 범위에서 관계형 데이터베이스의 모든 열이 선언되도록 규정한다.\n\n## MySQL\nMySQL에 대해 간단히 소개하자면, MySQL은 세계에서 가장 많이 쓰이는 오픈 소스 관계형 데이터베이스 관리 시스템(RDBMS)이다.\n구조질의어 형식의 데이터베이스 관리 시스템으로 오라클이 관리 및 지원하고 있다.\n\n### MySQL 엔진\nMySQL은 사용자가 요청한 파서를 통해 SQL 쿼리를 분석 및 파싱하고,\n옵티마이저를 통해 최적의 실행 계획을 수립하고,\n스토리지 엔진을 호출하여 데이터를 저장하고 관리하는 역할을 한다.\nMySQL 8.0 버전에서는 다음과 같은 스토리지 엔진을 제공한다.\n\n- InnoDB\n- MyISAM\n- Memory\n- CSV\n- Archive\n- Blackhole\n- ND\n\n### InnoDB\nInnoDB는 MySQL의 기본 스토리지 엔진으로,\n트랜잭션 처리와 ACID(Atomicity, Consistency, Isolation, Durability) 특성을 지원한다.\n\nInnoDB는 트랜잭션 롤백, 커밋, 복구같은 장애 복구 기능을 지원한다.\n무결성을 가져하는 중요한 데이터를 필요로할 때 유용하게 사용된다.\n\nInnoDB 테이블은 기본적으로 클러스터형 테이블로 저장된다.\n클러스터형 테이블은 레코드를 기본키 순으로 정렬해서 저장하고,\n기본키에 대한 인덱스를 자동 생성해주기 때문에 기본키를 통한 범위 검색에 유리하다\n\n또한 InnoDB는 레코드의 여러 버전을 유지할 수 있게 해주는 MVCC라는 기술을 통해 트랜잭션이 가능하게 해준다.\n\n추가로 버퍼풀이라는 메모리 영역을 사용하여 데이터를 캐싱하고, 쓰기 지연 용도로 사용하여 디스크 I/O를 줄일 수 있다는 장점이 있다.\n\n\n\n## 참고\n- [InnoDB 스토리지 엔진](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)"},{"excerpt":"데이터 독립성 데이터 독립성(Data Independence)이란 데이터베이스 시스템의 중요한 특징 중 하나로,\n데이터베이스 시스템은 데이터와 응용 프로그램을 독립적으로 관리할 수 있도록 설계되어 있다.\n이러한 데이터 독립성은 데이터베이스의 유지보수와 확장성을 향상시키는 장점을 가진다.\n데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌…","fields":{"slug":"/database-data-independency/"},"frontmatter":{"date":"January 02, 2025","title":"데이터 독립성(Data Independence)","tags":["Database"]},"rawMarkdownBody":"\n\n## 데이터 독립성\n\n데이터 독립성(Data Independence)이란 데이터베이스 시스템의 중요한 특징 중 하나로,\n데이터베이스 시스템은 데이터와 응용 프로그램을 독립적으로 관리할 수 있도록 설계되어 있다.\n이러한 데이터 독립성은 데이터베이스의 유지보수와 확장성을 향상시키는 장점을 가진다.\n데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌 수 있다.\n\n### 논리적 데이터 독립성\n\n논리적 데이터 독립성은 데이터베이스의 논리적 구조와 응용 프로그램 간의 독립성을 의미한다.\n즉, 데이터베이스의 논리적 구조가 변경되어도 응용 프로그램은 영향을 받지 않는다.\n예를 들어, 데이터베이스의 테이블 구조가 변경되어도 쿼리나 트랜잭션은 변경되지 않고 그대로 사용할 수 있다.\n하지만 논리적 데이터 독립성은 한계가 있다.\n컬럼이 추가되거나 삭제되는 경우에는 해당 컬럼을 참조하는 쿼리에서 오류가 발생할 수 있다.\n이로 인해 논리적 데이터 독립성이 완전히 보장되지는 않는다.\n즉, 논리적 데이터 독립성은 주로 데이터베이스 구조의 변경에 따른 영향을 최소화하는 데 중점을 둔다.\n\n### 물리적 데이터 독립성\n\n물리적 데이터 독립성은 데이터베이스의 물리적 구조가 변경되어도 논리적 구조나 데이터의 내용에 영향을 주지 않는 것을 의미한다.\n예를 들어, 파일의 저장 방식이나 인덱스의 구성이 바뀌어도 데이터베이스의 스키마나 데이터는 그대로 유지될 수 있다.\n\n## 스키마\n이러한 데이터 독립성은 데이터베이스의 구조가 변경되더라도 응용 프로그램이나 사용자에게 영향을 주지 않으므로,\n시스템의 안정성과 신뢰성을 높일 수 있다.\n데이터 독립성 보장을 위한 데이터베이스 구조에는 3단계 데이터베이스 구조가 있다.\n3단계 데이터베이스 구조를 알아보기 전에 스키마에 대해 먼저 알아볼 필요가 있다.\n\n스키마는 데이터베이스를 구성하는 데이터 개체(Entity),\n개체의 특성을 나타내는 속성(Attribute),\n개체 사이에 존재하는 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관하여 기술한다.\n이를 메타데이터(MetaData)라고도 한다.\n\n쉽게 말해 DB 내에 데이터가 어떤 구조로 저장되는가를 나타내는 데이터베이스 구조를 스키마라고 한다.\n\n## 3단계 데이터베이스 구조\n\n이제 3단계 데이터베이스 구조에 대해 알아보자.\n앞서 소개한 스키마는 데이터베이스의 전체적인 모습을 보여주는 외부 스키마,\n데이터베이스의 물리적인 저장 방식을 결정하는 내부 스키마,\n그리고 외부 스키마와 내부 스키마 사이의 관계를 매핑하는 개념 스키마로 구성된다\n이렇게 3단계로 나뉘는 데이터베이스 구조를 3단계 데이터베이스 구조라고 한다.\n\n### 외부 스키마\n\n외부 스키마는 사용자의 요구에 따라 데이터베이스의 논리적 구조를 정의하는 것으로,\n사용자의 관점에서 데이터를 접근하고 조작할 수 있도록 한다.\n이러한 외부 스키마는 하나의 데이터베이스 시스템에서 다수로 존재하며,\n하나의 외부 스키마를 여러 응용 프로그램이나 사용자가 공유할 수 있다.\n또한 외부 스키마는 같은 데이터베이스에 대해 서로 다른 논리적 구조를 가질 수 있도록 정의하는 것을 허용하며,\nSQL과 같은 질의어를 이용하여 이를 조작할 수 있다.\n\n### 개념 스키마\n\n개념 스키마는 데이터베이스의 전체적인 논리적 구조로,\n모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다.\n이러한 개념 스키마는 개체간의 관계와 제약 조건을 나타내고\n데이터베이스의 접근 권한, 보안 및 무결성 규칙에 대해 정의를 한다.\n이렇게 개념 스키마는 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것으로,\n단순히 스키마라고 하면 개념 스키마를 의미한다.\n\n### 내부 스키마\n\n내부 스키마는 물리적 저장 방식을 결정하는 것으로, 저장장치와 관련된 세부적인 사항을 정의한다.\n실제로, 내부 스키마는 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고,\n인덱스의 생성 여부, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 결정한다.\n\n### 사상(mapping)\n\n3단계 데이터베이스 구조에서는 외부 스키마와 개념 스키마, 개념 스키마와 내부 스키마 사이의 관계를 매핑(mapping)한다.\n이러한 매핑은 데이터베이스의 논리적 구조와 물리적 구조 사이의 독립성을 보장하며,\n데이터베이스의 논리적 구조가 변경되어도 물리적 구조에 영향을 주지 않도록 한다.\n즉, 데이터 독립성을 실현하는 핵심적인 요소이다.\n위에서 언급했듯이 데이터 독립성은 논리적 데이터 독립성과 물리적 데이터 독립성으로 나눌 수 있으며, 각각의 사상이 이를 보장하는 역할을 한다.\n\n### 외부/개념 사상\n\n외부 스키마와 개념 스키마 사이의 사상을 외부/개념 사상이라고 하며, 응용 프로그램과 데이터베이스 사이의 인터페이스 역할을 한다.\n외부 스키마 사상은 사용자의 요구에 따라 데이터베이스의 논리적 구조를 정의하고, 논리적 데이터 독립성을 보장하는 역할을 한다.\n\n### 개념/내부 사상\n\n개념 스키마와 내부 스키마 사이의 사상을 개념/내부 사상이라고 하며, 데이터베이스의 논리적 구조와 물리적 구조 사이의 매핑을 담당한다.\n개념/내부 사상은 데이터베이스의 논리적 구조가 변경되어도 물리적 구조에 영향을 주지 않도록 하며, 물리적 데이터 독립성을 보장하는 역할을 한다.\n\n## 정리\n\n3단계 데이터베이스 구조를 통해, 사용자와 애플리케이션을 물리적인 데이터베이스로부터 독립시켜,\n데이터베이스의 물리적 구조나 저장 방식이 변경되더라도 사용자나 애플리케이션에 영향을 주지 않도록 한다.\n이를 통해 데이터 독립성을 보장하고, 데이터베이스의 유지보수와 확장성을 향상시킬 수 있다.\n\n## 참고\n\n- [데이터 독립성](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%8F%85%EB%A6%BD%EC%84%B1)\n- [데이터베이스 시스템](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C)\n- [데이터베이스 스키마](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8A%A4%ED%82%A4%EB%A7%88)\n- [데이터베이스 구조](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B5%AC%EC%A1%B0)\n- [데이터베이스 관리 시스템](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C)\n- [데이터베이스 시스템의 구조](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98_%EA%B5%AC%EC%A1%B0)"},{"excerpt":"많은 경우의 클래스들은 하나 이상의 리소스에 의존하는 양상을 띈다.\n알림을 보내는  클래스와 이메일을 보내는  클래스가 있다고 가정해보자.\n는 를 사용하여 이메일을 보낸다.\n여기서 가  리소스에 의존한다고 말한다.\n이때  클래스는 다음과 같이 구현하는 경우가 있다. 정적 유틸리티 클래스(Static Utility Class) 다음 코드는 알림을 보내는 를…","fields":{"slug":"/effective-java-dependency-injection/"},"frontmatter":{"date":"January 01, 2025","title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\n많은 경우의 클래스들은 하나 이상의 리소스에 의존하는 양상을 띈다.\n알림을 보내는 `NotificationService` 클래스와 이메일을 보내는 `EmailSender` 클래스가 있다고 가정해보자.\n`NotificationService`는 `EmailSender`를 사용하여 이메일을 보낸다.\n여기서 `NotificationService`가 `EmailSender` 리소스에 의존한다고 말한다.\n이때 `NotificationService` 클래스는 다음과 같이 구현하는 경우가 있다.\n\n## 정적 유틸리티 클래스(Static Utility Class)\n다음 코드는 알림을 보내는 `NotificationService`를 정적 유틸리티 클래스로 구현한 경우이다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private static final Sender sender = new EmailSender();\n\n    private NotificationService() {\n        throw new AssertionError();\n    }\n\n    public static boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n```\n\n위 코드에서는 `NotificationService` 클래스가 `EmailSender` 리소스에 직접 의존하고 있다.\n이 경우 알림 방식 추가 및 변경을 하기 위해서는 `NotificationService` 클래스를 수정해야 한다.\n또한 정적 메서드는 Mocking이 어렵고, 테스트가 제한되어 어려움이 있다.\n다음 경우를 보자.\n\n## 싱글톤(Singleton)\n다음 코드는 알림을 보내는 `NotificationService`를 싱글톤으로 구현한 경우이다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender = new EmailSender();\n\n    private NotificationService() {\n        throw new AssertionError();\n    }\n\n    public static final NotificationService INSTANCE = new NotificationService();\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n```\n\n위 코드 또한 `NotificationService` 클래스가 `EmailSender` 리소스에 직접 의존하고 있다.\n마찬가지로 알림 방식 추가 및 변경을 하기 위해서는 `NotificationService` 클래스를 수정해야 한다.\n테스트부분 또한 싱글톤 패턴은 Mocking이 어렵고, 테스트가 제한되어 어려움이 있다.\n\n## 의존 객체 주입(Dependency Injection)\n앞서 구현한 두 가지 방식은 `EmailSender`만 사용하는 경우에는 문제가 없지만, 언급했듯이 알림 방식을 추가하거나 변경할 때 문제가 발생한다.\n이처럼 어떤 클래스가 사용할 의존 리소스에 따라 동작이 달라지는 경우에는 정적 유틸리티 클래스나 싱글톤 패턴을 사용하는 것은 부적절해 보인다.\n그럼 `EmailSender` 대신 `SmsSender`를 사용하거나 추가하고 싶다면 어떻게 해야할까?\n이때는 새로운 인스턴스를 생성할 때 생성자에 필요한 리소스를 주입하는 방식을 사용하면 된다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender;\n\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        String MESSAGE = \"Hello, World!\";\n        \n        NotificationService emailNotificationService = new NotificationService(new EmailSender());\n        emailNotificationService.sendNotification(MESSAGE);\n\n        NotificationService smsNotificationService = new NotificationService(new SmsSender());\n        smsNotificationService.sendNotification(MESSAGE);\n    }\n}\n```\n\n앞선 두 가지 경우의 구현과 유사해보이지만 `NotificationService`는 런타임과정에서 생성자를 통해 `Sender` 인터페이스를 구현한 클래스를 주입받는다.\n이렇게 하면 무슨 이점이 있을까?\n`NotificationService`는 `Sender` 인터페이스를 구현한 클래스에만 의존하고 있기 때문에,\n`EmailSender` 대신 `SmsSender`와 같은 다양한 구현체를 사용하거나 추가하는 것이 쉬워져 유연성이 생기게 된다.\n또한 테스트 코드에서는 `Mocking`을 통해 테스트가 용이해진다.\n이 경우, `Mock`을 사용하면 테스트 시 실제 알림 없이도 검증이 가능하다.\n하지만 다른 방식으로 구현한 경우에는 의존성 주입이 불가능해 `Mocking`이 어렵고 테스트가 제한되어 어려움이 있다.\n\n```java\nclass NotificationServiceTest {\n\n    @DisplayName(\"의존 객체 주입 테스트\")\n    @Test\n    public void testNotificationService() throws Exception {\n        //given\n        Sender mockSender = mock(Sender.class);\n        when(mockSender.send(anyString())).thenReturn(false);\n        NotificationService notificationService = new NotificationService(mockSender);\n        //when\n        boolean result = notificationService.sendNotification(\"test\");\n        //then\n        assertThat(result).isFalse();\n        verify(mockSender).send(\"test\");\n    }\n}\n```\n\n위 의존 객체 주입 방식을 변형하여 리소스의 생성을 팩터리 메서드에 위임하는 방식인 팩터리 메서드 패턴(Factory Method Pattern)가 있다.\n이 방식은 `Supplier<T>` 인터페이스가 제공하는 `get()` 메서드를 이용하여 리소스를 생성하는 방식이다.\nSupplier<T>`를 인자로 받는 메서드는 보통 `bounded wildcard type`을 사용하여 제한을 두는 것이 좋다.\n\n```java\npublic class NotificationService {\n    private final Supplier<Sender> senderSupplier;\n\n    public NotificationService(Supplier<Sender> senderSupplier) {\n        this.senderSupplier = senderSupplier;\n    }\n\n    public boolean sendNotification(String message) {\n        return senderSupplier.get().send(message);\n    }\n}\n\nNotificationService service = new NotificationService(() -> new EmailSender());\n```\n\n## DI 프레임워크\n이처럼 의존 객체 주입을 사용하면 유연성이 높아지고 테스트가 용이하지만,\n프로젝트가 커질수록 생성자에 많은 인자가 필요한 경우 관리가 어려워질 수 있다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\npublic class NotificationService {\n    private final Sender sender;\n\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public boolean sendNotification(String message) {\n        return sender.send(message);\n    }\n}\n\n// 의존성 관리 클래스\npublic class Application {\n    private final NotificationService emailService;\n    private final NotificationService smsService;\n\n    public Application() {\n        Sender emailSender = new EmailSender();\n        Sender smsSender = new SmsSender();\n\n        // 모든 의존성을 수작업으로 생성하고 주입\n        this.emailService = new NotificationService(emailSender);\n        this.smsService = new NotificationService(smsSender);\n    }\n\n    public void run() {\n        emailService.sendNotification(\"Hello Email!\", \"email@example.com\");\n        smsService.sendNotification(\"Hello SMS!\", \"123-456-7890\");\n    }\n\n    public static void main(String[] args) {\n        Application app = new Application();\n        app.run();\n    }\n}\n\n```\n\n이때 DI 프레임워크(컨테이너를) 사용하면 이를 효과적으로 관리할 수 있다.\n`Spring`은 `@Autowired` 어노테이션을 통해 의존성을 자동으로 주입해주며, `@Component` 어노테이션을 통해 `Spring`이 관리하는 빈으로 등록할 수 있다.\n이렇게 하면 `Spring`이 의존성을 관리하고 주입하는 과정을 자동화하여 위 문제를 해결할 수 있다.\n\n```java\ninterface Sender {\n    boolean send(String message);\n}\n\n@Component\nclass EmailSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // 이메일을 보내는 코드\n        return false;\n    }\n}\n\n@Component\nclass SmsSender implements Sender {\n    @Override\n    public boolean send(String message) {\n        // SMS를 보내는 코드\n        return false;\n    }\n}\n\n// NotificationService에 @Service 추가\n@Service\npublic class NotificationService {\n    private final Sender sender;\n\n    // 의존성 자동 주입\n    @Autowired\n    public NotificationService(Sender sender) {\n        this.sender = sender;\n    }\n\n    public void sendNotification(String message) {\n        sender.send(message);\n    }\n}\n\n// Application 클래스에 @SpringBootApplication 추가\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n정리하자면 의존하는 리소스가 클래스의 동작에 영향을 미친다면, 정적 유틸리티 클래스나 싱글톤 패턴을 사용하는 것은 부적절하다.\n이러한 경우, 의존 객체 주입을 사용하면 구현체 교체와 테스트가 용이해지고, 코드의 유연성과 유지보수성이 향상된다.\n프로젝트 규모가 커질수록 의존성 주입을 효과적으로 관리하기 위해 DI 프레임워크를 사용하는 것이 좋다.\n\n## 참고\n* [의존성 주입](https://ko.wikipedia.org/wiki/의존성_주입)\n* [Mock](https://www.crocus.co.kr/1555)\n* [Spring DI](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)\n* [팩토리 메소드 패턴](https://ko.wikipedia.org/wiki/팩토리_메서드_패턴)\n* [Supplier 인터페이스](https://docs.oracle.com/javase/8/docs/api///?java/util/function/Supplier.html)"},{"excerpt":"자바가 제공하는 열거형(Enum) 타입은 서로 연관된 상수들의 집합을 의미한다.\n이러한 자바의 열거형을 이해하기 전에 먼저 열거형이 생겨난 이유에 대해 알아야 한다. 문자열과 타입 안전성 다음과 같은 상황을 가정하고 코드를 구현해 가면서 근본적인 문제점을 파악해 보겠다. 요구사항은 다음과 같다.\n고객을 , ,  등급으로 분류하고 각 등급에 따라 할인율을 …","fields":{"slug":"/java-enum/"},"frontmatter":{"date":"December 28, 2024","title":"자바 열거형 타입(Type-Safe Enum Pattern)","tags":["Java"]},"rawMarkdownBody":"\n자바가 제공하는 열거형(Enum) 타입은 서로 연관된 상수들의 집합을 의미한다.\n이러한 자바의 열거형을 이해하기 전에 먼저 열거형이 생겨난 이유에 대해 알아야 한다.\n\n## 문자열과 타입 안전성\n다음과 같은 상황을 가정하고 코드를 구현해 가면서 근본적인 문제점을 파악해 보겠다.\n\n요구사항은 다음과 같다.\n고객을 `BASIC`, `GOLD`, `DIAMOND` 등급으로 분류하고 각 등급에 따라 할인율을 부여한다.\n각각의 할인율은 10%, 20%, 30%이다. 할인 시 소수점 이하는 버린다.\n\n이제 회원 등급과 가격을 입력하면 할인 금액을 계산하는 코드를 구현해보자.\n\n```java\npublic class DiscountService {\n    public int discount(String grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade.equals(\"BASIC\")) {\n            discountPercent = 10;\n        } else if (grade.equals(\"GOLD\")) {\n            discountPercent = 20;\n        } else if (grade.equals(\"DIAMOND\")) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n위 코드에 대해서 설명하자면 `price * discountPercent / 100`는 `가격 * 할인율 / 100`을 계산하여 할인 금액을 구하는 코드이다.\n회원 등급 외 다른 값이 입력되면 가격을 그대로 반환한다. 이 경우 할인율이 0%이므로 가격 그대로 반환하는 것이다.\n상황을 단순화하기 위해 회원 등급에 `null`은 입력되지 않는다고 가정한다.\n\n지금과 같이 단순히 문자열을 사용하여 회원 등급을 구분하는 방식은 문제점이 있다.\n오타가 발생하기 쉽고, 유효하지 않는 값이 입력될 수 있다는 것이다.\n\n이것 또한 코드를 구현해가며 확인해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        // 존재하지 않는 등급을 입력\n        int vip = discountService.discount(\"VIP\", price);\n        System.out.println(\"VIP 등급의 할인 금액: \" + vip);\n\n        // 오타 입력\n        int godl = discountService.discount(\"GODL\", price);\n        System.out.println(\"GODL 등급의 할인 금액: \" + godl);\n        \n        // 소문자 입력\n        int basic = discountService.discount(\"basic\", price);\n        System.out.println(\"basic 등급의 할인 금액: \" + basic);\n    }\n}\n```\n\n위 코드는 다음과 같은 문제가 발생하고 있다.\n먼저 존재하지 않는 등급인 `VIP`를 입력하고 있다.\n그리고 두 번째로는 `GOLD` 등급을 오타로 `GODL`로 입력하고 있다.\n마지막으로는 `BASIC` 등급을 소문자로 입력하고 있다.\n\n이러한 문제의 코드는 문자열 오타가 발생하기 쉽고, 유효하지 않은 값이 입력될 수 있어서 타입 안정성 부족하며,\n`BASIC`, `basic`, `Basic` 등 다양한 형태로 입력될 수 있는 문자열을 입력할 수 있어 데이터의 일관성 또한 떨어진다.\n\n이 문제의 원인은 `String`을 사용하여 회원 등급을 구분하고 있기 때문에 발생한 것이다.\n`String`으로 상태나 카테고리를 표현하면, 이처럼 잘못된 입력이 발생할 수 있다.\n이러한 잘못된 값은 컴파일 시 확인할 수 없고, 런타임 시에 확인할 수 있기에 디버깅이 어려워질 수 있다.\n\n이런 문제를 해결하기 위해서는 입력을 특정 범위로 제한을 해야한다.\n예를 들면 `BASIC`, `GOLD`, `DIAMOND` 등의 값만 `discount()` 메서드에 전달될 수 있도록 제한을 해야한다.\n하지만 `String` 자체에는 문자열이면 무엇이든 할당할 수 있기에 자바 문법 관점에서 아무런 문제가 없다.\n이 말은 즉, `String` 타입을 사용해서는 문제를 해결할 수 없다는 말이 된다.\n\n이런 문제를 해결하기 위한 대안으로 문자열 상수를 사용해서 미리 정의한 변수명만 사용할 수 있게 하는 방법이 있다.\n코드를 통해 알아보도록 하겠다.\n\n```java\npublic class Grade {\n    public static final String BASIC = \"BASIC\";\n    public static final String GOLD = \"GOLD\";\n    public static final String DIAMOND = \"DIAMOND\";\n}\n```\n\n위 코드는 `Grade` 클래스를 생성하고 `BASIC`, `GOLD`, `DIAMOND` 등의 상수를 정의하였다.\n이제 `DiscountService` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class DiscountService {\n    public int discount(String grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade.equals(Grade.BASIC)) {\n            discountPercent = 10;\n        } else if (grade.equals(Grade.GOLD)) {\n            discountPercent = 20;\n        } else if (grade.equals(Grade.DIAMOND)) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n이제 `Main` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        int basic = discountService.discount(Grade.BASIC, price);\n        int gold = discountService.discount(Grade.GOLD, price);\n        int diamond = discountService.discount(Grade.DIAMOND, price);\n\n        System.out.println(\"BASIC 등급의 할인 금액: \" + basic);\n        System.out.println(\"GOLD 등급의 할인 금액: \" + gold);\n        System.out.println(\"DIAMOND 등급의 할인 금액: \" + diamond);\n    }\n}\n```\n\n문자열 상수를 사용한 덕분에 오타를 방지할 수 있고, 유효하지 않은 값이 입력될 수 없게 되었다.\n그리고 `discount()` 메서드에 전달되는 값은 `Grade` 클래스에 정의된 상수만 사용할 수 있게 되었다.\n이 덕분에 만약 `Grade` 클래스에 정의되지 않은 값이 입력되면 컴파일 에러가 발생하게 되고, 오류를 쉽고 빠르게 찾을 수 있게 되었다.\n\n하지만 이 방법에도 문제점이 있다.\n문자열 상수를 사용해도, 지금까지 발생한 문제들을 근본적으로 해결할 수 없다.\n왜냐하면 아직도 `String`을 사용하고 있기 때문에 문자열이면 무엇이든 입력할 수 있기 때문이다.\n여기서 어떤 개발자가 앞서 테스트한 것처럼 `VIP`, `GODL`, `basic` 등의 값이 입력되어도 방지할 수 있는 방법이 없다.\n\n그리고 사용해야 하는 문자열 상수가 어디에 있는지 `discount()` 메서드를 사용하는 개발자가 알아야 한다.\n코드를 보면 `String`은 다 입력 가능하게 되어있다.\n```java\npublic int discount(String grade, int price) {}\n```\n이렇게 되면 `discount()` 메서드를 사용하는 개발자가 `Grade` 클래스에 정의된 상수만 사용해야 한다는 것을 알 수 없다.\n주석을 남기거나 해서 알려줄 수 있지만, 이러한 방법은 개발자가 주석을 읽고 이해해야 하고 주석을 잊어버리고 직접 문자열을 입력할 수 있다.\n이렇게 문자열 상수를 사용하는 방법 또한 문제점이 많다.\n\n## Type-Safe Enum Pattern\n많은 개발자들도 이러한 문제점을 해결하기 위해 오랜기간 고민을 해왔고,\n이를 해결하기 위해 나온 결과가 타입 안전 열거형 패턴(Type-Safe Enum Pattern)이다.\n\n여기서 `Enum`은 `Enumeration`의 줄임말로 번역하면 열거라는 뜻이다.\n즉, 어떤 것을 나열한 것을 뜻한다.\n지금 상황에서는 `BASIC`, `GOLD`, `DIAMOND`이라는 회원 등급을 열거한 것이다.\n여기서 타입 안전 열거형 패턴을 사용하면 이렇게 나열한 항목만 사용할 수 있게 된다는 것이 핵심이다.\n이 말은 즉, `String`처럼 어떤 값이든 입력할 수 있는 것이 아니라, `BASIC`, `GOLD`, `DIAMOND`만 사용할 수 있게 된다는 것이다.\n\n이제 타입 안전 열거형 패턴을 구현하여 문제를 해결해보자.\n\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n}\n```\n\n위 코드는 `Grade` 클래스를 생성하고 `BASIC`, `GOLD`, `DIAMOND` 등의 상수를 선언하였다.\n각각을 상수로 선언하기 위해 `static`과 `final` 키워드를 사용하였다.\n이때 각각의 상수마다 별도의 인스턴스를 생성하고, 생성한 인스턴스를 상수에 할당하였다.\n\n![Enum Instance](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-enum/java-enum_1.png){: width=\"500\" }\n\n코드를 통해 확실한 이해를 해보도록 하겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"class BASIC = \" + Grade.BASIC.getClass());\n        System.out.println(\"class GOLD = \" + Grade.GOLD.getClass());\n        System.out.println(\"class DIAMOND = \" + Grade.DIAMOND.getClass());\n\n        System.out.println(\"ref BASIC = \" + Grade.BASIC);\n        System.out.println(\"ref GOLD = \" + Grade.GOLD);\n        System.out.println(\"ref DIAMOND = \" + Grade.DIAMOND);\n    }\n}\n```\n\n위 코드를 실행하면 다음과 같은 결과가 출력된다.\n\n```java\nclass BASIC = class enumeration.test.Grade\nclass BASIC = class enumeration.test.Grade\nclass BASIC = class enumeration.test.Grade\nref BASIC = enumeration.test.Grade@1b6d3586\nref GOLD = enumeration.test.Grade@4554617c\nref DIAMOND = enumeration.test.Grade@74a14482\n```\n\n각각의 상수는 모두 `Grade` 타입을 기반으로한 인스턴스이기에 `getClass()` 메서드를 호출하면 `Grade` 클래스가 출력된다.\n하지만 각각의 상수는 모두 별도의 `Grade` 인스턴스이기에 서로 다른 메모리 주소를 가지고 있다.\n\n또한 `static`을 사용하여 클래스 변수로 선언하였기에 `Grade` 클래스의 인스턴스를 생성하지 않고도 `Grade.BASIC`, `Grade.GOLD`, `Grade.DIAMOND` 상수를 사용할 수 있다.\n\n이제 `DiscountService` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class DiscountService {\n    public int discount(Grade grade, int price) {\n        int discountPercent = 0;\n        \n        if (grade == Grade.BASIC) {\n            discountPercent = 10;\n        } else if (grade == Grade.GOLD) {\n            discountPercent = 20;\n        } else if (grade == Grade.DIAMOND) {\n            discountPercent = 30;\n        } else {\n            System.out.println(grade + \": 할인X\");\n        }\n        return price * discountPercent / 100;\n    }\n}\n```\n\n위 코드에서는 `discount()` 메서드의 매개변수 타입을 `String`에서 `Grade`로 변경하였다.\n또한 값을 비교할 떄는 `grade == Grade.BASIC`와 같이 `==` 연산자를 사용하여 비교하였다.\n\n이제 `Main` 클래스를 수정하여 `Grade` 클래스를 사용하도록 코드를 수정해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n     \n        int basic = discountService.discount(Grade.BASIC, price);\n        int gold = discountService.discount(Grade.GOLD, price);\n        int diamond = discountService.discount(Grade.DIAMOND, price);\n\n        System.out.println(\"BASIC 등급의 할인 금액: \" + basic);\n        System.out.println(\"GOLD 등급의 할인 금액: \" + gold);\n        System.out.println(\"DIAMOND 등급의 할인 금액: \" + diamond);\n    }\n}\n```\n\n이제 `discount()`를 호출할 떄 미리 정의된 `Grade` 클래스의 상수만 사용할 수 있게 되었다.\n\n하지만 이 방법에도 문제점이 있다.\n그것은 외부에서 임의로 `Grade` 클래스의 인스턴스를 생성할 수 있다는 것이다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        DiscountService discountService = new DiscountService();\n\n        Grade vip = new Grade();\n        int vipDiscount = discountService.discount(vip, price);\n        System.out.println(\"VIP 등급의 할인 금액: \" + vipDiscount);\n    }\n}\n```\n\n이 문제를 해결하기 위해서는 생성자를 `private`으로 선언하여 외부에서 인스턴스를 생성할 수 없도록 제한하면 된다.\n\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n이제 `Grade` 클래스의 생성자를 `private`으로 선언하였기에 외부에서 인스턴스를 생성할 수 없게 되었다.\n또한 `Grade` 클래스의 인스턴스는 `BASIC`, `GOLD`, `DIAMOND` 상수만 사용할 수 있게 되었다.\n만일 `Grade` 클래스의 인스턴스를 생성하거나 정의된 값이 아닌 다른 값을 사용하려고 하면 컴파일 에러가 발생하게 된다.\n\n이렇게 함으로써 타입 안전 열거형 패턴을 구현할 수 있었고, 이를 통해 정해진 객체만 사용할 수 있기에 잘몬된 값을 입력하는 문제를 근본적으로 방지할 수 있게 되었다.\n또한 정해진 객체만 사용하므로 데이터의 일관성이 보장된다.\n\n> 참고 <br>\n> **제한된 인스턴스 생성**: 클래스는 사전에 정의된 몇 개의 인스턴스만 생성하고, 외부에서는 이 인스턴스들만 사용할 수 있도록 한다. 이를 통해 미리 정의된 값들만 사용하도록 보장한다.<br>\n> **타입 안전성**: 이 패턴을 사용하면, 잘못된 값이 할당되거나 사용되는 것을 컴파일 시점에 방지할 수 있다. 예를 들어, 특정 메서드가 특정 열거형 타입의 값을 요구한다면, 오직 그 타입의 인스턴스만 전달할 수 있다.\n\n이 패턴을 구현하려면 다음과 같이 코드가 길어지고, `private` 생성자를 선언해야 하는 등 번거로운 작업이 필요하다.\n```java\npublic class Grade {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n## Enum Type\n자바에서는 타입 안전 열거형 패턴을 더 쉽게 구현할 수 있도록 `Enum` 타입을 제공한다.\n`Enum` 타입은 열거형 상수를 정의하고 사용할 수 있도록 한다.\n`Enum` 타입을 사용하면 열거형 상수를 쉽게 정의하고 사용할 수 있으며, `Enum` 타입을 사용하면 `private` 생성자를 선언하거나 인스턴스를 생성하는 등의 작업을 할 필요가 없다.\n\n이제 `Enum` 타입을 사용하여 `Grade` 클래스를 구현해보자.\n\n```java\npublic enum Grade {\n    BASIC, GOLD, DIAMOND\n}\n```\n\n열거형을 정의할 때는 위 코드 처럼 `enum` 키워드를 사용하고, 열거형 상수를 정의하여 나열하면 된다.\n앞서 직접 `Grade` 클래스를 구현할 때와 달리 `private` 생성자를 선언하거나 인스턴스를 생성하는 등의 작업을 할 필요가 없다.\n\n자바의 열거형으로 작성한 `Grade` 클래스는 다음과 거의 같다고 할 수 있다.\n\n```java\npublic class Grade extends Enum {\n    public static final Grade BASIC = new Grade();\n    public static final Grade GOLD = new Grade();\n    public static final Grade DIAMOND = new Grade();\n\n    private Grade() {}\n}\n```\n\n열거형도 클래스이다.\n또한 자동(강제)으로 `java.lang.Enum` 클래스를 상속받기 때문에 `Enum` 클래스의 메서드를 사용할 수 있다.\n그리고 `Enum` 클래스는 `private` 생성자를 가지고 있기에 외부에서 인스턴스를 생성할 수 없다.\n생성할 경우 `enum classes may not be instantiated`라는 에러 메시지를 뱉어내며, 컴파일 에러가 발생하게 된다.\n\n이러한 열거형은 사전에 정의된 값만 사용할 수 있기에 타입 안전성을 보장한다.\n그리고 열거형을 사용하면 `static import`와 `switch`를 적절하게 사용할 수도 있고, 이로 인해 코드가 간결해지고 명확해져 가독성이 좋아진다.\n또한 데이터 일관성도 보장할 수 있게 된다.\n만일 새로운 타입을 추가하거나 삭제하려면 `Grade` 열거형에만 추가하거나 삭제하면 되기에 확장성 측면에서도 좋다.\n\n\n### Enum Type의 메서드\n앞서 열거형도 클래스라고 했다.\n그 말은 즉, 열거형 클래스가 제공하는 메서드들을 사용할 수 있다는 것이다.\n\n주요 메서드는 다음과 같다.\n- `values()`: 열거형의 모든 상수를 배열에 담아 반환한다.\n- `valueOf(String name)`: 지정된 이름(name)과 일치하는 열거형 상수를 반환한다.\n- `name()`: 열거형 상수의 이름을 문자열로 반환한다.\n- `ordinal()`: 열거형 상수가 정의된 순서를 반환한다.\n- `toString()`: 열거형 상수의 이름을 문자열로 반환한다.\n\n하지만 여기서 `ordinal()` 메서드는 사용을 지양해야 한다.\n왜냐하면 이 값을 사용하다가 중간에 상수를 선언하는 위치가 변경되면 전체 상수의 순서가 변경되기 때문이다.\n\n### Enum Type 사용한 리팩토링\n이제 `Enum` 타입을 사용하여 `Grade` 클래스 코드를 리팩토링해보자.\n코드의 응집성을 위해 등급별 할인율과 할인 금액을 계산하는 코드를 `Grade` 열거형에 추가하고,\n`DiscountService` 클래스에서 `Grade` 열거형을 사용하도록 코드를 수정했다.\n\n\n```java\npublic enum Grade {\n    BASIC(10), GOLD(20), DIAMOND(30);\n    \n    private final int discountPercent;\n    \n    Grade(int discountPercent) {\n        this.discountPercent = discountPercent;\n    }\n    \n    public int getDiscountPercent() {\n        return discountPercent;\n    }\n    \n    public int discount(int price) {\n        return price * discountPercent / 100;\n    }\n}\n```\n\n여기서 기존 `DiscountService` 클래스의 기능을 `Grade` 열거형에 추가하였다.\n더는 `DiscountService` 클래스에서 할인율을 계산하는 코드를 작성할 필요가 없어졌다.\n\n이제 `main` 메서드를 수정하여 `Grade` 열거형을 사용하도록하고 중복된 코드를 제거하는 방향으로 수정해보겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int price = 10000;\n        \n        Grade[] grades = Grade.values();\n        for (Grade grade : grades) {\n            printDiscount(grade, price);\n        }\n    }\n    \n    private static void printDiscount(Grade grade, int price) {\n        System.out.println(grade.name() + \" 등급의 할인 금액: \" + grade.discount(price));\n    }\n}\n```\n\n이제 `main` 메서드에서는 `Grade` 열거형의 모든 상수를 배열로 가져와서 반복문을 통해 할인 금액을 출력하도록 수정하였다.\n이렇게 함으로써 중복된 코드를 제거하고, 코드의 응집성을 높일 수 있게 되었다."},{"excerpt":"Class 클래스 자바에서  클래스는 클래스의 정보(메타데이터)를 다루는데 사용된다.\n 클래스를 토앻 개발자는 실행 중인 자바 애플리케이션 내에서 필요한 클래스의 정보를 조회하고 조작할 수 있다.  클래스의 주요 기능은 다음과 같다. 타입 정보 얻기: 클래스의 이름, 슈퍼 클래스, 인터페이스, 필드, 메서드, 생성자 정보 등과 같은 정보를 얻을 수 있다.…","fields":{"slug":"/java-class-system/"},"frontmatter":{"date":"December 27, 2024","title":"자바 Class 클래스와 System 클래스","tags":["Java"]},"rawMarkdownBody":"\n# Class 클래스\n자바에서 `Class` 클래스는 클래스의 정보(메타데이터)를 다루는데 사용된다.\n`Class` 클래스를 토앻 개발자는 실행 중인 자바 애플리케이션 내에서 필요한 클래스의 정보를 조회하고 조작할 수 있다.\n\n`Class` 클래스의 주요 기능은 다음과 같다.\n- 타입 정보 얻기: 클래스의 이름, 슈퍼 클래스, 인터페이스, 필드, 메서드, 생성자 정보 등과 같은 정보를 얻을 수 있다.\n- 리플렉션: 클래스에 정의된 메서드, 필드, 생성자 등을 조회하고, 이들을 통해 클래스의 인스턴스를 생성하거나 메서드를 호출는 등의 작업을 할 수 있다.\n- 동적 로딩과 생성: `Class.forName()` 메서드를 사용해 동적으로 클래스를 로딩하고, `newInstance()` 메서드를 사용해 클래스의 인스턴스를 생성할 수 있다.\n- 애노테이션 처리: 클래스에 적용된 애노테이션 정보를 조회하고, 이를 통해 클래스의 동작을 변경할 수 있는 기능을 제공한다.\n\n예를 들어, `String.class`는 `String` 클래스의 정보를 담고 있는 `Class` 객체를 반환한다.\n이를 통해 `String` 클래스의 정보를 조회하거나 조작할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class stringClass = String.class; //클래스에서 조회 \n        //Class stringClass = \"java.lang.String\".getClass(); // 인스턴스에서 조회\n        //Class stringClass = Class.forName(\"java.lang.String\"); // 문자열로 조회\n        \n        \n        // 모든 필드 조회\n        Field[] fields = stringClass.getDeclared;\n        for (Field field : fields) {\n            System.out.println(\"Field: \" + field.getType() + field.getName());\n        }\n        \n        // 모든 메서드 조회\n        Method[] methods = stringClass.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(\"Method: \" + method.getReturnType() + method.getName());\n        }\n        \n        // 상위 클래스 조회\n        System.out.println(stringClass.getSuperclass()); // class java.lang.Object\n        \n        // 인터페이스 조회\n        Class[] interfaces = stringClass.getInterfaces();\n        for (Class inter : interfaces) {\n            System.out.println(\"Interface: \" + inter.getName());\n        }\n    }\n}\n```\n\n위 코드의 실행 결과는 다음과 같다.\n\n```\nField: class java.lang.Stringvalue\n...\nMethod: class java.lang.StringcharAt\nMethod: class java.lang.StringcodePointAt\n...\nSuperclass: java.lang.Object\nInterface: java.io.Serializable\nInterface: java.lang.Comparable\n```\n\n`Class` 클래스는 다음과 같이 3가지 방법으로 조회할 수 있다.\n```java\nClass stringClass = String.class; //클래스에서 조회\nClass stringClass = \"java.lang.String\".getClass(); // 인스턴스에서 조회\nClass stringClass = Class.forName(\"java.lang.String\"); // 문자열로 조회\n```\n\n## Class 클래스의 주요 메서드\n`Class` 클래스는 다음과 같은 주요 메서드를 제공한다.\n\n- `getDeclaredFields()`: 모든 필드를 조회한다.\n- `getDeclaredMethods()`: 모든 메서드를 조회한다.\n- `getSuperclass()`: 슈퍼 클래스를 조회한다.\n- `getInterfaces()`: 인터페이스를 조회한다.\n\n이러한 메서드들을 통해 해당 클래스의 다양한 정보를 확인할 수 있다.\n\n## 클래스 생성\n`Class` 클래스에는 클래스의 모든 정보가 담겨 있기 때문에, 이를 통해 클래스의 인스턴스를 생성하거나, 메서드를 호출하고, 필드의 값도 변경할 수 있다.\n이 문단에서는 간단하게 클래스의 인스턴스를 생성하는 방법을 알아본다.\n\n```java\npublic class Hello {\n    public void hello() {\n        System.out.println(\"Hello, Java!\");\n    }\n}\n```\n\n위와 같은 `Hello` 클래스가 있다고 가정하자.\n이 클래스의 인스턴스를 생성하고, `hello()` 메서드를 호출하는 코드는 다음과 같다.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class helloClass = Hello.class;\n        Hello hello = (Hello) helloClass.getDeclaredConstructor().newInstance();\n        hello.hello();\n    }\n}\n```\n\n위 코드의 실행 결과는 다음과 같다.\n\n```\nHello, Java!\n```\n\n코드에서 사용된 `getDeclaredConstructor().newInstance()` 메서드에 기능은 다음과 같다.\n`getDeclaredConstructor()` 메서드를 통해 클래스의 생성자를 조회하고, `newInstance()` 메서드를 통해 생성자를 호출하여 인스턴스를 생성한다.\n\n## 리플렉션(Relfection)\n`Class` 클래스를 통해 클래스의 메타 데이터를 기반으로 클래스의 인스턴스를 생성하거나, 메서드를 호출하는 등의 작업을 할 수 있다.\n이러한 작업을 리플렉션(Reflection)이라고 한다.\n추가로 애노테이션 정보를 읽어서 특별한 기능을 수행하거나 클래스의 동작을 변경하는 등의 작업도 가능하다.\n최신 프레임워크들은 리플렉션을 적극 활용하여 다양한 기능을 제공하고 있다.\n\n# System 클래스\n\n`System` 클래스는 자바 프로그램과 관련된 시스템과 관련된 정보를 다루는데 사용된다.\n주요 기능을 코드를 통해 알아보겠다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 현재 시간(밀리초)를 가져온다.\n        long currentTimeMillis = System.currentTimeMillis();\n        System.out.println(\"currentTimeMillis: \" + currentTimeMillis);\n\n        // 현재 시간(나노초)를 가져온다.\n        long currentTimeNano = System.nanoTime();\n        System.out.println(\"currentTimeNano: \" + currentTimeNano);\n        \n        // 환경 변수를 읽는다.\n        System.out.println(\"getenv = \" + System.getenv());\n        \n        // 시스템 속성을 읽는다.\n        System.out.println(\"properties = \" + System.getProperties());\n        System.out.println(\"Java version: \" + System.getProperty(\"java.version\"));\n        \n        // 배열을 고속으로 복사한다.\n        char[] originalArray = new char[]{'h', 'e', 'l', 'l', 'o'};\n        char[] copiedArray = new char[5];\n        System.arraycopy(originalArray, 0, copiedArray, 0,\n                originalArray.length);\n        \n        // 배열 출력\n        System.out.println(\"copiedArray = \" + copiedArray);\n        System.out.println(\"Arrays.toString = \" + Arrays.toString(copiedArray));\n        \n        //프로그램 종료\n        System.exit(0);\n    }\n}\n```\n\n- 표준 입력, 출력, 에러 스트림: `System.in`, `System.out`, `System.err` 필드를 통해 표준 입력, 출력, 에러 스트림을 사용할 수 있다.\n- 시간 측정: `System.currentTimeMillis()`, `System.nanoTime()`를 통해 현재 시간을 밀리초, 나노초 단위로 가져올 수 있다.\n- 환경 변수 읽기: `System.getenv()`를 통해 환경 변수를 읽을 수 있다.\n- 시스템 속성 읽기: `System.getProperties()`로 시스템 속성을 읽을 수 있고, `System.getProperty(String key)` 메서드를 통해 특정 속성을 읽을 수 있다.\n- 시스템 종료: `System.exit(int status)`를 통해 프로그램을 종료할 수 있다. 여기서 `status`는 종료 상태를 나타낸다. 일반적으로 0은 정상 종료, 그 외의 값은 비정상 종료를 의미한다.\n- 배열 고속 복사: `System.arraycopy()`는 시스템 레벨에서 최적화된 방식으로 메모리 복사를 연산을 수행한다. 직접 반복문을 사용해서 배열을 복사하는 것보다 수 배 이상 빠른 성능을 제공한다.\n\n"},{"excerpt":"Wrapper Class 자바에서 기본형 타입을 객체로 다루기 위해 제공하는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n래퍼 클래스는 기본형의 한계 때문에 객체로 다루어야 할 때 사용한다. 기본형의 한계 자바는 객체 지향 언어이지만, 자바가 제공하는 것들 중 객체가 아닌 것들이 있다.\n그것들은 , , ,  등과 같은 기본형(Primitiv…","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"date":"December 26, 2024","title":"래퍼 클래스(Wrapper Class)","tags":["Java"]},"rawMarkdownBody":"\n# Wrapper Class\n자바에서 기본형 타입을 객체로 다루기 위해 제공하는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n래퍼 클래스는 기본형의 한계 때문에 객체로 다루어야 할 때 사용한다.\n\n## 기본형의 한계\n자바는 객체 지향 언어이지만, 자바가 제공하는 것들 중 객체가 아닌 것들이 있다.\n그것들은 `int`, `char`, `float`, `double` 등과 같은 기본형(Primitive Type)이다.\n기본형은 앞서 말했듯이 객체가 아니기에 다음과 같은 한계가 있다.\n\n## 객체가 아니기에 발생하는 한계\n\n계속 언급했듯이 기본형 데이터는 객체가 아니기 때문에, 객체 지향 프로그래밍의 특징과 장점을 살릴 수 없다.\n예를 들자면 객체는 유용한 메서드를 가지고 있고 제공할 수 있지만, 기본형은 객체가 아니기에 메서드를 가질 수도 제공할 수도 없다.\n그리고 객체 참조가 필요한 컬렉션 프레임워크를 사용할 수 없고, 제네릭 또한 사용할 수 없다.\n\n기본형의 한계를 이해하기 위해 코드로 예시를 들어보겠다.\n예시 코드는 두 값을 비교해서 다음과 같은 결과를 출력한다\n- 두 값이 같다면 `0`\n- 첫 번째 값이 더 크다면 `1`\n- 두 번째 값이 더 크다면 `-1`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int value = 10;\n        int intValue1 = compareTo(value, 5);\n        int intValue2 = compareTo(value, 10);\n        int intValue3 = compareTo(value, 15);\n\n        System.out.println(\"intValue1: \" + intValue1);\n        System.out.println(\"intValue2: \" + intValue2);\n        System.out.println(\"intValue3: \" + intValue3);\n    }\n\n    public static int compareTo(int value, int target) {\n        if (value < target) {\n            return -1;\n        } else if (value > target) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n```\n\n위 코드는 `value`와 비교 대상 값을 `compareTo` 메서드에 넘겨주어 비교한 후 결과를 출력한다.\n그런데 자기 사신인 `value`와 다른 값을 연산하는 것이기에 항상 자기 자신의 값인 `value`가 사용된다.\n이런 경우 만약 `value`가 객체라면 `value` 객체 스스로 자기 자신의 값과 비교 대상 값을 비교할 수 있는 메소드를 만드는 것이 더 효율적일 것이다.\n\n그래서 이런 한계를 극복하기 위해 자바는 기본형을 객체로 다루기 위한 래퍼 클래스를 제공한다.\n이 문단에서는 래퍼 클래스를 구현해서 기본형의 한계를 극복하는 방법을 알아보겠다.\n\n먼저 `int`를 객체로 다루기 위한 래퍼 클래스를 구현해보자.\n`int`는 클래스가 아니지만, `int` 값을 가지고 있는 객체를 만들어서 `int`를 객체로 다룰 수 있다.\n다음 코드는 `int`를 객체로 다루기 위한 래퍼 클래스를 구현한 코드이다.\n이렇게 특정 기본형을 감싸서(Wrap) 객체로 만들어주는 클래스를 래퍼 클래스(Wrapper Class)라고 한다.\n\n```java\npublic class IntWrapper {\n    \n    private final int value;\n\n    public IntWrapper(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public int compareTo(int target) {\n        if (value < target) {\n            return -1;\n        } else if (value > target) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    \n    @Override\n    public String toString() {\n        return String.valueOf(value);tring\n    }\n}\n```\n\n위 코드에서 `IntWrapper` 클래스는 `int` 값을 가지고 있는 객체를 만들어주는 래퍼 클래스이다.\n이를 통해 기본형 변수를 편리하게 사용할 수 있도록 다양한 메소드를 제공한다.\n앞에서 구현한 `compareTo` 메서드를 `IntWrapper` 클래스에 내부로 캡슐화하여 구현했다.\n그리고 이클래스는 불변으로 만들기 위해 `value` 필드를 `final`로 선언했다.\n\n이제 `IntWrapper` 클래스를 사용해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntWrapper value = new IntWrapper(10);\n        int intValue1 = value.compareTo(5);\n        int intValue2 = value.compareTo(10);\n        int intValue3 = value.compareTo(15);\n\n        System.out.println(\"intValue1: \" + intValue1);\n        System.out.println(\"intValue2: \" + intValue2);\n        System.out.println(\"intValue3: \" + intValue3);\n    }\n}\n```\n\n위 코드는 `IntWrapper` 클래스의 `compareTo` 메서드를 사용하여 `value`와 비교 대상 값을 비교한다.\n`IntWrapper`는 객체이기에 예시 코드처럼 자신이 가진 메서드를 편리하게 호출할 수 있다.\n\n## null 값을 가질 수 없는 한계\n\n기본형은 항상 값을 가져야 한다. 하지만 프로그래밍을 하다보면 상황에 따라 데이터가 없는 경우가 발생한다.\n그리고 이때 데이터가 없음을 나타내기 위해 `null`이라는 상태가 필요할 수 있다.\n하지만 기본형은 `null` 값을 가질 수 없기 때문에 이런 상황을 처리하기 어렵다.\n\n해당 상황에 대한 예시 코드를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int[] values = {-1, 0, 1, 2, 3};\n        System.out.println(findValue(values, -1)); // -1\n        System.out.println(findValue(values, 0)); // 0\n        System.out.println(findValue(values, 1)); // 1\n        System.out.println(findValue(values, 100)); // -1\n    }\n\n    public static int findValue(int[] values, int target) {\n        for (int value : values) {\n            if (value == target) {\n                return value;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n위 코드는 `findValue` 메서드를 사용하여 배열에서 특정 값을 찾는다.\n그리고 해당 값이 있으면 값을 반환하고, 없으면 `-1`을 반환한다.\n`findValue`는 결과로 항상 `int`를 반환하게 되는데, 이때 `int`와 같은 기본형은 항상 값이 있어야 한다.\n여기서도 값을 반환할 때 값을 찾지 못한다면 숫자 중에 하나를 반환해야 하는데 보통 이때는 `-1`이나 `0`을 반환한다.\n\n하지만 이런 경우에는 `-1`이나 `0`이 실제로 배열에 있는 값일 수도 있다.\n코드를 보면 `-1`일 때 `-1`을 반환하는 경우가 있는데, 배열에 없는 값 `100`을 입력해도 같은 `-1`을 반환한다.\n그래서 이런 경우에는 `-1`을 반환하는 것이 정상적인 결과인지 아닌지 판단하기 어렵다.\n\n객체의 경우는 이런 상황에서 데이터가 없다는 것을 나타내기 위해 `null`을 사용할 수 있다.\n그럼 이제 `null`을 가질 수 있는 래퍼 클래스를 이용한 코드를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntWrapper[] values = {new IntWrapper(-1), new IntWrapper(0), new IntWrapper(1), new IntWrapper(2), new IntWrapper(3)};\n        System.out.println(findValue(values, new IntWrapper(-1))); // -1\n        System.out.println(findValue(values, new IntWrapper(0))); // 0\n        System.out.println(findValue(values, new IntWrapper(1))); // 1\n        System.out.println(findValue(values, new IntWrapper(100))); // null\n    }\n    \n    private static IntWrapper findValue(IntWrapper[] values, IntWrapper target) {\n        for (IntWrapper value : values) {\n            if (value.equals(target)) {\n                return value;\n            }\n        }\n        return null;\n    }\n}\n```\n\n위 코드에선 앞서 구현해놓은 `IntWrapper` 클래스를 사용하여 `null`을 반환할 수 있는 `findValue` 메서드를 구현했다.\n실행결과를 보면 `findValue` 메서드는 배열에서 특정 값을 찾아서 반환하는데, 값이 없다면 `null`을 반환한다.\n이렇게함으로써 `null`을 반환하면 값이 없다는 것을 명확하게 나타낼 수 있다.\n\n앞선 `IntWrapper`를 사용하지 않은 예시에서도 본 것 처럼 기본형은 항상 값이 존재해야 한다.\n반면에 객체인 참조형은 값이 없다는 `null`을 사용할 수 있다.\n물론 `null` 값을 반환하는 경우 잘못하면 `NullPointerException`이 발생할 수 있기 때문에 주의해서 사용해야 한다.\n\n## 자바 래퍼 클래스\n위에서 설명한 것처럼 래퍼 클래스는 기본형을 객체로 감싸서 더 편리하게 사용할 수 있도록 다양한 기능을 제공하기에 상당히 유용하다는 것을 알 수 있었다.\n지금까지 설명은 기본형의 한계로 인한 래퍼 클래스에 대한 필요성을 이해하고자 설명을 한 것이다.\n그래서 자바에서는 기본형을 객체로 다루기 위한 래퍼 클래스를 제공한다.\n\n자바는 다음과 같이 기본형에 대응하는 래퍼 클래스를 기본으로 제공한다.\n- `byte`: `Byte`\n- `short`: `Short`\n- `int`: `Integer`\n- `long`: `Long`\n- `float`: `Float`\n- `double`: `Double`\n- `char`: `Character`\n- `boolean`: `Boolean`\n\n그리고 자바가 제공하는 기본 래퍼 클래스는 다음과 같은 특징을 가진다.\n- 불변(Immutable)이어서 값을 변경할 수 없다.\n- `equals()`로 값을 비교해야한다.\n\n### 박싱(Boxing)\n앞서 말해듯이 자바의 기본 래퍼 클래스는 기본형을 객체로 다루기 위해 존재한다.\n기본형을 객체로 다루기 위해 래퍼 클래스로 변경하는 모습이 마치 상자에 기본형을 담는 것과 같다고 해서 이런 행위를 박싱(Boxing)이라고 한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int intValue = 10;\n        Integer integerValue = Integer.valueOf(intValue); // Boxing\n    }\n}\n```\n\n### 언박싱(Unboxing)\n박싱과 반대로 래퍼 클래스를 기본형으로 변경하는 것을 언박싱(Unboxing)이라고 한다.\n박스에 담겨져 있는 것을 꺼내는 것 같다고 해서 이런 행위를 언박싱이라고 한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue = Integer.valueOf(10);\n        int intValue = integerValue.intValue(); // Unboxing\n    }\n}\n```\n\n### 비교는 equals() 사용\n래퍼 클래스는 객체이기에 `==` 연산자로 비교하면 주소값을 비교하게 된다.\n그래서 래퍼 클래스는 `equals()` 메서드를 재정의하여 내부의 값을 비교하도록 구현되어 있다.\n따라서 래퍼 클래스의 값을 비교할 때는 `equals()` 메서드를 사용해야 한다.\n참고로 래퍼 클래스 객체를 그대로 출해도 내부의 값을 출력하도록 `toString()` 메서드 역시 재정의되어 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue1 = Integer.valueOf(10);\n        Integer integerValue2 = Integer.valueOf(10);\n        System.out.println(integerValue1 == integerValue2); // false\n        System.out.println(integerValue1.equals(integerValue2)); // true\n    }\n}\n```\n\n### 오토 박싱(Auto Boxing)과 오토 언박싱(Auto Unboxing)\n자바에서는 기본형에서 래퍼 클래스로 변환하는 작업이 자주 발생하기 때문에 이를 편리하게 사용할 수 있도록 오토 박싱(Auto Boxing)과 오토 언박싱(Auto Unboxing) 기능을 제공한다.\n여기서 오토 박싱은 기본형을 래퍼 클래스로 자동으로 변환하는 것이고, 오토 언박싱은 래퍼 클래스를 기본형으로 자동으로 변환하는 것이다.\n자동으로 변환되기 때문에 개발자는 이를 명시적으로 변환하지 않아도 된다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer integerValue = 10; // Auto Boxing\n        int intValue = integerValue; // Auto Unboxing\n    }\n}\n```\n\n## 래퍼 클래스 주요 메서드\n래퍼 클래스는 기본형을 객체로 다루기 위한 클래스이기에 기본형과 관련된 다양한 메서드를 제공한다.\n래퍼 클래스의 주요 메서드는 다음과 같다.\n\n- `valueOf()`: 기본형 값을 래퍼 클래스 객체로 변환한다.\n- `parseInt()`: 문자열을 정수로 변환한다.\n- `compareTo()`: 두 값을 비교한다.\n- `Integer.sum()`, `Integer.max()`, `Integer.min()`: `static` 메서드로 두 값을 더하거나 최대값, 최소값을 구한다.\n\n### parseInt()와 valueOf()\n`parseInt()`와 `valueOf()` 메서드는 문자열을 정수로 변환하는 메서드이다.\n`parseInt()`는 정적 메서드로 문자열을 정수로 변환하고, `valueOf()`는 인스턴스 메서드로 문자열을 정수로 변환한다.\n- `parseInt(\"10\")`은 기본형인 `int`를 반환한다.\n- `valueOf(\"10\")`은 래퍼 클래스인 `Integer`를 반환한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int intValue1 = Integer.parseInt(\"10\");\n        Integer integerValue2 = Integer.valueOf(\"10\");\n    }\n}\n```\n\n## 래퍼 클래스 성능\n래퍼 클래스는 객체이기에 기본형보다 다양한 메서드를 제공하고 편리하게 사용할 수 있다.\n근데 그렇다면 기본형 보다 좋은 래퍼 클래스만 사용하면 되지 왜 기본형을 제공하고 사용하는 것일까?\n다음 코드를 통해 래퍼 클래스와 기본형의 성능 차이를 알아보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int iterations = 1_000_000_000;\n        long startTime, endTime;\n        long sumPrimitive = 0;\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < iterations; i++) {\n            sumPrimitive += i;\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"기본 자료형 연산 경과 시간: \" + (endTime - startTime) + \"ms\");\n        \n        Long sumWrapper = 0L;\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < iterations; i++) {\n            sumWrapper += i;\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"래퍼 클래스 연산 경과 시간: \" + (endTime - startTime) + \"ms\");\n        \n    }\n}\n```\n\n단순히 값을 반복해서 10억번 더하는 코드를 작성했다.\n그리고 기본형 `long`과 래퍼 클래스 `Long`을 사용하여 성능을 비교했다.\n결과는 다음과 같다.\n\n```java\n기본 자료형 연산 경과 시간: 361ms\n래퍼 클래스 연산 경과 시간: 1828ms\n```\n\n물론 시스템 성능의 따라 다르겠지만, 기본형 연산이 래퍼 클래스 연산보다 약 5배 정도 빠르다는 것을 확인 할 수 있다.\n그 이유는 기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지한다. 예를들면 `int`는 4바이트, `long`은 8바이트이다.\n하지만 래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 외에도 자바에서 객체를 다루는데 필요한 객체 메타데이터를 포함하므로 더 많은 메모리를 차지한다.\n대략 래퍼 클래스는 기본형의 2배 정도의 메모리를 차지한다.\n\n### 유지보수와 최적화\n그럼 뭐를 사용하라는 것일까?\n아까는 래퍼 클래스가 기본형보다 편해서 좋다고 했다가,\n지금은 기본형이 래퍼 클래스보다 성능이 좋다고 했다가\n혼란스럽지 않은가?\n\n앞서 실험한 코드를 보면 5배라는 성능 차이는 10억번의 연산을 수행했을 때 발생한 것이다.\n기본형이든 래퍼 클래스든 이것을 1회로 환산하면 둘 다 매우 빠르게 연산이 수행된다.\n즉 10억번 연산의 결과인 0.3초와 1.8초라는 차이는 사실 1번 연산의 결과로 환산하면 0.3초 나누기 10억과 1.8초 나누기 10억이라는 매우 작은 차이이다.\n일반적인 애플리케이션을 만드는 관점에서 봤을 때 이정도의 성능 차이는 최적화를 한다 해도 큰 의미가 없다.\n\n만약 이렇게 유지보수와 최적화를 두고 둘중에 하나를 선택해야 한다면 유지보수를 먼저 고려하는 것이 좋다.\n우선 요즘 컴퓨터는 매우 빠르기 때문에 이정도의 성능 차이는 크게 의미가 없다.\n그리고 코드 변경 없이 성능 최적화를 하면 가장 좋겠지만, 성능 최적화는 대부분 단순함보다 복잡함을 요구하고, 더 많은 코드를 추가로 작성해야 한다.\n이는 최적화를 위해 유지보수 해야 할 코드가 늘어난다는 것이다.\n그런데 여기서 진짜 문제는 최적화를 한다고 했지만 전체 애플리케이션의 성능 관점에서 보면 불필요한 최적화일 수 있다.\n시간과 노력을 들여서 최적화를 했지만, 전체 애플리케이션의 성능에는 큰 영향을 미치지 않는다면 그것은 얼마나 비효율적인가?\n\n특히 웹 어플리케이션의 경우, 메모리 안에서 발생하는 연산 속도보다 네트워크 호출 속도가 수천수만배는 더 느리다.\n이 말은 자바 메모리 내부에서 발생하는 연산을 수천번에서 한 번으로 줄이는 것보다, 네트워크 호출 한 번을 줄이는 것이 훨씬 더 중요하다는 것이다.\n그래서 성능 최적화를 할 때는 전체 애플리케이션의 성능을 고려해야 한다.\n\n\n"},{"excerpt":"String Optimization 자바 컴파일러는 다음과 같이 문자열을 처리하는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다. String literal 결합 최적화 위 코드는 과 를 합쳐 에 저장하는 코드이다. 하지만 자바 컴파일러는 이 코드를 다음과 같이 최적화하여 처리한다. 컴파일과정에서 문자열을 합치는 코드를 만나면, 이를 최적화하…","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"date":"December 24, 2024","title":"문자열 최적화(String Optimization)","tags":["Java"]},"rawMarkdownBody":"\n# String Optimization\n자바 컴파일러는 다음과 같이 문자열을 처리하는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다.\n\n## String literal 결합 최적화\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\nString str3 = str1 + str2;\n```\n\n위 코드는 `str1`과 `str2`를 합쳐 `str3`에 저장하는 코드이다. 하지만 자바 컴파일러는 이 코드를 다음과 같이 최적화하여 처리한다.\n\n```java\nString str3 = \"HelloWorld\";\n```\n\n컴파일과정에서 문자열을 합치는 코드를 만나면, 이를 최적화하여 하나의 문자열로 만들어준다.\n따라서 런타임에 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상된다.\n\n## String 변수 최적화\n문자열 변수의 경우 그 안에 어떤 문자열이 들어있는지 컴파일 시점에서는 알 수 없기 때문에, 단순하게 결합할 수 없다.\n\n```java\nString result = str1 + str2;\n```\n\n이런 상황인 경우, 다음과 같이 최적화를 수행한다.(최적화 방식은 자바 버전에 따라 다를 수 있다.)\n\n```java\nString result = new StringBuilder().append(str1).append(str2).toString();\n```\n\n> 참고\n> 자바 9부터는 `StringConcatFactory` 클래스를 통해 `invokedynamic`를 사용하여 문자열 결합 최적화를 수행한다.\n\n이렇듯 자바가 최적화 처리해주기 때문에 간단한 경우에는 `StringBuilder`를 사용하지 않아도 된다.\n\n## String 최적화가 어려운 경우\n하지만 다음과 같이 문자열을 루프안에서 문자열을 결합하는 경우에는 최적화가 이루어지지 않는다.\n\n```java\nString result = \"\";\nfor (int i = 0; i < 10000; i++) {\n    result += i;\n}\n```\n\n왜냐하면 루프안에서 문자열을 결합할 때마다 다음과 같이 새로운 문자열을 생성하기 때문이다.\n\n```java\nString result = \"\";\nfor (int i = 0; i < 10000; i++) {\n    result = new StringBuilder().append(result).append(i).toString();\n}\n```\n\n반복문의 내부에서는 최적화가 되는 것 처럼 보이지만, 실제로는 반복 횟수만큼 새로운 문자열을 생성하고 이를 참조하게 된다.\n반복문 내에서의 문자열 연결은 런타임에 연결할 문자열의 개수와 내용이 결정된다.\n이런 경우, 컴파일러는 얼마나 많은 반복이 일어날지, 각 반복에서 어떤 문자열이 결합될지 알 수 없기 때문에 최적화를 수행하기에 어려움이 있다.\n\n`StringBuffer`도 마찬가지로 최적화가 이루어지지 않을 것이다.\n아마도 대략 반복 횟수인 10,000번만큼 `StringBuffer` 객체를 생성하고, 이를 참조하게 했을 것이다.\n\n위 코드를 실행하면, `String`을 사용한 경우에는 약 1초 정도가 걸렸다.\n이럴 떄는 `StringBuilder`를 사용하면 된다.\n\n```java\nStringBuilder result = new StringBuilder();\nfor (int i = 0; i < 10000; i++) {\n    result.append(i);\n}\n```\n\n`StringBuilder`를 사용한 경우에는 1ms도 걸리지 않는다.\n\n정리를 하자면 문자열을 결합하는 상황의 대부분의 경우 최적화가 되므로 `+` 연산을 사용하면 된다.\n하지만 `StringBuiler`를 사용하는 것이 더 좋은 경우도 있다.\n\n\n## StringBuilder를 직접 사용하는 것이 더 좋은 경우\n반복문에서 반복해서 문자를 연결할 때\n조건문을 통해 동적으로 문자열을 조합할 때\n복잡한 문자열의 특정 부분을 변경해야 할 때\n매우 긴 대용량 문자열을 다룰 때\n\n> 참고 - StringBuilder vs StringBuffer\n> `StringBuilder` 와 똑같은 기능을 수행하는 `StringBuffer` 클래스도 있다.\n> `StringBuffer` 는 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인해 성능이 느리다.\n> `StringBuilder` 는 멀티 쓰레드에 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 속도가 빠르다.\n> 자세한 내용은 [String vs StringBuilder vs StringBuffer](https://023-dev.github.io/2024-11-05/java-string-stringbuffer-stringbuilder)를 참고하면 되겠다.\n\n## StringBuilder와 Method Chain\n`String`은 `char[]`를 보다 효율적이고 쉽게 다룰 수 있도록 한 클래스이다.\n`StringBuilder` 또한 이러한 기능들을 제공하는데 그 중 하나가 메서드 체인(Method Chain)이다.\n\n`StringBuilder`의 `append()` 메서드의 내부코드를 보면 `this`로 자기 자신의 참조값을 반환하고 있다.\n\n```java\npublic StringBuilder append(String str) {\n    super.append(str);\n    return this;\n}\n```\n\n`StringBuilder`에서 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 `this`를 반환하고 있다.\n이를 이용하면 다음과 같이 메서드를 연쇄적으로 호출할 수 있다.\n\n대표적으로 `insert()`, `delete()`, `reverse()`, `replace()` 등이 있다.\n\n앞서 `StringBuilder`를 사용한 코드를 다음과 같이 개선할 수 있다.\n\n```java\nStringBuilder sb = new StringBuilder();\nString string = sb.append(\"A\").append(\"B\").append(\"C\").append(\"D\")\n        .insert(4, \"Java\")\n        .delete(4, 8)\n        .reverse()\n        .toString();\n\nSystem.out.println(string); // DCBA\n```\n\n이렇게 메서드 체인을 사용하면 코드가 간결해지고 가독성이 좋아진다.\n메서드 체이닝의 구현은 복잡하고 번거롭지만 사용하는 입장에서는 편리함을 경험할 수 있다.\n자바의 라이브러리와 오픈 소스들은 메서드 체이닝 기법을 많이 사용하고 있다.\n\n"},{"excerpt":"불변 객체(Immutable Object) 객체의 상태(객체 내부 데이터, 필드, 속성)가 객체의 수명 동안 변하지 않는 객체를 불변 객체(Immutable Object)라고 한다.\n불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다. 자바에서 가장 많이 사용되는  또한 불변 객체이다.\n뿐만…","fields":{"slug":"/java-immutable/"},"frontmatter":{"date":"December 23, 2024","title":"불변 객체(Immutable Object)","tags":["Java"]},"rawMarkdownBody":"\n# 불변 객체(Immutable Object)\n객체의 상태(객체 내부 데이터, 필드, 속성)가 객체의 수명 동안 변하지 않는 객체를 불변 객체(Immutable Object)라고 한다.\n불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다.\n\n자바에서 가장 많이 사용되는 `String` 또한 불변 객체이다.\n뿐만 아니라 자바가 기본적으로 제공하는 래퍼클래스나 `LocalDate`, `LocalTime`, `LocalDateTime` 등도 불변으로 설계되어 있다.\n이러한 클래스를 제대로 활용하기 위해서는 불변 객체에 대한 원이를 제대로 이해해야 할 것이다.\n\n## 불변 객체 설계\n불변 클래스는 다음 코드와 같이 만들 수 있다.\n\n```java\npublic class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n위 코드에서 `ImmutablePerson` 클래스는 `name`과 `age` 필드를 가지고 있다.\n내부 값이 변경되지 않기 위해 필드를 `final`로 선언하고, 생성자를 통해 필드 값을 초기화를 제한한다.\n또한 값을 변경할 수 있는 `setter` 메소드를 제공하지 않는다.\n이 클래스는 생성자를 통해 값을 초기화하고, 이후에는 값을 변경하는 것이 불가능하다.\n\n이렇듯 불변 클래스를 만드는 방법은 아주 단순하다.\n어떻게든 객체의 상태를 변경하는 메소드를 제공하지 않고, 객체의 상태를 변경할 수 없도록 만들면 된다.\n\n이러한 불변이라는 단순한 제약을 사용해서 참조형 객체를 사용할 때 발생할 수 있는 사이드 이펙트라는 문제를 방지할 수 있다.\n하지만 불변 객체는 설계상 값을 변경할 수 없다.\n따라서 불변 객체의 값을 변경하고자 한다면 변경하고 싶은 값으로 새로운 불변 객체를 생성해야 한다.\n이렇게 해야 기존 변수들이 참조하는 값에 영향을 주지 않고 새로운 값을 생성할 수 있다.\n\n> 참고 - 가변(Mutable) 객체와 불변(Immutable) 객체\n> 가변은 이름 그대로 처음 만든 이후 상태가 변할 수 있는 객체를 의미한다.\n> 가변 객체는 객체의 상태가 변할 수 있기 때문에 객체를 생성한 시점의 상태를 유지하지 않으며, 객체의 상태를 변경할 수 있다.\n> 불변은 처음 만든 이후 상태가 변하지 않는 객체를 의미한다.\n> 불변 객체는 객체의 상태가 변하지 않기 때문에 객체를 생성한 시점의 상태를 유지하며, 객체의 상태를 변경할 수 없다.\n\n## 값 변경\n이러한 불변 객체를 사용하지만 그래도 값을 변경해야 하는 경우가 있다.\n그럼 어떻게 해야 할까?\n기존 객체의 값을 변경하는 대신 그대로 두고 대신에 변경된 결과를 가지는 새로운 객체를 생성하여 반환하면 된다.\n이때 불변 객체에서 변경과 관련된 메서드들은 보통 객체를 새로 생성해서 반환하기 때문에\n반환 값을 받아야 한다.\n\n```java\npublic class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public ImmutablePerson changeName(String name) {\n        return new ImmutablePerson(name, this.age);\n    }\n\n    public ImmutablePerson changeAge(int age) {\n        return new ImmutablePerson(this.name, age);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n위 코드에서 `changeName`과 `changeAge` 메소드는 이름과 나이를 변경한 새로운 `ImmutablePerson` 객체를 생성하여 반환한다.\n이렇게 하면 기존 객체의 상태를 변경하지 않고 새로운 객체를 생성하여 변경된 값을 가질 수 있다.\n\n## 불변 객체 존재 이유\n보통 우리가 설계하는 대부분의 클래스는 가변 객체일 것이다.\n이렇게 까지 불변 객체를 사용하는 이유는 무엇일까?\n그것은 불변 객체가 가지는 여러 장점 때문이다.\n먼저 캐시 안정성이다.\n불변 객체는 한 번 생성되면 그 상태가 변하지 않기 때문에 캐싱할 수 있다.\n또한 멀티 스레드 안전성을 보장한다.\n불변 객체는 여러 스레드에서 동시에 접근해도 안전하다.\n마지막으로 엔티티의 값 타입으로 사용할 수 있다.\n불변 객체는 값 타입으로 사용하기에 적합하다. \n\n"},{"excerpt":"여기서 가치있는 정보를 얻으려면 데이터를 많이 수집해야하지만, 무조건 많이 수집하는 것만으로는 충분하지 않다.\n수집된 데이터를 효율적으로 관리하고 언제든 필요한 정보를 빠르게 찾아낼 수 있어야 한다.\n이 글에서는 이러한 효율적인 데이터 관리를 위한 데이터베이스 관리 시스템(DBMS)에 대해 알아본다. 파일 시스템의 문제점 데이터베이스 관리 시스템(DBMS…","fields":{"slug":"/database-dbms/"},"frontmatter":{"date":"December 21, 2024","title":"데이터베이스 관리 시스템(DBMS)","tags":["Database"]},"rawMarkdownBody":"\n여기서 가치있는 정보를 얻으려면 데이터를 많이 수집해야하지만, 무조건 많이 수집하는 것만으로는 충분하지 않다.\n수집된 데이터를 효율적으로 관리하고 언제든 필요한 정보를 빠르게 찾아낼 수 있어야 한다.\n이 글에서는 이러한 효율적인 데이터 관리를 위한 데이터베이스 관리 시스템(DBMS)에 대해 알아본다.\n\n## 파일 시스템의 문제점\n\n데이터베이스 관리 시스템(DBMS)에 대해 알아보기 전에, 데이터베이스 이전에 데이터를 관리하기 위해 가장 먼저 사용되던 방식은 파일 시스템에 대해 알아보자.\n파일 시스템은 데이터를 파일 단위로 저장하고 관리하는 방식이다.\n\n그럼 왜 파일 시스템을 사용하지 않고 데이터베이스를 사용할까?\n이것을 알아가기 전에 먼저 파일 시스템의 저장 방식을 알아야 한다.\n파일 시스템은 데이터를 파일 단위로 저장하고, 이 파일을 읽고 쓰는 방식으로 데이터를 처리한다.\n흔히 사용되는 윈도우 파일 탐색기를 예로 들 수 있다.\n이러한 파일 시스템은 애플리케이션마다 필요한 데이터를 독립적으로 저장하고 관리한다.\n이는 특정 하드웨어나 소프트웨어에 종속되는 것을 의미한다.\n\n그럼 이제 왜 파일 시스템을 사용하지 않고 데이터베이스를 사용하는지 파일 시스템의 문제점을 살펴보자.\n\n### 데이터 종속의 문제\n위에서 언급한 것처럼 파일 시스템은 특정 하드웨어나 소프트웨어에 종속되어 있다.\n이는 데이터를 저장하는 방식이나 데이터에 접근하는 방식이 특정 시스템에 의존적이라는 것을 의미한다.\n이러한 종속성은 데이터를 다른 시스템으로 마이그레이션하거나 다른 시스템에서 사용하기 어렵게 만든다.\n\n### 데이터 중복의 문제\n파일 시스템은 애플리케이션마다 필요한 데이터를 독립적으로 저장하고 관리한다고 언급했다.\n이때 애플리케이션 별로 데이터를 생성하기에 동일한 데이터가 여러 번 중복되어 저장될 수 있다.\n이렇게 생성된 중복 데이터들은 데이터의 일관성을 해치는 다양한 문제를 야기한다.\n어떠한 데이터를 수정할 때 동일한 그리고 중복된 모든 데이터를 수정해야 하기에 데이터 관리가 어려워진다.\n그리고 중복 데이터를 저장하는 것은 그만큼 저장 공간을 차지하여 낭비하는 것이기에 경제성 또한 떨어진다.\n중복된 데이터는 보안성에서도 문제가 되는데, 각각의 동일 데이터에 대한 보안 수준을 유지하기 어려워 진다.\n\n### 무결성 훼손의 문제\n데이터의 무결성은 데이터의 정확성과 일관성을 의미한다.\n이러한 무결성을 보장하기 위해서는 제약조건을 설정하고 이를 지키는 것이 중요하다.\n파일 시스템은 데이터를 독립적으로 저장하고 이에따른 수많은 중복 데이터가 많아짐에 따른 개별 데이터들을 모니터링을 하여 이러한 제약조건을 지키기 어렵다.\n이로 인해 데이터의 무결성이 훼손될 가능성이 높아진다.\n\n### 동시 접근의 문제\n파일 시스템에서 다수의 사용자가 동시에 데이터에 접근하려고 할 때 문제가 발생할 수 있다.\n예를 들어 사용자 A가 파일을 수정하고 있는 동안 사용자 B가 동일 파일을 읽으려고 한다면 어떻게 될까?\n이 경우에 사용자 B는 수정 중인 파일을 읽을 수 없게 된다.\n이러한 문제를 해결하기 위해서는 파일을 읽기 전에 잠금을 걸어 다른 사용자가 파일을 수정하지 못하게 해야 한다.\n하지만 파일 시스템은 이러한 동시 접근 문제를 해결하기 위한 기능을 제공하지 않는다.\n\n## 데이터베이스의 정의\n파일 시스템의 문제점을 해결하기 위해 등장한 방식이 데이터베이스이다.\n데이터베이스는 무엇인지에 대한 정의는 다음과 같다.\n\n### 통합된 데이터\n데이터베이스는 중복 데이터를 최소화하고 중복 데이터를 피하기 위해 데이터를 통합하여 저장한다.\n이를 통해 데이터의 일관성을 유지하고 데이터의 정확성을 보장한다.\n\n### 저장된 데이터\n데이터베이스의 데이터는 컴퓨터가 접근할 수 있는 저장 매체에 저장된다.\n이러한 저장 매체는 하드디스크, SSD, 메모리 등이 있을 수 있다.\n\n### 운영 데이터\n데이터베이스는 조직의 운영에 필요한 데이터를 저장하고 관리한다.\n이러한 데이터는 조직의 운영에 필요한 데이터로, 조직의 목적에 따라 다양한 데이터가 저장될 수 있다.\n\n### 공용 데이터\n데이터베이스는 여러 사용자가 동시에 데이터에 접근할 수 있도록 공유된다.\n이러한 공용 데이터는 여러 사용자가 동시에 데이터에 접근할 수 있도록 하기 위해 데이터베이스 관리 시스템(DBMS)에 의해 관리된다.\nDBMS에 대해서는 뒤에서 자세히 다룰 것이다.\n\n## 데이터베이스의 특징\n데이터베이스에 대해 알아보았다.\n그럼 이러한 데이터베이스는 어떻게 파일 시스템과 다른지 그리고 어떻게 파일 시스템의 문제점을 해결할 수 있는지 데이터베이스가 가지는 특징을 살펴보자.\n\n\n### 실시간 접근성\n데이터베이스는 사용자의 수시적이고 비정형적인 질의 요구에 실시간으로 응답할 수 있어야 한다.\n실시간 처리에서는 사용자의 개인 특성이나 제공되는 서비스 유형에 따라 허용되는 응답 시간이 다르지만 대개 몇 초를 넘지 않는 시간 내에 데이터를 제공할 수 있어야 한다.\n\n### 지속적인 변화\n데이터베이스는 현실 세계의 상태르 정확히 반영해야 의미가 있다.\n그렇지만 현실 세계는 끊임없이 변화한다.\n이에 데이터베이스는 지속적인 변화를 반영할 수 있어야 한다.\n즉, 데이터베이스는 동적인 상태 유지를 위해 새로운 데이터의 삽입(Insert),삭제(Delete),갱신(Update)로 항상 최신의 데이터를 유지해야 한다.\n\n### 동시 공유\n데이터베이스는 동시 공유의 특성을 제공해 다수의 사용자가 동시에 데이터에 접근하고 데이터를 수정할 수 있도록 해야 한다.\n여기서 공시 공유는 사용자가 서로 다른 데이터를 동시에 접근하는 것뿐만아니라, 동일한 데이터에 대해 동시에 접근하는 것도 포함한다.\n\n### 내용에 의한 참조\n일반적인 컴퓨터 시스템의 검색은 저장된 데이터의 주소를 알아야 가능하다.\n하지만 데이터베이스는 저장된 주소가 아닌 데이터의 내용이나 값으로 데이터를 찾아 참조할 수 있다.\nC언어의 포인터나, URL 주소를 떠올리면 된다.\n\n## 데이터베이스 관리 시스템(DBMS) 특징\n데이터베이스 관리 시스템(DBMS)은 데이터베이스를 사용하는 사용자나 응용 프로그램이 데이터베이스에 접근할 수 있도록 해주며, 데이터베이스의 보안, 무결성, 백업, 복구 등을 관리한다.\n이러한 DBMS는 데이터베이스의 효율적인 관리를 위해 다양한 기능을 제공하고 다음과 같은 특징을 가진다.\n\n### 데이터 독립성\n데이터베이스를 이용하면 업무의 흐름에 따라 데이터를 통합 및 분리하여 관리할 수 있게 되므로 중복성을 줄일 수 있다.\n이 부분은 모델링의 정규화에 대한 이야기로, 데이터의 중복성을 줄이고 데이터의 일관성을 유지하기 위한 방법이다.\n\n### 데이터 무결성\n데이터베이스는 데이터의 무결성을 보장하기 위해 제약조건을 설정할 수 있다.\n제약조건에 맞지 않는 데이터의 삽입, 수정, 삭제를 방지하여 데이터의 무결성을 보장한다.\n기능적으로는 참조 무결성, 개체 무결성, 도메인 무결성 등이 있다.\n\n### 데이터 보안성\n데이터베이스 시스템의 데이터는 중요한 정보를 담고 있기 때문에 데이터의 보안성이 중요하다.\nDBMS는 데이터베이스에 접근하는 사용자의 권한을 관리하여 데이터의 보안성을 보장한다.\n\n### 데이터 일관성\n데이토의 불일치성을 미리 방지하여 데이터를 정확하게 유지하여 사용자에게 일관된 정보를 제공한다.\n트랜잭션이라는 작업의 논리적 단위를 통해 데이터의 일관성을 유지한다.\n\n\n## 참고\n- [데이터베이스](https://ko.wikipedia.org/wiki/데이터베이스)\n- [데이터베이스 관리 시스템](https://ko.wikipedia.org/wiki/데이터베이스_관리_시스템)\n- [파일 시스템](https://ko.wikipedia.org/wiki/파일_시스템)\n- [데이터베이스의 정의와 특징](https://coding-factory.tistory.com/214)"},{"excerpt":"Phantom Read란 무엇인가? Phantom Read는 트랜잭션이 동일한 조건의 쿼리를 반복 실행할 때, 나중에 실행된 쿼리에서 처음에는 존재하지 않았던 새로운 행이 나타나는 현상을 말한다.\n이는 주로 읽기 일관성(Read Consistency) 을 유지하는 과정에서 발생할 수 있는 문제로, 데이터의 삽입이나 삭제가 다른 트랜잭션에 의해 이루어질 때…","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"date":"December 21, 2024","title":"Phantom Read와 Gap Lock, Next-Key Lock","tags":["Database"]},"rawMarkdownBody":"\n# Phantom Read란 무엇인가?\n\nPhantom Read는 트랜잭션이 동일한 조건의 쿼리를 반복 실행할 때, 나중에 실행된 쿼리에서 처음에는 존재하지 않았던 새로운 행이 나타나는 현상을 말한다.\n이는 주로 읽기 일관성(Read Consistency) 을 유지하는 과정에서 발생할 수 있는 문제로, 데이터의 삽입이나 삭제가 다른 트랜잭션에 의해 이루어질 때 발생한다.\n\n```sql\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A 첫 번째 조회\nSELECT * FROM orders WHERE amount > 150;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B 새로운 행 삽입\nINSERT INTO orders (customer_id, amount) VALUES (4, 250);\n\n-- 트랜잭션 B 커밋\nCOMMIT;\n\n-- 동일한 조건으로 트랜잭션 A 두 번째 조회시, 트랜잭션 A의 첫 번째 조회에는 존재하지 않던,\n-- 트랜잭션 B에서 삽입된 새로운 행이 함께 조회됨\nSELECT * FROM orders WHERE amount > 150;\n```\n\n# 갭락(Gap Lock)이란?\n\n갭 락은 특정 인덱스 값 사이의 공간을 잠그는 락을 의미한다.\n기존 레코드 간의 간격을 보호하여 새로운 레코드의 삽입을 방지한다.\n갭 락은 범위 내에 특정 레코드가 존재하지 않을 때 적용된다.\n트랜잭션이 특정 범위 내에서 데이터의 삽입을 막아 팬텀 읽기(Phantom Read) 현상을 방지한다.\n예를 들어, 인덱스 값 10과 20 사이의 갭을 잠그면 이 범위 내에 새로운 레코드 15를 추가할 수 없다.\n\n```sql\n-- id 1, 3, 5가 저장된 orders 테이블\n\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A 1-3과 3-5 사이의 갭과 3 레코드 락 설정(넥스트키 락)\nSELECT * FROM orders WHERE orders_id BETWEEN 2 AND 4 FOR UPDATE;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B가 id 4에 데이터 삽입 시도 시, 갭락으로 인해 삽입이 차단되어 대기\nINSERT INTO orders (orders_id, orders_amount) VALUES (4, 200);\n...\n```\n\n# 넥스트키 락(Next-Key Lock)이란?\n\n넥스트키 락은 레코드 락과 갭락을 결합한 형태로, 특정 인덱스 레코드와 그 주변의 갭을 동시에 잠그는 락이다.\n이를 통해 레코드 자체의 변경과 함께 그 주변 공간의 변경도 동시에 제어할 수 있다.\n\n넥스트키 락은 특정 레코드와 그 주변 공간을 잠그기 때문에, 다른 트랜잭션이 새로운 레코드를 삽입하여 팬텀 리드를 발생시키는 것을 방지한다.\n\n|orders_id|orders_amount|\n|---|---|\n|1|100|\n|2|200|\n|3|300|\n\n\n```sql\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 A amount = 200인 orders_id = 2 레코드에 대한 레코드 락과 1-2, 2-3에 대한 갭락을 동시에 잠금으로써 넥스트키 락을 설정\nSELECT * FROM orders WHERE orders_amount = 200 FOR UPDATE;\n\n-- 트랜잭션 B 시작\nSTART TRANSACTION;\n\n-- 트랜잭션 B orders_id = 4, orders_amount = 200인 레코드 삽입 시도 시, 넥스트키 락으로 인해 차단되어 대기\nINSERT INTO orders (orders_id, order_amount) VALUES (4, 200);\n...\n```\n\n# 갭락과 넥스트키 락을 통한 팬텀 리드 방지 메커니즘\n\n트랜잭션 A가 특정 범위의 데이터를 조회할 때, 해당 범위에 대해 갭락 또는 넥스트키 락을 설정한다.\n락이 설정된 범위 내에서는 트랜잭션 B가 새로운 레코드를 삽입하거나 기존 레코드를 수정하는 것이 차단된다.\n따라서, 트랜잭션 A가 다시 동일한 조건으로 조회를 수행하더라도, 트랜잭션 B에 의해 새로운 데이터가 삽입되지 않아 팬텀 리드가 발생하지 않는다."},{"excerpt":"기본형(Primitive)과 참조형(Reference) 자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을…","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"date":"December 20, 2024","title":"기본형(Primitive)과 참조형(Reference)","tags":["Java"]},"rawMarkdownBody":"\n# 기본형(Primitive)과 참조형(Reference)\n자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을 살펴보자.\n\n## 데이터 공유\n기본형은 하나의 값을 여러 변수에서 절대로 공유할 수 없디.\n하지만, 참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.\n\n여기서 하나의 값을 공유하거나 공유하지 않는다는 것은 무엇을 의미할까?\n기본형과 참조형의 차이를 이해하기 위해 아래의 코드를 살펴보자.\n\n먼저 기본형의 경우를 살펴보자.\n기본형은 하나의 값을 여러 변수에서 공유할 수 없다.\n\n```java\nint a = 10;\nint b = a;\na = 20;\nSystem.out.println(b); // 10\n```\n\n우선 기본형 변수 `a`와 `b`는 절대로 같은 값을 공유하지 않는다.\n`b = a`라고 하더라도 `b` 변수는 `a` 변수의 값을 복사하여 가지고 있는다.\n그래서 `a`와 `b` 변수는 같은 숫자 값을 가지고 있게되지만, `a`가 가지고 있는 `10`과 `b`가 가지고 있는 `10`은 복사된 완전히 다른 `10`이다.\n메모리 상에서도 `a`와 `b`는 서로 다른 메모리 주소를 가지고 있다.\n\n이제 참조형의 경우를 살펴보자.\n참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.\n\n```java\nclass Person {\n    String name;\n    int age;\n}\n\nPerson person1 = new Person();\nperson1.name = \"Alice\";\nperson1.age = 20;\n\nPerson person2 = person1;\nperson1.name = \"Bob\";\nSystem.out.println(person2.name); // Bob\n```\n\n위 코드는 `Person` 클래스를 정의하고, `Person` 객체를 생성하여 `person1` 변수에 할당한다.\n그리고 `person2` 변수에 `person1` 변수를 할당한다.\n`person1` 변수의 `name` 필드를 변경한 후, `person2` 변수의 `name` 필드를 출력하면 어떻게 되는지 테스트하는 코드다.\n코드의 결과는 `Bob`이 출력된다.\n\n참조형 변수들은 같은 참조값을 공유해 같은 인스턴스를 가리킨다.\n따라서 `person1` 변수의 `name` 필드를 변경하면, `person2` 변수도 같은 인스턴스를 가리키고 있기 때문에 `person2` 변수의 `name` 필드도 변경된다.\n\n## 공유 참조와 사이드 이펙트\n사이드 이펙트(Side Effect)는 함수나 메소드가 주된 행위 및 작업 외에 추가적인 부수 효과를 일으키는 것을 의미한다.\n앞서 살펴본 참조형 변수의 경우, `person1`의 `name` 필드를 변경하고자 `person1.name = \"Bob\"`를 실행한다.\n하지만 `person2`가 `person1`과 같은 참조값을 가지고 있기 때문에 `person2`의 `name` 필드도 변경된다.\n이렇게 같은 참조값을 공유할 때 발생하는 사이드 이펙트로 인해 디버깅이 어려워지고 코드의 안정성이 저하될 수 있다.\n\n## 사이드 이펙트 방지\n사이드 이펙트를 방지하기 위해서는 참조형 변수를 공유하지 않도록 해야한다.\n그러면 어떻게 참조형 변수를 공유하지 않도록 할 수 있을까?\n그것은 생각보다 단순하다.\n참조형 변수를 공유하지 않으려면 새로운 인스턴스를 생성하여 참조값을 할당하면 된다.\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n위 코드는 `Person` 클래스의 인스턴스를 두 개 생성하여 `person1` 변수와 `person2` 변수에 할당한다.\n이제 `person1` 변수와 `person2` 변수는 서로 다른 인스턴스를 가리키고 있기 때문에 `person1` 변수의 필드를 변경하더라도 `person2` 변수의 필드는 변경되지 않는다.\n\n사실 이러한 사이드 이펙트를 방지하기 위해 불변 객체(Immutable Object)를 사용하는 방법 또한 존재한다.\n불변 객체란 간단히 말해 객체의 상태가 변경되지 않는 객체를 의미한다.\n이러한 불변 객체를 사용하면 객체의 상태가 변경되지 않기 때문에 사이드 이펙트를 방지할 수 있다.\n불변 객체에 대한 자세한 내용은 [Immutable Object](https://023-dev.github.io/2024-12-23/java-immutable-object)를 참고하자."},{"excerpt":"동일성와 동등성 자바에서는 두 객체가 같은지 비교하는 두 가지 방법이 있다. 동일성(Identity):  연산자를 사용하여 두 객체의 주소값을 비교해서 동일한 객체를 참조하는지 확인 동등성(Equality):  메서드를 사용하여 두 객체의 내용이 같은지 확인 쉽게 설명하면  연산자는 두 객체의 주소값을 비교하는 것이고,  메서드는 두 객체의 내용을 비교하…","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"date":"December 19, 2024","title":"동일성(Identity)와 동등성(Equality)","tags":["Java"]},"rawMarkdownBody":"\n# 동일성와 동등성\n자바에서는 두 객체가 같은지 비교하는 두 가지 방법이 있다.\n- 동일성(Identity): `==` 연산자를 사용하여 두 객체의 주소값을 비교해서 동일한 객체를 참조하는지 확인\n- 동등성(Equality): `equals()` 메서드를 사용하여 두 객체의 내용이 같은지 확인\n\n쉽게 설명하면 `==` 연산자는 두 객체의 주소값을 비교하는 것이고, `equals()` 메서드는 두 객체의 내용을 비교하는 것이다.\n\n예를 들어 같은 내용을 가진 두 객체를 생성하고 `==` 연산자와 `equals()` 메서드를 사용하여 비교해보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = new String(\"hello\");\n        String str2 = new String(\"hello\");\n\n        System.out.println(str1 == str2); // false\n        System.out.println(str1.equals(str2)); // true\n    }\n}\n```\n\n동일성을 비교하는 `==` 연산자는 두 객체의 주소값을 비교하기 때문에 `str1`과 `str2`는 서로 다른 객체를 참조하고 있기 때문에 `false`를 반환한다.\n반면에 동등성을 비교하는 `equals()` 메서드는 두 객체의 내용을 비교하기 때문에 `str1`과 `str2`는 내용이 같기 때문에 `true`를 반환한다.\n\n![In Java, Compare Identity & Equality](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-identity-equality/java-identity-equality_1.png){: width=\"500\" }\n\n## equals() 메서드\n`equals()` 메서드는 두 객체의 내용이 같은지 비교하는 메서드이다.\n`Object` 클래스에서는 `equals()` 메서드가 두 객체의 주소값을 비교하기 때문에 `==` 연산자와 같은 결과를 반환한다.\n내부 구현은 다음과 같다.\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n동등성이라는 개념은 객체마다 다르게 정의할 수 있다. 어떤 객체는 회원번호를 비교하고, 어떤 객체는 주민번호를 비교할 수 있다.\n따라서 동등성 비교를 위해서는 `equals()` 메서드를 오버라이딩하여 적절한 객체의 내용을 비교하도록 구현해야 한다.\n\n회원 객체를 생성하고 `equals()` 메서드를 오버라이딩하여 회원번호가 같은지 비교하는 것으로 예를 들어보겠다.\n\n```java\npublic class Member {\n    private int memberId;\n\n    public Member(int memberId) {\n        this.memberId = memberId;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Member) {\n            Member member = (Member) obj;\n            return this.memberId == member.memberId;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Member member1 = new Member(1);\n        Member member2 = new Member(1);\n\n        System.out.println(member1.equals(member2)); // true\n        System.out.println(member1 == member2); // false\n    }\n}\n```\n\n`equals()` 메서드를 오버라이딩하여 회원번호를 비교하도록 구현하였기 때문에 `member1`과 `member2`는 회원번호가 같기 때문에 `true`를 반환한다.\n반면 이것을 동일성 관점에서 보면 `member1`과 `member2`는 서로 다른 객체를 참조하고 있기 때문에 `false`를 반환해야 한다.\n\n## 정확한 동등성 비교를 위한 equals() 메서드 구현\n앞서 살펴본 `equals()` 메서드는 회원번호를 비교하는 것으로 간단한 예제를 보여주었다.\n하지만 실제 프로젝트에서 `equals()` 메서드를 오버라이딩하여 정확한 동등성 비교를 위해서는 다음과 같은 사항을 고려해야 한다.\n- 반사성(Reflexivity): 객체는 자기 자신과 동등해야한다. 즉, `x.equals(x)`는 항상 `true`를 반환해야 한다.\n- 대칭성(Symmetry): 두 객체가 동등하다면, 서로에 대해서도 동등해야 한다. 즉, `x.equals(y)`가 `true`를 반환하면 `y.equals(x)`도 `true`를 반환해야 한다.\n- 추이성(Transitivity): 세 객체가 동등하다면, 이들 간의 모든 비교에서 동등해야 한다. 즉, `x.equals(y)`와 `y.equals(z)`가 모두 `true`를 반환하면 `x.equals(z)`도 `true`를 반환해야 한다.\n- 일관성(Consistency): 객체의 내용이 변경되지 않았다면, `equals()` 메서드의 결과는 항상 동일해야 한다.\n- null 비교: `null`과의 비교는 항상 `false`를 반환해야 한다.\n\n참고로 동일성 비교가 항상 필요한 것은 아니다.\n동등성 비교가 필요한 경우에만 `equals()` 메서드를 오버라이딩하여 구현하면 된다.\n\n## hashCode() 메서드\n해시코드는 객체의 주소값을 기반으로 생성되는 정수값으로 `hashCode()` 메서드는 객체의 해시코드를 반환하는 메서드이다.\n`hashCode()` 메서드는 보통 `equals()` 메서드와 함께 사용되는데, `equals()` 메서드로 두 객체의 내용이 같은지 비교한 후에 `hashCode()` 메서드로 두 객체가 같은 객체인지 해시코드를 비교한다.\n\n그럼 `hashCode()` 메서드를 오버라이딩해야 하나라는 의문이 들 것이다.\n`hashCode()` 메서드를 오버라이딩하지 않으면 `equals()` 메서드를 오버라이딩한 클래스에서 `hashCode()` 메서드를 호출할 때 `Object` 클래스의 `hashCode()` 메서드가 호출되어 객체의 주소값을 기반으로 해시코드를 생성한다.\n따라서 `equals()` 메서드와 `hashCode()` 메서드의 일관성을 유지하기 위해서는 `hashCode()` 메서드를 오버라이딩해야 한다.\n\n회원 객체를 생성하고 `hashCode()` 메서드를 오버라이딩하여 회원번호를 기반으로 해시코드를 생성하는 것으로 예를 들어보겠다.\n\n```java\npublic class Member {\n    private int memberId;\n\n    public Member(int memberId) {\n        this.memberId = memberId;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Member) {\n            Member member = (Member) obj;\n            return this.memberId == member.memberId;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return memberId;\n    }\n\n    public static void main(String[] args) {\n        Member member1 = new Member(1);\n        Member member2 = new Member(1);\n\n        System.out.println(member1.equals(member2)); // true\n        System.out.println(member1.hashCode() == member2.hashCode()); // true\n    }\n}\n```\n\n`hashCode()` 메서드를 오버라이딩하여 회원번호를 기반으로 해시코드를 생성하도록 구현하였기 때문에 `member1`과 `member2`는 회원번호가 같기 때문에 `true`를 반환한다.\n"},{"excerpt":"Object 클래스를 알아가기 전에 먼저 Object 클래스가 속한 패키지에 대해 알아야 한다.\nObject 클래스가 속한 패키지는  패키지에 포함되어 있다. java.lang 패키지 소개 자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 패키지로 여기서 은 를 의미한다. 즉, 자바를 이루는 가장 기본이 되는 클래스들의 패키지라고 …","fields":{"slug":"/java-object/"},"frontmatter":{"date":"December 16, 2024","title":"자바 Object 클래스","tags":["Java"]},"rawMarkdownBody":"\nObject 클래스를 알아가기 전에 먼저 Object 클래스가 속한 패키지에 대해 알아야 한다.\nObject 클래스가 속한 패키지는 `java.lang` 패키지에 포함되어 있다.\n# java.lang 패키지 소개\n자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 패키지로 여기서 `lang`은 `Language`를 의미한다. 즉, 자바를 이루는 가장 기본이 되는 클래스들의 패키지라고 생각하면 된다.\n그런 이유 때문인지 `java.lang` 패키지는 모든 자바에서 자동으로 `import`된다. 따라서 따로 `import` 구문을 사용하지 않아도 된다.\n## java.lang 대표적인 클래스\n- `Object`: 모든 자바 객체의 부모 클래스\n- `String`: 문자열\n- `Integer`, `Long`, `Double`: 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것\n- `Class`: 클래스 메타 정보\n- `System`: 시스템과 관련된 기본 기능들을 제공\n\n# Object 클래스\n자바에서 모든 클래스의 최상위 부모 클래스는 항상 `Object` 클래스이다.\n![Java Object Class Inheritance.png](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_1.png){: width=\"400\" }\n\n근데 여기서 의문이 든다. 내가 생성한 클래스에는 아무것도 `extends`을 한 것이 없는데 어떻게 `Object` 클래스를 상속받은 클래스로 알고 있는걸까 이 의문에 답은 바로  클래스들은 부모 클래스가 없으면 자바가 알아서 묵시적(`Implicit`)으로  `Object` 클래스를 상속 받기 때문이다.\n아래 코드로 예를 들어보겠다.\n```java\npublic class Parent {\n\tpublic void parent() {System.out.println(\"Parent.parentMethod\");}\n}\n```\n보기엔 `Parent` 클래스에는 부모 클래스가 없어 보이지만, 사실 다음 코드와 같다고 볼 수 있다.\n```java\npublic class Parent extends Object {\n\tpublic void parent() {System.out.println(\"Parent.parentMethod\");}\n}\n```\n이처럼 자바가 `extends Object` 코드를 자동으로 생성해 주기때문에 `extends Object`를 생략해주는 것을 권장한다. 또한 이때 `Parent` 클래스에서는  `Obejct` 클래스를 묵시적(`Implicit`)으로 상속 받았기 때문에 메모리에도 함께 생성된다.\n\n그럼 `Parent`를 상속받은 클래스에서는 어떨지 의문이 들 수 있다.\n```java\npublic class Child extends Parent {\n\tpublic void childMethod() {System.out.println(\"Child.childMethod\");}\n}\n```\n이처럼 클래스에 상속받을 부모 클래스를 명시적(`Explicit`)으로 지정하면 `Object` 클래스를 상속 받지 않는다.\n\n> 여기서 묵시적(`Implicit`)이란 개발자가 코드에 직접 기술해서 작동하는 것을 의미하는 명시적(`Explicit`)이란 개념과 상반된 개념으로 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미한다.\n\n위의 말대로 라면 아무 클래스를 상속받지 않는 `Parent`  클래스에서는 `Object` 클래스를 묵시적(`Implicit`)으로 상속받기에 `Parent` 클래스를 상속받은 `Child` 클래스도 `Object`의 메서드를 사용할 수 있어야 한다. 이 말이 맞는지 확인해보자.\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tChild child = new Child();\n\t\tchild.childMethod();\n\t\tchild.parentMethod();\n\n\t\tString childToString = child.toString();\n\t\tSystem.out.println(childToString);\n\t}\n}\n```\n`toString`은 `Object` 클래스의 메서드로 객체의 정보를 반환한다.\n\n실행결과는 다음과 같다.\n```java\nChild.childMethod\nParent.parentMethod\nlang.object.Child@3feba861\n```\n동작 과정은 다음과 같다.\n- `child.toString()`을 호출한다.\n- 먼저 본인의 타입인 `Child`에서 `toString()`을 찾는다. 없으면 부모 타입으로 올라가서 찾는다.\n- 부모 타입인 `Parent`에서 찾는다. 이 곳에서도 없으므로 부모 타입으로 올라가서 찾는다.\n- 부모 타입인 `Object`에서 찾는다. `Object`에 `toString()`이 있으므로 해당 메서드를 호출한다.\n\n이해를 돕기 위해 그림을 그려봤다.\n![Java Object Class Inheritance Detail.png](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_2.png){: width=\"500\" }\n\n## 자바에서 Object 클래스가 최상위 부모 클래스인 이유\n모든 클래스가 `Object` 클래스를 상속받는 이유는 공통 기능 제공하는 것과 다형성의 기본 구현함에 있다.\n\n### 공통 기능 제공\n객체의 정보나 다른 객체와 비교하는 기능과 기능들은 모든 객체가 필요로 하는 기본 기능일 것이다. 이러한 기능들을 객체를 구현할 때마다 항상 정의해서 만들어야 한다면 상당히 비효율적일 것이다. 그리고 이를 구현하게 되면 개발자가 누구인지에 따라 메서드의 이름부터 해서 달라질 수 있기에 일관성 또한 없을 것이다.\n\n`Object` 클래스에서는 이러한 모든 객체가 필요로 하는 기능들을 구현한 공통 기능을 제공한다. 이렇게 하면 위에서 증명했듯이 `Object`가 최상위 부모 클래스일 수 밖에 없기 때문에 모든 객체는 공통 기능을 상속 받아 효율적으로 제공 받을 수 있어 프로그래밍이 단순화되고 일관성을 가질 수 있게 된다.\n\n`Object` 클래스가 제공하는 공통 기능은 다음과 같다.\n- 객체의 정보를 제공하는 `toString()`\n- 객체를 비교하는 `equals()`\n- 객체의 클래스 정보를 제공하는 `getClass()`\n- `hashCode()`, `notify()`, etc.\n\n### 다형성의 기본 구현\n`Object` 클래스는 모든 클래스의 부모 클래스라는 것을 알 수 있었다. 따라서 모든 객체를 참조할 수 있다는 것을 알 수 있다. 이 말은 모든 자바 객체가 `Object` 타입으로 처리될 수 있고, `Object` 타입으로 다양한 타입의 객체를 통합적으로 처리할 수 있다는 것을 의미한다. 즉, `Object`는 모든 객체를 담을수도 있고 타입이 각각 다른 객체들을 보관할 수 있다는 것이다.\n\n## Object 다형성\n`Object`는 모든 클래스의 부모 클래스로 모든 객체를 참조할 수 있는 다형적 참조가 가능하다고 언급을 했다.\n하지만 `Object`가 자식들의 모든 메서드를 알 수 없기에 `Object`를 통해 전달 받은 객체를 호출하기 위해서는 각 객체에 맞는 다운캐스팅 과정이 필요하다.\n\n\n```java\npublic class Car {\n\tpublic void move() { System.out.println(\"car moving\"); }\n}\n```\n```java\npublic class Dog {\n\tpublic void sound() { System.out.println(\"dog sound\"); }\n}\n```\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tCar car = new Car();\n\n\t\taction(dog);\n\t\taction(car);\n\t}\n\n\tprivate static void action(Object obj) {\n\t\tobj.move();\n\t\tobj.sound();\n\t}\n}\n```\n만일 다운캐스팅을 하지 않는다면 `Object`타입에서 `move()`와 `sound` 메서드를 찾을 수 없고, 뿐만아니라 최상위 부모이므로 더는 올라가서 찾을 수 없다.\n따라서 action`메서드에서 컴파일 날 것이다.\n\n![Java Object Class Poly](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_3.png){: width=\"500\" }\n\n그래서 해당 상황에서 오류없이 컴파일 하기 위해서는 다운 캐스팅을 해야한다.\n```java\nprivate static void action(Object obj) {    \n    //객체에 맞는 다운캐스팅 필요  \n    if (obj instanceof Dog dog) {  \n        dog.sound();  \n    } else if (obj instanceof Car car) {  \n        car.move();  \n    }  \n}\n```\n\n![Java Object Class Poly Solution](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_4.png){: width=\"500\" }\n\n이처럼 `Object`는 다형적 참조가 가능하지만, 메서드 오버라이딩을 활용 할 수 없기에 다형성을 활용하기에 한계가 있다.\n\n# Object 배열\n`Object` 클래스는 모든 클래스의 부모 클래스이기 때문에 `Object` 배열을 선언하면 모든 객체를 담을 수 있다.\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        Car car = new Car();\n        Object object = new Object();\n        Object[] objects = {dog, car, object};\n        size(objects);\n    }\n    private static void size(Object[] objects) {\n        System.out.println(\"전달된 객체의 수는: \" + objects.length);\n    }\n}\n```\nsize 메서드에서 전달된 객체의 수를 출력하는 메서드이다. 실행결과는 다음과 같다.\n```java\n전달된 객체의 수는: 3\n```\n이 메서드는 `Object` 배열을 매개변수로 받기 때문에 모든 객체를 담을 수 있기 때문에,\n클래스가 추가되거나 변경되어도 메서드를 수정할 필요가 없다.\n`Object`의 메서드들은 모든 객체가 공통으로 가지고 있는 메서드들이기 때문에 이러한 다형성을 활용할 수 있다.\n\n![Java Object Array](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_5.png){: width=\"500\" }\n\n## Object가 없다면?\n만일 `Object` 클래스가 없다면 어떻게 될까?\n모든 클래스가 `Object` 클래스를 상속받지 않는다면 다형성을 활용할 수 없게 된다.\n또한 모든 객체를 담을 수 있는 컬렉션을 만들 수 없게 된다.\n그리고 직접 정의를 하게되는 경우 모든 클래스에 공통적으로 필요한 메서드를 모든 개발자가 직접 구현해야 하기에 매우 비효율적일 것이다.\n따라서 `Object` 클래스가 없다면 자바의 객체지향 프로그래밍은 불가능할 것이다.\n\n# toString()\n`toString()` 메서드는 객체의 정보를 문자열로 반환한다.\n이러한 `toString()` 메서드는 디버깅과 로깅을 할 때 객체의 정보를 확인하기 위해 유용하게 사용된다.\n이 메서드는 `Object` 클래스에서 정의되어 있기 때문에 모든 클래스에서 상속받아 사용할 수 있다.\n내부 구현은 다음과 같다.\n\n```java\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n`getClass().getName()`은 패키지를 포함한 객체의 클래스 이름을 반환하고, `hashCode()`는 객체의 해시 코드 값을 반환하는데 `Integer.toHexString(hashCode())`는 이를 16진수로 변환한다.\n\n## println()와 toString()\n`println()`과 `toString()` 메서드는 서로 연관이 있다.\n각 메서드를 호출한 결과 값은 같다.\n그 이유는 `System.out.println()` 메서드는 객체를 출력할 때 `toString()` 메서드를 호출하기 때문이다.\n내부 구현은 다음과 같다.\n\n```java\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    if (getClass() == PrintStream.class) {\n        // need to apply String.valueOf again since first invocation\n        // might return null\n        writeln(String.valueOf(s));\n    } else {\n        synchronized (this) {\n            print(s);\n            newLine();\n        }\n    }\n}\npublic static String valueOf(Object obj) {\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n그래서 `System.out.println(dog)`를 호출하면 `dog.toString()`이 호출되어 `Dog` 클래스에서 오버라이딩한 `toString()` 메서드가 호출된다.\n\n## toString() 오버라이딩\n`Object.toString()` 메서드는 객체의 정보를 문자열로 반환하는데, 이는 객체의 메모리 주소를 반환하기 때문에 객체의 정보를 확인하기 어렵다.\n따라서 `toString()` 메서드를 오버라이딩하여 객체의 정보를 반환하도록 구현하여 사용한다.\n\n![Java Object Overriding](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-object/java-object_6.png){: width=\"150\" }\n\n```java\npublic class Dog {\n    private String name;\n    private int age;\n\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Dog{name='\" + name + \"', age=\" + age + \"}\";\n    }\n}\n```\n이렇게 하면 `Dog` 객체의 정보를 확인하기 쉽게 출력할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"멍멍이\", 2);\n        System.out.println(dog);\n    }\n}\n```\n실행결과는 다음과 같다.\n```java\nDog{name='멍멍이', age=2}\n```\n\n# Object 클래스와 OCP\n\n만약 `Object` 클래스가 없다면 어떻게 될까?\n객체지향 프로그래밍에서는 객체를 다형적으로 사용하는 것이 중요하다.\n그러나 모든 클래스가 `Object` 클래스를 상속받지 않는다면 다형성을 활용할 수 없게 된다.\n\n## OCP 원칙\nOCP(Open-Closed Principle)는 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙이다.\n- Open: 기존 코드를 변경하지 않고 새로운 기능을 확장할 수 있어야 한다.\n- Closed: 기존 코드를 수정하지 않아야 한다.\n  이 원칙은 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있어야 한다는 것을 의미한다.\n\n## 구체적인 개념에 의존\n`Object` 클래스가 없다면 모든 클래스가 `Object` 클래스를 상속받지 않기 때문에 다형성을 활용할 수 없게 된다.\n따라서 다형성을 활용하기 위해서는 구체적인 클래스에 의존하게 되어 유연성이 떨어지게 된다.\n이는 객체지향 프로그래밍의 핵심인 OCP(Open-Closed Principle)를 위배하게 된다.\n만약 `Object` 클래스가 없다면 새로운 클래스를 추가할 때마다 코드를 수정해야 하기 때문에 OCP를 위배하게 된다.\n\n## 추상적인 개념에 의존\n반면에 `Object` 클래스가 있다면 모든 클래스가 `Object` 클래스를 상속받기 때문에 다형성을 활용할 수 있게 된다.\n따라서 추상적인 개념에 의존하게 되어 유연성이 높아지게 된다.\n이는 OCP를 준수하게 되어 새로운 클래스를 추가할 때 코드를 수정할 필요가 없게 된다.\n\n## System.out.println()\n`System.out.println()` 메서드는 `Object` 타입을 매개변수로 받기 때문에 모든 객체를 출력할 수 있다.\n만약 `Object` 클래스가 없다면 `System.out.println()` 메서드는 모든 클래스를 매개변수로 받아야 하기 때문에 유연성이 떨어지게 된다.\n따라서 `Object` 클래스가 없다면 이와같은 메서드들을 구현하기 위해서는 매우 많은 오버로딩을 해야 하기 때문에 유지보수가 어려워진다.\n이러한 이유로 자바에서는 `Object` 클래스를 제공을 한다.\n\n> 참고 - 정적 의존관계와 동적 의존관계\n> 정적 의존관계는 컴파일 시점에 결정되는 의존관계를 말한다. 즉, 코드를 작성하는 시점에 이미 결정되는 의존관계이다. 예를 들어, 클래스 A가 클래스 B를 사용한다면 A 클래스는 B 클래스에 정적 의존관계를 가진다. 이는 코드를 작성하는 시점에 이미 결정되어 있기 때문에 변경이 어렵다. 따라서 유연성이 떨어진다.\n> 동적 의존관계는 실행 시점에 결정되는 의존관계를 말한다. 즉, 코드를 실행하는 시점에 결정되는 의존관계이다. 예를 들어, 객체 A가 객체 B를 사용한다면 A 객체는 B 객체에 동적 의존관계를 가진다. 이는 코드를 실행하는 시점에 결정되기 때문에 변경이 쉽다. 따라서 유연성이 높다."},{"excerpt":"JVM(Java Virtual Machine) JVM(Java Virtual Machine)은 자바 프로그램이 실행되는 환경으로, 운영체제와 독립적으로 동작할 수 있도록 중간 역할을 한다.\n그럼 어떻게 JVM이 동작하길래 운영체제에 독립적인지 알아보자. JVM 동작 방식 JVM은 자바 애플리케이션을 실행하기 위해 메모리를 할당받고, 자바 소스 파일을 바이…","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"date":"November 25, 2024","title":"자바 가상 머신(Java Virtual Machine)","tags":["Java"]},"rawMarkdownBody":"\n# JVM(Java Virtual Machine)\n\n<hr>\n\nJVM(Java Virtual Machine)은 자바 프로그램이 실행되는 환경으로, 운영체제와 독립적으로 동작할 수 있도록 중간 역할을 한다.\n그럼 어떻게 JVM이 동작하길래 운영체제에 독립적인지 알아보자.\n\n# JVM 동작 방식\n\n<div class=\"mermaid\">\ngraph TD\n    A[JAVA Source] -->|JAVA Compiler| B[JAVA Byte Code]\n    B --> C[Class Loader]\n    subgraph JVM [JVM]\n        C <--> D[Runtime Data Area]\n        D <--> E[Execution Engine]\n        C <--> E\n    end\n</div>\n\n1. JVM은 자바 애플리케이션을 실행하기 위해 메모리를 할당받고, 자바 소스 파일을 바이트 코드로 변환하여 실행하는 역할을 한다.\n2. 자바 프로그램 실행 시, 자바 컴파일러(`javac`)는 소스 코드(`.java`)를 바이트 코드(`.class`)로 변환된다.\n3. 이후 바이트 코드는 JVM의 `Class Loader`를 통해 필요한 클래스들이 동적으로 로딩되고 링크되어 `Runtime Data Area`에 배치된다.\n4. 이 영역은 실행 중 메모리를 관리하는 핵심 공간으로, 여기에 로드된 바이트 코드는 JVM의 `Execution Engine`에 의해 해석되고 실행된다.\n5. 이 과정에서 `Garbage Collector`가 메모리 관리를 담당하며, `Thread` 동기화와 같은 멀티스레드 환경에서의 작업도 `Execution Engine`에 의해 처리된다.\n\n이러한 동작 방식은 자바 프로그램의 효율적인 실행을 보장하는 동시에 플랫폼 독립성을 실현하는 기반이 된다.\n> 2번 컴파일하는 이러한 동작방식으로 JVM은 속도 저하라는 단점을 가지고 있지만, JIT(Just-In-Time) 컴파일러를 통해 이를 개선하려는 시도를 하고 있다.\n\n# JVM의 구조\n\n<div class=\"mermaid\"> \ngraph TD\nA[Java Source File] -->|Java Compiler| B[Java Byte Code]\nB --> C[Class Loader]\n    subgraph JVM [JVM]\n        C --> D[Execution Engine]\n        D --> D1[Interpreter]\n        D --> D2[JIT Compiler]\n        D --> D3[Garbage Collector]\n        C --> E[Runtime Data Areas]\n        E --> E1[Method Area]\n        E --> E2[Heap]\n        E --> E3[PC Register]\n        E --> E4[JVM Stack]\n        E --> E5[Native Method Stack] \n        E5 --> F[Native Method Interface]\n        F --> G[Native Method Library]\n    end\n</div>\n\nJVM(Java Virtual Machine)의 구조는 자바 애플리케이션 실행 과정에서 핵심 역할을 담당하는 다양한 구성 요소로 이루어져 있다.\n이 중 가장 중요한 세 가지 구성 요소는 클래스 로더(Class Loader), 실행 엔진(Execution Engine), 그리고 런타임 데이터 영역(Runtime Data Area)이다.\n클래스 로더는 자바 바이트 코드(.class 파일)를 메모리에 로드하고, 필요한 클래스와 자원을 동적으로 링크한다.\n실행 엔진은 로드된 바이트 코드를 해석하거나(JIT 컴파일러와 인터프리터 사용) 실행하며, 이 과정에서 가비지 콜렉터(Garbage Collector)를 통해 메모리를 관리한다.\n런타임 데이터 영역은 JVM이 애플리케이션 실행 시 사용하는 메모리 구조로, 메소드 영역(Method Area), 힙 영역(Heap), PC 레지스터(PC Register), 스택 영역(Stack Area), 네이티브 메소드 스택(Native Method Stack)으로 구성된다.\n추가적으로 네이티브 메소드 인터페이스(JNI)는 네이티브 메소드 라이브러리와 상호작용하여 JVM에서 자바 이외의 언어로 작성된 코드를 호출할 수 있도록 한다.\n이러한 구조는 JVM의 동작을 효율적으로 지원하며, 자바 프로그램이 플랫폼 독립적으로 실행될 수 있는 기반을 제공한다.\n\n## 클래스 로더 (Class Loader)\n\n클래스 로더(Class Loader)는 JVM에서 클래스 파일(*.class)을 동적으로 로드하고 이를 링크(Linking)를 통해 JVM 메모리 영역(Runtime Data Areas)에 배치하는 역할을 담당한다.\n클래스 로더는 자바 애플리케이션 실행 시 필요한 클래스만 동적으로 메모리에 적재하며, 모든 클래스를 한 번에 로드하지 않음으로써 메모리 효율성을 높인다.\n클래스 로딩 과정은 크게 로딩(Loading), 링킹(Linking), **초기화(Initialization)**의 3단계로 이루어진다.\n\n<div class=\"mermaid\">\ngraph TD\n    A[Loading] --> B[Verifying]\n    D --> E[Initializing]\n    subgraph Linking\n        B --> C[Preparing]\n    C --> D[Resolving]\n    end\n</div>\n\n1. **Loading(로드)**: 클래스 파일을 읽어 JVM 메모리로 로드하는 단계이다. 필요한 시점에 동적으로 로드된다.\n2. **Linking(링크)**: 로드된 클래스 파일을 검증하고 사용할 준비를 하는 과정으로, 다시 세부적으로 나뉜다.\n    - **Verifying(검증)**: 클래스 파일이 JVM 명세를 준수하는지 확인한다.\n    - **Preparing(준비)**: 클래스가 필요로 하는 메모리를 할당한다.\n    - **Resolving(분석)**: 클래스의 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변환하여 메모리 주소를 연결한다.\n3. **Initialization(초기화)**: 클래스 변수(static 필드 등)를 지정된 초기값으로 설정하고 필요한 초기화 작업을 수행한다.\n\n## 실행 엔진(Execution Engine)\n\n실행 엔진(Execution Engine)은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 읽고 이를 명령어 단위로 실행하는 역할을 한다.\n자바의 바이트 코드(.class 파일)는 기계가 직접 이해할 수 있는 언어가 아니라, JVM이 이해할 수 있는 중간 단계의 코드이기 때문에 실행 엔진은 이 바이트 코드를 실제로 기계어(Native Code)로 변환하여 실행한다.\n이 과정에서 실행 엔진은 **인터프리터(Interpreter)**와 **JIT 컴파일러(Just-In-Time Compiler)** 두 가지 방식을 사용한다.\n인터프리터는 바이트 코드를 한 줄씩 해석하며 실행하지만, 반복적으로 호출되는 메소드의 경우 속도가 느려지는 단점이 있다.\n이를 보완하는 JIT 컴파일러는 반복되는 코드를 네이티브 코드로 변환한 후 캐싱하여, 이후에는 직접 실행함으로써 성능을 개선한다.\nJIT 방식은 변환 비용이 소요되므로 JVM은 초기에는 인터프리터 방식을 사용하다가 일정 기준이 넘으면 JIT 컴파일러를 활성화한다.\n\n또한, 실행 엔진에는 **가비지 컬렉터(Garbage Collector, GC)**가 포함되어 있어 힙(Heap) 메모리에서 사용하지 않는 객체를 자동으로 회수한다.\nC 언어와 달리 자바는 메모리를 개발자가 직접 관리할 필요 없이 GC가 이를 자동으로 처리하므로, 프로그래밍의 생산성과 안정성이 높아진다.\n단, GC는 실행 시간이 정해져 있지 않고, Full GC가 발생하면 모든 스레드가 일시 정지되므로 성능 문제나 장애가 발생할 수 있다.\n참고로 `System.gc()` 메서드를 통해 GC를 수동으로 요청할 수 있지만, 실제 실행이 보장되지는 않는다.\n실행 엔진의 이러한 설계는 자바 애플리케이션의 효율적인 실행과 메모리 관리의 자동화를 지원하며, 자바의 주요 강점 중 하나로 작용한다.\n\n## 런타임 데이터 영역(Runtime Data Area)\n런타임 데이터 영역(Runtime Data Area)은 JVM의 메모리 공간으로, 자바 애플리케이션 실행 시 사용되는 데이터를 저장하는 영역이다.\n이 영역은 크게 **메서드 영역(Method Area)**, **힙 영역(Heap Area)**, **스택 영역(Stack Area)**, **PC 레지스터(Program Counter Register)**, **네이티브 메서드 스택(Native Method Stack)**으로 나뉜다. 이 중 **메서드 영역**과 **힙 영역**은 모든 쓰레드가 공유하며, **스택 영역**, **PC 레지스터**, **네이티브 메서드 스택**은 각 쓰레드마다 독립적으로 생성된다.\n\n### 메서드 영역(Method Area)\n**메서드 영역(Method Area)**은 JVM 시작 시 생성되며, 클래스 정보(필드, 메서드, 타입 정보 등)를 저장하는 공간이다.\n이 영역은 클래스 로딩 시 초기화되며, JVM 종료 시까지 유지된다.\n정적 필드, 메서드 정보와 함께 **런타임 상수 풀(Constant Pool)**도 포함되어 있어 클래스와 인터페이스의 참조 정보를 관리한다.\n\n### 힙 영역(Heap Area)\n**힙 영역(Heap Area)**은 런타임 시 동적으로 객체를 할당하는 공간이다.\n모든 쓰레드가 공유하며, `new` 연산자로 생성된 객체와 배열 등이 저장된다.\n힙 영역은 가비지 컬렉터(GC)에 의해 관리되며, **Young Generation**(Eden, Survivor 영역)과 **Old Generation**으로 나뉘어 효율적인 메모리 관리를 수행한다.\n객체가 참조되지 않으면 GC에 의해 제거된다.\n\n### 스택 영역(Stack Area)\n**스택 영역(Stack Area)**은 메서드 호출 시 사용되는 공간으로, 기본 자료형 및 지역 변수를 저장한다.\n메서드 호출 시 **스택 프레임(Stack Frame)**이 생성되며, 호출이 종료되면 프레임이 제거된다.\nLIFO 구조로 동작하며, 스택 오버플로우가 발생할 수 있으므로 크기가 제한된다.\n\n### PC 레지스터(Program Counter Register)\n**PC 레지스터(Program Counter Register)**는 현재 실행 중인 JVM 명령어의 주소를 저장하는 공간으로, 쓰레드가 실행 중인 명령을 추적한다.\n자바 명령은 PC 레지스터에 저장되지만, 네이티브 메서드를 실행할 때는 `undefined` 상태가 된다.\n\n### 네이티브 메서드 스택(Native Method Stack)\n**네이티브 메서드 스택(Native Method Stack)**은 자바가 아닌 네이티브 코드(C, C++ 등)로 작성된 메서드를 실행하기 위한 공간이다. JIT 컴파일러에 의해 네이티브 코드로 변환된 메서드도 이 스택에서 실행된다.\n네이티브 메서드는 JNI(Java Native Interface)와 연결되어 JVM 외부의 네이티브 라이브러리를 호출하거나 실행한다.\n\n## JNI(Java Native Interface)\n\n<div class=\"mermaid\">\ngraph LR\n    A[C / C++ Side] <--> B[JNI]\n    B <--> C[Java Side]\n\n    subgraph TD \n    A[C / C++ Side]\n        A1[Function]\n        A2[Library]\n    end\n\n    subgraph TD\n     C[Java Side]\n        C1[Exception]\n        C2[Class]\n        C3[VM]\n    end\n</div>\n\nJNI(Java Native Interface)는 자바가 다른 언어로 작성된 애플리케이션과 상호작용할 수 있도록 지원하는 인터페이스를 제공한다.\n이를 통해 자바는 JVM 내부에서 네이티브 메서드를 로드하고 실행할 수 있으며, C/C++와 같은 언어로 구현된 라이브러리나 기능을 호출하여 사용할 수 있다.\n주로 네이티브 코드와의 통합이 필요한 상황에서 활용되며, 네이티브 코드의 강력한 성능과 자바의 이식성을 결합할 수 있는 장점을 제공한다.\n하지만 실제로는 C나 C++ 언어와의 상호작용에 가장 적합하게 설계되어 있어, 다른 언어와의 호환성은 제한적이다.\nJNI를 활용하면 네이티브 코드 기반의 고성능 기능을 자바 애플리케이션에서 손쉽게 호출할 수 있지만, 네이티브 코드 관리와 디버깅이 복잡해질 수 있으므로 신중하게 사용해야 한다.\n\n## Native Method Library\n\n<div class=\"mermaid\">\ngraph TD\n    A[Class loader sub system] <-->|Class files| B[Runtime data areas]\n    subgraph B[Runtime data areas]\n        B1[Method area]\n        B2[Heap]\n        B3[Java stacks]\n        B4[PC Registers]\n        B5[Native method stacks]\n    end\n\n    B <--> C[Execution Engine]\n    B5 <--> D[Native method interface]\n    D <--> E[Native method library]\n    C <--> D\n</div>\n\n**Native Method Library**는 C, C++로 작성된 라이브러리를 지칭하며, 자바 애플리케이션이 네이티브 메서드를 호출할 때 사용된다.\n이 라이브러리는 JNI(Java Native Interface)에 의해 JVM이 로드하여 실행된다.\n자바 코드가 네이티브 메서드를 호출하면, JVM은 필요한 네이티브 라이브러리를 메모리에 로드하고 실행 환경을 제공한다.\n필요할 경우, JNI는 네이티브 메서드 실행에 필요한 헤더 파일을 생성하거나 참조하며, 이를 통해 자바와 네이티브 코드를 연결한다.\nNative Method Library는 자바가 제공하지 않는 플랫폼 고유의 기능을 활용하거나, 성능이 중요한 로우레벨 작업을 수행할 때 유용하게 사용된다.\n"},{"excerpt":"GC(Garbage Collection) **가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와…","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"date":"November 24, 2024","title":"가비지 컬렉션(Garbage Collection)","tags":["Java"]},"rawMarkdownBody":"\n\n# GC(Garbage Collection)\n\n<hr>\n\n**가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와 달리, 자바에서는 GC가 메모리 관리를 대신 처리해줌으로써 메모리 누수(Memory Leak)를 방지하고 개발자가 로직 구현에만 집중할 수 있도록 돕는다.\n\n예를 들어, 반복문 내에서 다수의 객체를 생성하고 사용 후 버리는 코드가 있다고 가정할 때, GC는 이러한 객체들을 주기적으로 정리해줘서 메모리를 효율적으로 사용할 수 있게 한다.\nGC의 이러한 자동화는 자바뿐만 아니라 파이썬, 자바스크립트, Go 언어 등 다양한 언어에서도 기본적으로 제공되며, 웹 브라우저와 같은 소프트웨어에서도 GC를 활용해 메모리 관리를 자동화한다.\n\n그러나 GC에도 단점이 있다.\nGC가 언제 실행될지 명확히 알 수 없기 때문에 메모리 해제를 개발자가 직접 제어하기 어렵고, GC가 실행되는 동안 모든 애플리케이션 스레드가 멈추는 **Stop-The-World(STW)** 현상이 발생한다.\n이로 인해 GC가 지나치게 자주 실행되면 애플리케이션의 성능이 저하될 수 있으며, 실시간 성능이 중요한 시스템에서는 GC의 동작이 치명적일 수 있다.\n예를 들어, 과거의 웹 브라우저인 인터넷 익스플로러는 GC를 너무 자주 실행해 성능 문제를 야기했던 사례가 있다.\n\n이러한 이유로 GC의 실행을 최소화하고 최적화하는 작업이 중요시하며, 이를 **GC 튜닝**이라고 한다.\n> GC 튜닝은 어플리케이션의 성능을 유지하면서 효율적으로 메모리를 관리하는 방법을 설계하는 과정으로, 애플리케이션의 성능과 안정성을 보장하기 위해 필수적인 기술 중 하나이다.\n\n## 가비지 컬렉션 대상\n가비지 컬렉션(Garbage Collection)의 대상은 객체가 더 이상 프로그램에서 참조되지 않는 경우, 즉 도달 불가능(Unreachable)한 상태로 판단된 객체들이다.\n이를 위해 **도달성(Reachability)**이라는 개념이 사용된다. 객체에 참조가 있으면 해당 객체는 Reachable(도달 가능) 상태로 간주되고, 반대로 참조가 없다면 Unreachable(도달 불가능) 상태로 분류되어 가비지 컬렉션의 대상이 된다.\n\nReachable 상태의 객체는 현재 사용 중인 객체로, JVM의 Method Area나 Stack Area에서 해당 객체의 메모리 주소를 참조하고 있다.\n반면, Unreachable 상태의 객체는 어떤 변수나 메서드에서도 참조되지 않는 상태로, 더 이상 프로그램에서 사용되지 않는 객체다.\n이러한 Unreachable 객체는 힙(Heap) 영역에서만 존재하며, 가비지 컬렉션에 의해 자동으로 제거된다.\n\n<div class=\"mermaid\">\ngraph LR\n    subgraph Heap\n        A1[1 Reachable]\n        A2[2 Unreachable]\n        A3[3 Reachable]\n        A4[4 Reachable]\n        A5[5 Reachable]\n    end\n\n    subgraph Stack\n        B6[6]\n        B7[7]\n    end\n\n    subgraph MethodArea\n        C8[8]\n    end\n\n    B6 --> A1\n    B7 --> A5\n    A5 --> A4\n    C8 --> A3\n</div>\n\n예를 들어, 객체는 주로 힙 영역에서 생성되고, 메서드가 실행되거나 변수가 선언될 때 Method Area나 Stack Area에 객체의 참조 주소를 저장한다.\n하지만 메서드 종료와 같은 특정 이벤트로 인해 참조 변수가 삭제되거나 스코프를 벗어나면, 힙 영역의 해당 객체는 더 이상 참조되지 않게 된다.\n이처럼 도달 불가능한(Unreachable) 상태가 된 객체는 프로그램에서 쓸모없어진 것으로 간주되어 가비지 컬렉터가 주기적으로 수거하여 메모리를 해제한다.\n\n이 과정은 프로그래머가 명시적으로 메모리를 해제하지 않아도 JVM이 자동으로 메모리를 관리하게 해 주는 장점이 있다.\n하지만, 가비지 컬렉션이 언제 실행될지는 명확히 알 수 없으므로, 이를 고려한 메모리 관리 전략이 필요하다.\nUnreachable 객체를 효율적으로 식별하고 제거하는 것이 가비지 컬렉션의 핵심 역할이다.\n\n## 가비지 컬렉션 동작 방식\n\n**가비지 컬렉션의 청소 방식**은 Unreachable 객체를 식별하고 제거하는 과정에서 사용하는 알고리즘에 따라 달라진다.\n가장 기본적인 방식은 **Mark and Sweep** 알고리즘으로, 많은 GC에서 기본으로 사용되는 메모리 정리 방법이다.\n\n<div class=\"mermaid\">\ngraph TD\n    subgraph Mark\n        A1[Object <br> reachable]\n        A2[Object <br> unreachable]\n        A3[Object <br> reachable]\n        A4[Object <br> unreachable]\n        A5[Object <br> reachable]\n    end\n    subgraph Sweep\n        B1[Object <br> reachable]\n        B2[<br>]\n        B3[Object <br> reachable]\n        B4[<br>]\n        B5[Object <br> reachable]\n    end\n    subgraph Compaction\n        C1[Object <br> reachable]\n        C2[Object <br> reachable]\n        C3[Object <br> reachable]\n    end\n\n    Mark --> Sweep\n    Sweep --> Compaction\n</div>\n\n이 방식은 다음 세 단계로 구성된다:\n\n1. **Mark 과정**: GC는 Root Space(루트 공간)에서 시작해 연결된 객체들을 그래프 형태로 순회하며, 참조되고 있는 객체들을 식별하고 마킹한다. Root Space는 힙 메모리를 참조하는 Method Area, Static 변수, JVM Stack, Native Method Stack 등을 포함한다. 이 과정을 통해 Reachable 객체와 Unreachable 객체를 구분한다.\n\n2. **Sweep 과정**: 마킹되지 않은 객체들(Unreachable 객체)을 힙(Heap)에서 제거한다. 이 단계에서는 더 이상 사용되지 않는 메모리를 해제하여 새 객체가 저장될 수 있도록 공간을 확보한다.\n\n3. **Compaction 과정**: Sweep 이후에 메모리 조각화(Fragmentation)를 줄이기 위해 남아있는 객체들을 힙의 시작 주소 쪽으로 압축한다. 이를 통해 연속된 메모리 공간을 확보해 새로운 객체를 할당할 때 메모리 할당 실패를 방지한다. 단, 이 과정은 모든 GC에서 수행되는 것은 아니며, 가비지 컬렉터의 종류에 따라 생략되기도 한다.\n\n이 방식은 **루트 공간(Root Space)** 기준으로 객체의 Reachable 상태를 판단하기 때문에 순환 참조와 같은 문제가 있는 객체도 효과적으로 정리할 수 있다.\nRoot Space는 JVM 메모리 구조에서 중요한 요소로, Method Area, Static 변수, JVM Stack, Native Method Stack이 루트 역할을 한다.\n\nMark and Sweep 방식은 간단하고 효율적이지만, 모든 객체를 순회하고 처리해야 하므로 수행 시간에 따라 애플리케이션의 성능에 영향을 줄 수 있다.\n또한, GC가 실행되는 동안 애플리케이션이 멈추는 **Stop-The-World(STW)** 현상이 발생할 수 있어 최적화된 GC 전략이 필요하다.\nMark and Sweep 알고리즘은 이런 기본 원리를 바탕으로 다양한 GC 최적화 기술의 기반이 되고 있다.\n\n# 가비지 컬렉션 동작 과정\n\n<hr>\n\n<div class=\"mermaid\">\ngraph TB\n    subgraph JVM_Memory [JVM Memory Runtime Data Area]\n        A[Method Area]\n        B[Heap]\n        C[JVM Language Stacks]\n        D[PC Registers]\n        E[Native Method Area]\n    end\n\n    subgraph Heap_Structure [Heap Structure]\n        F[Eden]\n        G[Survivor 1]\n        H[Survivor 2]\n        I[Old Generation]\n        J[Permanent Generation]\n    end\n\n    A --> B\n    B --> F\n    B --> I\n    G --> F\n    H --> G\n    I --> H\n    I --> J\n\n    F -->|Minor GC| G\n    G -->|Minor GC| H\n    H -->|Major GC <br> Full GC| I\n</div>\n\n## Heap 메모리의 구조\n\n**힙(Heap) 메모리의 구조**는 JVM에서 동적으로 생성된 객체와 레퍼런스 데이터를 저장하며, 가비지 컬렉션의 대상이 되는 공간이다.\nJVM의 힙 영역은 객체의 생존 기간과 특성을 기반으로 효율적으로 설계되었으며, 크게 **Young Generation**과 **Old Generation** 두 영역으로 나뉜다. 이러한 설계는 **Weak Generational Hypothesis**에 기반하며, 대부분의 객체는 금방 Unreachable 상태가 되고, 오래된 객체에서 새로운 객체로의 참조는 드물다는 가정을 전제로 한다.\n\n### Young Generation (Young 영역)\n**Young 영역**은 새롭게 생성된 객체가 처음 할당되는 공간이다. 대부분의 객체가 이 영역에서 생성되고 금방 Unreachable 상태가 되어 제거되며, 소규모 가비지 컬렉션인 **Minor GC**가 주로 이 영역에서 수행된다.\nYoung 영역은 다음 세 가지로 더 나뉜다:\n- **Eden**: 새롭게 생성된 객체가 위치하며, 정기적인 Minor GC 수행 후 살아남은 객체가 Survivor 영역으로 이동된다.\n- **Survivor 0 / Survivor 1**: Eden에서 살아남은 객체가 복사되는 영역으로, 최소 한 번 이상 GC를 통과한 객체들이 이곳에 존재한다. Survivor 0과 Survivor 1은 하나가 항상 비어 있어야 하는 규칙이 있다.\n\n### Old Generation (Old 영역)\n**Old 영역**은 Young 영역에서 여러 번의 GC를 거쳐 살아남은 객체가 복사되는 공간이다.\nYoung 영역보다 크며, 오래된 객체들이 위치하기 때문에 가비지 발생률이 상대적으로 낮다.\nOld 영역에서 수행되는 GC는 **Major GC** 또는 **Full GC**로 불리며, Young 영역보다 훨씬 더 큰 메모리를 다룬다.\n\n### 힙 영역 설계의 효율성\nOld 영역이 Young 영역보다 크도록 설계된 이유는, Young 영역의 객체 수명이 짧기 때문에 큰 공간을 필요로 하지 않으며, 대형 객체는 Young 영역을 거치지 않고 바로 Old 영역에 할당되기 때문이다.\n또한, Young 영역을 Eden과 두 개의 Survivor 영역으로 나누어 객체의 생존 기간을 면밀히 추적하고, 불필요한 객체를 효율적으로 제거하도록 가비지 컬렉션의 정확도를 높인다.\n\n### Permanent Generation (Java 7 이전)과 Metaspace (Java 8 이후)\n**Permanent Generation(PermGen)**은 클래스 로더에 의해 로드된 클래스와 메서드의 메타정보가 저장되던 공간으로, Java 7까지 힙 영역에 존재했다.\n그러나 Java 8 이후에는 힙 메모리에서 분리되어 **Metaspace**라는 Native Method Stack 영역에 통합되었다.\n이를 통해 PermGen에서 발생하던 메모리 부족 문제를 해결하고, 보다 유연한 메모리 관리를 가능하게 했다.\n\n## Minor GC 과정\n**Minor GC 과정**은 Young Generation에서 메모리를 효율적으로 관리하기 위해 수행되는 가비지 컬렉션으로, 객체의 생명 주기와 도달 가능성을 기준으로 불필요한 객체를 제거하는 프로세스이다.\nYoung Generation은 Eden 영역과 두 개의 Survivor 영역(Survivor 0, Survivor 1)으로 구성되어 있으며, Minor GC는 주로 Eden 영역에서 발생한다.\n\n주요 과정은 다음과 같다:\n\n1. **객체 생성 및 Eden 영역 할당**: 새로운 객체는 Young Generation의 Eden 영역에 위치하며, Eden 영역이 가득 차기 전까지 계속 저장된다.\n\n2. **Eden 영역 가득참 및 Minor GC 실행**: 객체가 계속 생성되어 Eden 영역이 꽉 차게 되면 Minor GC가 실행된다.\n\n3. **Mark 동작**: GC가 Eden 영역에서 Reachable 객체를 탐색하여 마킹한다. Reachable 객체는 참조되고 있는 상태로, 메모리에서 제거되지 않는다.\n\n4. **Reachable 객체 Survivor 영역 이동**: Eden 영역에서 살아남은 객체는 하나의 Survivor 영역(예: Survivor 0)으로 이동된다.\n\n5. **Unreachable 객체 메모리 해제**: Eden 영역에서 참조되지 않은 Unreachable 객체는 메모리에서 해제(Sweep)된다.\n\n6. **객체의 Age 증가**: Survivor 영역에 남아있는 객체들은 **age** 값이 1씩 증가한다. 이 값은 객체가 Survivor 영역에서 살아남은 횟수를 의미하며, `Object Header`에 기록된다. 특정 임계값(예: HotSpot JVM의 기본값 31)에 도달하면 객체는 Old Generation으로 승격(Promotion)된다.\n\n7. **다시 Eden 영역 할당**: Eden 영역에 신규 객체가 추가로 생성되어 다시 가득 차게 되면, Minor GC가 반복된다.\n\n8. **Survivor 영역 교체**: 마킹된 객체들은 비어있는 다른 Survivor 영역(예: Survivor 1)으로 이동하며, 사용 중인 Survivor 영역은 비워진다.\n\n9. **반복적인 Minor GC**: Eden 영역이 반복적으로 가득 차고, 객체들이 Survivor 영역 간 이동하며 age 값이 증가하는 과정을 계속 반복한다.\n\n10. **Survivor 영역의 제한 조건**: Survivor 영역 중 하나는 항상 비어 있어야 한다. 두 Survivor 영역이 동시에 사용 중이거나 모두 비어 있다면, 이는 시스템이 비정상적으로 작동하고 있음을 의미한다.\n\nMinor GC는 메모리 공간이 상대적으로 작은 Young Generation에서 수행되기 때문에 짧은 시간 내에 완료될 수 있다.\n하지만 Minor GC의 빈도가 지나치게 높아지면 애플리케이션 성능에 영향을 미칠 수 있으므로, 이를 고려한 메모리 관리 전략이 필요하다.\n이 과정을 통해 메모리를 효율적으로 관리하면서 Old Generation으로의 객체 이동을 최소화한다.\n\n## Major GC 과정\n\n**Major GC 과정**은 Old Generation 영역에서 발생하는 가비지 컬렉션으로, 상대적으로 수명이 긴 객체들이 저장된 메모리 공간을 관리하는 역할을 한다. Old Generation에 있는 객체들은 대부분 Young Generation에서 시작되어 Minor GC를 여러 번 통과하며, age 값이 임계값(예: 8)에 도달하면 Promotion 과정을 거쳐 이동된 객체들이다. Major GC는 Old Generation에 더 이상 새로운 객체를 저장할 공간이 부족해질 때 실행되며, Old Generation의 모든 객체를 검사해 참조되지 않은 객체를 제거한다.\n\n### Major GC의 주요 단계\n1. **객체 Promotion**: Young Generation에서 age 값이 임계값에 도달한 객체들은 Old Generation으로 이동된다.\n2. **Old Generation 메모리 부족**: Old Generation 영역에 객체가 계속 Promotion되면, 결국 메모리가 부족해지는 상황이 발생한다.\n3. **Major GC 발생**: Old Generation이 가득 차게 되면 Major GC가 실행된다. 이 과정에서는 Old Generation 내의 모든 객체를 검사하고, Unreachable 객체를 한꺼번에 제거한다.\n\n### Minor GC와 Major GC 비교\n\n| **항목**        | **Minor GC**                       | **Major GC (Full GC)**                |\n|-----------------|-----------------------------------|--------------------------------------|\n| **대상 영역**   | Young Generation                 | Old Generation                      |\n| **발생 빈도**   | 빈번하게 발생                    | 드물게 발생                         |\n| **처리 속도**   | 빠르다 (0.5~1초)                  | 상대적으로 느리다 (10배 이상 소요)    |\n| **영향**        | 애플리케이션 성능에 큰 영향 없음 | Stop-The-World 발생으로 성능 저하    |\n\n### Major GC의 특성과 문제점\nMajor GC는 Old Generation의 메모리를 확보하기 위해 모든 객체를 검사하므로 Minor GC에 비해 처리 시간이 오래 걸린다.\n이 과정에서 애플리케이션의 모든 스레드가 정지하는 **Stop-The-World** 현상이 발생하며, CPU에 부하를 주고 애플리케이션이 일시적으로 멈추거나 느려지는 현상을 유발할 수 있다.\n이로 인해 Major GC는 실시간 성능이 중요한 애플리케이션에서 문제가 될 수 있다.\n\n현재도 Major GC로 인한 성능 저하를 줄이기 위해 다양한 알고리즘을 활용하여 GC의 처리 시간을 최소화하고, Stop-The-World 현상을 줄이는 방향으로 최적화 작업이 이루어지고 있다.\nJDK에서 제공하는 가비지 컬렉션 알고리즘의 종류와 각 버전에 따른 GC 방식의 변화에 대해 알아보고, 이를 통해 애플리케이션의 성능을 최적화할 수 있는 가비지 컬렉션 설정을 이해해보도록 하자.\n\n# JVM의 가비지 컬렉션 알고리즘 종류\n\n<hr>\n\n자바의 가비지 컬렉션(GC)은 메모리 관리 효율성을 극대화하고 애플리케이션 성능을 유지하기 위해 다양한 알고리즘을 제공하며, 각 알고리즘은 특정한 요구와 환경에 맞게 설계되었다. GC 알고리즘은 JVM 옵션을 통해 상황에 따라 설정할 수 있다. 다음은 주요 GC 알고리즘의 특징과 사용 방법에 대한 정리이다.\n\n## Serial GC\nCPU 코어가 1개인 환경에서 적합하며, 일반적인 서버 환경에서는 잘 사용되지 않음.\n- 단일 스레드(Single Thread)로 동작하며 가장 단순한 GC.\n- **Mark-Sweep** 방식으로 Minor GC, **Mark-Sweep-Compact** 방식으로 Major GC 수행.\n- Stop-The-World 시간이 가장 길며, 성능이 낮은 환경에서만 사용.\n\n```bash\njava -XX:+UseSerialGC -jar Application.java\n```\n\n## Parallel GC\n기본적인 멀티 코어 CPU 환경에서 사용.\n- Java 8의 기본 GC.\n- Minor GC를 멀티 스레드로 처리하지만, Old Generation은 싱글 스레드로 처리.\n- Serial GC 대비 Stop-The-World 시간이 줄어듦.\n\n```bash\njava -XX:+UseParallelGC -jar Application.java\njava -XX:ParallelGCThreads=N # 사용할 스레드 개수 지정\n```\n\n## Parallel Old GC\n멀티 코어 환경에서 Old Generation의 GC 성능이 중요한 경우 사용.\n- Parallel GC의 개선 버전.\n- Young Generation과 Old Generation 모두 멀티 스레드로 GC 수행.\n- Mark-Summary-Compact 방식을 사용하여 효율성 증가.\n\n```bash\njava -XX:+UseParallelOldGC -jar Application.java\njava -XX:ParallelGCThreads=N\n```\n\n## CMS GC (Concurrent Mark Sweep)\n실시간 처리가 중요한 애플리케이션에서 사용되었으나 현재는 사용되지 않음.\n- 애플리케이션 스레드와 GC 스레드가 동시에 실행되어 Stop-The-World 시간을 줄임.\n- GC 과정이 복잡하고 CPU 사용량이 높으며, 메모리 파편화 문제가 존재.\n- Java 9에서 deprecated, Java 14에서 제거됨.\n\n```bash\njava -XX:+UseConcMarkSweepGC -jar Application.java\n```\n\n## G1 GC (Garbage First)\n힙 크기가 4GB 이상이며, 실시간 응답성이 중요한 애플리케이션에서 사용.\n- CMS GC를 대체하기 위해 JDK 7에서 도입, Java 9부터 기본 GC.\n- 힙 메모리를 고정된 Young/Old 영역으로 나누지 않고 **Region**이라는 단위로 분할.\n- 메모리가 많이 사용된 Region을 우선적으로 수집하여 효율성 향상.\n- Stop-The-World 시간이 짧고 예측 가능(0.5초).\n\n```bash\njava -XX:+UseG1GC -jar Application.java\n```\n\n## Shenandoah GC\nPause 시간이 중요한 대규모 애플리케이션에서 적합.\n- Java 12에서 도입, Red Hat에서 개발.\n- 강력한 동시성(Concurrency)으로 Stop-The-World 시간을 최소화.\n- CMS의 단편화와 G1의 Pause 이슈를 해결한 GC.\n- 힙 크기에 관계없이 일정한 Pause 시간이 특징.\n\n```bash\njava -XX:+UseShenandoahGC -jar Application.java\n```\n\n## ZGC (Z Garbage Collector)\n매우 낮은 지연 시간과 대규모 메모리 관리가 필요한 애플리케이션에서 사용.\n- Java 15에서 도입.\n- 대규모 메모리(8MB ~ 16TB)를 처리하며 Stop-The-World 시간이 10ms를 넘지 않음.\n- 힙 메모리를 **ZPage**라는 동적 크기의 영역으로 관리.\n\n```bash\njava -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java\n```\n\n## GC 알고리즘 비교 요약\n\n| **알고리즘**       | **특징**                                                  | **장점**                         | **단점**                            |\n|------------------|-------------------------------------------------------|--------------------------------|-----------------------------------|\n| Serial GC        | 단일 스레드, 가장 단순한 GC                             | 구현 간단, CPU가 낮은 환경에 적합 | Stop-The-World 시간이 길다         |\n| Parallel GC      | Young 영역 멀티 스레드 처리                             | 성능 향상, Stop-The-World 감소   | Old Generation은 싱글 스레드 처리 |\n| Parallel Old GC  | Old Generation도 멀티 스레드 처리                       | 더 나은 성능                    | 높은 CPU 사용량                   |\n| CMS GC           | 동시 실행으로 Stop-The-World 최소화                     | 실시간 처리 적합                | 복잡한 과정, 메모리 파편화 문제    |\n| G1 GC            | Region 개념 도입, 메모리 효율성 증가                     | 낮은 지연 시간                  | 설정이 복잡할 수 있음             |\n| Shenandoah GC    | 매우 짧은 Pause 시간                                    | 힙 크기와 상관없는 일정한 Pause | 최신 JVM에서만 사용 가능           |\n| ZGC              | 대규모 메모리와 낮은 지연 시간 처리                     | Stop-The-World 시간 10ms 이하   | 메모리 사용량이 많을 수 있음       |\n\n# GC 모니터링 및 메모리 문제\n\nGC는 JVM 메모리를 효율적으로 관리하기 위해 자동으로 수행되지만, 그 과정에서 예상치 못한 문제가 발생할 수 있다.\nGC가 과도하게 실행되면 CPU 사용량이 증가하고 메모리 자원이 부족해져 애플리케이션의 응답 시간이 길어질 수 있다.\n특히, 클라우드 환경이나 대규모 시스템에서는 리소스 관리가 중요한데, 이런 환경에서 GC가 적절히 작동하지 않으면 서비스 장애로 이어질 수 있다.\n이를 방지하기 위해 **jstat**, **VisualVM**, **Prometheus+Grafana** 같은 도구를 활용하여 GC와 메모리 사용 상태를 실시간으로 모니터링해야 한다.\n이를 통해 GC가 애플리케이션에 미치는 영향을 파악하고 적절한 조치를 취할 수 있다.\n\n### **OutOfMemoryError와 대처 방안**\nGC를 모니터링하던 중 **OutOfMemoryError**가 발생하는 경우, 이는 힙 메모리의 부족 또는 메모리 누수로 인해 발생할 가능성이 높다.\n이를 해결하려면 먼저 원인을 파악하는 것이 중요하다.\n**힙 덤프(Heap Dump)**를 생성한 뒤, **Eclipse MAT(Memory Analyzer Tool)**이나 **VisualVM** 같은 분석 도구를 활용해 메모리 누수 여부와 객체 참조 상태를 분석한다.\n\n1. **메모리 누수의 원인 파악**: 메모리 누수가 원인인 경우, 불필요한 객체 참조가 제거되지 않은 코드를 찾아 수정해야 한다. 일반적인 원인으로는 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션에 남아 있는 객체 등이 있다.\n2. **힙 메모리 크기 조정**: 애플리케이션 데이터 처리량이 메모리 크기를 초과하는 경우, JVM 옵션(`-Xmx`, `-Xms`)으로 힙 크기를 늘리고, 적합한 GC 알고리즘(G1 GC, ZGC 등)을 선택해 GC 튜닝을 수행한다.\n3. **추적과 예방**: 애플리케이션 로깅 및 모니터링 체계를 구축해 메모리 사용량 추이를 관찰하고, OutOfMemoryError가 발생하기 전에 문제를 사전에 탐지하도록 한다.\n\n### **메모리 누수 확인과 방지**\n메모리 누수는 GC가 제거하지 못하는 객체가 메모리를 지속적으로 점유하는 문제로, 힙 메모리를 고갈시킬 수 있다.\n이를 해결하려면 실행 중인 애플리케이션에서 **힙 덤프**를 생성한 후, **객체 그래프**를 분석하여 불필요하게 참조되고 있는 객체를 식별해야 한다.\n\n- **분석 도구 활용**: **Eclipse MAT**이나 **VisualVM**을 사용해 객체의 참조 체인을 추적하고 의도치 않게 유지되고 있는 객체를 찾아낸다.\n- **실시간 모니터링**: **JConsole**, **jstat**, 또는 **APM(Application Performance Monitoring)** 도구를 사용해 메모리 사용량 변화를 실시간으로 모니터링한다. 이를 통해 메모리 사용량이 지속적으로 증가하는 패턴을 확인할 수 있다.\n- **일반적인 누수 원인 해결**: 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션 문제 등이 누수의 일반적인 원인이므로, 이러한 요소들을 면밀히 검토하여 코드 문제를 수정한다.\n\n> 추후 왜 STW(Stop-The-World)가 발생하는지 등에 대한 내용 추가할 예정이다."},{"excerpt":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX 와  그리고  메서드의 공통점은 모두 한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 와  그리고  메서드의 문제점…","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"date":"November 22, 2024","title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX","tags":["Java"]},"rawMarkdownBody":"\n# Vector와 Hashtable 그리고 Collections.SynchronizedXXX\n`Vector`와 `Hashtable` 그리고 `Collections.synchronizedXXX()` 메서드의 공통점은 모두 `Thread-Safe`한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n`Thread-Safe`한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 `Vector`와 `Hashtable` 그리고 `Collections.synchronizedXXX()` 메서드의 문제점에 대해 알아보자.\n\n## Vector와 Hashtable 문제점\n`Vector`와 `Hashtable`은 모두 레거시한 자바 클래스로, 데이터를 저장하고 관리하는 컬렉션 클래스이다.\n근데 왜 레거시한 자바 컬렉션인지 궁금할 수 있다. 이는 `Vector`와 `Hashtable`이 `Thread-Safe`한 컬렉션으로 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있다.\n이로 인해 두 클래스 모두 메서드 단위에서 동기화를 제공하지만, 이로 인해 앞서 언급했듯이 성능이 저하되는 문제가 발생한다.\n이는 필요한 부분만 동기화를 제공하지 않고, 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제이다.\n\n내부 구현이 어떻게 되어있는지 그리고 어떠한 상황에서 이러한 문제가 발생하는지 알아보겠다.\n\n```java\npublic synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n```\n\n위 코드 `Vector` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있는 것을 볼 수 있다.\n`Vector` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있기 때문에 두 스레드가 동시에 `add()` 메서드를 호출하면 한 스레드는 대기하게 된다.\n이로 인해 race condition이 발생하여 성능이 저하되는 문제가 발생한다.\n\n이러한 문제로 현재의 자바에서는 `Vector`와 `Hashtable` 대신 `ArrayList`와 `HashMap`을 사용하는 것을 권장하고 있다.\n`ArrayList` 클래스의 `add()` 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있지 않기에 두 스레드가 동시에 `add()` 메서드를 호출해도 서로 영향을 주지 않는다.\n그럼 동기화 메서드로 구성된 컬렉션을 사용하고 싶다면 어떻게 해야할까?\n\n## Collections.synchronizedXXX() 메서드\n`Collections.synchronizedXXX()` 메서드는 `Vector`와 `Hashtable`과 같이 동기화된 메서드로 구성된 컬렉션을 반환한다.\n이 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성된 컬렉션을 반환하기 때문에 `Thread-Safe`한 컬렉션을 사용할 수 있다.\n\n내부 구현이 어떻게 되어있는지 알아보겠다.\n\n```java\npublic static <T> List<T> synchronizedList(List<T> list) {\n    return (list instanceof RandomAccess ?\n            new SynchronizedRandomAccessList<>(list) :\n            new SynchronizedList<>(list));\n}\n```\n\n위 코드는 `Collections.synchronizedList()` 메서드의 내부 구현이다.\n이 메서드는 `List` 인터페이스를 구현한 컬렉션을 매개변수로 받아 `SynchronizedList` 클래스를 반환한다.\n이로 인해 `ArrayList`의 모든 메서드에 대해 동기화를 제공받게 된다.\n그러면 이 메서드를 사용하면 안전할까?\n그렇지는 않다. `Collections.synchronizedXXX()` 메서드는 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제가 발생한다.\n이 문제 또한 `Vector`와 `Hashtable`의 문제와 같은 문제이다.\n그럼 이러한 문제를 해결하기 위해 어떻게 해야할까?\n이러한 문제로 현재의 자바에서는 `Collections.synchronizedXXX()` 메서드 대신 `ConcurrentHashMap`과 같은 `Concurrent` 패키지의 컬렉션을 사용하는 것을 권장하고 있다.\n\n## Concurrent\n`Concurrent` 패키지는 멀티 스레드 환경에서 안전하게 사용할 수 있는 컬렉션을 제공한다.\n`ConcurrentHashMap`은 `Hashtable`과 같이 `Thread-Safe`한 컬렉션으로 동기화된 메서드로 구성되어 있지만, `ConcurrentHashMap`은 필요한 부분만 동기화를 제공하기 때문에 성능이 향상된다.\n\n내부 구현이 어떻게 되어있는지 알아보겠다.\n\n```java\npublic class ConcurrentHashMap<K, V> {\n    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) {\n            throw new NullPointerException();\n        }\n        int hash = spread(key.hashCode());\n        return null;\n    }\n}\n```\n\n위 코드는 `ConcurrentHashMap` 클래스의 `put()` 메서드의 일부분이다.\n이 메서드는 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있지만, 필요한 부분만 동기화를 제공하기 때문에 `Thread-Safe`한 컬렉션을 사용하면서 성능이 향상된다.\n자세한 내용은 [ConcurrentHashMap vs SynchronizedMap](https://023-dev.github.io/2024-11-22/Java-ConcurrentHashMap-SynchronizedMap)을 참고하자.\n\n이렇게 주저리주저리 써봤는데 정리하자면 기존 레거시 자바 버전에서는 `Vector`와 `Hashtable`을 사용했지만 해당 컬레션들의 모든 메서드들이 `synchronized` 키워드를 사용하여 동기화된 메서드로 구성되어 있어 과도한 락이 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 `Vector`와 `Hashtable` 대신 `ArrayList`와 `HashMap`을 사용하는 것을 권장하고 있다.\n근데 이 부분에서 동기화 메서드가 필요로 해져서 `Collections.synchronizedXXX()` 메서드를 사용해 해당 컬렉션을 동기화된 형태로 래핑할 수 있게 되었다.\n하지만 이 부분에서도 `Vector`와 `Hashtable`과 같은 문제가 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 결과적으로 현재의 자바에서는 `ArrayList`와 `HashMap`을 `Thread-Safe`하게 사용하기 위한 방법으로 `Concurrent` 패키지의 컬렉션을 사용하는 것을 권장하고 있다."},{"excerpt":"SynchronizedList와 CopyOnWriteArrayList의 차이 SynchronizedList 를 사용해 기존 리스트를 동기화된 형태로 래핑한 클래스다. 특징: 내부적으로 모든 메서드가 동기화()되어 다중 스레드에서 안전하게 사용 가능. 읽기 및 쓰기 작업 모두 락을 사용하여 성능이 저하될 수 있음. 반복(iteration) 작업은 추가로 동…","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"date":"November 22, 2024","title":"SynchronizedList와 CopyOnWriteArrayList의 차이","tags":["Java"]},"rawMarkdownBody":"\n## SynchronizedList와 CopyOnWriteArrayList의 차이\n\n### **SynchronizedList**\n`Collections.synchronizedList`를 사용해 기존 리스트를 동기화된 형태로 래핑한 클래스다.\n- **특징**:\n    1. 내부적으로 **모든 메서드가 동기화**(`synchronized`)되어 다중 스레드에서 안전하게 사용 가능.\n    2. 읽기 및 쓰기 작업 모두 락을 사용하여 성능이 저하될 수 있음.\n    3. 반복(iteration) 작업은 추가로 동기화가 필요.\n       ```java\n       List<String> list = Collections.synchronizedList(new ArrayList<>());\n  \n       synchronized (list) { // 반복 작업 시 동기화 필요\n           for (String item : list) {\n               System.out.println(item);\n            }\n       }\n       ```\n\n- **장점**:\n    - 간단한 동기화 구현.\n    - 기존 `ArrayList` 또는 `LinkedList`를 동기화된 형태로 변환 가능.\n\n- **단점**:\n    - 읽기 작업과 쓰기 작업 간의 **불필요한 락 경쟁**으로 인해 성능 저하.\n    - 반복 작업 시 동기화 코드를 추가해야 함.\n\n---\n\n### CopyOnWriteArrayList\nJava Concurrency API(`java.util.concurrent`)에서 제공하는 동기화 리스트 구현체다.\n- **특징**:\n    1. 쓰기 작업 시, 내부 배열을 **복사(Copy)**하여 새로 작성.\n    2. **읽기 작업은 락 없이** 수행 가능.\n    3. 반복 작업 중에도 쓰기 작업이 가능하며, **ConcurrentModificationException**이 발생하지 않음.\n\n- **장점**:\n    - 읽기 작업이 많고 쓰기 작업이 적은 환경에서 성능이 우수.\n    - 반복 작업 중에도 안정적이며 동기화 필요 없음.\n\n- **단점**:\n    - 쓰기 작업 시 배열을 복사하므로 **메모리 사용량** 증가.\n    - 쓰기 작업이 많으면 성능 저하.\n\n**예제 코드**:\n```java\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class CopyOnWriteExample {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        list.add(\"A\");\n        list.add(\"B\");\n\n        for (String item : list) {\n            list.add(\"C\"); // 반복 중 추가 가능\n            System.out.println(item);\n        }\n    }\n}\n```\n\n### **사용 시 선택 기준**\n- **SynchronizedList**:\n    - 간단히 동기화를 구현해야 할 때.\n    - 읽기와 쓰기 작업이 균등하게 발생하는 환경.\n\n- **CopyOnWriteArrayList**:\n    - 읽기 작업이 대부분이고, 쓰기 작업이 드문 환경.\n    - 반복 작업 중에도 안전한 동기화가 필요한 경우.\n"},{"excerpt":"SynchronizedMap와 ConcurrentHashMap 과 은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다. SynchronizedMap 은  메소드를 통해 생성할 수 있…","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"date":"November 22, 2024","title":"SynchronizedMap vs ConcurrentHashMap","tags":["Java"]},"rawMarkdownBody":"\n# SynchronizedMap와 ConcurrentHashMap\n`SynchronizedMap`과 `ConcurrentHashMap`은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다.\n\n## SynchronizedMap\n`SynchronizedMap`은 `Collections.synchronizedMap()` 메소드를 통해 생성할 수 있다.\n이 클래스는 내부적으로 `synchronized` 키워드를 사용하여 동기화를 제공한다.\n`Collections.synchronizedxxx`의 초기화 코드는 다음과 같다.\n\n```java\nMap<String, String> map = Collections.synchronizedMap(new HashMap<>());\n```\n\n앞서 생성한 `HashMap`을 `Collections.synchronizedMap()` 메소드에 넘겨주면, 래핑 된 `SynchronizedMap`이 생성된다.\n하지만 이렇게 생성한 `SynchronizedMap`은 단순히 `synchronized` 키워드를 사용하여 객체 레벨의 잠금을 제공하여 동기화를 제공하기 때문에,\nput 및 get 메소드 호출 시 동일한 작업을 수행하기 위해 락을 선점해야 한다.\n이처럼 컬렉션 전체에 대한 락을 사용하면 오버 헤드가 발생하며, 한 스레드가 맵을 수정하는 동안 다른 스레드는 대기해야 하는 과도한 락 문제가 발생할 수 있다.\n또한 이는 성능 저하를 야기할 수 있으며, `ConcurrentModificationException`이 발생할 수 있다.\n\n## ConcurrentHashMap\n`ConcurrentHashMap`은 `SynchronizedMap`과 달리 락을 사용하여 동기화를 제공하지 않는다.\n이 클래스는 `synchronized` 키워드를 사용하지 않고, 내부적으로 락을 사용하여 동기화를 제공한다.\n\n`ConcurrentHashMap`은 다음과 같이 생성할 수 있다.\n\n```java\nMap<String, String> map = new ConcurrentHashMap<>();\n```\n\n`ConcurrentHashMap`은 `SynchronizedMap`과 달리 `synchronized` 키워드를 사용하지 않기 때문에, 객체 레벨의 락이 아닌 좀 더 세분화된\n버킷 레벨의 락을 사용하여 동기화를 제공한다.\n여기서 버킷 레벨의 락이란 맵의 각 버킷에 대해 락을 제공하는 것을 의미한다.\n배열, 연결 리스트 그리고 트리 등의 자료구조를 사용하여 버킷을 구성하며, 각 버킷은 독립적으로 락을 가지고 있다.\n보통 해시 충돌이 얼마나 발생하는지에 따라 버킷의 수가 결정되며, 해시 충돌이 많이 발생할수록 버킷의 수가 많아진다.\n또한 자료구조도 해시 충돌을 줄이기 위해 변경되는데 만약 해쉬 충돌이 적으면 배열과 연결 리스트를 사용하고, 해시 충돌이 많으면 Red-Black Tree를 사용한다.\n이를 통해 여러 스레드가 동시에 맵을 수정할 수 있으며, 더 많은 확정성을 지니게 된다.\n기본적으로 `ConcurrentHashMap`은 16개의 버킷을 가지고 있으며, 각 버킷은 독립적으로 락을 가지고 있다.\n이론적으로 봤을 때 16개의 버킷이 있기 때문에 16개의 스레드가 동시에 맵을 수정할 수 있다.\n필요하다면 `ConcurrentHashMap`의 크기를 늘릴 수 있으며, 이는 생성자에 전달할 수 있는 초기 용량을 조정하여 가능하다.\n\n## null 허용 여부\n`SynchronizedMap`과 `ConcurrentHashMap`은 null 키와 null 값을 다른 방식으로 처리한다.\n기본적으로 `SynchronizedMap`은 null 키와 null 값을 모두 허용한다.\n\n```java\nMap<String, String> synchronizedMap = Collections.synchronizedMap(new HashMap<>());\nsynchronizedMap.put(null, \"value\"); // null 키 허용\nsynchronizedMap.put(\"key\", null); // null 값 허용\n```\n\n하지만, `ConcurrentHashMap`은 null 키와 null 값을 모두 허용하지 않는다.\n따라서 `ConcurrentHashMap`을 사용할 때는 null 키와 null 값을 사용하지 않도록 주의해야 한다.\n\n```java\nMap<String, String> concurrentHashMap = new ConcurrentHashMap<>();\nconcurrentHashMap.put(null, \"value\"); // null 키 불허\nconcurrentHashMap.put(\"key\", null); // null 값 불허\n```\n\n```java\nException in thread \"main\" java.lang.NullPointerException\n    at java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1011)\n    at java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)\n    at com.example.demo.DemoApplication.main(DemoApplication.java:13)\n```\n\n그래도 `ConcurrentHashMap`을 사용하고 싶은데 null 키와 null 값을 사용해야 하는 경우에는,\n`ConcurrentHashMap` 대신 `ConcurrentHashMap`을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.\n\n```java\npublic class MyConcurrentHashMap<K, V> extends ConcurrentHashMap<K, V> {\n    @Override\n    public V put(K key, V value) {\n        if (key == null) {\n            throw new NullPointerException(\"null key\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null value\");\n        }\n        return super.put(key, value);\n    }\n}\n```\n\n`SynchronizedMap`과 `ConcurrentHashMap`은 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n`SynchronizedMap`은 `synchronized` 키워드를 사용하여 객체 레벨의 락을 제공하며, `ConcurrentHashMap`은 버킷 레벨의 락을 사용하여 동기화를 제공한다.\n따라서 `ConcurrentHashMap`이 `SynchronizedMap`보다 더 좋은 성능을 제공한다.\n또한 `ConcurrentHashMap`은 null 키와 null 값을 허용하지 않는다.\n따라서 null 키와 null 값을 사용해야 하는 경우에는 `ConcurrentHashMap`을 사용할 수 없다.\n이러한 경우에는 `ConcurrentHashMap`을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.\n"},{"excerpt":"CAS와 ABA CAS(Compare-And-Swap)와 ABA 문제에 대해 알아보기에 앞서 동기화와 Lock-Based 알고리즘, Lock-Free 알고리즘에 대해 알아보자. 동시성(Concurrency)과 병렬성(Parallelism) 동시성과 병렬성은 비슷한 개념이지만, 다르다.\n동시성은 여러 작업을 동시에 처리하는 것이고, 병렬성은 여러 작업을 동…","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"date":"November 21, 2024","title":"CAS(Compare-And-Swap)와 ABA 문제","tags":["Java"]},"rawMarkdownBody":"\n# CAS와 ABA\nCAS(Compare-And-Swap)와 ABA 문제에 대해 알아보기에 앞서 동기화와 Lock-Based 알고리즘, Lock-Free 알고리즘에 대해 알아보자.\n\n## 동시성(Concurrency)과 병렬성(Parallelism)\n동시성과 병렬성은 비슷한 개념이지만, 다르다.\n동시성은 여러 작업을 동시에 처리하는 것이고, 병렬성은 여러 작업을 동시에 처리하는 것이다.\n동시성은 하나의 코어에서 여러 작업을 번갈아가며 처리하는 것이고, 병렬성은 여러 코어에서 여러 작업을 동시에 처리하는 것이다.\n\n## 동기화(Synchronization)\n동기화는 동시성 프로그래밍에서 여러 스레드가 공유 자원에 접근할 때, 데이터 일관성을 유지하기 위해 사용하는 기법이다.\n이를 통해 스레드 간의 경합을 방지하고, 데이터 일관성을 유지할 수 있다.\nLock-Based 알고리즘과 Lock-Free 알고리즘이 동기화를 위한 방법에 속한다.\n\n## Lock-Based 알고리즘\nLock-Based 알고리즘은 락을 사용하여 동기화하는 방식으로, 락을 획득한 스레드만 작업을 수행하고, 다른 스레드는 대기하게 된다.\n하지만 락을 사용하면 경합이 발생하여 성능이 저하되는 문제가 발생한다.\n\n## Lock-Free 알고리즘\nLock-Free 알고리즘은 락을 사용하지 않고 동기화하는 방식으로, CAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\nLock-Based 알고리즘과 달리 락을 사용하지 않아 경합이 발생하지 않아 성능이 향상되는 장점이 있다.\n\n## CAS(Compare-And-Swap) 알고리즘\nCAS(Compare-And-Swap) 알고리즘은 락을 사용하지 않고 동기화하는 방식이다.\n값을 읽고, 비교하고, 교체하는 연산을 원자적으로 수행하는 방식으로 락을 사용하지 않아 경합이 발생하지 않아 성능이 향상된다.\n하지만 단점 또한 존재하는데, ABA 문제가 발생할 수 있다.\n\n## ABA 문제\nABA 문제는 CAS 알고리즘에서 발생하는 문제로, 스레드 A가 값을 읽고, 스레드 B가 값을 변경하고, 스레드 A가 다시 값을 변경할 때, 스레드 A는 값이 변경되지 않았다고 판단하여 문제가 발생한다.\n이를 해결하기 위해 AtomicStampedReference, AtomicMarkableReference 클래스들과 같은 스탬프 기반의 클래스를 사용하여 해결할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        AtomicReference<Integer> atomicReference = new AtomicReference<>(100);\n\n        Thread thread1 = new Thread(() -> {\n            atomicReference.compareAndSet(100, 200);\n            atomicReference.compareAndSet(200, 100);\n        });\n\n        Thread thread2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean result = atomicReference.compareAndSet(100, 300);\n            System.out.println(result); // true\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n위 코드에서 스레드 1은 100을 200으로 변경하고, 200을 100으로 변경한다.\n스레드 2는 1초를 대기한 후 100을 300으로 변경한다.\n하지만 스레드 2는 100을 200으로 변경한 후 200을 100으로 변경한 것을 알지 못하기 때문에 100을 300으로 변경할 수 있다.\n\n이러한 ABA 문제를 해결하기 위해 AtomicStampedReference, AtomicMarkableReference 클래스들을 사용하여 해결할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 0);\n\n        Thread thread1 = new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp();\n            atomicStampedReference.compareAndSet(100, 200, stamp, stamp + 1);\n            stamp = atomicStampedReference.getStamp();\n            atomicStampedReference.compareAndSet(200, 100, stamp, stamp + 1);\n        });\n\n        Thread thread2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            int stamp = atomicStampedReference.getStamp();\n            boolean result = atomicStampedReference.compareAndSet(100, 300, stamp, stamp + 1);\n            System.out.println(result); // false\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n위 코드에서 AtomicStampedReference 클래스를 사용하여 스탬프를 사용하여 ABA 문제를 해결할 수 있다.\n스레드 1은 100을 200으로 변경하고, 200을 100으로 변경한다.\n스레드 2는 1초를 대기한 후 100을 300으로 변경한다.\n하지만 스레드 2는 100을 200으로 변경한 후 200을 100으로 변경한 것을 알기 때문에 100을 300으로 변경할 수 없다.\n\n이러한 방식으로 ABA 문제를 해결할 수 있다.\n"},{"excerpt":"자바의 멀티 스레딩 이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다. 동시성과 병렬성의 차이점 동시성()과 병렬성()은 다중 작업을 처리하는 방식에서 차이가 있다. 동시성(): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다. 병렬성(): 여러 작업이 물리적으로 동시에 실행됩니다. 멀…","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"date":"November 20, 2024","title":"자바 멀티 스레딩","tags":["Java"]},"rawMarkdownBody":"\n# 자바의 멀티 스레딩\n\n<hr>\n\n이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다.\n\n## 동시성과 병렬성의 차이점\n동시성(`Concurrency`)과 병렬성(`Parallelism`)은 다중 작업을 처리하는 방식에서 차이가 있다.\n- 동시성(`Concurrency`): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다.\n- 병렬성(`Parallelism`): 여러 작업이 물리적으로 동시에 실행됩니다. 멀티코어 CPU에서 서로 다른 코어가 각각의 작업을 실행한다.\n\n## Thread-Safe하다는 것의 의미\n`Thread-Safe`는 다중 스레드 환경에서 동시 접근이 발생해도 데이터의 일관성을 유지하고 예측 가능한 결과를 보장하는 것을 의미한다.\n\n## Thread-Safe를 구현하는 방법\n\n다음은 자바에서 `Thread-Safe`를 구현하는 방법들을 정리한다.\n### Mutual Exclusion (상호 배제)\n\n`synchronized` 키워드를 사용하여 한 번에 하나의 스레드만 특정 코드 블록에 접근하도록 하여 제한하는 방식이다.\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n```\n\n### 불변 객체 사용\n\n객체의 상태를 변경하지 않음으로써 스레드 간의 충돌을 방지하여 동기화가 필요성을 소거하는 방식이다.\n\n```java\npublic class ImmutableCounter {\n    private final int count;\n\n    public ImmutableCounter(int count) {\n        this.count = count;\n    }\n\n    public ImmutableCounter increment() {\n        return new ImmutableCounter(this.count + 1);\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n### Thread-Local Storage\n\n`ThreadLocal` 클래스 사용해서 각 스레드가 고유한 메모리를 할당하여 독립적인 데이터를 가질 수 있도록 설정하는 방식이다.\n\n```java\npublic class ThreadLocalExample {\n    private static ThreadLocal<Integer> threadLocalCount = ThreadLocal.withInitial(() -> 0);\n\n    public void increment() {\n        threadLocalCount.set(threadLocalCount.get() + 1);\n    }\n\n    public int getCount() {\n        return threadLocalCount.get();\n    }\n}\n\n```\n\n### Concurrent 패키지 사용\n`java.util.concurrent` 패키지에서 제공하는 `Thread-Safe` 자료구조와 API 사용하는 방식으로 `ConcurrentHashMap`와 `CopyOnWriteArrayList`가 주로 사용된다.\n\n### Lock-Free Programming\n\n`AtomicInteger` 같은 CAS(Compare-And-Swap) 알고리즘을 사용하여 스레드 경합을 줄이고 성능을 개선하는 방식이다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Thread-Safe 구현에서의 고려 사항\n\n- 성능 문제\n   - `Thread-Safe`를 보장하는 방식은 대개 비용이 든다. 예를들어, `synchronized` 블록은 락을 사용하는데 이때 경합(Contension) 발생 시 성능 저하를 초래한다.\n- 데드락(`Deadlock`)\n   - 두 개 이상의 스레드가 서로의 락을 기다리면서 무한 대기 상태에 빠질 위험이 있다.\n- 락 경합 문제\n   - 여러 스레드가 동시에 동일한 리소스에 접근하려고 시도하면 경합으로 인해 처리 속도 저하의 원인이 된다.\n- 비효율적 동기화\n   - 불필요하게 동기화가 과도하게 사용되면 작업 처리 속도가 크게 떨어질 수 있다.\n\n### Thread-Safe하지 않은 경우 야기되는 문제\n두 개 이상의 스레드가 동시에 동일한 데이터에 접근 및 수정하여 일관되지 않은 결과를 초래하는 데이터 레이스(Data Race)현상을 야기한다.\n\n```java\npublic class NotThreadSafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// 여러 스레드에서 increment() 호출 시\n// count 값이 의도한 값보다 작게 나올 가능성.\n```\n\n### Thread-Safe를 구현하는 가장 성능이 좋은 방법\n동기화 비용을 줄이기 위해 CAS 알고리즘 기반의 Atomic 클래스를 사용하는 것이 일반적으로 더 효율적이다. 읽기 작업이 많은 경우, CopyOnWriteArrayList와 같은 데이터 구조 사용하면 된다.\n\n## 가시성 문제와 원자성 문제\n\n### 가시성 문제\n가시성 문제는 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이지 않는 현상을 의미한다.\n보통 가시성 문제의 원인은 다음과 같다.\n- 각 스레드는 메인 메모리 대신 CPU 캐시에 데이터를 저장하고 읽음으로 인해 메모리 불일치 발생한다.\n- 코드 실행 순서가 재배열되어 예상과 다른 동작한다.\n- 데이터의 일관성을 보장하는 메모리 배리어가 없어 업데이트가 다른 스레드에 전파되지 않음로 인해 발생한다.\n\n예를들면 아래 코드에서 `stop = true`로 값을 변경해도, 다른 스레드에서 `stop`의 변경 사항을 보지 못해 무한 루프가 발생할 수 있다.\n```java\npublic class VisibilityExample {\n    private static boolean stop = false;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            while (!stop) {\n                // 작업 수행\n            }\n            System.out.println(\"Stopped!\");\n        });\n        thread.start();\n\n        // stop 값을 변경\n        stop = true;\n    }\n}\n```\n\n#### 원자성 문제\n원자성 문제는 작업이 중간에 끼어들기 없이 완료되지 않는 현상을 의미한다.\n주로 특정 작업 단위가 나뉘어 실행될 경우, 다른 스레드가 작업 중간에 간섭하여 데이터 불일치 발생하게 된다.\n\n아래 코드는 count++는 Read, Modify, Write 세 단계로 나뉘어 실행되는데 이때 다른 스레드가 중간에 간섭 가능해서 count 값이 예상보다 작을 수 있다.\n\n```java\npublic class AtomicityExample {\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Count: \" + count); // 기대값: 2000, 실제값: 불확실\n    }\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            count++; // Read-Modify-Write\n        }\n    }\n}\n```\n\n### 자바의 동시성 이슈 해결 방법\n이러한 자바의 동시성 이슈를 해결하기 위해 다음과 같은 방법이 있다.\n- 변수의 변경 사항을 메인 메모리에 즉시 반영시켜 가시성을 보장하는 `volatile` 키워드를 사용한다.\n- 메모리의 일관성(원자성)을 보장하는 `synchronized` 키워드를 사용한다\n- `AtomicInteger` 클래스를 사용해 `CAS(Compare-And-Swap)` 알고리즘 기반으로 원자성 보장하는 방식이 주가된다.\n- Lock 객체를 사용하여 `ReentrantLock` 사용한다.\n\n\n### volatile 키워드\nCPU 캐시가 아닌 메인 메모리에서 값을 읽고 씀으로 변수의 값을 모든 스레드에서 즉시 읽을 수 있도록하여 컴파일러와 CPU의 재정렬 방지를 보장한다. 대신 원자성을 보장하지 않는다는 단점이 있다.\n\n```java\npublic class VolatileExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false; // 다른 스레드에서도 즉시 반영\n    }\n\n    public void doWork() {\n        while (running) {\n            // 작업 실행\n        }\n    }\n}\n```\n\n## synchronized 키워드\n\nsynchronized는 동기화를 통해 한 번에 하나의 스레드만 특정 코드 블록 또는 메서드에 접근할 수 있도록 제한하여 스레드 간 상호 배제(Mutual Exclusion)와 가시성(Visibility)을 보장하는 키워드다.\n\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n### synchronized의 내부 동작 원리\n`synchronized`는 JVM의 모니터 락(Monitor Lock)을 기반으로 바이트코드 레벨에서 동작한다.\n`monitorenter`로 락을 획득하거나 `monitorexit`으로 락을 해제 할 수 있고, 이때 객체 헤더(Object Header)에 있는 Monitor 필드에 락 상태가 기록된다.\n\n\n```java\npublic void synchronizedBlockExample() {\n    synchronized (this) {\n        count++;\n    }\n}\n\n//0: aload_0\n//1: dup\n//2: monitorenter // 락 획득\n//3: aload_0\n//4: dup\n//5: getfield \n// #2 // count 읽기\n//8: iconst_1\n//9: iadd\n//10: putfield \n//#2 // count 쓰기 \n//13: monitorexit // 락 해제 \n//14: return\n```\n\n### synchronized의 단점\n물론 이렇게 synchronized을 사용함으로써 단점도 존재한다.\n- 성능 저하\n   - 락 경쟁이 발생할 경우 스레드가 대기 상태에 머물러 성능 저하 발생한다.\n- 데드락(Deadlock)\n   - 여러 스레드가 서로의 락을 기다리며 무한 대기 상태가 발생한다.\n- Fine-Grained Locking 부족\n   - 동기화 범위가 크면, 불필요한 락 경쟁이 발생한다.\n\n ```java\n public class DeadlockExample {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            synchronized (lock2) {\n                System.out.println(\"Method1\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            synchronized (lock1) {\n                System.out.println(\"Method2\");\n            }\n        }\n    }\n}\n```\n\n\n## Atomic\nAtomic은 작업 중간에 다른 스레드가 개입할 수 없고, 작업이 완전히 수행되거나 아예 수행되지 않는 상태를 보장되어 분할되지 않는 작업 단위를 의미한다.\n이 개념의 핵심은 원자성을 보장하여 작업이 중간에 끼어든다거나 일관성이 침해되는 것을 방지하는 것이다.\n- **Atomic 타입**: `AtomicInteger`, `AtomicLong`, `AtomicReference` 등이 있음.\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 연산\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Java에서 원자성을 보장하는 방법\n\n#### synchronized 키워드: 동기화 블록을 사용하여 작업 단위를 원자적으로 처리.\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++; // synchronized로 원자성 보장\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n#### Atomic 클래스 사용해 CAS(Compare-And-Swap) 알고리즘을 기반으로 성능과 원자성을 모두 보장하는 방법.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 증가\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n\n```\n\n#### 불변 객체(Immutable Object)\n\nString, Integer 같은 클래스는 불변 객체로 설계되어 Thread-Safe하다.\n\n#### Lock-Free 알고리즘\nCAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\n\n## CAS(Compare-And-Swap) 알고리즘\n\nCAS(비교 및 교환)는 Lock-Free 동기화 기법으로, 데이터를 직접 락 없이 원자적으로 작업을 수행한다.\n동작 원리는 현재 메모리 값을 읽어서 예상 값과 현재 메모리 값을 비교하고 예상 값과 일치하면 새로운 값으로 변경, 그렇지 않으면 재시도하는 방식으로 동작하는 알고리즘이다.\n이로 인해 락을 사용하지 않아 스레드 경합이 줄어들어 성능이 향상되는 효과를 얻을 수 있다.\n\n하지만 단점도 존재한다.\n예상 값이 변경되었다가 다시 원래 값으로 돌아온 경우, CAS는 이를 감지하지 못하는 ABA문제가 발생할 수 있다.\n이를 해결하기 위해 AtomicStampedReference와 같은 스탬프(버전) 기반의 데이터 구조를 사용하면 된다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CASExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        while (true) {\n            int current = count.get();\n            int next = current + 1;\n            if (count.compareAndSet(current, next)) {\n                break;\n            }\n        }\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### ABA 문제\nABA 문제는 CAS(Compare-And-Swap) 알고리즘에서 발생하는 문제로, 메모리의 값이 변경되었다가 다시 원래 값으로 돌아왔을 때, CAS는 이를 감지하지 못해 값이 변경되지 않은 것으로 잘못 판단하는 현상이다.\n예를 들어, 값이 A → B → A로 변경되었더라도 CAS는 단순히 값이 A인지 여부만 확인하므로 중간 변경을 인식하지 못한다.\n\n### ABA 문제 해결 방법\n그럼 CAS가 더 효율적이라 사용하고 싶은데 ABA 문제가 발생한다고 하면 도대체 어떻게 사용을 하라는 걸까?\n당연히 그런 해결책도 존재했다.\n\n#### AtomicStampedReference\n`AtomicStampedReference`와 같은 버전 성질의 데이터 구조를 사용하는 것이다.\n`AtomicStampedReference`는 값과 함께 버전 정보(Stamp)를 저장하여 값이 중간에 변경되었는지 확인한다.\n내부 동작 과정은 값과 스탬프(버전)를 함께 저장하고, CAS 비교 시, 값뿐만 아니라 스탬프도 비교해서 값은 동일하더라도 스탬프가 다르면 중간 변경이 있었음을 탐지하는 방법으로 ABA문제를 해결할 수 있다.\n\n```java\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class ABAExample {\nprivate static AtomicStampedReference<Integer> atomicStampedRef =\nnew AtomicStampedReference<>(100, 0); // 초기 값 100, 초기 스탬프 0\n\n    public static void main(String[] args) {\n        int initialStamp = atomicStampedRef.getStamp(); // 현재 스탬프\n        Integer initialValue = atomicStampedRef.getReference(); // 현재 값\n\n        // 스레드 1: 값 변경 (100 -> 200 -> 100)\n        new Thread(() -> {\n            atomicStampedRef.compareAndSet(100, 200, initialStamp, initialStamp + 1); // 스탬프 증가\n            atomicStampedRef.compareAndSet(200, 100, initialStamp + 1, initialStamp + 2); // 다시 100으로 변경\n        }).start();\n\n        // 스레드 2: 값과 스탬프 확인 후 CAS 시도\n        new Thread(() -> {\n            try {\n                Thread.sleep(500); // 스레드 1이 변경하는 동안 대기\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            boolean success = atomicStampedRef.compareAndSet(\n                100, 300, initialStamp, initialStamp + 1 // 초기 스탬프를 사용\n            );\n\n            System.out.println(\"Update Success: \" + success); // false: 스탬프가 변경됨\n        }).start();\n    }\n}\n```"},{"excerpt":"HashMap 컬렉션 HashMap의 동작 원리 ****은 키-값() 쌍을 저장하는 데 사용되는 자바의 컬렉션으로, 내부적으로 해시 테이블(Hash Table) 자료구조를 사용합니다. 데이터를 저장, 검색, 삭제하는 데 효율적이며, 다음과 같은 방식으로 동작한다. 저장 구조 은 내부적으로 배열과 연결 리스트(또는 트리)를 조합하여 데이터를 저장한다. 배열…","fields":{"slug":"/java-hashmap/"},"frontmatter":{"date":"November 18, 2024","title":"HashMap 컬렉션","tags":["Java"]},"rawMarkdownBody":"\n\n# HashMap 컬렉션\n\n<hr>\n\n## HashMap의 동작 원리\n\n**`HashMap`**은 키-값(`Key-Value`) 쌍을 저장하는 데 사용되는 자바의 컬렉션으로, 내부적으로 **해시 테이블(Hash Table)** 자료구조를 사용합니다. 데이터를 저장, 검색, 삭제하는 데 효율적이며, 다음과 같은 방식으로 동작한다.\n\n### 저장 구조\n\n`HashMap`은 내부적으로 배열과 연결 리스트(또는 트리)를 조합하여 데이터를 저장한다.\n\n- **배열**  \n  해시 테이블의 주요 저장 공간으로, 각 요소는 **버킷(Bucket)** 역할을 한다.\n\n- **버킷**  \n  동일한 해시 값을 가진 키들이 저장되는 공간으로, 연결 리스트(또는 트리)로 구현된다.\n\n### 데이터 저장 (`put` 메서드)\n\n- **해시 함수 계산**\n    - 키(`Key`) 객체의 `hashCode()` 메서드를 호출하여 해시 값을 계산한다.\n    - 계산된 해시 값은 배열 인덱스로 변환된다.\n- **버킷에 데이터 저장**\n    - 계산된 인덱스를 기준으로 해당 버킷에 데이터를 저장한다.\n    - 동일한 인덱스에 여러 키가 저장될 경우, 연결 리스트 또는 트리 구조로 관리된다.\n\n```java\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(\"apple\", 1); // \"apple\"의 해시값을 계산해 저장\nhashMap.put(\"banana\", 2); // \"banana\"의 해시값을 계산해 저장\n```\n\n### 데이터 검색 (`get` 메서드)\n\n1. **해시 함수 계산**\n- 검색하려는 키의 `hashCode()`를 계산하여 배열의 인덱스를 얻는다.\n\n2. **버킷 탐색**\n- 해당 버킷의 연결 리스트(또는 트리)에서 키를 비교(`equals`)하여 값을 찾는다.\n\n```java\nint value = hashMap.get(\"apple\"); // \"apple\"의 해시값을 계산해 값 검색\nSystem.out.println(value); // 출력: 1\n```\n\n### 해시 충돌\n\n**해시 충돌**은 서로 다른 키가 동일한 해시 값을 가지는 경우 발생한다.  \n이 문제를 해결하기 위해 `HashMap`은 **체이닝(Chaining)**과 **트리화(Treeification)**를 사용한다.\n\n- **체이닝**  \n  동일한 해시 값을 가진 데이터를 연결 리스트로 저장.\n\n- **트리화**  \n  연결 리스트의 크기가 일정 수준을 초과하면, **이진 검색 트리**로 변환하여 성능을 개선.\n\n**JDK 8 이후 HashMap 내부 동작**\n\n```java\nif (bucketSize >= TREEIFY_THRESHOLD) {\n    // 연결 리스트를 트리로 변환\n    bucket = treeify(bucket);\n}\n```\n\n### 최악의 시간 복잡도\n\n**최적의 경우**\n- 해시 함수가 균등하게 동작하여 충돌이 발생하지 않을 경우,  \n  데이터 접근, 삽입, 삭제 모두 **O(1)**.\n\n**최악의 경우**\n- 모든 키가 동일한 해시 값을 가지는 경우(심각한 해시 충돌),  \n  연결 리스트 전체를 순회해야 하므로 **O(n)**.\n- JDK 8 이후에는 연결 리스트가 트리로 변환되므로, 최악의 시간 복잡도는 **O(log n)**로 개선.\n\n#### 시간 복잡도\n\n| **작업**         | **최적 시간 복잡도** | **최악 시간 복잡도**       |\n|------------------|----------------------|---------------------------|\n| **삽입 (`put`)** | O(1)                | O(log n) (JDK 8 이후)     |\n| **검색 (`get`)** | O(1)                | O(log n) (JDK 8 이후)     |\n| **삭제 (`remove`)** | O(1)              | O(log n) (JDK 8 이후)     |\n\n\n```java\nimport java.util.HashMap;\n\npublic class HashMapCollisionTest {\n    public static void main(String[] args) {\n        // 해시 충돌을 유발하는 키 생성\n        HashMap<Key, Integer> hashMap = new HashMap<>();\n        for (int i = 0; i < 10000; i++) {\n            hashMap.put(new Key(\"key\" + i), i);\n        }\n\n        long startTime = System.nanoTime();\n        System.out.println(hashMap.get(new Key(\"key9999\"))); // 값 검색\n        long endTime = System.nanoTime();\n\n        System.out.println(\"검색 시간: \" + (endTime - startTime) + \"ns\");\n    }\n\n    static class Key {\n        String key;\n\n        Key(String key) {\n            this.key = key;\n        }\n\n        @Override\n        public int hashCode() {\n            return 42; // 모든 키가 동일한 해시 값을 가지도록 설정\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Key && this.key.equals(((Key) obj).key);\n        }\n    }\n}\n```\n"},{"excerpt":"ArrayList 컬렉션 는 자바의 컬렉션 프레임워크에서 배열 기반으로 동작하는  인터페이스의 구현체 중 하나로 가장 많이 사용되는 컬렉션에 속한다.\n이 글에서는 자바의  컬렉션에 대해 다른 컬렉션들과 비교를 하며 알아보겠다. ArrayList 특징 먼저 의 특징에 대해서 알아보자. 연속적인 데이터 저장 데이터는 연속적으로 저장되며, 리스트 중간에 빈 공…","fields":{"slug":"/java-arraylist/"},"frontmatter":{"date":"November 17, 2024","title":"ArrayList 컬렉션","tags":["Java"]},"rawMarkdownBody":"\n# ArrayList 컬렉션\n\n<hr>\n\n`ArrayList`는 자바의 컬렉션 프레임워크에서 배열 기반으로 동작하는 `List` 인터페이스의 구현체 중 하나로 가장 많이 사용되는 컬렉션에 속한다.\n이 글에서는 자바의 `ArrayList` 컬렉션에 대해 다른 컬렉션들과 비교를 하며 알아보겠다.\n\n## ArrayList 특징\n\n먼저 `ArrayList`의 특징에 대해서 알아보자.\n\n- 연속적인 데이터 저장\n    - 데이터는 연속적으로 저장되며, 리스트 중간에 빈 공간이 생기지 않는다.\n- 내부 구조\n    - 내부적으로 `Object[]` 배열을 사용하여 데이터를 저장한다.\n- 빠른 접근성\n    - 배열 기반이기 때문에 인덱스를 이용해 요소에 빠르게 접근할 수 있다.\n- 가변적인 크기\n    - 배열과 달리, `ArrayList`는 데이터 적재량에 따라 크기를 동적으로 늘리거나 줄일 수 있다.\n    - 단, 배열 공간이 꽉 찰 때마다 새로운 배열을 생성하고 기존 데이터를 **복사(`copy`)**하는 방식으로 크기를 확장하므로,\n    - 이 과정에서 성능 지연이 발생할 수 있다.\n- 삽입/삭제 성능\n    - 리스트 중간에 데이터를 삽입/삭제할 경우, 중간의 빈 공간을 방지하기 위해 요소들을 자동으로 이동시킨다.\n    - 이로 인해 삽입/삭제 성능이 낮다.\n\n이러한 특징으로 `ArrayList`는 데이터 조회가 빈번한 경우에 사용하기 적합하다.\n\n# 다른 컬렉션과 비교를 통해 이해하기\n\n<hr>\n\n## ArrayList vs 배열 비교\n\n위에서 `ArrayList`는 배열을 기반으로 설계되었다고 나왔는데 그러면 배열과 어떠한 차이점이 있어 사용되는지 알아보도록하자.\n\n### 선언 및 초기화\n\n- 배열: 크기를 명시적으로 지정하며, 크기가 고정된다.\n\n```java\n// 배열 선언 및 초기화\nint[] arr = new int[5]; // 크기 고정\narr[0] = 10; // 데이터 추가\nSystem.out.println(arr[0]); // 출력: 10\n```\n\n- `ArrayList`: 크기를 초기화하지 않아도 사용 가능하며, 데이터가 추가되면 크기가 동적으로 조정된다.\n\n```java\n// ArrayList 선언 및 초기화\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10); // 데이터 추가\nSystem.out.println(arrayList.get(0)); // 출력: 10\n```\n\n### 용량 가변성\n\n- **배열**:\n    - 크기가 고정되어 생성 후 변경할 수 없다.\n    - 크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 한다.\n\n```java\nint[] arr = {1, 2, 3};\nint[] newArr = new int[5]; // 새로운 배열 생성\nSystem.arraycopy(arr, 0, newArr, 0, arr.length); // 데이터 복사\nnewArr[3] = 4; // 추가 데이터\nSystem.out.println(Arrays.toString(newArr)); // 출력: [1, 2, 3, 4, 0]\n```\n\n- **`ArrayList`**:\n    - 크기가 동적으로 조정된다.\n    - 내부적으로 배열을 사용하며, 배열 공간이 부족하면 새로운 배열을 생성하고 데이터를 복사한다.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(1);\narrayList.add(2);\narrayList.add(3);\n// 동적 크기 조정\narrayList.add(4);\nSystem.out.println(arrayList); // 출력: [1, 2, 3, 4]\n```\n\n### 데이터 접근\n\n- **배열**:\n    - 인덱스를 통해 데이터를 직접 접근할 수 있다.\n    - 접근 속도는 **O(1)**.\n\n```java\nint[] arr = {10, 20, 30};\nSystem.out.println(arr[1]); // 출력: 20\n```\n\n- **`ArrayList`**:\n    - 배열과 동일하게 인덱스를 통해 데이터를 접근할 수 있다.\n    - 내부적으로 배열을 사용하므로 접근 속도는 **O(1)**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(arrayList.get(1)); // 출력: 20\n```\n\n### 데이터 삽입/삭제\n\n- **배열**:\n    - 특정 위치에 데이터를 삽입하거나 삭제할 때 모든 요소를 이동해야 한다.\n    - 삽입/삭제 속도는 **O(n)**.\n\n```java\nint[] arr = {1, 2, 4, 5};\nint[] newArr = new int[5]; // 새로운 배열 생성\nSystem.arraycopy(arr, 0, newArr, 0, 2); // 기존 데이터 복사\nnewArr[2] = 3; // 삽입\nSystem.arraycopy(arr, 2, newArr, 3, 2); // 나머지 데이터 복사\nSystem.out.println(Arrays.toString(newArr)); // 출력: [1, 2, 3, 4, 5]\n```\n\n- **`ArrayList`**:\n    - 배열과 마찬가지로 삽입/삭제 시 요소를 이동시켜야 하지만, 추가 메서드(`add`, `remove`)로 쉽게 처리할 수 있다.\n    - 삽입/삭제 속도는 **`O(n)`**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(1, 2, 4, 5));\narrayList.add(2, 3); // 2번 인덱스에 삽입\nSystem.out.println(arrayList); // 출력: [1, 2, 3, 4, 5]\narrayList.remove(2); // 2번 인덱스 삭제\nSystem.out.println(arrayList); // 출력: [1, 2, 4, 5]\n```\n\n### 메모리 사용 및 성능\n\n- **배열**:\n    - 고정 크기이므로 메모리를 미리 할당한다.\n    - 메모리 사용 효율이 높고, 복사 비용이 없다.\n\n- **`ArrayList`**:\n    - 크기가 동적으로 변경되므로 내부적으로 더 많은 메모리를 할당한다.\n    - 크기가 부족할 때 새로운 배열을 생성하고 기존 데이터를 복사하는 비용이 발생한다.\n    - 디폴트로 1.5배 크기로 확장된다.\n\n**`ArrayList` 내부 동작 코드 예시** (JDK 8):\n\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 기존 크기의 1.5배\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n## ArrayList vs LinkedList 비교\n\n`ArrayList`와 `LinkedList`는 모두 **리스트** 인터페이스를 구현한 컬렉션으로, 데이터 저장 및 관리에 사용된다.  \n그러나 내부 구조와 동작 방식에서 큰 차이가 있어, 사용 목적과 상황에 따라 선택해야 한다.\n\n### 내부 구조\n\n- **`ArrayList`**\n    - 내부적으로 **배열**을 사용하여 데이터를 저장한다.\n    - 요소들은 배열의 인덱스로 접근하며, 연속적인 메모리 공간에 저장된다.\n\n```java\n// ArrayList 내부 구조 예제\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10); // 배열의 끝에 추가\nSystem.out.println(arrayList.get(0)); // 인덱스를 통해 접근\n```\n\n- **`LinkedList`**\n    - **이중 연결 리스트**(`Doubly Linked List`)로 구현된다.\n    - 각 요소는 데이터와 함께 다음 요소 및 이전 요소를 가리키는 포인터를 가진 노드로 구성된다.\n\n```java\n// LinkedList 내부 구조 예제\nLinkedList<Integer> linkedList = new LinkedList<>();\nlinkedList.add(10); // 노드로 데이터 추가\nSystem.out.println(linkedList.get(0)); // 순차적으로 접근\n```\n\n### 데이터 접근\n\n- **`ArrayList`**\n    - 배열 기반이므로 **임의 요소 접근**이 빠르다.\n    - 시간 복잡도: **`O(1)`**.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(arrayList.get(1)); // 출력: 20\n```\n\n- **`LinkedList`**\n    - 노드를 따라가며 순차적으로 접근해야 하므로, **임의 요소 접근**이 느리다.\n    - 시간 복잡도: **`O(n)`**.\n\n```java\nLinkedList<Integer> linkedList = new LinkedList<>(Arrays.asList(10, 20, 30));\nSystem.out.println(linkedList.get(1)); // 출력: 20 (노드를 순차적으로 탐색)\n```\n\n### 데이터 삽입/삭제\n\n- **`ArrayList`**\n    - 중간 삽입/삭제 시, 나머지 요소들을 **이동**해야 하므로 속도가 느리다.\n    - 시간 복잡도: **O(n)** (중간 삽입/삭제), **O(1)** (끝에 추가).\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>(Arrays.asList(10, 20, 30));\narrayList.add(1, 15); // 1번 인덱스에 삽입\nSystem.out.println(arrayList); // 출력: [10, 15, 20, 30]\n```\n\n- **`LinkedList`**\n    - 연결 리스트 구조 덕분에 중간 삽입/삭제 시 노드 포인터만 변경하면 되므로 속도가 빠르다.\n    - 시간 복잡도: **O(1)** (노드 참조 후 삽입/삭제).\n\n```java\nLinkedList<Integer> linkedList = new LinkedList<>(Arrays.asList(10, 20, 30));\nlinkedList.add(1, 15); // 1번 인덱스에 삽입\nSystem.out.println(linkedList); // 출력: [10, 15, 20, 30]\n```\n\n### 메모리 사용\n\n- **`ArrayList`**\n    - 연속적인 메모리 공간을 사용하며, 크기가 부족할 경우 기존 데이터를 새로운 배열로 복사해야 한다.\n    - 배열의 크기는 기본적으로 1.5배씩 증가한다.\n\n```java\n// ArrayList 동적 크기 증가 코드 (JDK 8 내부 구현)\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 기존 크기의 1.5배\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n- **`LinkedList`**\n    - 각 노드가 데이터와 함께 두 개의 포인터(다음 및 이전 노드 참조)를 저장하므로, 메모리 사용량이 더 많다.\n\n\n## 성능 비교 요약\n\n| **기능**             | **ArrayList**                           | **LinkedList**                         |\n|---------------------|----------------------------------------|---------------------------------------|\n| **임의 요소 접근**    | 빠름 (**O(1)**)                         | 느림 (**O(n)**)                        |\n| **중간 삽입/삭제**    | 느림 (**O(n)**, 데이터 이동 필요)          | 빠름 (**O(1)**, 포인터 변경만 필요)      |\n| **순차 접근**         | 빠름 (**O(n)**)                         | 빠름 (**O(n)**)                        |\n| **메모리 사용**       | 적음 (배열만 저장)                        | 많음 (노드와 포인터 저장)                |\n| **크기 조정**         | 동적 크기 조정 (복사 비용 발생)             | 필요 없음                               |\n\n---\n\n### 사용 사례\n\n| **상황**                                 | **ArrayList** 추천                           | **LinkedList** 추천                     |\n|-----------------------------------------|--------------------------------------------|----------------------------------------|\n| **조회 작업이 많은 경우**                 | 빠른 접근 속도로 적합                         | 적합하지 않음                           |\n| **삽입/삭제 작업이 많은 경우**             | 삽입/삭제가 적은 경우 적합                    | 삽입/삭제가 많은 경우 적합               |\n| **데이터 크기가 자주 변경되는 경우**        | 동적 크기 조정이 자동으로 이루어짐             | 데이터 크기 변경 시 적합하지 않음          |\n| **메모리 효율성이 중요한 경우**            | 적합 (메모리 사용량이 낮음)                   | 비적합 (메모리 사용량이 높음)             |\n\n---\n\n- **ArrayList**는 데이터 조회가 많고 삽입/삭제가 적은 작업에 적합하다.\n- **LinkedList**는 데이터 삽입/삭제가 빈번한 작업에 적합하다.\n\n### 조회와 삽입/삭제 비교\n\n```java\nimport java.util.*;\n\npublic class ListComparison {\n    public static void main(String[] args) {\n        int n = 100000; // 데이터 개수\n\n        // ArrayList 테스트\n        List<Integer> arrayList = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            arrayList.add(i); // 데이터 추가\n        }\n        long start = System.nanoTime();\n        arrayList.get(n / 2); // 중간 요소 접근\n        long end = System.nanoTime();\n        System.out.println(\"ArrayList 조회 시간: \" + (end - start) + \"ns\");\n\n        start = System.nanoTime();\n        arrayList.add(n / 2, -1); // 중간에 삽입\n        end = System.nanoTime();\n        System.out.println(\"ArrayList 삽입 시간: \" + (end - start) + \"ns\");\n\n        // LinkedList 테스트\n        List<Integer> linkedList = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            linkedList.add(i); // 데이터 추가\n        }\n        start = System.nanoTime();\n        linkedList.get(n / 2); // 중간 요소 접근\n        end = System.nanoTime();\n        System.out.println(\"LinkedList 조회 시간: \" + (end - start) + \"ns\");\n\n        start = System.nanoTime();\n        linkedList.add(n / 2, -1); // 중간에 삽입\n        end = System.nanoTime();\n        System.out.println(\"LinkedList 삽입 시간: \" + (end - start) + \"ns\");\n    }\n}\n```\n\n\n## ArrayList vs Vector 비교\n\n`ArrayList`와 `Vector`는 모두 **리스트 인터페이스**를 구현한 컬렉션으로, 내부적으로 배열을 기반으로 데이터를 관리합니다.  \n하지만, 동작 방식과 사용 목적에서 몇 가지 차이점이 있습니다.\n\n\n### 내부 구조 및 동작\n\n- **`ArrayList`**\n    - 내부적으로 **비동기적**으로 동작합니다.\n    - 멀티스레드 환경에서 동기화가 지원되지 않으므로 동시성 문제를 처리하려면 별도의 동기화 작업이 필요합니다.\n\n```java\nArrayList<Integer> arrayList = new ArrayList<>();\narrayList.add(10);\narrayList.add(20);\nSystem.out.println(arrayList); // 출력: [10, 20]\n```\n\n- **`Vector`**\n    - 내부적으로 **동기화**된 메서드가 사용되므로 `Thread-Safe`합니다.\n    - 멀티스레드 환경에서 안전하게 사용할 수 있지만, 단일 스레드 환경에서는 불필요한 성능 오버헤드가 발생합니다.\n\n```java\nVector<Integer> vector = new Vector<>();\nvector.add(10);\nvector.add(20);\nSystem.out.println(vector); // 출력: [10, 20]\n```\n\n### 동기화 (Thread-Safety)\n\n- **`ArrayList`**\n    - 동기화를 지원하지 않으므로 단일 스레드 환경에서 사용이 적합합니다.\n    - 멀티스레드 환경에서 동기화를 적용하려면 `Collections.synchronizedList()`를 사용해야 합니다.\n\n```java\nList<Integer> synchronizedArrayList = Collections.synchronizedList(new ArrayList<>());\nsynchronizedArrayList.add(10);\nsynchronizedArrayList.add(20);\nSystem.out.println(synchronizedArrayList); // 출력: [10, 20]\n```\n\n- **`Vector`**\n    - 메서드 자체에 동기화가 적용되어 있으므로 멀티스레드 환경에서 안전하게 사용할 수 있습니다.\n    - 하지만 동기화로 인해 단일 스레드 환경에서는 성능이 떨어집니다.\n\n```java\nVector<Integer> vector = new Vector<>();\nvector.add(10);\nvector.add(20);\nSystem.out.println(vector); // 출력: [10, 20]\n```\n\n### 크기 조정\n\n- **`ArrayList`**\n    - 배열의 크기가 부족할 때 **기본적으로 1.5배**로 크기를 늘립니다.\n    - 동적 크기 조정이 효율적이며 메모리 사용을 최적화합니다.\n\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5배 크기 증가\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n- **`Vector`**\n- 배열의 크기가 부족할 때 **기본적으로 2배**로 크기를 늘립니다.\n- 메모리 낭비가 발생할 가능성이 높습니다.\n\n```java\nprivate void ensureCapacityHelper(int minCapacity) {\n    if (elementData.length - minCapacity < 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    int newCapacity = elementData.length * 2; // 2배 크기 증가\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n### 성능 비교\n\n| **기능**                | **ArrayList**                      | **Vector**                         |\n|------------------------|----------------------------------|-----------------------------------|\n| **Thread-Safe 여부**    | 비동기적 (Thread-Safe 아님)          | 동기적 (Thread-Safe 지원)           |\n| **멀티스레드 환경**      | 추가 동기화가 필요 (`synchronizedList`) | 멀티스레드 환경에 적합               |\n| **단일 스레드 환경**      | 적합 (불필요한 동기화 없음)            | 부적합 (불필요한 동기화로 성능 저하)   |\n| **동적 크기 조정**        | 1.5배씩 크기 증가                    | 2배씩 크기 증가                     |\n| **삽입/삭제 성능**        | 빠름 (단일 스레드 환경)               | 느림 (동기화 오버헤드)                |\n| **메모리 효율성**         | 메모리 사용 효율적                    | 메모리 낭비 가능성 있음                |\n\n\n### 사용 사례\n\n| **상황**                                   | **ArrayList** 추천                           | **Vector** 추천                           |\n|-------------------------------------------|--------------------------------------------|------------------------------------------|\n| **단일 스레드 환경**                       | 적합                                       | 부적합                                   |\n| **멀티스레드 환경**                         | `Collections.synchronizedList`로 동기화 필요 | 기본적으로 `Thread-Safe`라 적합            |\n| **메모리 효율성이 중요한 경우**              | 효율적 (1.5배 동적 증가)                     | 비효율적 (2배 동적 증가)                   |\n| **성능이 중요한 경우**                      | 성능에 민감한 작업에서 적합                  | 성능 저하가 발생하므로 비적합               |\n\n### ArrayList와 Vector의 성능 비교\n\n```java\nimport java.util.ArrayList;\nimport java.util.Vector;\n\npublic class ListPerformanceComparison {\n    public static void main(String[] args) {\n        int n = 100000; // 데이터 개수\n\n        // ArrayList 테스트\n        ArrayList<Integer> arrayList = new ArrayList<>();\n        long start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            arrayList.add(i);\n        }\n        long end = System.nanoTime();\n        System.out.println(\"ArrayList 데이터 추가 시간: \" + (end - start) + \"ns\");\n\n        // Vector 테스트\n        Vector<Integer> vector = new Vector<>();\n        start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            vector.add(i);\n        }\n        end = System.nanoTime();\n        System.out.println(\"Vector 데이터 추가 시간: \" + (end - start) + \"ns\");\n    }\n}\n```"},{"excerpt":"자바의 멀티 스레딩 이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다. 동시성과 병렬성의 차이점 동시성()과 병렬성()은 다중 작업을 처리하는 방식에서 차이가 있다. 동시성(): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다. 병렬성(): 여러 작업이 물리적으로 동시에 실행됩니다. 멀…","fields":{"slug":"/java-atomic/"},"frontmatter":{"date":"November 17, 2024","title":"멀티 스레드 환경에서 동시성 프로그래밍","tags":["Java"]},"rawMarkdownBody":"\n# 자바의 멀티 스레딩\n\n<hr>\n\n이 글에서는 자바에서의 멀티 스레딩을 이해하는 과정에서 필요한 개념을 정리한다.\n\n## 동시성과 병렬성의 차이점\n동시성(`Concurrency`)과 병렬성(`Parallelism`)은 다중 작업을 처리하는 방식에서 차이가 있다.\n- 동시성(`Concurrency`): 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 CPU가 시분할 방식으로 실행한다.\n- 병렬성(`Parallelism`): 여러 작업이 물리적으로 동시에 실행됩니다. 멀티코어 CPU에서 서로 다른 코어가 각각의 작업을 실행한다.\n\n## Thread-Safe하다는 것의 의미\n`Thread-Safe`는 다중 스레드 환경에서 동시 접근이 발생해도 데이터의 일관성을 유지하고 예측 가능한 결과를 보장하는 것을 의미한다.\n\n## Thread-Safe를 구현하는 방법\n\n다음은 자바에서 `Thread-Safe`를 구현하는 방법들을 정리한다.\n### Mutual Exclusion (상호 배제)\n\n`synchronized` 키워드를 사용하여 한 번에 하나의 스레드만 특정 코드 블록에 접근하도록 하여 제한하는 방식이다.\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n```\n\n### 불변 객체 사용\n\n객체의 상태를 변경하지 않음으로써 스레드 간의 충돌을 방지하여 동기화가 필요성을 소거하는 방식이다.\n\n```java\npublic class ImmutableCounter {\n    private final int count;\n\n    public ImmutableCounter(int count) {\n        this.count = count;\n    }\n\n    public ImmutableCounter increment() {\n        return new ImmutableCounter(this.count + 1);\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n### Thread-Local Storage\n\n`ThreadLocal` 클래스 사용해서 각 스레드가 고유한 메모리를 할당하여 독립적인 데이터를 가질 수 있도록 설정하는 방식이다.\n\n```java\npublic class ThreadLocalExample {\n    private static ThreadLocal<Integer> threadLocalCount = ThreadLocal.withInitial(() -> 0);\n\n    public void increment() {\n        threadLocalCount.set(threadLocalCount.get() + 1);\n    }\n\n    public int getCount() {\n        return threadLocalCount.get();\n    }\n}\n\n```\n\n### Concurrent 패키지 사용\n`java.util.concurrent` 패키지에서 제공하는 `Thread-Safe` 자료구조와 API 사용하는 방식으로 `ConcurrentHashMap`와 `CopyOnWriteArrayList`가 주로 사용된다.\n\n### Lock-Free Programming\n\n`AtomicInteger` 같은 CAS(Compare-And-Swap) 알고리즘을 사용하여 스레드 경합을 줄이고 성능을 개선하는 방식이다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Thread-Safe 구현에서의 고려 사항\n\n- 성능 문제\n  - `Thread-Safe`를 보장하는 방식은 대개 비용이 든다. 예를들어, `synchronized` 블록은 락을 사용하는데 이때 경합(Contension) 발생 시 성능 저하를 초래한다.\n- 데드락(`Deadlock`)\n  - 두 개 이상의 스레드가 서로의 락을 기다리면서 무한 대기 상태에 빠질 위험이 있다.\n- 락 경합 문제\n  - 여러 스레드가 동시에 동일한 리소스에 접근하려고 시도하면 경합으로 인해 처리 속도 저하의 원인이 된다.\n- 비효율적 동기화\n  - 불필요하게 동기화가 과도하게 사용되면 작업 처리 속도가 크게 떨어질 수 있다.\n\n### Thread-Safe하지 않은 경우 야기되는 문제\n두 개 이상의 스레드가 동시에 동일한 데이터에 접근 및 수정하여 일관되지 않은 결과를 초래하는 데이터 레이스(Data Race)현상을 야기한다.\n\n```java\npublic class NotThreadSafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// 여러 스레드에서 increment() 호출 시\n// count 값이 의도한 값보다 작게 나올 가능성.\n```\n\n### Thread-Safe를 구현하는 가장 성능이 좋은 방법\n동기화 비용을 줄이기 위해 CAS 알고리즘 기반의 Atomic 클래스를 사용하는 것이 일반적으로 더 효율적이다. 읽기 작업이 많은 경우, CopyOnWriteArrayList와 같은 데이터 구조 사용하면 된다.\n\n## 가시성 문제와 원자성 문제\n\n### 가시성 문제\n가시성 문제는 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이지 않는 현상을 의미한다.\n보통 가시성 문제의 원인은 다음과 같다.\n- 각 스레드는 메인 메모리 대신 CPU 캐시에 데이터를 저장하고 읽음으로 인해 메모리 불일치 발생한다.\n- 코드 실행 순서가 재배열되어 예상과 다른 동작한다.\n- 데이터의 일관성을 보장하는 메모리 배리어가 없어 업데이트가 다른 스레드에 전파되지 않음로 인해 발생한다.\n\n예를들면 아래 코드에서 `stop = true`로 값을 변경해도, 다른 스레드에서 `stop`의 변경 사항을 보지 못해 무한 루프가 발생할 수 있다.\n```java\npublic class VisibilityExample {\n    private static boolean stop = false;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            while (!stop) {\n                // 작업 수행\n            }\n            System.out.println(\"Stopped!\");\n        });\n        thread.start();\n\n        // stop 값을 변경\n        stop = true;\n    }\n}\n```\n\n#### 원자성 문제\n원자성 문제는 작업이 중간에 끼어들기 없이 완료되지 않는 현상을 의미한다.\n주로 특정 작업 단위가 나뉘어 실행될 경우, 다른 스레드가 작업 중간에 간섭하여 데이터 불일치 발생하게 된다.\n\n아래 코드는 count++는 Read, Modify, Write 세 단계로 나뉘어 실행되는데 이때 다른 스레드가 중간에 간섭 가능해서 count 값이 예상보다 작을 수 있다.\n\n```java\npublic class AtomicityExample {\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Count: \" + count); // 기대값: 2000, 실제값: 불확실\n    }\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            count++; // Read-Modify-Write\n        }\n    }\n}\n```\n\n### 자바의 동시성 이슈 해결 방법\n이러한 자바의 동시성 이슈를 해결하기 위해 다음과 같은 방법이 있다.\n- 변수의 변경 사항을 메인 메모리에 즉시 반영시켜 가시성을 보장하는 `volatile` 키워드를 사용한다.\n- 메모리의 일관성(원자성)을 보장하는 `synchronized` 키워드를 사용한다\n- `AtomicInteger` 클래스를 사용해 `CAS(Compare-And-Swap)` 알고리즘 기반으로 원자성 보장하는 방식이 주가된다.\n- Lock 객체를 사용하여 `ReentrantLock` 사용한다.\n\n\n### volatile 키워드\nCPU 캐시가 아닌 메인 메모리에서 값을 읽고 씀으로 변수의 값을 모든 스레드에서 즉시 읽을 수 있도록하여 컴파일러와 CPU의 재정렬 방지를 보장한다. 대신 원자성을 보장하지 않는다는 단점이 있다.\n\n```java\npublic class VolatileExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false; // 다른 스레드에서도 즉시 반영\n    }\n\n    public void doWork() {\n        while (running) {\n            // 작업 실행\n        }\n    }\n}\n```\n\n## synchronized 키워드\n\nsynchronized는 동기화를 통해 한 번에 하나의 스레드만 특정 코드 블록 또는 메서드에 접근할 수 있도록 제한하여 스레드 간 상호 배제(Mutual Exclusion)와 가시성(Visibility)을 보장하는 키워드다.\n\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n### synchronized의 내부 동작 원리\n`synchronized`는 JVM의 모니터 락(Monitor Lock)을 기반으로 바이트코드 레벨에서 동작한다.\n`monitorenter`로 락을 획득하거나 `monitorexit`으로 락을 해제 할 수 있고, 이때 객체 헤더(Object Header)에 있는 Monitor 필드에 락 상태가 기록된다.\n\n\n```java\npublic void synchronizedBlockExample() {\n    synchronized (this) {\n        count++;\n    }\n}\n\n//0: aload_0\n//1: dup\n//2: monitorenter // 락 획득\n//3: aload_0\n//4: dup\n//5: getfield \n// #2 // count 읽기\n//8: iconst_1\n//9: iadd\n//10: putfield \n//#2 // count 쓰기 \n//13: monitorexit // 락 해제 \n//14: return\n```\n\n### synchronized의 단점\n물론 이렇게 synchronized을 사용함으로써 단점도 존재한다.\n- 성능 저하\n  - 락 경쟁이 발생할 경우 스레드가 대기 상태에 머물러 성능 저하 발생한다.\n- 데드락(Deadlock)\n  - 여러 스레드가 서로의 락을 기다리며 무한 대기 상태가 발생한다.\n- Fine-Grained Locking 부족\n  - 동기화 범위가 크면, 불필요한 락 경쟁이 발생한다.\n\n ```java\n public class DeadlockExample {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            synchronized (lock2) {\n                System.out.println(\"Method1\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            synchronized (lock1) {\n                System.out.println(\"Method2\");\n            }\n        }\n    }\n}\n```\n\n\n## Atomic\nAtomic은 작업 중간에 다른 스레드가 개입할 수 없고, 작업이 완전히 수행되거나 아예 수행되지 않는 상태를 보장되어 분할되지 않는 작업 단위를 의미한다.\n이 개념의 핵심은 원자성을 보장하여 작업이 중간에 끼어든다거나 일관성이 침해되는 것을 방지하는 것이다.\n- **Atomic 타입**: `AtomicInteger`, `AtomicLong`, `AtomicReference` 등이 있음.\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 연산\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### Java에서 원자성을 보장하는 방법\n\n#### synchronized 키워드: 동기화 블록을 사용하여 작업 단위를 원자적으로 처리.\n```java\npublic class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++; // synchronized로 원자성 보장\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n#### Atomic 클래스 사용해 CAS(Compare-And-Swap) 알고리즘을 기반으로 성능과 원자성을 모두 보장하는 방법.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet(); // 원자적 증가\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n\n```\n\n#### 불변 객체(Immutable Object)\n\nString, Integer 같은 클래스는 불변 객체로 설계되어 Thread-Safe하다.\n\n#### Lock-Free 알고리즘\nCAS 알고리즘을 직접 구현하거나, Atomic 클래스를 통해 활용하여 중복 계산이나 경합 없이 작업을 처리하는 방식이다.\n\n## CAS(Compare-And-Swap) 알고리즘\n\nCAS(비교 및 교환)는 Lock-Free 동기화 기법으로, 데이터를 직접 락 없이 원자적으로 작업을 수행한다.\n동작 원리는 현재 메모리 값을 읽어서 예상 값과 현재 메모리 값을 비교하고 예상 값과 일치하면 새로운 값으로 변경, 그렇지 않으면 재시도하는 방식으로 동작하는 알고리즘이다.\n이로 인해 락을 사용하지 않아 스레드 경합이 줄어들어 성능이 향상되는 효과를 얻을 수 있다.\n\n하지만 단점도 존재한다.\n예상 값이 변경되었다가 다시 원래 값으로 돌아온 경우, CAS는 이를 감지하지 못하는 ABA문제가 발생할 수 있다.\n이를 해결하기 위해 AtomicStampedReference와 같은 스탬프(버전) 기반의 데이터 구조를 사용하면 된다.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CASExample {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        while (true) {\n            int current = count.get();\n            int next = current + 1;\n            if (count.compareAndSet(current, next)) {\n                break;\n            }\n        }\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n```\n\n### ABA 문제\nABA 문제는 CAS(Compare-And-Swap) 알고리즘에서 발생하는 문제로, 메모리의 값이 변경되었다가 다시 원래 값으로 돌아왔을 때, CAS는 이를 감지하지 못해 값이 변경되지 않은 것으로 잘못 판단하는 현상이다.\n예를 들어, 값이 A → B → A로 변경되었더라도 CAS는 단순히 값이 A인지 여부만 확인하므로 중간 변경을 인식하지 못한다.\n\n### ABA 문제 해결 방법\n그럼 CAS가 더 효율적이라 사용하고 싶은데 ABA 문제가 발생한다고 하면 도대체 어떻게 사용을 하라는 걸까?\n당연히 그런 해결책도 존재했다.\n\n#### AtomicStampedReference\n`AtomicStampedReference`와 같은 버전 성질의 데이터 구조를 사용하는 것이다.\n`AtomicStampedReference`는 값과 함께 버전 정보(Stamp)를 저장하여 값이 중간에 변경되었는지 확인한다.\n내부 동작 과정은 값과 스탬프(버전)를 함께 저장하고, CAS 비교 시, 값뿐만 아니라 스탬프도 비교해서 값은 동일하더라도 스탬프가 다르면 중간 변경이 있었음을 탐지하는 방법으로 ABA문제를 해결할 수 있다.\n\n```java\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class ABAExample {\nprivate static AtomicStampedReference<Integer> atomicStampedRef =\nnew AtomicStampedReference<>(100, 0); // 초기 값 100, 초기 스탬프 0\n\n    public static void main(String[] args) {\n        int initialStamp = atomicStampedRef.getStamp(); // 현재 스탬프\n        Integer initialValue = atomicStampedRef.getReference(); // 현재 값\n\n        // 스레드 1: 값 변경 (100 -> 200 -> 100)\n        new Thread(() -> {\n            atomicStampedRef.compareAndSet(100, 200, initialStamp, initialStamp + 1); // 스탬프 증가\n            atomicStampedRef.compareAndSet(200, 100, initialStamp + 1, initialStamp + 2); // 다시 100으로 변경\n        }).start();\n\n        // 스레드 2: 값과 스탬프 확인 후 CAS 시도\n        new Thread(() -> {\n            try {\n                Thread.sleep(500); // 스레드 1이 변경하는 동안 대기\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            boolean success = atomicStampedRef.compareAndSet(\n                100, 300, initialStamp, initialStamp + 1 // 초기 스탬프를 사용\n            );\n\n            System.out.println(\"Update Success: \" + success); // false: 스탬프가 변경됨\n        }).start();\n    }\n}\n```\n"},{"excerpt":"프로세스와 스레드 이 글에서는 자바의 스레드()를 이해하기에 앞서 운영체제를 공부하게 되면 접하게 되는 프로세스와 스레드를 알아간다.\n간단히 설명을 달아보면 프로세스는 운영체제로부터 필요한 자원을 할당받은 작업의 단위로 보면 되고, 스레드는 이러한 프로세스의 자원을 활용해 실제 작업을 수행하는 단위라고 알고 가면 된다. 프로세스 프로세스에 이해하기에 앞서…","fields":{"slug":"/java-thread/"},"frontmatter":{"date":"November 14, 2024","title":"프로세스(Process)와 스레드(Thread)","tags":["Java"]},"rawMarkdownBody":"\n# 프로세스와 스레드\n\n<hr>\n\n이 글에서는 자바의 스레드(`Thread`)를 이해하기에 앞서 운영체제를 공부하게 되면 접하게 되는 프로세스와 스레드를 알아간다.\n간단히 설명을 달아보면 프로세스는 운영체제로부터 필요한 자원을 할당받은 작업의 단위로 보면 되고, 스레드는 이러한 프로세스의 자원을 활용해 실제 작업을 수행하는 단위라고 알고 가면 된다.\n\n## 프로세스\n프로세스에 이해하기에 앞서 프로세스와 프로그램의 차이를 명확히 짚어볼 필요가 있다.\n프로그램은 컴퓨터에서 실행 가능한 파일을 의미한다.\n하지만 이 파일이 아직 실행되지 않은 상태라면, 이를 정적 프로그램(`Static Program`) 또는 줄여서 프로그램(`Program`)이라고 부른다.\n이를 다르게 해석하면 자바같은 프로그래밍 언어로 작성된 코드의 집합이라고 볼 수 있다.\n그리고 프로세스란 프로그램이 실행된 상태를 말한다.\n즉, 정적인 프로그램이 동적으로 변하여 실행 중인 상태를 나타내는 개념이다.\n프로그램은 코드의 집합이고, 프로세스는 그 코드를 실행한 결과라고 이해하면 된다.\n\n> 모든 프로그램이 실행되려면 운영체제가 메모리 공간을 할당해 주어야 한다.\n> 프로그램을 실행하는 순간, 파일은 컴퓨터의 메모리에 올라가고, 운영체제로부터 시스템 자원(CPU 등)을 할당받아 프로그램 코드가 실행된다.\n> 이를 통해 사용자는 서비스를 이용할 수 있다.\n> 즉, 프로그램 → 프로세스의 과정을 거치게 된다.\n\n## 스레드\n\n과거에는 프로그램을 실행할 때 하나의 프로세스만을 사용하여 작업을 처리했지만, 기술이 발전하고 프로그램이 복잡해지면서 단일 프로세스로는 멀티태스킹과 자원 효율성을 충족하기 어려운 한계가 있었다.\n동일한 프로그램을 여러 프로세스로 실행하면 각 프로세스가 독립적인 메모리를 점유해 자원이 낭비되었고, 성능 저하를 초래했다.\n또한, 프로세스 생성과 전환에는 높은 오버헤드가 발생해 실시간 처리가 어려웠다.\n이러한 문제를 해결하기 위해 스레드라는 개념이 등장하게 됐다.\n\n### 스레드 개념\n\n스레드는 하나의 프로세스 내에서 동시에 실행되는 작업 흐름의 단위를 의미한다.\n설명을 돕자면, 브라우저를 실행하면 하나의 프로세스가 생성된다.\n이때, 유튜브를 재생하면서 웹 서핑을 하는 등의 작업을 동시에 할 수 있다.\n이처럼 하나의 프로세스 내부에서 여러 작업이 동시에 진행될 수 있는 이유는 바로 스레드 덕분이다.\n설명을 덧붙이자면 이러한 스레드를 다중으로 실행하는 경우를 멀티스레드라고 한다.\n\n### 스레드와 프로세스의 관계\n\n일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고,\n하나의 프로세스는 반드시 하나 이상의 스레드를 포함한다.\n즉, 프로세스를 생성하면 기본적으로 하나의 **메인 스레드(main thread)**가 생성된다.\n\n"},{"excerpt":"자바에서는 컬렉션 프레임워크(Java Collection Framework)을 제공한다. 이는 자바 프로그래밍을 하면서 없어서는 안되는 필수적인 요소이다.\n이 글에서는 자바의 컬렉션 프레임워크에 대해 알아본다. 자바 컬렉션 프레임워크 자바 컬렉션 프레임워크에서 컬렉션()이란 무엇인지 부터 알아보자.\n컬렉션은 다수의 요소를 하나의 그룹으로 묶어 효율적으로 …","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"date":"November 14, 2024","title":"자바 컬렉션 프레임워크(Collection Framework)","tags":["Java"]},"rawMarkdownBody":"\n자바에서는 컬렉션 프레임워크(Java Collection Framework)을 제공한다. 이는 자바 프로그래밍을 하면서 없어서는 안되는 필수적인 요소이다.\n이 글에서는 자바의 컬렉션 프레임워크에 대해 알아본다.\n\n# 자바 컬렉션 프레임워크\n\n<hr>\n\n자바 컬렉션 프레임워크에서 컬렉션(`Collection`)이란 무엇인지 부터 알아보자.\n컬렉션은 다수의 요소를 하나의 그룹으로 묶어 효율적으로 저장하고 관리할 수 있는 기능을 제공하는 일종의 **컨테이너(`Container`)**라고 이해할 수 있다.\n그렇다면 컬렉션 프레임워크를 사용하면 어떤 이점이 있는지 살펴보자.\n\n## 컬렉션 프레임워크의 장점\n\n컬렉션 프레임워크는 아래와 같은 장점을 제공한다.\n\n\n- 가변적인 저장 공간을 제공하여 고정된 크기의 배열보다 유연하다.\n- 컬렉션 프레임워크는 인터페이스와 다형성을 이용한 객체지향적 설계를 기반으로 다양한 클래스에서 일관된 방식으로 데이터를 다룰 수 있다.\n- 다양한 자료구조와 최적화된 효율적인 알고리즘이 구현된 채로 제공되어 직접 작성할 필요가 없다.\n\n> 자바의 컬렉션 프레임워크는 객체(`Object`)만 저장할 수 있다.\n> 원시 타입(`int`, `double`, etc.)은 컬렉션에 직접 저장할 수 없으며, 이를 **래퍼 클래스(`Wrapper Class`)로 변환하는 박싱(Boxing) 과정**을 거쳐야 한다.\n> 컬렉션은 객체의 참조값(주소값)을 저장하므로, 특별한 값인 `null`도 저장이 가능하다.\n> `null`을 저장한다는 것은 아무 객체도 참조하지 않는다는 의미이다.\n\n# 컬렉션 프레임워크의 계층구조\n\n<hr>\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n    Collection --> List\n    Collection --> Queue\n    Collection --> Set\n    List --> ArrayList\n    List --> LinkedList\n    List --> Vector\n    List --> Stack\n    Queue --> PriorityQueue\n    Queue --> Deque\n    Deque --> LinkedList\n    Deque --> ArrayDeque\n    Set --> HashSet\n    Set --> LinkedHashSet\n    Set --> SortedSet\n    SortedSet --> TreeSet\n    Map --> HashMap\n    Map --> HashTable\n    Map --> SortedMap\n    SortedMap --> TreeMap\n</div>\n\n컬렉션 프레임 워크는 크게 `Collection` 인터페이스와 `Map` 인터페이스로 나뉜다.\n- `Collection` 인터페이스는 `List`, `Set`, `Queue`의 공통 부분을 정의하고 있다.\n- `Map` 인터페이스는 키(`Key`)-값(`Value`) 쌍을 다루며, `Collection` 인터페이스와는 별도로 설계되었다.\n\n\n> 대부분의 컬렉션 클래스는 List, Set, Map 중 하나의 인터페이스를 구현하며, 구현한 인터페이스의 이름이 클래스 이름에 포함된다.\n> (e.g., ArrayList, HashSet, HashMap, etc.)<br>\n> 하지만 Vector, Stack, Hashtable과 같은 클래스는 컬렉션 프레임워크가 도입되기 이전에 만들어진 클래스들로, 컬렉션 프레임워크의 명명 규칙을 따르지 않는다.\n> 이들 클래스는 호환성을 위해 남아 있는 것으로, 가급적 사용하지 않는 것이 권장된다.\n\n## Iterable 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n</div>\n\n`Iterable` 인터페이스는 자바 컬렉션 인터페이스 계층 구조에서 가장 최상위에 위치한 인터페이스이다.\n컬렉션을 다룰 때 자료를 순회하기 위해 사용하는 이터레이터(`iterator`) 객체를 관리하는 역할을 한다고 볼 수 있다.\n\n- 컬렉션의 최상위 인터페이스로 모든 컬렉션 클래스가 Iterable 인터페이스를 상속받아 구현된다.\n- 컬렉션을 순회하는 데 필요한 이터레이터 객체를 반환하는 메서드를 제공한다\n\n### 메서드\n\n- `default void forEach(Consumer<? super T> action)`: 함수형 프로그래밍을 지원하는 메서드로, 주어진 람다식을 사용해 컬렉션 요소를 순회할 수 있다.\n- `Iterator<T> iterator()`: 컬렉션에 저장된 요소들을 순회할 수 있는 이터레이터 객체를 반환한다.\n- `default Spliterator<T> spliterator()`: 병렬 처리를 위한 파이프라이닝 관련 메서드로, 데이터를 분할하여 처리하는 데 사용된다.\n\n> `Map`은 `Iterable` 인터페이스를 상속받지 않으므로 `iterator()`와 `spliterator()` 메서드가 구현되어 있지 않다.\n> 따라서 `Map` 컬렉션을 직접 순회할 수 없으며, 다음과 같은 간접적인 방법을 사용해야 한다\n> - 키(`key`) 또는 값(`value`)를 별도의 컬렉션으로 변환하여 순회하는 방법\n    >   - e.g., `map.keySet()`, `map.values()`\n> - `Stream` API를 사용해 순회하는 방법\n    >   - e.g., `map.entrySet().stream()`\n\n## Collection 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Iterable --> Collection\n    Collection --> List\n    Collection --> Queue\n    Collection --> Set\n</div>\n\nCollection 인터페이스는 `List`, `Set`, `Queue` 인터페이스의 공통된 기능을 정의한 최상위 컬렉션 타입이다.\n\n- 다형성을 지원하여 업캐스팅을 사용해 여러 컬렉션 타입(`List`, `Set`, `Queue`)을 동일한 방식으로 처리할 수 있다.\n- 공통 작업(삽입, 탐색, 삭제, 변환, etc.) 을 수행하는 데 필요한 메서드를 정의한다.\n\n### 메소드\n\n- `boolean add(Object o)`: 지정된 객체를 컬렉션에 추가한다.\n- `boolean addAll(Collection c)`: 지정된 컬렉션에 포함된 객체들을 컬렉션에 추가한다.\n- `boolean contains(Object o)`: 지정된 객체가 컬렉션에 포함되어 있는지 확인한다.\n- `boolean containsAll(Collection c)`: 지정된 컬렉션의 모든 객체가 현재 컬렉션에 포함되어 있는지 확인한다.\n- `boolean remove(Object o)`: 지정된 객체를 컬렉션에서 삭제한다.\n- `boolean removeAll(Collection c)`: 지정된 컬렉션에 포함된 객체들을 모두 삭제한다.\n- `boolean retainAll(Collection c)`: 지정된 컬렉션에 포함된 객체만 남기고 나머지는 삭제한다. (교집합 연산과 유사)\n- `void clear()`: 컬렉션의 모든 객체를 삭제한다.\n- `boolean isEmpty()`: 컬렉션이 비어 있는지 확인한다.\n- `int size()`: 컬렉션에 저장된 객체의 개수를 반환한다.\n- `boolean equals(Object o)`: 두 컬렉션이 동일한지 비교한다.\n- `int hashCode()`: 컬렉션의 해시 코드를 반환한다.\n- `Iterator iterator()`: 컬렉션을 순회할 수 있는 이터레이터를 반환한다.\n- `Object[] toArray()`: 컬렉션의 객체를 객체 배열(`Object[]`)로 반환한다.\n- `<T> T[] toArray(T[] a)`: 지정된 배열에 컬렉션의 객체를 저장하여 반환한다.\n- `default Stream stream()`: 컬렉션 데이터를 스트림으로 반환한다.\n- `default Stream parallelStream()`: 병렬 스트림 반환한다.\n- `default boolean removeIf(Predicate<? super E> filter)`: 조건에 맞는 요소를 컬렉션에서 제거한다.\n- `default void forEach(Consumer<? super T> action)`: 람다식을 이용한 요소 순회한다.\n\n```java\nCollection<Number> col1 = new ArrayList<>();\ncol1.add(1);\n\nCollection<Number> col2 = new HashSet<>();\ncol1.add(1);\n\nCollection<Number> col3 = new LinkedList<>();\ncol1.add(1);\n```\n\n> `Collection` 인터페이스를 보면 요소(객체)에 대한 추가, 삭제, 탐색은 가능하지만, 데이터를 직접 **조회(get)**하는 메서드는 포함되어 있지 않다.\n> 이는 각 컬렉션이 사용하는 자료 구조가 다르기 때문에, 최상위 타입에서 통일된 방식으로 데이터를 조회하기가 어렵기 때문이다.\n\n## List 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    List --> ArrayList\n    List --> LinkedList\n    List --> Vector\n    List --> Stack\n</div>\n\n- 요소가 추가된 순서대로 저장된다.\n- 동일한 값을 가진 요소를 여러 번 저장할 수 있다.\n- 배열과 달리 크기가 고정되지 않으며 데이터 양에 따라 동적으로 늘어나거나 줄어든다.\n- 요소 간 빈 공간을 허용하지 않으므로 삽입/삭제 시 배열 이동이 발생한다.\n- 요소 사이에 빈공간을 허용하지 않아 삽입/삭제 할때마다 배열 이동이 일어난다\n\n### 메서드\n\n- `void add(int index, Object element)`: 지정된 위치(`index`)에 객체(`element`)를 추가한다.\n- `boolean addAll(int index, Collection c)`: 지정된 위치에 컬렉션의 모든 객체를 추가한다.\n- `Object remove(int index)`: 지정된 위치의 객체를 삭제하고 반환한다.\n- `Object get(int index)`: 지정된 위치의 객체를 반환한다.\n- `Object set(int index, Object element)`: 지정된 위치의 객체를 새로운 객체로 대체한다.\n- `int indexOf(Object o)`: 지정된 객체의 첫 번째 위치(`index`)를 반환한다.\n- `int lastIndexOf(Object o)`: 지정된 객체의 마지막 위치를 반환한다.\n- `List subList(int fromIndex, int toIndex)`: 지정된 범위의 객체들을 포함하는 서브 리스트를 반환한다.\n- `void sort(Comparator c)`: 지정된 비교자를 사용하여 리스트를 정렬한다.\n- `ListIterator listIterator()`: 리스트를 순회할 수 있는 `ListIterator` 객체를 반환한다.\n- `ListIterator listIterator(int index)`: 지정된 위치부터 순회할 수 있는 `ListIterator`를 반환한다.\n\n### ArrayList\n\n- 배열 기반 리스트\n    - 내부적으로 배열을 사용하여 데이터를 저장한다.\n- 장점\n    - 저장 순서가 유지된다.\n    - 중복 요소를 허용한다.\n    - 데이터 양에 따라 용량(`capacity`)이 동적으로 조정된다.\n    - **순차적 데이터 접근에 강점이 있어 조회 속도가 빠르다.**\n- 단점\n    - 삽입/삭제 속도가 느리다. (단, 맨 끝에 추가하거나 삭제하는 경우는 빠르다.)\n\n```java\nList<String> arrayList = new ArrayList<>();\n\narrayList.add(\"a\");\narrayList.add(\"b\");\narrayList.add(\"c\");\n\narrayList.get(0);// \"a\"\n```\n\n### LinkedList\n\n- 노드 기반 리스트\n    - 배열이 아닌 노드를 연결하여 데이터를 저장한다.\n- 장점\n    - **중간 위치에 데이터를 삽입하거나 삭제할 때 성능이 우수하다.**\n    - `LinkedList`는 양방향 연결 리스트(`Doubly LinkedList`)로 구성되어 있어 양쪽에서 접근이 가능하다.\n- 단점\n    - 임의 위치의 요소에 대한 접근 속도가 느리다.\n- 다목적 활용 가능\n    - `LinkedList`는 리스트 외에도 자료구조(스택, 큐, 덱, 트리, etc.)를 구현하는 데 사용된다.\n\n```java\nList<String> linkedList = new LinkedList<>();\n\nlinkedList.add(\"a\");\nlinkedList.add(\"b\");\nlinkedList.add(\"c\");\n\nlinkedList.get(0); // \"a\"\n```\n\n### Vector 클래스\n\n- `ArrayList`의 레거시 버전으로 내부 구현이 거의 동일하다.\n- 차이점\n    - 모든 메서드가 `synchronized`로 처리되어 `Thread-Safe`하다.\n- 현재는 사용하지 않는 것을 권장\n    - 구버전 자바와의 호환성을 위해 남겨두었으나, 잘 사용되지 않는다.\n\n> 동기화가 필요하면 `Collections.synchronizedList()`를 사용해 `ArrayList`를 동기화 처리하는 것이 좋다.\n\n```java\nList<String> vector = new Vector<>();\n\nvector.add(\"a\");\nvector.add(\"b\");\nvector.add(\"c\");\n\nvector.get(0); // \"a\"\n```\n\n### Stack 클래스\n\n- 후입선출 (`LIFO`) 자료구조로, 마지막에 추가된 요소가 가장 먼저 제거된다.\n- 기본 연산\n    - `push`: 데이터를 추가.\n    - `pop`: 데이터를 제거하고 반환.\n- 문제점\n    - `Stack`은 `Vector`를 상속하고 있어 레거시 문제점이 많아 사용이 권장되지 않는다.\n      <br> 대신 **ArrayDeque**를 사용하는 것이 좋다.\n\n```java\nStack<String> stack = new Stack<>();\n\nstack.push(\"a\");\nstack.push(\"b\");\n\nstack.pop(); // \"a\"\nstack.pop(); // \"b\"\n```\n\n## Queue 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Queue --> LinkedList\n    Queue --> PriorityQueue\n    Queue --> ArrayDeque\n</div>\n\n`Queue` 인터페이스는 선입선출(`FIFO`: `First-In-First-Out`) 구조를 기반으로 한 자료구조를 구현하는 데 사용된다.\n첫 번째로 들어온 데이터가 가장 먼저 나가는 방식으로 동작하며, 자바에서는 `Queue`가 인터페이스로 제공되므로 구현체를 필요에 따라 선택해 사용할 수 있다.\n\n- 선입선출 `FIFO(First-In-First-Out)` 구조\n- 처음 들어온 원소가 가장 먼저 나간다\n- 자바에서는 `Queue` 는 인터페이스이고 필요에 따라 큐 컬렉션을 골라 사용할 수 있다.\n\n### 메서드\n\n- `boolean add(Object o)`: 지정된 객체를 큐에 추가. 저장 공간 부족 시 `IllegalStateException`을 발생시킨다.\n- `boolean offer(Object o)`: 지정된 객체를 큐에 추가. 저장 공간 부족 시 `false`를 반환한다.\n- `Object remove()`: 큐의 첫 번째 객체를 삭제 후 반환. 비어 있을 경우 `NoSuchElementException`을 발생시킨다.\n- `Object poll()`: 큐의 첫 번째 객체를 삭제 후 반환. 비어 있을 경우 `null`를 반환.\n- `Object element()`: 큐의 첫 번째 객체를 삭제 없이 반환. 비어 있을 경우 `NoSuchElementException`을 발생시킨다.\n- `Object peek()`: 큐의 첫 번째 객체를 삭제 없이 반환. 비어 있을 경우 `null`를 반환한다.\n\n### PriorityQueue 클래스\n\n우선순위 큐는 일반적인 큐와 달리 원소의 우선순위에 따라 정렬되고 처리되는 큐다.\n\n- 우선순위 기반 동작\n    - 원소는 우선순위(`priority`)가 높은 순으로 처리된다.\n      <br> e.g., 우선순위가 중요한 작업(네트워크 제어, 작업 스케줄링, etc.)에서 사용.\n- 정렬 기준\n    - 저장할 객체는 반드시 `Comparable` 인터페이스를 구현하거나, `Comparator`를 사용해 정렬 기준을 명시해야 한다.\n- 내부 구현\n  <br> 배열을 사용하며, 각 요소는 힙(`heap`) 자료구조로 관리된다.\n    - 힙은 이진 트리의 한 형태로, 루트 노드에 가장 우선순위가 높은 값이 위치한다.\n    - 이를 통해 최댓값이나 최솟값을 빠르게 찾을 수 있다.\n- 제약사항\n    - `null` 값은 저장할 수 없다.\n\n> 힙은 이진 트리의 한 종류로 우선순위가 가장 높은 자료를 루트 노드로 갱신한다는 점으로, 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있다는 특징이 있다.\n\n```java\nimport java.util.Queue;\n\n// 우선순위 큐에 저장할 객체는 필수적으로 Comparable를 구현\nclass Person implements Comparable<Student> {\n  String name; // 원소 값\n  int priority; // 우선순위 값\n\n  public Person(String name, int priority) {\n    this.name = name;\n    this.priority = priority;\n  }\n\n  @Override\n  public int compareTo(Person other) {\n    // Student의 priority 필드값을 비교하여 우선순위를 결정하여 정렬\n    return Integer.compare(this.priority, other.priority);\n  }\n\n  @Override\n  public String toString() {\n    return \"Person{name='\" + name + \"', priority=\" + priority + '}';\n  }\n}\n\npublic static void main(String[] args) {\n    Queue<Person> priorityQueue = new PriorityQueue<>();\n\n    priorityQueue.add(new Person(\"John\", 1));\n    priorityQueue.add(new Person(\"Daniel\", 2));\n    priorityQueue.add(new Person(\"Alex\", 5));\n    priorityQueue.add(new Person(\"Adam\", 9));\n  \n    System.out.println(priorityQueue.peek()); // 가장 낮은 우선순위: John\n    while (!priorityQueue.isEmpty()) {\n      System.out.println(priorityQueue.poll()); // 우선순위 순으로 출력\n    }\n}\n```\n\n### Deque 인터페이스\n\nDeque (Double-Ended Queue)**는 양쪽에서 삽입과 삭제가 가능한 큐다\n\n- 스택 및 큐 동작 지원\n    - 큐처럼 사용: FIFO(선입선출) 방식.\n    - 스택처럼 사용: LIFO(후입선출) 방식.\n- 구현체\n    - ArrayDeque\n    - LinkedList\n\n### ArrayDeque 클래스\n\n`ArrayDeque`는 `Deque` 인터페이스의 구현체로, 다음과 같은 특징이 있다\n\n- 빠른 성능\n    - 스택으로 사용할 때 `Stack` 클래스보다 빠르다.\n    - 큐로 사용할 때 `LinkedList` 보다 빠르다.\n- 제약사항\n    - `null` 요소는 저장할 수 없다.\n    - 크기는 동적으로 조정되며, 제한이 없다.\n\n```java\nDeque<String> deque = new ArrayDeque<>();\n\ndeque.offerLast(\"a\"); // [\"a\"]\ndeque.offerFirst(\"b\"); // [\"b\", \"a\"]\ndeque.offerFirst(\"c\"); // [\"c\", \"b\", \"a\"]\n\ndeque.pollFirst(); // \"c\" <- [\"b\", \"a\"]\ndeque.pollLast(); // [\"b\"] -> \"a\" \ndeque.pollLast(); // [] -> \"b\"\n```\n\n### LinkedList 클래스\n\n`LinkedList`는 `List`와 `Queue` 인터페이스를 동시에 구현하며, 다음과 같은 특징이 있다\n\n- 다목적 활용\n    - 리스트, 스택, 큐로 모두 사용할 수 있다.\n- 큐 관련 메서드 지원\n    - 큐의 기본 동작(`offer`, `poll`, `peek`, etc.)을 제공한다.\n\n```java\nQueue<String> linkedList = new LinkedList<>(); // Queue 타입으로 받음\n\nlinkedList.offer(\"a\");\nlinkedList.offer(\"b\");\nlinkedList.offer(\"c\");\n\nlinkedList.poll(); // \"a\" - 선입선출\n\nSystem.out.println(linkedList); // [b, c]\n```\n\n> 큐(`queue`)는 큐는 데이터를 꺼낼 때 항상 첫 번째 요소를 삭제하므로 배열 기반의 `ArrayList`를 사용하면 요소 이동/복사가 발생해 비효율적이다.\n> <br> 따라서 LinkedList를 사용하여 큐를 구현하는 것이 적합하다.\n\n## Set 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Set --> HashSet\n    Set --> LinkedSet\n    Set --> TreeSet\n</div>\n\n`Set` 인터페이스는 데이터의 중복을 허용하지 않으며, 저장된 데이터의 순서를 유지하지 않는 집합 구조를 구현한다.\n\n- 중복 저장 불가\n  <br> 동일한 객체는 한 번만 저장되며, null 값도 최대 하나만 저장 가능하다.\n- 순서 없음\n  <br> 데이터가 저장된 순서를 보장하지 않으므로, 인덱스를 이용한 객체 검색(get(index))은 지원되지 않는다.\n\n\n\n### 메서드\n\n- `boolean add(E e)`: 지정된 객체를 저장. 성공 시 `true`, 중복 객체일 경우 `false`를 반환한다.\n- `boolean contains(Object o)`: 지정된 객체가 저장되어 있는지 확인한다.\n- `Iterator<E> iterator()`: 저장된 객체를 순회할 수 있는 반복자를 반환한다.\n- `boolean isEmpty()`: 컬렉션이 비어 있는지 확인한다.\n- `int size()`: 저장된 객체의 개수를 반환한다.\n- `void clear()`: 모든 객체를 삭제한다.\n- `boolean remove(Object o)`: 지정된 객체를 삭제한다.\n\n### HashSet 클래스\n\n`HashSet`은 배열과 연결 노드의 결합 구조를 사용하는 `Set` 구현체다.\n\n- 빠른 데이터 접근\n  <br> 추가, 삭제, 검색, 접근 속도가 빠르다.\n- 순서 보장 없음\n  <br> 저장된 데이터의 순서는 예측할 수 없다.\n\n```java\nSet<String> hashSet = new HashSet<>();\n\nhashSet.add(\"a\");\nhashSet.add(\"b\");\nhashSet.add(\"c\");\nhashSet.add(\"a\"); // 중복된 요소는 저장되지 않음\n\nSystem.out.println(hashSet.size()); // 3\nSystem.out.println(hashSet); // 출력 순서는 예측할 수 없음 (e.g., [\"b\", \"a\", \"c\"])\n```\n\n### LinkedHashSet 클래스\n\n`LinkedHashSet`은 추가된 순서를 유지하는 `HashSet`이다.\n\n- 순서 유지\n  <br> 데이터가 추가된 순서 또는 가장 최근에 접근된 순서대로 데이터 접근이 가능하다.\n- 중복 제거와 순서 유지\n  <br> 중복을 제거하면서도 데이터의 저장 순서를 유지하고 싶을 때 적합하다.\n\n```java\nSet<String> linkedHashSet = new LinkedHashSet<>();\n\nlinkedHashSet.add(\"a\");\nlinkedHashSet.add(\"b\");\nlinkedHashSet.add(\"c\");\nlinkedHashSet.add(\"a\"); // 중복된 요소는 저장되지 않음\n\nSystem.out.println(linkedHashSet.size()); // 3\nSystem.out.println(linkedHashSet); // [\"a\", \"b\", \"c\"]\n```\n\n### TreeSet 클래스\n\n`TreeSet`은 이진 검색 트리(`Binary Search Tree`) 기반의 `Set` 구현체다.\n\n- 정렬된 데이터 저장\n  <br> 데이터를 저장할 때 자동으로 정렬한다. (기본적으로 오름차순)\n\n- 중복 제거와 정렬\n  <br> 중복 없는 정렬된 데이터가 필요할 때 적합하다.\n\n- 높은 검색 성능\n  <br> 정렬된 구조로 인해 검색 및 범위 검색에서 높은 성능을 제공한다.\n\n```java\nSet<String> treeSet = new TreeSet<>();\n\ntreeSet.add(\"a\");\ntreeSet.add(\"d\");\ntreeSet.add(\"b\");\ntreeSet.add(\"c\");\ntreeSet.add(\"e\");\n\nSystem.out.println(treeSet); // [a, b, c, d, e]\n```\n\n### EnumSet 추상 클래스\n\n`EnumSet`은 `Enum` 타입과 함께 사용되는 `Set` 구현체다.\n\n- 효율성\n  <br> 산술 비트 연산을 기반으로 구현되어 `HashSet` 보다 빠르고 적은 메모리를 사용한다.\n- 제약사항\n    - `Enum` 타입의 값만 저장이 가능하다.\n    - 모든 요소는 동일한 `Enum` 타입에 소속되어야 한다.\n- 내부 구현\n    - 요소가 64개 이하인 경우 `RegularEnumSet`을 사용한다.\n    - 64개 초과 시 `JumboEnumSet`을 사용한다.\n\n```java\nenum Alphabet {\n  A, B, C, D, E, F\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    EnumSet<Alphabet> enumSet = EnumSet.allOf(Alphabet.class);\n\n    System.out.println(enumSet.size()); // 6\n    System.out.println(enumSet); // [A, B, C, D, E, F]\n  }\n}\n```\n\n## Map 인터페이스\n\n<div class=\"mermaid\"> \n    graph TD;\n    Map --> HashMap\n    Map --> LinkedHashMap\n    Map --> HashTable\n    HashTable --> Properties\n    Map --> SortedMap\n    SortedMap --> TreeMap\n</div>\n\nMap 인터페이스는 데이터를 `Key`와 `Value`의 쌍으로 저장하는 자료구조를 구현한다.\n\n- 키와 값의 유일성\n    - ``Key``는 중복될 수 없으며, 고유해야 한다.\n    - Value는 중복 저장이 가능하다.\n- 키-값 덮어쓰기\n  <br> 동일한 `Key`로 새로운 값을 저장하면, 기존 값은 덮어쓰여 사라진다.\n- 순서 없음\n  <br> 대부분의 `Map` 구현체는 저장 순서를 보장하지 않는다. (예외: `LinkedHashMap`)\n\n### 메서드\n\n- `Object put(Object key, Object value)`: 지정된 `Key`와 `Value`를 맵에 저장. 기존에 동일한 `Key`가 있으면 덮어쓴다.\n- `void putAll(Map t)`: 지정된 `Map`의 모든 데이터를 추가.\n- `Object get(Object key)`: 지정된 `Key`에 해당하는 `Value`를 반환.\n- `boolean containsKey(Object key)`: 지정된 `Key`가 존재하는지 확인.\n- `boolean containsValue(Object value)`: 지정된 `Value`가 존재하는지 확인.\n- `Object remove(Object key)`: 지정된 `Key`에 해당하는 데이터를 삭제.\n- `void clear()`: 모든 데이터를 삭제.\n- `boolean isEmpty()`: 맵이 비어 있는지 확인.\n- `int size()`: 맵에 저장된 `Key-Value` 쌍의 개수를 반환.\n- `Set keySet()`: 맵에 저장된 모든 `Key`를 `Set` 형태로 반환.\n- `Collection values()`: 맵에 저장된 모든 `Value`를 `Collection` 형태로 반환.\n- `Set<Map.Entry<K, V>> entrySet()`: 모든 `Key-Value` 쌍을 `Map.Entry` 객체 형태로 반환.\n\n> `Key`는 중복을 허용하지 않으므로 `Set` 타입으로 반환되고, `Value`는 중복을 허용하므로 `Collection` 타입으로 반환된다.\n\n### Map.Entry 인터페이스\n\n`Map.Entry`는 `Map` 인터페이스 내부의 내부 인터페이스로, `Key-Value` 쌍을 표현한다.\n이 인터페이스를 통해 맵의 각 데이터를 객체지향적으로 관리할 수 있다.\n\n```java\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 1);\nmap.put(\"b\", 2);\nmap.put(\"c\", 3);\n\nSet<Map.Entry<String, Integer>> entrySet = map.entrySet();\n\nfor (Map.Entry<String, Integer> entry : entrySet) {\n    System.out.printf(\"{ %s : %d }\\n\", entry.getKey(), entry.getValue());\n}\n// 출력:\n// { a : 1 }\n// { b : 2 }\n// { c : 3 }\n```\n\n### HashMap 클래스\n\n- 핵심 특징\n    - `HashTable`을 개선한 비동기 `Map`의 구현체다.\n    - 배열과 연결 노드를 결합한 `Hashing` 자료구조로 동작한다.\n    - 순서를 보장하지 않으며, 키와 값 모두 `null` 저장 가능하다.\n- 장점\n    - 빠른 추가, 삭제, 검색 성능을 가지고 있다.\n- 단점\n    - 멀티스레드 환경에서는 동기화가 지원되지 않으므로 `ConcurrentHashMap`의 사용을 권장한다.\n\n```java\nMap<Integer, String> hashMap = new HashMap<>();\n\nhashMap.put(1, \"a\");\nhashMap.put(2, \"b\");\nhashMap.put(3, \"c\");\n\nfor (Integer key : hashMap.keySet()) {\n    System.out.println(key + \" => \" + hashMap.get(key));\n}\n// 출력:\n// 1 => a\n// 3 => c\n// 2 => b\n```\n\n### LinkedHashMap 클래스\n\n- 순서 보장\n    - `HashMap`과 달리, 데이터 입력 순서를 유지한다.\n- 활용 사례\n    - 입력 순서가 중요한 경우 사용한다.\n\n```java\nMap<Integer, String> linkedHashMap = new LinkedHashMap<>();\nlinkedHashMap.put(1, \"a\");\nlinkedHashMap.put(2, \"b\");\nlinkedHashMap.put(3, \"c\");\n\nfor (Integer key : linkedHashMap.keySet()) {\n        System.out.println(key + \" => \" + linkedHashMap.get(key));\n        }\n// 출력:\n// 1 => a\n// 2 => b\n// 3 => c\n```\n\n### TreeMap 클래스\n\n- 이진 검색 트리 기반\n    - 데이터를 자동으로 정렬하여 저장한다.\n    - `Key`를 기준으로 오름차순으로 정렬한다.\n- 장점\n    - 빠른 검색 및 범위 검색이 가능하다.\n- 단점\n    - 삽입 시 정렬 비용으로 인해 성능이 다소 낮다.\n\n```java\nMap<Integer, String> treeMap = new TreeMap<>();\ntreeMap.put(3, \"c\");\ntreeMap.put(1, \"a\");\ntreeMap.put(2, \"b\");\n\nfor (Integer key : treeMap.keySet()) {\n        System.out.println(key + \" => \" + treeMap.get(key));\n        }\n// 출력:\n// 1 => a\n// 2 => b\n// 3 => c\n```\n\n### HashTable 클래스\n\n- 레거시 클래스\n    - 동기화가 기본 지원되지만, `HashMap`에 비해 느리다.\n    - `Key`와 `Value` 모두 `null` 저장이 불가하다.\n\n### Properties 클래스\n\n- 주요 특징\n    - `Key`와 `Value`가 모두 String 타입이다.\n    - 애플리케이션 설정 파일(`.properties`) 관리에 사용한다.\n\n```java\nProperties properties = new Properties();\nproperties.setProperty(\"AppVersion\", \"1.0.0\");\nproperties.setProperty(\"Theme\", \"Github\");\n\nSystem.out.println(properties.getProperty(\"AppVersion\")); // 1.0.0\n```\n\n\n# 컬렉션 프레임워크 선택 시점\n\n<hr>\n\n<div class=\"mermaid\"> \ngraph LR\n    A[ArrayList<br>Vector] -- 추가,삭제기능향상 --> B[LinkedList]\n    A -- 검색 기능 향상 --> C[HaspMap<br>HashTable]\n    A --> D[Stack]\n    B --> E[Queue]\n    B --> C\n    B -- 검색, 정렬 기능 향상 --> F[TreeMap]\n    F --> G[TreeSet]\n    C --> H[Properties]\n    C -- 순서 유지 기능 향상 --> I[LinkedHashMap]\n    C --> J[HashSet]\n    I -- 순서 유지 기능 향상 --> K[LinkedHashSet]\n</div>\n\n아래는 상황별로 적합한 컬렉션 구현체를 정리한 내용이다.\n\n## ArrayList\n\n- 기본 선택\n    - 리스트 자료구조를 사용하는 경우 가장 일반적인 선택이다.\n- 장점\n    - 임의 요소에 대한 빠른 접근성 제공한다.\n    - 순차적인 데이터 추가/삭제가 가장 빠르다.\n- 단점\n    - 중간 요소의 삽입/삭제 성능이 떨어진다.\n\n## LinkedList\n\n- 장점\n    - 중간 요소의 삽입/삭제이 강점이다.\n- 단점\n    - 임의 요소에 대한 접근 성능이 낮다.\n    - 순차 접근이 필요할 때 적합하다.\n\n## HashMap / HashSet\n\n- 장점\n    - 해싱을 이용한 빠른 추가/삭제/검색/접근성이 좋다.\n    - get 메서드의 시간 복잡도는 `O(1)`이다.\n    - 데이터 순서에 상관없는 작업에 적합하다.\n- 단점\n    - 데이터 정렬이 필요할 경우 부적합하다.\n\n## TreeMap / TreeSet\n\n- 사용 시점\n    - 요소를 정렬해야 하는 경우에 사용한다.\n    - 범위 검색이 필요한 경우에 사용한다.\n- 장점\n    - 자동으로 정렬된 상태로 데이터를 저장한다.\n    - 범위 검색에 높은 성능을 제공한다.\n- 단점\n    - 검색 성능이 `HashMap`/`HashSet`보다 낮다.\n\n## LinkedHashMap / LinkedHashSet\n\n- 사용 시점\n    - 저장된 순서를 유지해야 하는 경우에 사용한다.\n- 특징\n    - `HashMap`/`HashSet`과 동일한 성능에 순서 유지 기능이 추가된거다.\n\n## Queue\n\n- 사용 시점\n    - 스택(`LIFO`) 또는 큐(`FIFO`) 자료구조가 필요한 경우에 사용한다.\n- 추천 구현체\n    - ArrayDeque: 빠르고 유연한 동작을 지원한다.\n\n## Stack, Hashtable\n- 사용 지양\n    - 레거시 컬렉션으로, 현재는 `deprecated` 상태이다.\n    - 스택의 경우 `ArrayDeque`를 대체 구현체로 사용하는 것이 권장된다."},{"excerpt":"자바에서 예외처리는 오류를 예측하고 이에 대응하여 프로그램의 안정성을 높일 뿐만 아니라, 상황에 따라서 단순히 발생한 오류를 잡아내는 것을 넘어, 필요에 따라 예외를 발생시키거나 떠넘기고,\n예외를 다른 예외로 감싸 처리하는 등 다양한 방법을 유현하게 활용하여 코드의 가독성과 유지보수성을 높일 수 있다. 이 글에서는 자바의 예외처리 핵심 개념인 와  그리고…","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"date":"November 06, 2024","title":"throw와 throws 그리고 Chained Exception","tags":["Java"]},"rawMarkdownBody":"\n자바에서 예외처리는 오류를 예측하고 이에 대응하여 프로그램의 안정성을 높일 뿐만 아니라, 상황에 따라서 단순히 발생한 오류를 잡아내는 것을 넘어, 필요에 따라 예외를 발생시키거나 떠넘기고,\n예외를 다른 예외로 감싸 처리하는 등 다양한 방법을 유현하게 활용하여 코드의 가독성과 유지보수성을 높일 수 있다.\n\n이 글에서는 자바의 예외처리 핵심 개념인 `throw`와 `throws` 그리고 `Chained Exception`에 대해 알아본다.\n\n# 예외 던지기\n\n<hr>\n\n## 예외 발생시키기\n\n일반적으로 프로그램은 실행 중 예외가 발생하면 시스템이 자동으로 오류를 탐지하고 이를 처리하도록 되어 있다.\n하지만 특정 상황에서는 개발자가 의도적으로 `throw`를 사용해 예외를 발생시키고 `catch`에서 이를 처리하는 경우도 있다.\n\n`throw`는 `new` 연산자로 예외 클래스의 객체를 초기화하여 사용하며, 생성자에 메시지를 전달하면 `catch`에서 `getMessage()` 메서드를 통해 해당 메시지를 출력할 수 있다.\n\n아래 코드에서는 사용자가 음수를 입력한 경우, `IllegalArgumentException` 예외가 발생하도록 설정하였다. `throw` 키워드를 통해 예외를 발생시키고, `catch`에서 이를 받아 오류 메시지를 출력한다.\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Scanner scanner = new Scanner(System.in);\n            System.out.print(\"양수를 입력하세요: \");\n            int number = scanner.nextInt();\n            \n            if (number < 0) {\n                // 사용자가 음수를 입력한 경우, 의도적으로 예외 발생\n                throw new IllegalArgumentException(\"양수만 입력할 수 있습니다.\"); // 예외 메시지를 설정하여 catch 블록으로 전달\n            }\n            \n            System.out.println(\"정상적인 입력을 받았습니다.\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        } finally {\n            System.out.println(\"프로그램이 종료됩니다.\");\n        }\n    }\n}\n```\n\n## 예외 떠넘기기\n\n예외가 발생할 수 있는 코드를 작성할 때는 `try-catch`를 통해 예외를 처리하는 것이 일반적이다.\n하지만 경우에 따라 예외 처리를 호출한 메서드로 넘겨 다른 곳에서 처리하도록 할 수 있다.\n이를 위해 사용하는 키워드다 `throws`다.\n`throws`는 메서들 선언부 끝에 작성되며, 해당 메서드에서 발생할 수 있는 예외를 직접 처리(`catch`)하지 않고 호출한 곳으로 떠넘긴다.\n\n> throw는 예외를 발생시키는, throws는 예외를 메서드에 선언하는 키워드이다.\n\n아래 코드에서는 `method1()`, `method2()`, `method3()` 세 메서드가 각각 예외 처리를 위해 `try-catch`로 감싸져 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        method1();\n        method2();\n        method3();\n    }\n\n    public static void method1() {\n        try {\n            throw new ClassNotFoundException(\"에러 발생: 클래스 찾기 실패\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void method2() {\n        try {\n            throw new ArithmeticException(\"에러 발생: 수학적 오류\");\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void method3() {\n        try {\n            throw new NullPointerException(\"에러 발생: Null 참조\");\n        } catch (NullPointerException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n이 경우 코드가 길어지고 가독성이 떨어질 수 있다.\n위와 같은 코드에서 각 메서드에 `throws` 키워드를 사용해 예외를 떠넘기면, 예외가 발생해도 호출한 메서드에서 한꺼번에 처리할 수 있다.\n이렇게 하면 중복된 `try-catch`를 줄여 코드가 간결해지고 가독성이 향상된다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            method1();\n            method2();\n            method3();\n        } catch (ClassNotFoundException | ArithmeticException | NullPointerException e) {\n            System.out.println(\"오류: \" + e.getMessage());\n        }\n    }\n\n    public static void method1() throws ClassNotFoundException {\n        throw new ClassNotFoundException(\"에러 발생: 클래스 찾기 실패\");\n    }\n\n    public static void method2() throws ArithmeticException {\n        throw new ArithmeticException(\"에러 발생: 수학적 오류\");\n    }\n\n    public static void method3() throws NullPointerException {\n        throw new NullPointerException(\"에러 발생: Null 참조\");\n    }\n}\n```\n\n이렇게 메서드 선언부에 예외 클래스를 `throws`로 명시하면, 해당 메서드에서 예외를 처리하지 않고 호출한 상위 메서드로 떠넘기게 된다.\n`throws`를 사용해 예외를 던진 메서드는 자신이 예외를 직접 처리하지 않고, 예외를 호출한 메서드에게 전달해 처리하게끔 할 수 있다.\n\n이 예외는 호출 스택을 따라 상위 메서드로 계속 전달될 수 있으며, 최종적으로 `main` 메서드까지 떠넘겨질 수 있다.\n만약 `main` 메서드도 `throws`로 예외를 던진다면, 마지막에는 JVM에서 처리하게 된다.\n\n# 연결된 예외\n\n<hr>\n\n## 예외를 다른 예외로 감싸 던지기\n\n연결된 예외(Chained Exception)는 원인 예외를 다른 예외로 감싸서 던지는 기법이다.\n\n`Throwable` 클래스에서는 연결된 예외를 처리할 수 있도록 다음과 같은 메서드를 제공한다.\n\n- `Throwable initCause(Throwable caues)`: 원인 예외를 등록하는 메서ㅡㄷ\n- `Throwable getCause()`: 원인 예외를 반환하는 메서드\n\n이 메서드들을 통해 발생한 예외를 다른 예외로 감싸 던질 수 있으며, `Exception` 클래스의 상위 클래스인 `Throwable`에 정의되어 있기 때문에 모든 예외에서 사용할 수 있다.\n\n아래 코드는 `FileNotFountException`을 원인 예외로 감싸 `IOException`으로 던지는 방식이다.\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\nclass FileProcessingException extends IOException {\n    public FileProcessingException(String message) {\n        super(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            processFile();\n        } catch (FileProcessingException e) {\n            System.out.println(\"원인 예외: \" + e.getCause()); // 원인 예외 출력\n            e.printStackTrace();\n        }\n    }\n\n    public static void processFile() throws FileProcessingException {\n        try {\n            throw new FileNotFoundException(\"파일을 찾을 수 없습니다.\"); // 원인 예외 발생\n        } catch (FileNotFoundException e) {\n            FileProcessingException fileProcessingException = new FileProcessingException(\"파일 처리 중 오류 발생\"); // 새로운 예외 생성\n            fileProcessingException.initCause(e); // FileProcessingException의 원인 예외를 FileNotFoundException으로 지정\n            throw fileProcessingException; // FileProcessingException을 던져 상위 메서드로 전달\n        }\n    }\n}\n```\n\n코드에 대한 부가 설명을 하겠다.\n\n1. `processFile()` 메서드에서 `FileNotFoundException`이 발생한다.\n2. `catch`에서 `FileProcessingException` 예외 객체를 생성한다.\n3. 그리고 `FileProcessingException`의 `initCause()` 메서드를 통해 원인 예외를 `FileNotFoundException`으로 지정한다.\n4. `FileProcessingException`을 상위 메서드로 던지며, `main()` 메서드에서 `catch`가 이를 처리한다.\n5. `getCause()` 메서드를 사용해 원인 예외(`FileNotFoundException`)를 `catch`하고 `getCause()` 메서드를 통해 원인 예외 로르글 출력한다.\n\n이렇게 연결된 예외를 사용하는 이유는 여러 예외를 하나의 큰 범주의 예외로 묶어서 처리하기 위함이다.\n예외를 감싸는 방식은 다형성을확장하여 다양한 예외를 한 번에 처리하는 방법을 제공하며, 복잡한 예외 처리를 간소화 할 수 있다.\n또한, 특정 예외에 대한 명확한 에러 메시지를 제공하는 대신, 단계별로 문제의 원인과 발생 과정을 추적할 수 있게 해준다.\n\n## Checked Exception를 Unckecked Exception으로 변환하기\n\n연결된 예외(`Chained Exception`)를 사용하는 또 다른 이유는 `Checked Exception`을 `Unchecked Exception`으로 변환하여 컴파일러가 예외 처리를 강제하지 않도록 하는 것이다.\n\n자바에서 `Checked Exception`을 도입한 이유는 프로그래밍 경험이 적은 개발자도 안정적인 프로그래밍을 하도록 돕기 위함이다.\n하지만 런타임 예외로 처리해도 무방한 예외들이 `Checked Exception`으로 등록되어 있는 경우가 많다.\n이때 연결된 예외를 사용해 `Checked Exception`을 `Unchecked Exception`으로 감싸 변환하면, 컴파일러의 예외 처리 강제성을 회피할 수 있다.\n이렇게 함으로써 예외처리가 선택사항이 되어 코드가 더 간결해지고, 개발자는 필수적인 부분에서만 예외를 다루는 선택을 할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n            install();\n    }\n\n    public static void install() {\n        throw new RuntimeException(new IOException(\"설치할 공간이 부족합니다.\"));\n        // Checked 예외인 IOException을 Unchecked 예외인 RuntimeException으로 감싸 Unchecked 예외로 변환\n    }\n}\n```"},{"excerpt":"리플렉션(Reflection) 리플렉션은 런타임 중에 클래스의 속성, 메서드, 타입 등을 조사하고 수정할 수 있는 자바 API입니다. 리플렉션을 사용하면 컴파일 시간에는 알 수 없던 클래스 정보에 접근하거나, 동적으로 객체를 생성하고 메서드를 호출할 수 있습니다.\n프로그램이 실행 중 경로에 존재하는 코드들을 하나하나 확인하는 것 왜 사용할까? 주석처럼 코…","fields":{"slug":"/java-reflection/"},"frontmatter":{"date":"November 05, 2024","title":"자바 리플렉션(Reflection)","tags":["Java"]},"rawMarkdownBody":"\n# 리플렉션(Reflection)\n\n<hr>\n\n리플렉션은 런타임 중에 클래스의 속성, 메서드, 타입 등을 조사하고 수정할 수 있는 자바 API입니다. 리플렉션을 사용하면 컴파일 시간에는 알 수 없던 클래스 정보에 접근하거나, 동적으로 객체를 생성하고 메서드를 호출할 수 있습니다.\n프로그램이 실행 중 경로에 존재하는 코드들을 하나하나 확인하는 것\n\n## 왜 사용할까?\n주석처럼 코드를 설명하는 것 이상의 구체적인 메타 정보를 제공하여, 프레임워크나 API에서 설정 및 구성을 단순화하고, 런타임 시 동작을 제어하기 위해 사용합니다.\n\n# 어노테이션(Annotation)\n\n<hr>\n\n어노테이션은 코드에 추가 정보를 제공하는 방법으로, 리플렉션을 사용하여 런타임에 해석될 수 있습니다. 어노테이션은 코드의 의도를 명확히 하고, 프레임워크가 코드를 자동으로 처리하는 데 도움을 줄 수 있습니다.\n리플렉션을 효율적으로 하게 해주는 것\n\n# 리플렉션을 활용한 어노테이션 메타 데이터 가져오기 경험\n<hr>\n\n실제로 리플렉션을 활용해 커스텀 어노테이션의 메타 데이터를 추출하고, 자동 주입 로직을 구현한 경험이 있습니다."},{"excerpt":"이 글은 예외 처리를 알아보는 글이다. 앞서 에러와 예외의 구분, 컴파일에러와 런타임에러의 차이, 과 에 대한 기본적인 이해가 필요하다. 자바의 Error와 Exception 이해하기\n자바의 throw와 throws 그리고 Chained Exception 이해하기 예외 처리하기(Exception Handling) 예외 처리란 프로그램이 실행 중 발생할 수…","fields":{"slug":"/java-try-catch/"},"frontmatter":{"date":"November 05, 2024","title":"자바 예외 처리하기(Exception Handling)","tags":["Java"]},"rawMarkdownBody":"\n이 글은 예외 처리를 알아보는 글이다.\n\n앞서 에러와 예외의 구분, 컴파일에러와 런타임에러의 차이, `Checked Exception`과 `Unchecked Exception`에 대한 기본적인 이해가 필요하다.\n\n<br>[자바의 Error와 Exception 이해하기](https://023-dev.github.io/2024-11-05/java-exception-error)\n<br>[자바의 throw와 throws 그리고 Chained Exception 이해하기](https://023-dev.github.io/2024-11-06/java-throw-chained-exception)\n\n# 예외 처리하기(Exception Handling)\n\n<hr>\n\n예외 처리란 프로그램이 실행 중 발생할 수 있는 예기치 못한 상황에 대비해 코드를 작성하여 프로그램의 비정상적인 동작을 막는 것이다.\n예외처리를 통해 오류가 발생했을 때 복구를 시도하거나 오류를 회피함으로써 프로그램이 정상적인 실행 상태를 유지하도록 할 수 있다.\n\n## try-catch 문\n\n예외 처리를 위해 사용하는 `try-catch`의 기본 구조는 다음과 같다.\n`try` 부분에는 예외가 발생할 가능성이 있는 코드가 위치하며, 예외가 발생하면 `catch`로 넘어가 해당 예외를 처리한다.\n만약 `try` 내에서 예외가 발생하지 않으면 `catch`은 실행되지 않는다.\n\n`catch`에서는 예외 클래스의 타입과 변수명을 선언하여, 발생한 예외를 특정 클래스의 인스턴스로 받아 처리한다.\n이렇게 함으로써 프로그램의 비정상적인 동작이 발생할 때 오류를 복구하거나 대안을 마련할 수 있다.\n\n아래 코드는 `ArithmeticException`이 발생하면 `catch`가 실행되어 예외 처리를 수행한다.\n예외 발생 시 `result` 값을 -1로 초기화함으로써, 예외 상황을 회피하여 이후의 정상 동작을 유지할 수 있게 한다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        int x, y, result;\n        try {\n            x = 10;\n            y = 0;\n            result = x / y; // 10 나누기 0 → 산술 오류 발생 (ArithmeticException)\n        } catch (ArithmeticException e) {\n            result = -1;  // 예외 발생 시 기본값으로 초기화\n            System.out.println(\"산술 오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n코드를 작성하면서 모든 오류를 예측하기 어렵다. 그래서 다양한 예외 상황에 대비해 여러 개의 `catch`를 사용할 수 있다.\n아래 코드는 각 `catch`가 특성 예외 상황에 맞게 적절한 메시지를 출력하도록 구성되어 있다.\n그러나 예외 클래스의 종류가 많이 때문에, 모든 예외를 일일 작성하기에는 비효율적일 수 있다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        try {\n            // 예외가 발생할 가능성이 있는 코드들\n            \n        } catch (NumberFormatException e) {\n            System.out.println(\"숫자로 변환할 수 없습니다.\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"클래스를 찾을 수 없습니다.\");\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"배열 인덱스 범위를 초과했습니다.\");\n        } catch (IOException e) {\n            System.out.println(\"입출력 오류가 발생했습니다.\");\n        } catch (NullPointerException e) {\n            System.out.println(\"NULL 참조 오류입니다.\");\n        }\n    }\n}\n```\n\n자바에서는 클래스의 상속관계를 이용해 특정 예외를 포괄하는 상위 클래스인 `Exception` 클래스를 사용하여, 이 상황을 타개할 수 있다.\n아래 코드 처럼 `catch`에서 세세한 예외 구분 없이 모든 예외를 포괄적으로 처리할 수 있다.\n\n```java\npublic class ExceptionHandling {\n    public static void main(String[] args) {\n        try {\n            // 예외가 발생할 가능성이 있는 코드들\n            \n        } catch (NumberFormatException e) {\n            System.out.println(\"숫자로 변환할 수 없습니다.\");\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"클래스를 찾을 수 없습니다.\");\n        } catch (Exception e) { // 상위 클래스 예외로 처리\n            System.out.println(\"알 수 없는 오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n다만, 위 코드와 같은 방법을 사용하면 코드 간결성을 유지할 수 있는 장점이 있지만, 예외가 발생한 원인을 정확하게 파악하기 어려울 수 있다.\n이때 `printStackTrace()` 메서드를 사용하면 예외의 발생 원인을 추적할 수 있다.\n\n## try-catch-finally 문\n\n위에서 설명한 것처럼, 프로그램 실행 도중 예외가 발생하면 프로그램이 중단되거나 `catch`로 예외가 전달되어 예외 처리가 이루어진다.\n그러나 예외 발생 여부와 상관없이 반드시 실행해야 할 코드가 있는 경우, `finally`을 사용하여 해당 코드를 지정할 수 있다.\n\n```java\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            //만일 이 부분에서 오류 발생 시\n            //이후 코드는 실행되지 않음\n        } catch (Exception e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        }\n    }\n}\n```\n\n위 코드에서 실행 중 오류가 발생하면 `catch`로 넘어가기 때문에 다음 코드가 실행되지 않는다.\n이처럼 예외가 발생하더라도 특정 코드가 반드시 실행되어야 하는 경우가 있는데, 이때 `finally`를 사용하면 예외 발생 여부와 관계없이 `finally` 내의 코드가 무조건 실행된다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            //만일 이 부분에서 오류 발생 시\n            //이후 코드는 실행되지 않음\n        } catch (Exception e) {\n            System.out.println(\"오류 발생: \" + e.getMessage());\n        } finally {\n            // 예외 발생 여부에 관계없이 항상 실행됨\n        }\n    }\n}\n```\n\n이렇게 `finally`를 사용하면 `try` 내에서 오류가 발생 여부에 상관없이 `finally` 내의 코드가 실행된다.\n또한, 메서드에 `return`이  있는 경우에도 `finally`가 우선적으로 실행된다.\n예외를 발생하면 `try-catch-finally` 순서로 실행되고, 예외가 발생하지 않는 경우에는 `try-finally` 순으로 실행된다.\n\n## multi-catch 문\n\n여러 예외를 `|`를 사용해서 하나의 `catch`에서 처리할 수 있는 `multi-catch` 기법도 있다.\n이를 통해, 동일한 방식으로 처리할 여러 예외를 하나의 `catch` 블록으로 묶어 코드를 간결하게 만들 수 있으며, 연결할 수 있는 예외 클래스의 개수에는 제한이 없다.\n\n아래 코드에서는 `multi-catch` 기법을 사용하여 `NullPointerException`과 `ArrayIndexOutOfBoundsException`이 발생하면 동일한 방식으로 처리되게 작성했다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            // 예외 발생 가능 코드\n        } catch (NullPointerException | ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"널 참조 또는 배열 인덱스 초과 오류 발생\");\n        }\n    }\n}\n```\n\n다만 `multi-catch`는 여러 예외를 하나로 처리한다는 특성상, 예외마다 세밀한 제어가 필요한 경우에는 `if`문과 `instanceof` 연산자를 사용해 각각의 예외를 분기 처리해야 한다.\n\n```java\npublic class TryCatchFinallyExample {\n    public static void main(String[] args) {\n        try {\n            // 예외 발생 가능 코드\n        } catch (NullPointerException | ArrayIndexOutOfBoundsException e) {\n            if (e instanceof NullPointerException) {\n                System.out.println(\"널 참조 오류 발생\");\n            } else if (e instanceof ArrayIndexOutOfBoundsException) {\n                System.out.println(\"배열 인덱스 초과 오류 발생\");\n            }\n        }\n    }\n}\n```\n\n# 예외 메시지 출력하기\n\n<hr>\n\n`catch`의 `(Exception e)` 부분에서 `Exception`은 예외 타입을 나타내는 클래스이고, `e`는 예외 객체를 참조하는 변수다.\n이 변수는 `Exception` 클래스에서 제공하는 다양한 메서드를 사용하여 예외에 대한 정보를 확인할 수 있도록 한다.\n\n- `printStackTrace()`: 예외 발생 당시의 호출 스택(Call Stack)에 있었던 메서드 정보와 예외 메시지를 출력한다.\n- `getMessage()`: 예외 인스턴스에 저장된 기본적인 예외 메시지만을 간략하게 얻을 수 있다.\n\n> 자바에서 오류와 예외는 최상위 클래스인 `Object`를 상속받고, 중간에는 `Throwable` 클래스가 있다. `Throwable` 클래스는 오류나 예외에 대한 메시지를 담는 역할을 하며, `getMessage()`와 `printStackTrace()`가 포함되어 있다. 따라서 `Throwable`을 상속받은 `Error`와 `Exception` 클래스에서도 해당 메서드들이 제공된다.\n\n이 외에도 다양한 메서드가 존재하지만, 주로 예외 메시지를 확인하기 위해서는 위의 두 메서드를 사용한다.\n다만, `printStackTrace`는 호출 스택을 상세하게 출력하기 때문에, 보안 문제를 방지하려면 외부 사용자에게 노출되지 않도록 주의 해야한다.\n\n# 예외를 커스텀하기 (Custom Exception)\n\n<hr>\n\n자바에서는 `Exception`을 상속받아 커스텀 예외(`Custom Exception`)을 구현할 수 있다.\n이렇게 구현된 커스텀 예외는 `throw`를 통해 강제로 발생시키고, `catch`에서 커스텀 예외만의 처리를 할 수 있다.\n\n```java\n// 커스텀 예외 클래스\nclass InvalidValueException extends Exception {\n    private String errorMessage;\n    \n    // 커스텀 예외 클래스 생성자\n    public InvalidValueException(String errorMessage) {\n        super(errorMessage); // 상위 Exception 클래스 생성자 호출\n        this.errorMessage = errorMessage;\n    }\n    \n    // 커스텀 예외 클래스 전용 메시지 출력 메서드\n    public void printCustomMessage() {\n        System.out.println(\"오류: \" + this.errorMessage);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            validateValue(-10); // 유효하지 않은 값으로 예외 발생\n        } catch (InvalidValueException e) {\n            e.printCustomMessage(); // 커스텀 예외 메시지 출력\n            e.printStackTrace(); // 상속받은 부모 클래스의 메서드 실행\n        }\n    }\n    \n    // 값이 유효한지 확인하는 메서드, 유효하지 않으면 커스텀 예외 발생\n    public static void validateValue(int value) throws InvalidValueException {\n        if (value < 0) {\n            throw new InvalidValueException(\"값이 0보다 작을 수 없습니다.\");\n        }\n        System.out.println(\"값이 유효합니다: \" + value);\n    }\n}\n```"},{"excerpt":"프로그래밍을 처음 배우면 와 같이 콘솔에 출력을 시도하게 된다.\n콘솔 창에 \"프로그램이 정상적으로 동작함을 확인하는 과정은 모든 개발자가 겪는 경험일 것이다.\n우리는 원하는 기능을 구현한 후, 값이 제대로 출력되는지 확인하기 위해 종종 을 사용한다. 그러나 을 무차별적으로 사용해서는 안 된다. 그 이유는 무엇인지 아래에서 자세히 알아보자. System.o…","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"date":"November 05, 2024","title":"System.out.println()를 사용한 로깅을 피해야 하는 이유","tags":["Java"]},"rawMarkdownBody":"\n프로그래밍을 처음 배우면 `System.out.println(\"Hello World\");`와 같이 콘솔에 출력을 시도하게 된다.\n콘솔 창에 \"프로그램이 정상적으로 동작함을 확인하는 과정은 모든 개발자가 겪는 경험일 것이다.\n우리는 원하는 기능을 구현한 후, 값이 제대로 출력되는지 확인하기 위해 종종 `System.out.println`을 사용한다.\n\n그러나 `System.out.println`을 무차별적으로 사용해서는 안 된다. 그 이유는 무엇인지 아래에서 자세히 알아보자.\n\n# System.out.println이란 무엇인가?\n\n`System.out.println`은 자바에서 디버깅 용도로 콘솔에 정보를 출력하기 위해 사용하는 메서드이다.\n\n이를 간단히 설명하자면:\n- `System`: 자바의 `java.lang` 패키지에 내장된 `final` 클래스이다.\n- `out`: `System` 클래스의 정적 멤버 필드로, `PrintStream` 객체이다.\n- `println`: `PrintStream` 클래스의 메서드로, 표준 콘솔에 전달된 인자를 출력하며 자동으로 줄바꿈을 추가한다.\n\n이렇게 `System.out.println`을 통해 출력이 이루어지지만, 여러 가지 이유로 인해 이를 사용하지 않는 것이 좋다.\n\n# System.out.println을 사용하면 안 되는 이유\n\n## 성능 문제\n\n`System.out.println`을 사용하는 것은 성능에 악영향을 줄 수 있다.\n그 주요 이유는 블로킹 I/O와 멀티스레드 환경에서의 락 발생이다.\n`System.out.println`이 호출될 때는 메서드 내부의 `synchronized` 블록이 락을 걸기 때문에, 해당 메서드가 끝날 때까지 다른 스레드들은 기다려야 한다.\n이로 인해 불필요한 성능 저하가 발생한다.\n\n아래 코드에서 `System.out.println(\"hello Wor``ld\")`를 사용하는 예시를 보자.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"hello World\");\n    }\n}\n\npublic void println(String x) { \n    if (getClass() == PrintStream.class) {\n        writeln(String.valueOf(x));\n     } else {\n        synchronized (this) {\n            print(x);\n            newLine();\n        }\n        s = 33\n    }\n }\n\n```\n\n위 코드에서 `println` 메서드는 `synchronized` 블록을 사용하고 있는데, 이는 여러 스레드가 동시에 접근하지 못하도록 락을 걸기 때문이다.\n이로 인해 `System.out.println`이 콘솔에 출력될 때 성능 저하가 발생할 수 있다.\n\n## 로그 레벨 관리가 어려움\n\n`System.out.println`은 로그 레벨을 지정할 수 없으므로 디버깅 용도로 사용할 때도 로그가 어떤 수준에서 출력되는지 구분하기 어렵다.\n로그 레벨이 제대로 관리되지 않으면, 프로덕션 환경에서도 불필요한 디버깅 정보가 그대로 노출될 수 있다.\n이러한 정보는 시스템의 안정성과 보안에 문제가 생길 수 있는 요인이 된다.\n\n## 유지보수성 저하\n\n출력 메시지가 코드에 하드코딩되어 있으면, 나중에 메시지를 수정하거나 삭제하는 작업이 어렵다.\n특히 큰 프로젝트나 협업 환경에서 유지보수성에 큰 영향을 미친다.\n\n## System.out.println 사용 개선 전후 성능 비교\n\n`System.out.println`을 사용하는 코드와 이를 로거로 대체하거나 제거한 후의 성능을 비교해 보자.\n\n|               | 응답 시간 | 개선율 |\n|---------------|-----------|--------|\n| 변경 전       | 1,242ms   | -      |\n| 변경 1        | 893ms     | 39%    |\n| 변경 2        | 504ms     | 146%   |\n\n- **변경 1**: 로깅 프레임워크를 사용하여 로그 출력을 `false`로 설정\n- **변경 2**: 모든 로깅 코드를 주석 처리하고 `System.out.println`을 제거\n\n변경 1에서 성능이 39% 개선되었고, 변경 2에서 146%까지 개선된 것을 볼 수 있다.\n즉, 로그 메시지를 콘솔에 출력하는 것만으로도 시스템 성능에 상당한 영향을 미칠 수 있음을 알 수 있다.\n\n# 로그를 남기면 안 되는가?\n\n<hr>\n\n그렇다면 로그를 남기는 것은 아예 피해야 할까? 아니다.\n대신 로그를 남길 때는 `System.out.println` 대신 로거(Logger)를 사용하는 것이 좋다.\n로컬 환경에서 간단히 확인하는 용도로 `System.out.println`을 사용할 수 있지만, 실수로 배포 단계에서도 출력이 남지 않도록 로거를 사용하는 습관을 들이는 것이 중요하다.\n\n`logback`이나 `log4j`와 같은 **로깅 프레임워크**를 사용해 로그 레벨을 관리하며 체계적으로 로그를 남기는 방식이 이상적이다.\n\n[참고](https://systemdata.tistory.com/21): "},{"excerpt":"String 자바에서 문자를 다루는 대표적인 타입은 와  이렇게 2가지가 있다.\n기본형인 는 문자 하나를 다루는데 사용되고, 를 사용해서 여러 문자 즉 문자열을 다루기 위해선 을 사용해야 한다.\n하지만 이렇게 을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 이라는 클래스를 제공한다. String 내부 구조  클래스는 대략 다음과 같은 구조로 이루…","fields":{"slug":"/java-string/"},"frontmatter":{"date":"November 05, 2024","title":"자바 문자열(String)","tags":["Java"]},"rawMarkdownBody":"\n# String\n<hr>\n\n자바에서 문자를 다루는 대표적인 타입은 `char`와 `String` 이렇게 2가지가 있다.\n기본형인 `char`는 문자 하나를 다루는데 사용되고, `char`를 사용해서 여러 문자 즉 문자열을 다루기 위해선 `char[]`을 사용해야 한다.\n하지만 이렇게 `char[]`을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 `String`이라는 클래스를 제공한다.\n\n## String 내부 구조\n`String` 클래스는 대략 다음과 같은 구조로 이루어져 있다.\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    private final char value[]; //자바 9이전\n    private final byte value[];//자바 9이후\n    private final int offset;\n    \n    private final int count;\n    private int hash; // Default to 0\n    \n    public String concat(String str) {...}\n    public int length() {...}\n}\n```\n\n클래스이므로 필드와 메소드로 구성되어 있다.\n\n### 필드(속성)\n\n```java\nprivate final char value[];\n```\n\n`String`은 `char`형 배열을 필드로 가지고 있고, 여기에는 `String`이 가지고 있는 실제 문자열을 저장하는 배열이다.\n이 말의 뜻은 문자 데이터 자체는 `char`형 배열에 저장되어 있고, `String` 객체는 이 배열을 참조하고 있다는 것이다.\n그러면 `char[]`가 불편해서 `String`을 사용하는 거 아닌가? 근데 `String`도 결국 `char[]`를 참조하고 있으니 똑같은 거 아닌가? 라는 의문이 들 수 있다.\n하지만 `String` 클래스는 `char[]`를 참조하고 있지만, 개발자가 직접 다루기 힘든 `char[]`를 내부에 숨겨놓고, `String` 클래스의 메소드를 통해 문자열을 다룰 수 있게 해준다.\n\n> 참고\n> 자바 9부터는 `String` 클래스 내부에 `byte[]`를 사용하는 방식으로 변경되었다.\n> 자바에서 문자 하나를 표현하는데 `char` 타입을 사용하면 `2byte`가 필요하다.\n> 여기서 영어, 숫자는 보통 `1byte`로 표현하고(정확히는 Latin-1 인코딩의 경우 1byte로 표현 가능),\n> 그렇지 않은 다른 언어는 `2byte`인 `UTF-16` 인코딩으로 표현해야 한다.\n> 때문에 `char` 타입을 사용하면 메모리 낭비가 발생할 수 있다.\n> 그래서 자바 9부터는 `byte[]`를 사용하여 문자열을 저장하고,\n> `String` 클래스의 메소드를 통해 `byte[]`를 `char[]`로 변환하여 사용함으로써 메모리를 더 효율적으로 사용할 수 있게 되었다.\n\n## String은 클래스\n자바에서 `String`은 위에 보다시피 클래스로 `int`,`char`와 달리 기본형(Primitive Type) 변수가 아닌 참조형(Reference Type) 변수로 분류 된다.\n참조형은 변수에 실제 값이 아닌 주소값을 가지고 있기에, 원칙적으로 `+`와 같은 연산을 할 수 없다.\n자바에서 `String`은 클래스이지만, 문자열을 다루기 쉽게 하기 위해 `+`연산자를 사용할 수 있게 오버로딩 되어 있다.\n\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\n\nString str3 = str1 + str2;\n\nSystem.out.println(str3); // HelloWorld\n```\n\n또한 `String`는 참조형이므로 변수에 문자열을 대입하면 실제 문자열은 메모리의 힙(Heap) 영역에 생성되고, `String` 변수는 이 문자열을 참조하게 된다.\n\n\n## String은 불변(Immutable)\n기본적으로 자바에서는 `String`의 값을 변경할 수 없다.\n\n`String`의 내부 구조를 위에서 보여줬듯이 `char[]` 혹은 `byte[]`를 가지고 있지만, 이 배열은 `final`로 선언되어 있어서 한 번 생성되면 변경할 수 없다.\n\n하지만 `String`의 값을 변경하는 것 처럼 보이는 연산을 할 수 있다.\n\n```java\nString str = \"Hello\";\n\nstr = str + \" World\";\n\nSystem.out.println(str); // Hello World\n```\n\n위의 코드를 보면 `str` 변수에 `Hello`라는 문자열을 대입하고, `str` 변수에 `World`라는 문자열을 더해서 다시 대입했다.\n이렇게 보면 `String`의 값을 변경한 것 처럼 보이지만, 실제로는 새로운 문자열 데이터 객체를 생성하고, 이를 `str` 변수가 참조하게 된다.\n\n즉, `String`은 불변(Immutable)하다는 것은 **한 번 생성된 문자열은 변경할 수 없다는 것**을 의미한다.\n\n`hashCode()` 메소드를 이용해 실제로 변수가 가지고 있는 주소값을 찍어보면 알 수 있다.\n> `hashCode()` 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하는 메소드이다.\n\n```java\nString str = \"Hello\";\n\nSystem.out.println(str.hashCode()); // 69609650\n\nstr = str + \" World\";\n\nSystem.out.println(str.hashCode()); // -862545276\n```\n똑같은 변수 str 의 해시코드(주소값)을 출력했음에도 **가지고 있는 값이 바뀜에 따라 아예 주소값이 달라짐**을 알 수 있다.\n즉, **문자열 값 자체는 불변이라 변경할수 없기 때문에 새로운 문자열 데이터 객체를 대입하는 식으로 값을 대체 하기 때문에** 이러한 현상이 생기는 것이다.\n\n### 왜 불변으로 설계 되었는가?\n이처럼 `String`이 불변적인 특성을 가지는 이유는 크게 3가지로 꼽을 수 있다.\n첫번째는 JVM(자바 가싱 머신) 에서는 따로 String Constant Pool 이라는 독립적인 영역을 만들고 문자열들을 Constant 화 하여 다른 변수 혹은 객체들과 공유하게 되는데, 이 과정에서 **데이터 캐싱**이 일어나고 그 만큼 성능적 이득을 취할 수 있기 때문이다.\n두번째는 데이터가 불변(immutable) 하다면 Multi-Thread 환경에서 동기화 문제가 발생하지 않기 때문에 더욱 safe 한 결과를 낼 수 있기 때문이다.\n세번째는 보안(Security) 적인 측면을 들 수 있다.\n예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데,\n만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.\n\n### 불변인 String 클래스의 단점\n하지만 불변(Immutable)한 `String` 클래스는 메모리 사용량이 많아지는 단점이 있다.\n불변인 `String` 클래스는 문자열을 변경할 때마다 새로운 문자열 객체를 생성해야 한다는 점이다.\n문자를 변경하는 상황이 자주 발생하는 상황이라면 `String` 객체를 만들고 GC가 빈번히 발생한다.\n결과적으로 CPU와 메모리를 많이 사용하게 되어 성능에 영향을 미칠 수 있다.\n그리고 문자열의 크기가 클수록, 문자열을 더 자주 변경할수록 이러한 단점이 더욱 부각된다.\n\n이러한 단점을 보완하기 위해 `StringBuffer`와 `StringBuilder` 클래스가 존재한다.\n`StringBuffer`와 `StringBuilder`는 `String`과 달리 가변적인 특성을 가지고 있어 문자열을 변경할 때 새로운 객체를 생성하지 않고 기존 객체를 변경한다.\n이러한 특성 때문에 문자열을 변경하는 작업이 많은 상황에서는 `StringBuffer`와 `StringBuilder`를 사용하는 것이 성능상 이점이 있다.\n\n자세한 내용은 [자바의 String, StringBuffer, StringBuilder 차이 알아보기](https://023-dev.github.io/2024-11-05/java-string-stringbuffer-stringbuilder)를 참고하자.\n\n## String의 주소 할당 방식\n<hr>\n\nString을 통해 문자열을 생성하는 방법은 대표적으로 두가지 방식이 있다.\n\n1. `String Literal`을 이용한 방식\n2. `new String(\"\")`을 이용한 방식\n\n```java\nString str1 = \"Hello\"; // String Literal\n\nString str2 = new String(\"Hello\"); // new String(\"\")\n```\n이 둘은 `\"Hello\"`라는 같은 문자열 값을 저장한지만, JVM 메모리 할당에서 차이가 존재한다.\n\n### String Contstant Pool\n`String`의 주소 할당을 어떠한 방식으로 하는지에 따라 메모리에서 형태가 다르게 된다.\n\n`String Literal`을 변수에 저장하게 되면 이 값은 `String Constant Pool`이라는 영역에 존재하게 되고, `new` 연산자를 통해 `String`을 생성하면 이 값은 `Heap` 영역에 존재하게 된다.\n\n```java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\n\nString str3 = new String(\"Hello\");\nString str4 = new String(\"Hello\");\n```\n\n위의 코드를 실행하면 문자열 리터럴 값으로 두 변수 `str1`, `str2`가 같은 메모리 주소를 가리킨다.\n\n그 이유는 `String`이 불변(immutable)하다는 특성 덕분에, 동일한 `String Literal`은 `String Constant Pool`이라는 메모리 영역에서 재사용되어 같은 문자열 가리킨다.\n\n이러한 이유로 `str1`과 `str2`는 동일한 메모리 주소를 참조하게 된다.\n\n정리하면, `String Constant Pool`은 동일한 문자열 리터럴을 캐싱하여 불필요한 객체 생성을 줄여 메모리를 사용을 최적화하고 성능을 향상시킨다.\n이러한 이유로 new String() 방식보다 문자열 리터럴 할당이 선호된다.\n\n> 참고\n> 풀(Pool)은 자원이 모여있는 곳을 의미한다.\n> 프로그래밍에서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻한다.\n> 여러 곳에서 함께 사용할 수 있는 객체를 필요할 때마다 생성하고, 제거하는 것은 비효율적이다.\n> 대신 이렇게 문자열 리터럴을 `String Constant Pool`에 저장해두고, 필요할 때마다 참조하는 방식으로 메모리를 효율적으로 사용할 수 있다.\n> 참고로 앞서 언급했듯이 `String Constant Pool`은 `Heap` 영역에 존재한다.\n> 그리고 `String Constant Pool`에서 문자열을 찾을 때는 해시 알고리즘을 사용하는데,\n> 이 떄문에 빠른 속도로 원하는 `String` 인스턴스를 찾을 수 있다.\n\n## String 비교\n\n`String` 클래스를 비교할 때는 `==` 비교가 아니라 `equals()` 메소드를 사용해야 한다.\n\n- 동일성(Idnetity): `==` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인.\n- 동등성(Equality): `equals()` 메소드를 사용해서 두 객체의 값이 같은지 확인.\n\n간단히 정리하자면 `==` 연산자와 `equals()` 메소드의 차이는 `주소값을 비교하냐`, `대상의 값 자체를 비교하냐`의 차이다.\n그래서 `String Literal`의 비교는 `==` 연산자를 사용해도 `String Constant Pool`에서 같은 객체 값을 참조하고 있기 때문에 주소값이 같아 `true`가 반환된다.\n\n하지만 `new Stirng(\"\")`의 비교는 힙 메모리에서 다른 주소 값을 참조하고 있어서 `==` 연산자를 사용하면 `false`가 반환된다. 따라서 `new Stirng(\"\")`은 주소 값이 아닌 그 안에 값 자체를 비교해야 하고 이 역할을 `equals()` 메소드가 한다.\n```java\nString str1 = \"Hello\"; // String Literal\nString str2 = \"Hello\";\n\nString str3 = new String(\"Hello\"); // new String(\"\")\nString str4 = new String(\"Hello\");\n\n// String Literal 비교\nSystem.out.println(str1 == str2); // true\n\n// new String(\"\") 비교\nSystem.out.println(str3 == str4); // false\nSystem.out.println(str3.equals(str4)); // true\n\n// 리터럴과 객체 문자열 비교\nSystem.out.println(str1 == str3); // false\nSystem.out.println(str3.equals(str1)); // true\n```\n\n## String의 메소드\n\n### 문자열 정보 조회\n- `length()`: 문자열의 길이를 반환한다.\n- `charAt(int index)`: 문자열의 특정 인덱스에 위치한 문자를 반환한다.\n- `isEmpty()`: 문자열이 비어있는지 확인한다.(길이가 0인 경우)\n- `isBlank()`: 문자열이 공백 문자로만 이루어져 있는지 확인한다.(길이가 0인 경우 || 공백(witespace)만 있는 경우), 자바 11부터 지원\n\n### 문자열 비교\n- `equals(Object obj)`: 문자열이 주어진 객체와 동일한지 비교한다.\n- `equalsIgnoreCase(String str)`: 대소문자를 무시하고 문자열이 같은지 비교한다.\n- `compareTo(String str)`: 문자열을 사전 순으로 비교한다.\n- `compareToIgnoreCase(String str)`: 대소문자를 무시하고 문자열을 사전 순으로 비교한다.\n- `startsWith(String prefix)`: 문자열이 특정 문자열로 시작하는지 확인한다.\n- `endsWith(String suffix)`: 문자열이 특정 문자열로 끝나는지 확인한다.\n\n\n### 문자열 검색\n- `contains(CharSequence s)`: 문자열이 특정 문자열을 포함하는지 확인한다.\n- `indexOf(String str)`: 문자열에서 특정 문자열이 처음으로 등장하는 인덱스를 반환한다.\n- `lastIndexOf(String str)`: 문자열에서 특정 문자열이 마지막으로 등장하는 인덱스를 반환한다.\n\n### 문자열 조작 및 변환\n- `concat(String str)`: 문자열을 연결한다.\n- `substring(int beginIndex)`: 문자열의 특정 인덱스부터 끝까지의 부분 문자열을 반환한다.\n- `replace(CharSequence target, CharSequence replacement)`: 문자열에서 특정 문자열을 다른 문자열로 대체한다.\n- `replaceAll(String regex, String replacement)`: 문자열에서 특정 정규 표현식과 일치하는 문자열을 다른 문자열로 대체한다.\n- `replaceFirst(String regex, String replacement)`: 문자열에서 특정 정규 표현식과 일치하는 첫 번째 문자열을 다른 문자열로 대체한다.\n- `toLowerCase()`: 문자열을 소문자로 변환한다.\n- `toUpperCase()`: 문자열을 대문자로 변환한다.\n- `trim()`: 문자열의 앞뒤 공백을 제거한다.\n- `strip()`: 문자열의 앞뒤 공백을 제거한다. 자바 11부터 지원\n\n### 문자열 분할 및 결합\n- `split(String regex)`: 문자열을 특정 정규 표현식을 기준으로 나누어 배열로 반환한다.\n- `join(CharSequence delimiter, CharSequence... elements)`: 문자열을 결합한다.\n\n### 기타 유틸리티\n- `format(String format, Object... args)`: 지정된 형식 문자열을 사용하여 문자열을 생성한다.\n- `valueOf(Object obj)`: 지정된 값을 문자열로 변환한다.\n- `toCharArray()`: 문자열을 문자 배열로 변환한다.\n- `matches(String regex)`: 문자열이 특정 정규 표현식과 일치하는지 확인한다.\n\n> 참고\n> `CharSequence`는 `String`, `StringBuffer`, `StringBuilder` 클래스의 부모 인터페이스이다.\n> 문자열을 처리하는 다양한 클래스를 사용할 때, `CharSequence`를 사용하면 유연하게 문자열을 다룰 수 있다."},{"excerpt":"자바에서는 , , 라는 3가지 클래스 자료형을 통해 문자열을 다룰 수 있다. 어떤 상황에 어떤 자료형을 사용하는 것이 성능적인 측면에서 좋은지 알아본다. StringBuffer / StringBuilder 클래스 와  클래스는 문자열을 연결이나 수정하는 연산을 할 때 주로 사용하는 자료형이다. 이 둘의 차이점을 간단하게 하자면 는 멀티 쓰레드 환경에서 안…","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"date":"November 05, 2024","title":"String과 StringBuffer 그리고 StringBuilder","tags":["Java"]},"rawMarkdownBody":"\n\n자바에서는 `String`, `StringBuffer`, `StringBuilder`라는 3가지 클래스 자료형을 통해 문자열을 다룰 수 있다.\n\n어떤 상황에 어떤 자료형을 사용하는 것이 성능적인 측면에서 좋은지 알아본다.\n\n# StringBuffer / StringBuilder 클래스\n\n<hr>\n\n`StringBuffer`와 `StringBuilder` 클래스는 문자열을 연결이나 수정하는 연산을 할 때 주로 사용하는 자료형이다. 이 둘의 차이점을 간단하게 하자면 `StringBuffer`는 멀티 쓰레드 환경에서 안전하다는 장점이 있고, `StringBuilder`는 문자열 파싱 성능이 가장 우수하다는 장점이 있다.\n`String`에서는 `+` 연산이나 `concat()` 메소드를 사용할 수 있지만 `String`의 특성상 **인스턴스의 문자열 값이 바뀌게 되면 새로운 String 인스턴스를 생성**하게 되어,\n이러한 연산을 할수록 메모리랑 성능적인 측면에서 저하 발생된다.\n\n```java\nString str = \"\";\nstr +=  \"Hello\";\nstr +=  \" \";\nstr +=  \"World\";\nSystem.out.println(str);\n```\n\n그래서 자바에서는 이러한 이슈로 인해 연산을 전용으로 하는 자료형을 제공해 주고 있다.\n\n`StringBuffer` 클래스는 내부적으로 **버퍼(Buffer)라고 하는 독립적인 공간을 가지게되어, 문자열 연산을 할 때 버퍼에 적용하여 메모리나 성능적인 측면에서 저하가 발생하는 현상을 방지**한다.\n\n```java\nStringBuffer sb = new String();\nsb.append(\"Hello\");\nsb.append(\" \");\nsb.append(\"World\");\nSystem.out.println(sb.toString());\n```\n\n> `StringBuffer`는 버퍼에 기본적으로 16개의 문자를 저장하는 크기를 지원한다. 이때 한 문자는 2바이트를 차지하므로, 초기 버퍼 크기는 총 32바이트이다. 생성자를 통해 크기를 설정할 수 있고 만일 문자열 연산 중 할당된 버퍼의 크기를 넘게 되면 자동으로 버퍼를 스케일업 해준다.\n\n## StringBuffer 내장 메소드\n`StringBuffer`클래스는 효율적인 문자열 연산을 위한 메소드를 제공하고 이 메서드를은 `StringBuilder` 클래스에서도 동일하게 제공된다.\n- `append(...)`: 문자열을 끝에 추가\n- `insert(int pos, ...)`: 지정 위치에 문자열 삽입\n- `delete(int start, int end)`: 지정 범위의 문자열 삭제\n- `deleteCharAt(int index)`: 특정 인덱스의 문자 삭제\n- `replace(int start, int end, String str)`: 지정 범위의 문자열을 다른 문자열로 대체\n- `reverse()`: 문자열을 뒤집음\n- `substring(int start)`: 시작 위치부터 끝까지의 문자열 반환\n- `substring(int start, int end)`: 지정 범위의 문자열 반환\n- `toString()`: `StringBuffer` 객체를 `String`으로 변환\n- `setCharAt(int index, char ch)`: 특정 인덱스의 문자 변경\n- `setLength(int newLength)`: 문자열의 길이를 지정된 길이로 설정\n- `capacity()`: 버퍼의 용량 반환\n- `length()`: 현재 문자열의 길이 반환\n- `charAt(int index)`: 특정 인덱스의 문자 반환\n- `ensureCapacity(int minimumCapacity)`: 버퍼의 최소 용량 설정\n- `trimToSize()`: 현재 문자열 길이에 맞게 버퍼 크기 조정\n\n\n# Stinrg과 StringBuffer/StringBuilder 비교\n\n<hr>\n\n## 문자열 자료형의 불변성과 가변성\n\n### String은 불변\n자바에서는 `String`은 **불변(Immutable) 자료형**이다. 그래서 초기 값과 다른 값에 대한 연산에 많은 추가 자원을 사용하게 된다는 특징이 있다.\n\n실제로 String 객체의 내부 구조를 보면 다음과 같이 되어 있다.\n\n```java\npublic final class String implements java.io.Serializable, Comparable {\n\tprivate final byte[] value;\n}\n```\n\n인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 이 `value`라는 인스턴스 변수에 문자형 배열로 저장되게 된다. 이 `value`는 상수형인 `final`이니 값을 바꾸지 못하는 것이다.\n\n아래 코드를 보면 변수 `str`이 참조하는 메모리의 \"Hello\"라는 값에 \" World\"라는 문자열을 더해서 `String` 객체의 자체의 값을 업데이트 시킨 것으로 볼 수 있지만 실제로는 메모리에 새로 \"Hello World\"라는 값을 저장한 영역을 만들고 `str`이 다시 참조하는 방식으로 작동한다.\n\n```java\nString str = \"Hello\";\nstr += \" World\";\n\nSystem.out.println(str);\n```\n\n![String](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_1.png)\n\n이외에도 문자열을 다루는데 있어 가장 많이 사용하는 `trim`이나 `toUpperCase`, `toLowerCase` 같은 메소드 사용 형태를 보면, 문자열이 변경되는 것 처럼 보일 수 있지만 해당 메소드 수행 시 새로운 `String` 객체를 생성해서 반환할 뿐이다.\n\n```java\nString str = \"abc\";  // \"abc\"\nstr.toUpperCase();  // \"ABC\"\n\nSystem.out.println(str); // \"abc\"\n```\n\n자바에서 `String`을 불변으로 설정한 이유는 다음 글에서 볼 수 있다.\n[자바의 String 이해하기](https://023-dev.github.io/2024-11-05/java-string#:~:text=%ED%98%84%EC%83%81%EC%9D%B4%20%EC%83%9D%EA%B8%B0%EB%8A%94%20%EA%B2%83%EC%9D%B4%EB%8B%A4.-,%EC%99%9C%20%EB%B6%88%EB%B3%80%EC%9C%BC%EB%A1%9C%20%EC%84%A4%EA%B3%84%20%EB%90%98%EC%97%88%EB%8A%94%EA%B0%80%3F,-%EC%9D%B4%EC%B2%98%EB%9F%BC%20String%EC%9D%B4)\n\n`String`은 문자열이 변할 때마다 계속해서 새로운 메모리를 잡게 되고, 변하기 전의 값이 있던 메모리는 가비지 컬렉션(Garbage Collector, GC) 대상이 되어 `Minor GC`을 빈번히 발생시킨다. 이러한 `Minor GC`의 잦은 발생은 `Full GC(Major GC)`으로 이어질 수 있다.\n\n> `Minor GC`는 자바 메모리의 작은 영역에서 불필요한 메모리를 빠르게 정리하는 작업이며, `Full GC`는 전체 메모리를 대상으로 하는 더 큰 정리 작업이다. 이때 `Minor GC`가 빈번히 발생하면, 시스템은 `Full GC`를 시작한다. `Full GC`는 전체 메모리를 검사하고 불필요한 객체를 모두 제거하므로 시간이 오래 걸리고 CPU 자원을 많이 사용해 성능저하와 지연을 초래할 수 있다.\n\n### StringBuffer/StringBuilder는 가변\n`StringBuffer`와 `StringBuilder는`의 경우 문자열 데이터를 다룬다는 점에서 `String` 객체와 같지만, 객체의 공간이 부족해지는 경우 버퍼를 스케일업 해주어 가변적이라는 차이점이 있다.\n\n실제 `StringBuffer` 객체의 내부 구조를 보면 `String`과 달리 `final`이 없다.\n\n```java\npublic final class StringBuffer implements java.io.Serializable {\n\tprivate byte[] value;\n}\n```\n\n두 클래스는 내부적으로 데이터를 임시로 저장할 수 있는 메모리인 버퍼을 가지고 있어 버퍼에 문자열을 저장해두고 필요한 연산 작업을 추가적인 메모리 없이 작업을 할 수 있도록 설계되어 있다.\n\n```java\nStringBuffer sb = new StringBuffer(\"Hello\");\nsb.append(\" World\");\nSystem.out.println(sb.toString());\n```\n\n![StringBuffer](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_2.png)\n\n따라서 값이 변함에 따라 새로운 객체를 생성하는 불변적인 `String` 보다 메모리와 성능적인 측면에서 좋기 때문에, 문자열 연산이 빈번하게 발생하는 경우에는 `String`가 아닌 `StringBuffer/StringBuilder`를 사용하는 것이 이상적이다.\n\n## 문자열 자료형의 값 비교\n\n### String 값 동등 비교\n`String`은 `equals()`을 사용해 동등 비교가 가능하다.\n\n```java\nString str1 = \"Hello\";\nString str2 = new String(\"Hello\");\n\nSystem.out.println(str1 == str2; // false\nSystem.out.println(str2.equals(str1)); //true\n```\n\n### StringBuffer/StringBuilder 값 동등 비교\n`StringBuffer`와 `StringBuilder`는 `String`와 달리 `equals()` 메서드를 오버라이딩하지 않아 `==`로 비교한 것과 같은 결과를 얻게 되어 버린다.\n\n```java\nStringBuffer sb1 = new StringBuffer(\"Hello\");\nStringBuffer sb2 = new StringBuffer(\"Hello\");\n\nSystem.out.println(sb1 == sb2); // false\nSystem.out.println(sb2.equals(sb1)); // false\n```\n\n그래서 `toString()`으로 `StringBuffer`와 `StringBuilder`을 `String`으로 변환 후 `equals()`로 비교를 한다.\n\n```java\nString sb1_tmp = sb1.toString();\nString sb2_tmp = sb2.toString();\nSystem.out.println(sb1_tmp.equals(sb2_tmp)); // true\n```\n\n## 문자열 자료형의 성능 비교\n위에서 설명했듯이, `String`을 `+`으로 연산하면 불필요한 객체들이 힙(Heap) 메모리에 추가되어 안좋기 때문에 `StringBuffer`이나 `StringBuilder`의 `append()`를 통해 문자열 연산을 수행하는 것이 좋다.\n\n하지만 이런 연산 작업 빈도 수가 적으면 `String`의 `+` 연산이랑 `StringBuffer`이나 `StringBuilder`의 `append()`가 차이가 없어 보일 수 도 있다.\n\n```java\nString str = \"Hello\" + \" World\";\n// 컴파일 전 내부적으로 StringBuilder 클래스를 만든 후 아래와 같은 작업을 수행한다.\nString str = new StringBuilder(\"Hello\").append(\" World\").toString();\n```\n\n이처럼 겉으로는 보기에는 문자열 리터럴(String Literal)로 `+` 연산하거나, `StringBuilder`를 사용하거나 어차피 자동 변환해줘서 차이가 없어 보일지도 모른다.\n\n하지만 다음과 같이 문자열을 합치는 일이 많을 경우 단순히 `+`연산을 쓰면 성능과 메모리 효율이 떨어지게 된다.\n\n```java\nString str = \"\";\n\nfor(int i = 0; i < 10000; i++) {\n    str += i;\n}\n\n// 반복 횟수 만큼 new StringBuilder() 메모리를 생성하고 다시 변수에 대입하는 하는 것을 알 수 있다.\nString str = \"\";\n\nfor(int i = 0; i < 10000; i++) {\n    str = new StringBuilder(\"\").append(i).toString();\n}\n```\n\n위 코드에서 문자열 값을 변경하는 작업이 많을수록 성능저하를 유발하는 원인이 될 수 있다는 것을 느낄 수 있다.\n\n그래서 만일 문자열 연산이 빈번하게 수행 될 경우 초기부터 `StringBuidler`을 사용해서 문자열을 관리하는게 이상적이다.\n\n```java\nStringBuilder sb = new StringBuilder();\n\nfor(int i = 0; i < 10000; i++) {\n        sb.append(i);\n}\n```\n\n![+ 연산자 성능 비교](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_3.png)\n\n정리하자면, 문자열 연산 작업이 잦을 경우에는 `StringBuffer/StringBuilder`를, 문자열 변경 작업이 거의 없는 경우에는 `String`을 사용하는 것만 이상적이다.\n\n# StringBuffer와 StringBuilder 차이점\n\n<hr>\n\n`StringBuffer`와 `StringBuilder`는 공통적으로 가변성을 가지고 있고, 제공하는 메서드도 같고, 사용법도 동일하다.\n\n하지만 멀티 쓰레드 환경(Tread)에서 안정성(Safety)에 대한 차이가 난다.\n\n## 쓰레드 안전성\n\n`StringBuffer`와 `StringBuilder`는 동기화(Synchronization)에서의 지원 측면에서 보면 차이가 명확해진다.\n\n`StringBuffer`는 동기화를 지원하는 반면,  `StringBuilder`는 동기화를 지원하지 않는다. 이로 인해 `StringBuffer`는 멀티 쓰레드 환경에서도 안전하게 동작할 수 있다.\n그 이유는 `StringBuffer`의 모든 메서드에 `synchronized` 키워드가 붙어 있기때문이다.\n\n> 자바에서 `synchronized` 키워드는 한 번에 하나의 스레드만 접근할 수 있도록 잠금을 걸어, 다른 스레드는 현재 작업이 끝날 때까지 기다리게 해서 여러 스레드가 동시에 하나의 자원에 접근할 때 발생할 수 있는 데이터 불일치 문제를 방지한다.\n\n\n아래 코드는 `StringBuffer`와 `StringBuilder`을 생성해서 멀티 쓰레드 환경에서의 `synchronized` 키워드의 유무차이와 필요성을 보여준다.\n```java\npublic class StringBufferVsStringBuilderTest {\n    public static void main(String[] args) throws InterruptedException {\n        StringBuffer stringBuffer = new StringBuffer();\n        StringBuilder stringBuilder = new StringBuilder();\n\n        // StringBuffer에 문자열 추가하는 두 스레드\n        Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuffer.append(\"A\"); });\n        Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuffer.append(\"A\"); });\n\n        // StringBuilder에 문자열 추가하는 두 스레드\n        Thread t3 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuilder.append(\"B\"); });\n        Thread t4 = new Thread(() -> { for (int i = 0; i < 10000; i++) stringBuilder.append(\"B\"); });\n\n        // 스레드 실행 및 완료 대기\n        t1.start(); t2.start(); t3.start(); t4.start();\n        t1.join(); t2.join(); t3.join(); t4.join();\n\n        // 결과 출력\n        System.out.println(\"StringBuffer length: \" + stringBuffer.length());   // 20000\n        System.out.println(\"StringBuilder length: \" + stringBuilder.length()); // 18957\n    }\n}\n```\n\n위 코드에서 볼 수 있듯이 `StringBuilder`의 값이 더 작은 것을 확인 할 수 있는데, 이는 쓰레드 안전성이 없어 충돌이 발생한 결과이다.\n반면, `StringBuffer`는 쓰레드 안전성을 보장해주어 정상적인 결과값이 출력되는 것을 볼 수 있다.\n\n그래서 웹이나 소켓같은 비동기로 동작하는 환경에서는 `StringBuffer`을 사용하는 것이 안전하다.\n\n## 성능 비교\n그럼 멀티 쓰레드 환경이 아니라 쓰레드 안정을 생각하지 않고 사용하는 상황일 때 어떤 것을 사용하는 것이 좋을까?\n아래코드는 `StringBuffer`와 `StringBuilder`의 성능을 비교하는 코드이다.\n\n```java\npublic class StringBufferVsStringBuilderPerformanceTest {\n    public static void main(String[] args) {\n        final int loopCount = 100_000;\n\n        // StringBuffer 성능 테스트\n        long startTimeBuffer = System.nanoTime();\n        StringBuffer stringBuffer = new StringBuffer();\n        for (int i = 0; i < loopCount; i++) {\n            stringBuffer.append(\"*\");\n        }\n        long endTimeBuffer = System.nanoTime();\n        System.out.println(\"StringBuffer time: \" + (endTimeBuffer - startTimeBuffer) + \" ns\");// StringBuffer time: 123456789 ns\n\n        // StringBuilder 성능 테스트\n        long startTimeBuilder = System.nanoTime();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < loopCount; i++) {\n            stringBuilder.append(\"*\");\n        }\n        long endTimeBuilder = System.nanoTime();\n        System.out.println(\"StringBuilder time: \" + (endTimeBuilder - startTimeBuilder) + \" ns\");// StringBuilder time: 98765432 ns\n\n    }\n}\n```\n\n결과를 보면, 순수 성능은 `StringBuilder`가 우월한 것을 알 수 있다. 그 이유는 위에서 설명한 `+`연산 시 컴파일 전에 `StringBuilder`로 변환하는 이유와 같다.\n\n`StringBuffer`와 `StringBuilder` 차이는 `synchronized`의 키워드 유무로 인한 쓰레드 안전성인데, 이때 `StringBuffer`는 `synchronized` 키워드를 사용하면서 동기화 오버헤드가 발생하기 때문에 이러한 결과가 나온다.\n\n![String StringBuffer StringBuilder 속도 비교](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-string-stringbuffer-stringbuilder/java-string-stringbuffer-stringbuilder_4.png)\n\n위 그래프를 보면 10만번 이상의 연산 작업 수행 시 `String`의 수행시간이 기하급수적으로 늘어나지만, `StringBuffer`와 `StringBuilder`는 1000만번까지 준수하다가, 그 후로는 `StringBuilder`가 더 좋다는 것을 볼 수 있다.\n\n그래서 멀티 쓰레드 환경이 아니고선 `StringBuilder`을 사용하는 것이 이상적이다.\n\n정리하자면 `String`은 불변 객체로 문자열을 변경할 수 없으며, 문자열 연산이 적고 스레드 안전성이 중요한 경우에 적합하다.\n반면, `StringBuffer`와 `StringBuilder`는 가변 객체로, 동일 객체 내에서 문자열을 수정할 수 있다.\n`StringBuffer`는 모든 메서드가 `synchronized`되어 쓰레드 안전성을 보장해 멀티 쓰레드 환경에서 안전하게 사용할 수 있지만, 이로 인해 `StringBuilder`보다 약간 느리다.\n`StringBuilder`는 쓰레드 안전성을 제공하지 않지만 가장 빠른 성능을 제공하므로, 단일 스레드 환경에서 빈번한 문자열 조작이 필요할 때 사용하는 것이 적합하다."},{"excerpt":"람다 표현식(Lambda Expression) 람다 표현식(Lambda Expression)은 함수형 프로그래밍을 위해 자바에서 제공하는 간결한 함수식으로, 자바의 메서드를 간단하게 표현할 수 있는 방법이다.\n기존 자바에서는 메서드를 표현하려면 별도의 클래스를 정의해야 했지만, 람다 표현식을 사용하면 메서드의 이름과 반환값을 생략하여 코드가 간결해지게 할…","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"date":"November 05, 2024","title":"자바 람다(Lambda)와 스트림(Stream)","tags":["Java"]},"rawMarkdownBody":"\n# 람다 표현식(Lambda Expression)\n\n<hr>\n\n람다 표현식(Lambda Expression)은 함수형 프로그래밍을 위해 자바에서 제공하는 간결한 함수식으로, 자바의 메서드를 간단하게 표현할 수 있는 방법이다.\n기존 자바에서는 메서드를 표현하려면 별도의 클래스를 정의해야 했지만, 람다 표현식을 사용하면 메서드의 이름과 반환값을 생략하여 코드가 간결해지게 할 수 있다.\n\n`int add(int x, int y) { return x  + y; }`와 같은 메서드 표현식을 아래 코드처럼 람다식을 사용하면 간결하게 작성할 수 있다.\n이처럼 람다식은 이름없는 함수다 해서 익명함수(anonymous function)라고도 불린다.\n\n```java\n// 기존 메서드 표현\nint add(int x, int y) {\n    return x + y;\n}\n\n// 람다 표현식을 사용한 간결한 표현 (메서드 반환 타입과 이름 생략)\n(int x, int y) -> {\n        return x + y;\n};\n\n// 매개변수 타입까지 생략\n        (x, y) -> {\n        return x + y;\n};\n\n// 리턴문 한 줄만 있을 때는 중괄호와 return까지 생략\n(x, y) -> x + y;\n```\n\n> 위 코드에서 타입을 생략해도 컴파일러가 오류를 발생시키지 않는 이유는, 컴파일러가 생략된 타입을 추론할 수 있기 때문이다.\n\n람다식은 특히 컬렉션의 요소를 필터링하거나 매핑할 때 사용하면 원하는 결과를 코드의 가독성을 살리면서 얻을 수 있다.\n\n## 람다식의 화살표 함수\n\n자바의 화살표 함수는 자바스크립트의 화살표함수와 구조와 개념이 유사하다.\n자바스크립트는 약타입 언어로 타입 선언 없이 자유롭게 변수를 받을 수 있지만, 자바는 강타입 언어이므로 람다식을 사용하기 위해 함수형 인터페이스를 통해 타입을 선언해야 한다.\n하지만, 자바에는 함수 타입을 직접 표현할 자료형이 없기 때문에, 인터페이스를 사용하여 람다식을 표현할 수 있도록 설계되어 있다.\n\n```javascript\n// JavaScript - 화살표 함수 사용\nconst MyFunction = {\n    print: (str) => console.log(str)\n};\nMyFunction.print(\"Hello World\");\n\n```\n\n```java\n// Java - 람다 표현식 사용\ninterface MyFunction {\n    void print(String str);\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyFunction myfunc = (str) -> System.out.println(str);\n        myfunc.print(\"Hello World\");\n    }\n}\n```\n\n## 람다식과 함수형 인터페이스\n람다식은 마치 메서드를 변수로 선언하는 것처럼 보이지만, 사실 자바에서는 메서드를 단독으로 표현할 수 없다.\n때문에 람다식은 함수형 인터페이스를 구현하는 익명 클래스로 간략하게 표현된 객체라고 할 수 있다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IAdd lambda = (x, y) -> x + y; // 익명 클래스로 람다식 사용\n        int result = lambda.add(1, 2);\n        System.out.println(result);\n    }\n}\n```\n이때 람다식 객체를 콘솔에 출력해보면 `외부클래스명$$Lambda$번호`와 같은 형식으로 출력되며, 이는 익명 구현 객체로 표현되는 것을 의미합니다.\n단, 람다 표현은 함수형 인터페이스의 추상 메서드를 구현할 때만 가능하며, 익명 클래스의 모든 메서드를 람다식으로 줄일 수는 없다.\n\n### 함수형 인터페이스\n함수형 인터페이스란 딱 하나의 추상 메더스가 있는 인터페이스를 의미한다.\n람다식은 이와 같은 함수형 인터페이스의 추상메서드를 간단하게 표현할 수 있도록 고안되었다.\n\n람다식은 하나의 메서드를 한 줄로 정의하기 때문에, 함수형 인터페이스에 추상 메서드가 두 개 이상 존재하면 람다식으로 표현할 방법이 없으므로 람다 표현의 대상이 될 수 없다.\n단, 자바 8부터 함수형 인터페이스에는 `default`, `static`, `private` 메서드를 추가할 수 있는데 이러한 메서드들은 추상 메서드가 아니기 때문에 인터페이스 내에 존재하더라도 람다식을 사용할 수 있다.\n\n```java\n// 함수형 인터페이스 - 하나의 추상 메서드만 존재\ninterface IAdd {\n    int add(int x, int y);\n}\n\n// 함수형 인터페이스가 아닌 경우 - 두 개의 추상 메서드 존재\ninterface ICalculate {\n    int add(int x, int y);\n    int subtract(int x, int y);\n}\n\n// 다양한 구성요소를 포함해도 추상 메서드가 하나면 함수형 인터페이스\ninterface IAdd {\n    int add(int x, int y);\n\n    final boolean isNumber = true; // 상수 필드\n    default void print() {}; // 디폴트 메서드\n    static void printStatic() {}; // 정적 메서드\n}\n```\n\n### @FunctionalInterface\n\n함수형 인터페이스를 정의할 때, @FunctionalInterface 어노테이션을 추가하면 추상 메서드가 하나만 존재해야 함을 컴파일러가 확인해준다.\n이 어노테이션을 붙임으로써 실수로 두 개 이상의 추상 메서드를 정의하는 경우 컴파일 오류가 발생하게 되어, 함수형 인터페이스 규칙을 명확히 준수할 수 있다.\n\n```java\n@FunctionalInterface\npublic interface MyFunctionalInterface {\n    void method();\n    // void anotherMethod(); // 추가 시 컴파일 오류 발생\n}\n```\n\n## 람다식의 타입 추론\n\n람다식은 리턴 타입이나 파라미터 타입을 명시하지 ㅇ낳는 점에서 컴파일러가 이 함수의 타입을 어떻게 인식하는지 궁금할 수 있다.\n사실, 컴파일러는 람다식을 보고 해당 함수의 타입을 스스로 추론하는데, 이 타입 추론은 사람이 미리 정의해놓은 타입 정보와 정의문을 보고 이루어진다.\n대부분의 함수형 인터페이스는 제네릭을 사용하기에 컴파일러가 타입을 추론하는데 필요한 타입 정보 대부분을 제네릭에서 판별해서 얻을 수 있다.\n\n아래 코드에서는 List<String> 타입의 리스트를 생성하고 Collections 클래스의 sort 메서드를 호출한다.\nsort 메서드는 첫 번째 인자로 리스트 객체를 받고, 두 번째 인자로는 람다식을 사용하여 문자열 길이를 기준으로 리스트를 정렬한다.\n\n```java\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n        // 문자열 길이를 기준으로 정렬\n        Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n    }\n}\n```\n\n여기서 컴파일러의 타입 추론 과정은 다음과 같다.\n\n1. `sort` 메서드의 첫 번째 매개변수로 `List<String>` 객체가 전달된다.\n2. 첫 번째 매개변수 타입으로 인해 `sort` 메서드의 제네릭 타입 매개변수는 `String`으로 지정된다.\n3. `Comparator` 인터페이스의 제네릭 타입 `T`도 `String`으로 지정된다.\n    - `Integer.compare(s1.length(), s2.length())`는 `Comparator` 함수형 인터페이스를 구현한 것이다.\n4. 최종적으로 람다식의 매개변수 s1과 s2는 String 타입으로, 리턴 타입은 `int`로 추론된다.\n\n따라서 위 코드와 같은 람다식에서 파라미터 타입을 명시하지 않더라도, 컴파일러는 제네릭 정보로 인해 String 타입 파라미터와 int 타입 리턴 타입을 자동으로 추론할 수 있다.\n\n### 명시적 타입 지정\n하지만, 상황에 따라 파라미터 타입을 명시적으로 작성하는 것이 유리할 때도 있다.\n특히, 복잡한 람다식에서는 타입을 명시하는 것이 코드의 카독성을 향상 시켜준다.\n이 부분은 상황에 따라 개발자가 트레이드 오프를 해야한다.\n```java\n// 람다식 파라미터 타입 명시\nCollections.sort(words, (String s1, String s2) -> Integer.compare(s1.length(), s2.length()));\n```\n\n## 람다 표현식의 한계\n\n람다 표현식은 자바 코드를 간결하게 만들지만, 모든 상황에 적합한 것은 아니다.\n람다 표현식이 갖는 몇 가지 한계점과 사용 시 주의사항을 살펴보겠다.\n\n### 람다는 문서화할 수 없다\n\n람다는 이름 없는 함수이기 때문에 메서드나 클래스와 다르게 문서화를 할 수 없다.\n코드 자체로 동작이 명확하게 설명되지 않거나, 람다가 길거나 읽기 어려운 경우에는 코드의 가독성과 유지보수를 고려해 람다를 쓰지 않는 방향으로 리팩토링하는 것이 좋다.\n\n### 람다는 디버깅이 어렵다\n\n람다식은 기본적으로 익명 구현 객체 기반으로 동작하여, 콜 스택(call stack) 추적이 어렵다.\n예를 들어, 0으로 나누는 오류가 발생하는 코드를 `for` 문과 람다식을 사용한 코드로 각각 구현했을 때, 오류 메시지에 표시되는 줄이 다르다.\n\n```java\n// 일반 for문 사용\npublic static void main(String[] args) {\n    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n    for (Integer i : list) {\n        for (int j = 0; j < i; j++) {\n            System.out.println(i / j); // 0으로 나누는 예외 발생\n        }\n    }\n}\n```\n\n```java\n// 람다 표현식 사용\npublic static void main(String[] args) {\n    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n    list.forEach(i -> {\n        IntStream.range(0, i).forEach(j -> {\n            System.out.println(i / j); // 0으로 나누는 예외 발생\n        });\n    });\n}\n```\n\n### Stream의 람다 사용은 `for` 문보다 성능이 떨어진다\n\n성능에 민감한 환경에서는 람다 표현식과 `Stream`이 일반 `for` 문보다 성능이 낮을 수 있다.\n아래 코드는 0부터 10,000까지 단순 순회하는 코드를 `Stream`의 람다와 `for` 문으로 각각 구성하여 실행 시간을 비교한다.\n\n```java\npublic static void main(String[] args) {\n    // 람다식 stream 순회\n    long startTime = System.nanoTime();\n    IntStream.range(0, 10000).forEach(value -> {});\n    long endTime = System.nanoTime();\n    System.out.println(\"람다식 stream 순회: \" + (endTime - startTime) + \"ns\");//13870700ns\n\n    // 일반 for문 순회\n    startTime = System.nanoTime();\n    for (int i = 0; i < 10000; i++) {}\n    endTime = System.nanoTime();\n    System.out.println(\"일반 for문 순회: \" + (endTime - startTime) + \"ns\");//43900ns\n}\n```\n\n### 람다를 남발하면 코드가 지저분해질 수 있다\n\n람다식은 실행부에서 직접 동작을 지정하기 때문에, 남발하면 비슷한 형태의 람다식이 반복되어 코드가 지저분해질 수 있다.\n예를 들어, 아래 코드와 같이 여러 연산을 위한 람다식을 매번 작성하면 코드가 반복적으로 길어질 수 있다.\n\n```java\ninterface OperationStrategy {\n    int calculate(int x, int y);\n}\n\n// 템플릿 클래스\nclass OperationTemplate {\n    int calculate(int x, int y, OperationStrategy cal) {\n        return cal.calculate(x, y);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int x = 100;\n        int y = 30;\n\n        OperationTemplate template = new OperationTemplate();\n\n        // 각 연산을 위한 람다식\n        System.out.println(template.calculate(x, y, (a, b) -> a + b)); // 덧셈\n        System.out.println(template.calculate(x, y, (a, b) -> a - b)); // 뺄셈\n        System.out.println(template.calculate(x, y, (a, b) -> a * b)); // 곱셈\n        System.out.println(template.calculate(x, y, (a, b) -> a / b)); // 나눗셈\n    }\n}\n```\n\n### 람다식은 재귀 호출에 부적합하다\n\n람다식은 재귀 함수를 작성하는 데 적합하지 않다.\n특히, 재귀 람다식을 사용하려고 하면 컴파일 오류가 발생할 수도 있다.\n예를 들어, 팩토리얼 함수를 람다식으로 작성하려 하면 다음과 같은 오류가 발생한다.\n\n```java\npublic static void main(String[] args) {\n    UnaryOperator<Long> factorial = (x) -> {\n        return x == 0 ? 1 : x * factorial.apply(x - 1); // 컴파일 오류 발생\n    };\n\n    System.out.println(factorial.apply(5L));\n}\n```\n\n이처럼, 람다식은 내부에서 자기 자신을 참조하는 재귀 호출이 불가능하며, 이는 함수형 인터페이스의 제한으로 인해 발생하는 문제다.\n\n\n## 스트림(Stream)\n\n이처럼 람다 표현식은 개별 연산을 간단히 표현하기에 탁월하지만, 컬렉션 전체에 걸친 데이터 흐름을 나타내기에는 제한적이다.\n람다식으로는 단일 동작만 표현할 수 있고, 복잡한 데이터를 다룰 때에는 여전히 반복문과 조건문이 필요했다.\n때문에 전체 데이터 흐름을 선언적으로 표현하기에는 한계가 있었다.\n이러한 부분들을 보완하고자 자바 8에서 람다와 같이 스트림(Stream)이 함께 출시되게 되었다.\n\n스트림은 컬렉션과 배열의 데이터를 람다처럼 간결하고 효율적으로 처리하기 위한 연속 데이터 처리 프레임워크다.\n스트림을 통해 데이터를 필터링, 매핑, 정렬 등 다양한 연산을 선언적으로 수행할 수 있고, 이로 인해 복잡한 반복문 대신 가독성이 높은 코드로 데이터 처리 흐름을 구성할 수 있다.\n\n스트림의 주요 특징으로는 다음과 같다.\n- 지연 연산: 스트림은 필요할 때에만 연산을 수행한다. 최종 연산이 호출되기 전까지는 실제 연산이 수행되지 않고, 설정한 모든 연산이 최종 연산 시점에 한꺼번에 처리된다.\n- 병렬 처리: `parallelStream`을 사용해 병렬 처리를 수행할 수 있어서 대용량 데이터 처리에 적합하다.\n\n### 스트림 수행 과정\n\n스트림은 다음과 같은 과정들을 통해 수행되어진다.\n\n#### 스트림 생성\n\n스트림을 이용하기 위해서는 먼저 스트림을 생성해야한다.\n`Stream Collection.stream()` 을 이용하여 원하는 타입의 컬렉션을 기반으로 스트림을 생성할 수 있다.\n\n#### 중간 연산\n\n데이터의 유형 변환 혹은 필터링, 정렬 등 스트림을 활용하기 전 데이터를 필요에 따라 가공하는 작업이 필요하다.\n이를 위해서 사용되는 메소드를은 다음과 같다.\n\n- map(변환)\n- sorted(정렬)\n- skip(스트림 자르기)\n- limit(스트림 자르기)\n\n#### 최종 연산\n\n스트림이 한번 결과를 반환하면, 이후에는 닫혀서 재사용이 불가능하다.\n최종 연산 결과 값은 하나의 값이거나, 배열 혹은 다른 유형의 컬렉션 데이터일 수 있다.\n그러므로 필요에 따라, 결과값의 데이터 타입을 변환하거나 결과값을 가지고 원하는 형태로 바꾸는 추가적인 최종 연산이 필요할 수 있다.\n예를 들어 `collect()` 매서드를 활용해 다른 컬렉션 유형으로 변환하거나 `reduce` 를 활용하여 특정한 수 만큼 일정하게 값이 증가하는 증분연산(Incremental Calculation)을 할 수도 있다.\n필요에 따라서 다양한 형태의 연산이 가능하다.\n\n```java\nList<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n// 스트림을 사용하여 데이터 필터링, 매핑, 정렬, 출력\nwords.stream()\n   .filter(word -> word.length() > 4)    // 길이가 4보다 큰 단어만 남김\n   .map(String::toUpperCase)             // 대문자로 변환\n   .sorted()                             // 정렬\n   .forEach(System.out::println);        // 출력\n```\n"},{"excerpt":"제네릭(Generics)이란? 자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정할 수 있는 기법을 의미한다.\n제네릭을 통해 각 객체가 서로 다른 타입의 데이터를 다룰 수 있게 되어, 객체 지향 프로그래밍의 다형성을 더욱 유연하게 활용할 수 있다. 예를 들어, 자주 사용되는 와 같은 컬렉션 클래스에서 과 같은 꺾쇠 괄호…","fields":{"slug":"/java-generic/"},"frontmatter":{"date":"November 05, 2024","title":"자바 제네릭(Generics)","tags":["Java"]},"rawMarkdownBody":"\n# 제네릭(Generics)이란?\n\n<hr>\n\n자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정할 수 있는 기법을 의미한다.\n제네릭을 통해 각 객체가 서로 다른 타입의 데이터를 다룰 수 있게 되어, 객체 지향 프로그래밍의 다형성을 더욱 유연하게 활용할 수 있다.\n\n예를 들어, 자주 사용되는 `List`와 같은 컬렉션 클래스에서 `<String>`과 같은 꺾쇠 괄호(`<>`)를 보았을 것이다.\n\n```java\nArrayList<String> list = new ArrayList<>();\n```\n\n위 코드에서 `<String>`이 바로 제네릭 타입이다.\n`ArrayList`가 `String` 타입으로 지정되면, 이 리스트는 오직 문자열만을 저장할 수 있게 된다.\n배열과 리스트의 선언문 형태를 비교해 보면, 배열처럼 컬렉션 자료형의 타입을 외부에서 지정해주는 방식이라고 생각할 수 있다.\n\n이처럼 제네릭은 컬렉션 클래스나 메서드에서 사용할 내부 데이터 타입을 파라미터처럼 외부에서 지정하여, 유연한 타입 변수를 사용하는 기능이라고 볼 수 있다.\n\n> 제네릭을 통해 객체에 타입을 지정하는 것은 변수를 선언할 때 타입을 지정하는 것과 비슷한 개념이다.\n\n## 제네릭 타입 매개변수\n\n제네릭은 `<>` 꺾쇠 괄호를 사용해 타입을 지정한다.\n이 괄호는 다이아몬드 연산자라고 불리며, 괄호 안의 기호는 타입 매개변수(type parameter)를 의미한다.\n\n### 타입 파라미터 정의\n\n제네릭 타입은 주로 클래스나 메서드를 설계할 때 사용된다.\n다음은 제네릭을 사용하여 정의된 클래스 예제이다.\n\n```java\nclass FruitBox<T> {\n    List<T> fruits = new ArrayList<>();\n\n    public void add(T fruit) {\n        fruits.add(fruit);\n    }\n}\n```\n\n위에서 `<T>` 기호를 통해 `FruitBox` 클래스가 제네릭 타입을 사용함을 볼 수 있다.\n인스턴스를 생성할 때 타입을 명시하면, 해당 타입이 `T`로 지정되어 클래스 내부에서 사용된다.\n\n```java\n// 정수 타입\nFruitBox<Integer> intBox = new FruitBox<>();\n\n// 실수 타입\nFruitBox<Double> doubleBox = new FruitBox<>();\n\n// 문자열 타입\nFruitBox<String> strBox = new FruitBox<>();\n\n// 클래스 타입 (예: Apple 클래스)\nFruitBox<Apple> appleBox = new FruitBox<>();\n```\n\n이처럼 실행 시 지정한 타입이 `T`로 전파되어 타입이 구체화되는 과정을 구체화(Specialization)라 한다.\n\n### 타입 파라미터 생략\n\nJDK 1.7 이후부터는 생성자 부분의 제네릭 타입은 생략할 수 있다. 컴파일러가 타입을 자동으로 추론하기 때문이다.\n\n```java\nFruitBox<Apple> appleBox = new FruitBox<>();\n```\n\n## 제네릭 타입 제한\n\n제네릭 타입으로 원시 타입(Primitive Type)은 사용할 수 없다.\n즉, `int`, `double`과 같은 기본 타입을 제네릭 타입 파라미터로 사용할 수 없고, 대신 `Integer`, `Double`과 같은 Wrapper 클래스를 사용해야 한다.\n\n```java\n// 기본 타입 int 사용 불가\nList<int> intList = new ArrayList<>(); // 오류 발생\n\n// Wrapper 클래스 사용\nList<Integer> integerList = new ArrayList<>();\n```\n\n제네릭을 통해 클래스 간 상속 관계를 활용한 다형성도 적용할 수 있다.\n\n```java\nclass Fruit { }\nclass Apple extends Fruit { }\nclass Banana extends Fruit { }\n\nclass FruitBox<T> {\n    List<T> fruits = new ArrayList<>();\n\n    public void add(T fruit) {\n        fruits.add(fruit);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FruitBox<Fruit> box = new FruitBox<>();\n\n        box.add(new Fruit());\n        box.add(new Apple()); // 업캐스팅 적용\n        box.add(new Banana()); // 업캐스팅 적용\n    }\n}\n```\n\n## 복수 타입 파라미터\n\n제네릭 타입은 하나 이상 지정할 수 있다.\n여러 타입이 필요할 경우 `<T, U>`와 같이 쉼표로 구분해 여러 타입 파라미터를 지정할 수 있다.\n\n```java\nclass Apple {}\nclass Banana {}\n\nclass FruitBox<T, U> {\n    List<T> apples = new ArrayList<>();\n    List<U> bananas = new ArrayList<>();\n\n    public void add(T apple, U banana) {\n        apples.add(apple);\n        bananas.add(banana);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FruitBox<Apple, Banana> box = new FruitBox<>();\n        box.add(new Apple(), new Banana());\n    }\n}\n```\n\n## 중첩 타입 파라미터\n\n제네릭 객체를 제네릭 타입 파라미터로 사용하는 중첩 형식도 가능하다.\n\n```java\npublic static void main(String[] args) {\n    // LinkedList<String>을 원소로 가지는 ArrayList\n    ArrayList<LinkedList<String>> list = new ArrayList<>();\n\n    LinkedList<String> node1 = new LinkedList<>();\n    node1.add(\"apple\");\n    node1.add(\"banana\");\n\n    LinkedList<String> node2 = new LinkedList<>();\n    node2.add(\"cherry\");\n    node2.add(\"date\");\n\n    list.add(node1);\n    list.add(node2);\n    System.out.println(list);\n}\n```\n\n## 타입 파라미터 네이밍 규칙\n\n제네릭 기호는 보통 `<T>`와 같이 표현되지만, 통상적인 명명 규칙이 존재한다.\n이러한 관례는 가독성을 높이고 코드 이해를 돕는다.\n\n- `<T>`: 타입(Type)\n- `<E>`: 요소(Element), 주로 `List`에서 사용\n- `<K>`: 키(Key), 주로 `Map<K, V>`에서 사용\n- `<V>`: 값(Value), 매핑된 값\n- `<N>`: 숫자(Number)\n- `<S, U, V>`: 2번째, 3번째, 4번째 타입\n\n## 제네릭 사용 이유와 이점\n\n### 컴파일 타임에 타입 검사 가능\n\n제네릭은 컴파일 타임에 타입을 검사하여 타입 안전성을 보장한다.\n예를 들어, JDK 1.5 이전에는 `Object` 타입을 인수나 반환값으로 사용했지만, 타입 변환 시 런타임 오류가 발생할 위험이 있었다.\n\n```java\nclass Apple {}\nclass Banana {}\n\nclass FruitBox {\n    private Object[] fruits;\n\n    public FruitBox(Object[] fruits) {\n        this.fruits = fruits;\n    }\n\n    public Object getFruit(int index) {\n        return fruits[index];\n    }\n}\n```\n\n위와 같은 코드에서는 `FruitBox`가 `Object` 타입을 사용해 모든 타입을 저장할 수 있지만, 형변환 오류를 컴파일 시점에 감지하지 못해 런타임 에러가 발생할 수 있다.\n제네릭을 사용하면 이 문제를 해결할 수 있다.\n\n```java\nclass FruitBox<T> {\n    private T[] fruits;\n\n    public FruitBox(T[] fruits) {\n        this.fruits = fruits;\n    }\n\n    public T getFruit(int index) {\n        return fruits[index];\n    }\n}\n\npublic static void main(String[] args) {\n    Apple[] apples = { new Apple(), new Apple() };\n    FruitBox<Apple> box = new FruitBox<>(apples);\n\n    Apple apple = box.getFruit(0); // 안전한 형변환\n}\n```\n\n### 불필요한 형변환 제거로 성능 향상\n\n제네릭을 사용하면 형변환이 필요 없어 성능이 향상된다.\n\n```java\n// 형변환이 필요 없음\nFruitBox<Apple> box = new FruitBox<>(apples);\n\nApple apple1 = box.getFruit(0);\nApple apple2 = box.getFruit(1);\n```\n\n형변환이 없어짐에 따라 코드의 가독성이 높아지고, 형변환으로 인한 오버헤드가 줄어들어 성능이 개선된다.\n\n## 제네릭 사용 시 주의사항\n\n### 제네릭 타입의 객체 생성 불가\n\n제네릭 타입 자체로 객체를 생성할 수 없다.\n즉, `new` 연산자 뒤에 제네릭 타입 파라미터를 사용할 수 없다.\n\n```java\nclass Sample<T> {\n    public void someMethod() {\n        T t = new T(); // 컴파일 오류\n    }\n}\n```\n\n### static 멤버에 제네릭 타입 사용 불가\n\n`static` 변수나 메서드에서는 제네릭 타입 파라미터를 사용할 수 없다.\n`static` 멤버는 클래스가 공통으로 사용하는 변수이기 때문에, 제네릭 객체 생성 전에 타입이 결정되어야 하기 때문이다.\n\n```java\nclass Student<T> {\n    private String name;\n\n    // static 메서드의 반환 타입\n\n에 제네릭 타입 사용 불가\n    public static T getInstance() {  // 오류 발생\n        return new T();\n    }\n}\n```\n\n### 제네릭으로 배열 선언 주의점\n\n제네릭 타입의 배열은 만들 수 없지만, 제네릭 배열 선언은 허용된다.\n\n```java\nclass Sample<T> {}\n\npublic class Main {\n    public static void main(String[] args) {\n        // 제네릭 배열 선언 허용\n        Sample<Integer>[] arr = new Sample[10];\n        \n        // 제네릭 타입을 생략해도 위에서 Integer로 지정된 제네릭 타입을 추론\n        arr[0] = new Sample<>();\n    }\n}\n```"},{"excerpt":"프로그램에서 오류가 발생하면 시스템 레벨에서 문제를 일으켜 원치 않는 버그를 유발하거나, 심각한 경우 프로그램을 강제로 종료시키기도 한다.\n이러한 오류의 원인은 다양하며, 내부적으로 프로그램 설계 로직의 허점에서 비롯될 수 있고, 외부적으로는 프로그램 자체가 아닌 하드웨어 문제로 인해 발생할 수도 있다. 이 글에서는 자바 이것들을 어떻게 처리하는 알아본다…","fields":{"slug":"/java-exception-error/"},"frontmatter":{"date":"November 05, 2024","title":"자바 에러(Error)와 예외처리(Exception)","tags":["Java"]},"rawMarkdownBody":"\n프로그램에서 오류가 발생하면 시스템 레벨에서 문제를 일으켜 원치 않는 버그를 유발하거나, 심각한 경우 프로그램을 강제로 종료시키기도 한다.\n이러한 오류의 원인은 다양하며, 내부적으로 프로그램 설계 로직의 허점에서 비롯될 수 있고, 외부적으로는 프로그램 자체가 아닌 하드웨어 문제로 인해 발생할 수도 있다.\n\n이 글에서는 자바 이것들을 어떻게 처리하는 알아본다.\n\n# 프로그래밍의 오류 종류\n\n<hr>\n\n프로그래밍을 하다 보면 단순한 오타부터 해서 파일이 존재하지 않는 문제, 또는 메모리 누수와 같은 오류까지 다양한 종류의 오류를 경험하게 된다.\n이러한 오류는 발생 시점에 따라 크게 세 가지로 구분할 수 있다.\n\n- 논리적 에러(Logical Error): 코드가 실행은 되지만, 의도한 대로 동작하지 않는 오류로, 프로그램이 예상과 다른 결과를 반환할 때 발생한다.\n- 컴파일 에러(Compile-time Error): 코드가 컴파일될 때 발생하는 오류로, 주로 문법 오류나 잘못된 타입 사용 등이 원인이다.\n- 런타임 에러(Runtime Error): 프로그램이 실행되는 도중 발생하는 오류로, 주로 NullPointerException이나 ArrayIndexOutOfBoundsException과 같은 예외가 이에 해당한다.\n\n## 논리적 에러\n\n논리적 에러(Logical Error)는 흔히 버그로 알려져 있으며, 프로그램이 정상적으로 실행되고 있는 것처럼 보여도 예상한 결과가 나오지 않음으로써 문제를 일으킬 수 있다.\n이러한 오류는 사용자가 의도한 작업이 제대로 수행되지 않게 하여 서비스 이용에 지장이 될 수 있다.\n\n논리적 오류는 프로그램 입장에서는 아무런 문제 없이 실행되기 때문에 에러 메시지를 출력하지 않는다. 따라서 개발자가 직접 프로그램의 전반적인 로직과 알고리즘을 검토해야 한다.\n\n## 컴파일 에러\n\n컴파일 에러(Compilation Error)는 프로그램을 컴파일하는 과정에서 발생하는 오류로, 대표적인 원인으로는 문법 오류(syntax error)가 있다.\n\n컴파일에러는 IDE(Integrated Development Environment)에서 일정 주기로 소스를 자동으로 컴파일하여 오류를 미리 표시함으로써 즉시 알려주는 경우가 많아, 비교적 해결하기 쉬운 오류다.\n컴파일에 성공하지 않으면 프로그램이 생성되지 않아 실행 자체가 불가능하므로, 개발자는 컴파일러가 표시하는 오류를 수정하여 해결하면 된다.\n\n## 런타임 에러\n\n런타임 에러(Runtime Error)는 컴파일 과정에서 문제없이 통과해 프로그램이 실행되더라도 실행 중에 발생하는 오류로, 프로그램이 비정상적으로 종료되거나 예상치 못한 결과를 초래할 수 있으며, 메모리 부족같은 외부요인으로 인해 발생하기도 한다.\n\n이것이 이 글에서 중점으로 생각해보는 내용이다. 이러한 런타임 에러는 주로 설계 미숙에서 기인하며, 발생 시 역추적하여 원인을 파악해야 한다.\n이를 방지하기 위해서는 다양한 예외 상황을 미리 고려하고 대비해야 한다.\n\n## 오류와 예외\n자바에서는 **실행 시(Runtime) 발생할 수 있는 문제를 에러(Error)와 예외(Exception)로 구분**한다.\n\n![Error Exception](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_1.png)\n\n에러는 메모리 부족(`OutOfMemoryError`)이나 스택 오버플로우(`StackOverflowError`)처럼, 프로그램 코드로 해결할 수 없는 심각한 오류다.\n에러는 예측이 어려우며 발생 시 복구가 거의 불가능하다. 시스템이나 JVM 레벨에서 발생하는 경우가 개발자가 대처하기도 힘들다.\n\n예외는 잘못된 로직, 잘못된 입력값, 예상 외의 입력 패턴 등으로 인해 발생하는 오류다.\n그래서 예외는 에러와 달리 발생하더라도 대비 코드를 작성해, 예상치 못한 상황에서도 프로그램이 비정상적으로 종료 혹은 동작이 수행되지 않도록 방지할 수 있다.\n이러한 예외에 대한 대비 코드가 예외 처리 문법인 `try-catch`다.\n\n# 자바의 예외 클래스\n\n<hr>\n\n## 예외 클래스의 계층구조\n\n자바는 프로그램 실행 중 예외가 발생하면 해당 예외에 맞는 객체를 생성하고, 예외처리 코드에서 이 객체를 이용해 오류를 파악하고 해결할 수 있게 도와준다.\n자바에서는 오류를 `Error`와 `Exception`라는 클래스로 계층적으로 구조를 나누어 관리한다.\n\n![Throwable Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_2.png)\n\n`Error` 클래스는 주로 시스템 레벨의 심각한 오류를 나타내며, 개발자가 해결할 수 없는 외부적인 문제로 간주된다.\n반면, `Exception` 클래스는 애플리케이션 레벨에서 발생하는 오류를 관리하기 때문에, 우리가 주로 다루어야 할 대상이다.\n\n> `Throwable` 클래스는 최상위 클래스인 `Object`를 상속받는다. 예외와 오류 메시지를 담는 역할을 하며, 대표적으로 `getMessage()`와 `printStackTrace()` 메서드를 제공하여 예외의 원인과 발생 위치를 추적할 수 있게 한다.\n\n자바에서 다루는 모든 예외는 `Exception` 클래스로 처리하는데 컴파일 시점에서 체크되는 `Checked Exception`과 런타임에 발생하는 `RuntimeException`으로 나누어 관리한다.\n\n![Exception Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_3.png)\n\n### 컴파일 타임 예외 클래스\n\n`Checked Exception`은 프로그램 외부 요인으로 인해 발생하는 예외로, 컴파일러가 예외처리를 강제한다.\n\n- `FileNotFoundException`: 파일을 찾을 수 없을 때 발생한다.\n- `ClassNotFoundException`: 클래스가 로드되지 않았을 때 발생한다.\n- `IOException`: 입출력 작업 중 문제가 발생할 때 발생한다.\n- `SQLException`: 데이터베이스 접근 오류 발생 시 발생한다.\n\n### 런타임 예외 클래스\n\n반면, `RuntimeException`은 개발자의 실수로 인해 발생하는 예외로, 주로 코드의 논리적 오류에서 비롯된다.\n예외처리를 강제하지 않는다.\n\n- `IndexOutOfBoundsException`: 배열이나 리스트의 범위를 벗어났을 때 발생한다.\n- `NullPointerException`: null인 객체에 접근할 때 발생한다.\n- `ArithmeticException`: 숫자를 0으로 나누려 할 때 발생한다.\n- `ClassCastException`: 잘못된 타입 변환 시 발생한다.\n- `ArrayIndexOutOfBoundsException`: 배열의 범위를 넘어선 인덱스를 참조할 때 발생한다.\n- `NumberFormatException`: 정수가 아닌 문자열을 정수로 변환할 때 발생한다.\n\n# Checked Exception과 Unchecked Exception\n\n<hr>\n\n`Exception`은 예외를 처리할지 여부를 강제할지에 따라 `Checked Exception`과 `Unchecked Exception`으로 나눈다.\n간단히 정리하자면 `Checked Exception`은 컴파일 단계에서 검출되는 예외이고, `Unchecked Exception`은 런타임 중에 발생하는 예외를 말한다.\n\n![Exception Hierarchy](https://raw.githubusercontent.com/023-dev/023-dev.github.io/refs/heads/main/_posts/_images/java-exception-error/java-exception-error_4.png)\n\n## 코드에서 명시적 예외 처리 유무\n\nChecked Exception와 Unchecked Exception의 차이점은 명시적 예외 처리의 의무 여부이다.\n`Checked Exception`은 컴파일 단계에서 체크하기 때문에 예외처리를 하지 않았다면 컴파일이 진행되지 않는다.\n따라서 `Checked Exception`을 발생시킬 가능성이 있는 메서드라면 반드시 `try-catch`로 감싸거나 `throws`로 예외를 처리해야 한다.\n\n```java\n// try - catch로 예외 처리\npublic static void fileOpen() {\n    try {\n        FileWriter file = new FileWriter(\"data.txt\");\n        file.write(\"Hello World\");\n        file.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n// throws로 예외 처리\npublic static void fileOpen() throws IOException {\n    FileWriter file = new FileWriter(\"data.txt\");\n    file.write(\"Hello World\");\n    file.close();\n}\n```\n\n반면, `Unchecked Exception`는 개발자가 충분히 예방할 수 있는 경우로 명시적인 예외처리가 강제되지 않는다.\n즉, 런타임 시 예외가 발생하더라도, 개발자가 사전에 주의를 기울여 방지할 수 있기 때문에 자바 컴파일러는 예외처리를 필수로 요구하지 않는다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        while (true) {\n            String s = null;\n            s.length(); // NullPointerException 발생 (Unchecked Exception이므로 예외 처리 의무 없음)\n        }\n    }\n}\n```\n\n위 코드는 `NullPointerException`을 발생시키지만, `Unchecked Exception`이기 때문에 `try-catch`로 감싸지 않아도 컴파일 시 오류가 발생하지 않는다.\n프로그램은 예외가 발생해도 오류 로그만 쌓일 뿐, 프로그램 전체가 즉각 종료되는 상황을 초래하지 않는다.\n\n## Checked Exception를 Unchecked Exception로 변환하기\n\n`Checked Exception`은 반드시 `try-catch`로 감싸거나 `throws`로 처리해야 하지만, 모든 코드에서 예외 처리를 강제하는 것은 번거롭고 가독성을 해칠 수 있다.\n이때 `Chained Exception` 기법을 사용해 `Checked Exception`을 `Unchecked Exception`으로 변환하면, 예외 처리를 선택적으로 할 수 있다.\n\n예를 들어, `IOException` 같은 `Checked Exception`을 `RuntimeException`으로 감싸면 `Unchecked Exception`으로 전환되어 컴파일러가 예외 처리를 강제하지 않는다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        install();\n    }\n\n    public static void install() {\n        throw new RuntimeException(new IOException(\"설치할 공간이 부족합니다.\"));\n    }\n}\n```"},{"excerpt":"1. 포스트 추가하기  경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다. 1-1. 포스트 파일 구조 새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면,  파일을  디렉토리에 추가할 수 있습니다. 두번째 방법은 먼저 디…","fields":{"slug":"/writing-guide-kr/"},"frontmatter":{"date":"April 03, 2021","title":"🤔 3. 작성 가이드","tags":["hoodie","writing-guide"]},"rawMarkdownBody":"\n## 1. 포스트 추가하기\n\n`contents/post` 경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다.\n\n### 1-1. 포스트 파일 구조\n\n새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면, `about-javascript.md` 파일을 `contents/posts` 디렉토리에 추가할 수 있습니다.\n\n두번째 방법은 먼저 디렉토리를 생성한 뒤, 디렉토리 안에 `index.md` 파일을 추가하는 것 입니다. 이 방법은 문서 내에 여러 이미지 파일 등 부수적인 파일 여러개가 포함되었을 때 유용합니다.\n\n첫번째 방법으로 생성한 파일명이나, 두번째 방법으로 생성한 디렉토리 이름은 웹사이트에서 고유의 주소를 갖습니다. `https://siteURL/about-javascript` 와 같이요.\n\n### 1-2. Frontmatter\n\n마크다운은 문서의 메타데이터인 Frontmatter 라 불리는 정보를 가지고 있습니다.\n\n```\n---\ntitle: \"🤔 3. 작성 가이드\"\ndescription: \"어떻게 글을 작성하고 추가할까요?\"\ndate: 2021-04-03\nupdate: 2021-04-03\ntags:\n  - hoodie\n  - writing-guide\nseries: \"gatsby-starter-hoodie 로 블로그 시작하기\"\n---\n```\n\n위는 지금 여러분이 읽고 있는 문서의 Frontmatter 입니다. `title` 과 `date` 는 필수 값입니다. 띄어쓰기를 포함된 문자열을 입력할 때에는 따옴표로 감싸는 것을 추천합니다.\n\n### 1-3. 마크다운 작성하기\n\n만약 Frontmatter 까지 작성했다면, 여러분은 그 아래에 마크다운 문서를 작성하면 됩니다. gatsby-starter-hoodie 는 대부분의 마크다운 문법을 지원합니다. 마크다운 작성 방법을 알고 싶다면, Github 의 Mastering Markdown[^1] 문서를 참고하세요.\n\n## 2. 코드 하이라이팅 & Katex\n\n### 2-1. 코드 하이라이팅\n\nPrism.JS 에 기반한 코드 하이라이팅이 제공됩니다.\n\n#### 예시\n\nJavascript\n\n```javascript\nconsole.log(\"Hello, world!\")\n```\n\nPython\n\n```python\nprint(\"Hello, world!\")\n```\n\n그 외 더 많은 언어를 제공합니다. 제공되는 언어를 확인하고 싶다면, [Prism.js 웹사이트](https://prismjs.com/) 를 참고하세요.\n\n### 2-2. Katex\n\nKatex 문법을 지원하여 복잡한 수식도 쉽게 표현할 수 있습니다.\n\n#### 인라인 모드\n\n$$E = m c^{2}$$\n\n#### 블럭 모드\n\n$$\n\\int_{0}^{\\infty} f(x) dx\n$$\n\n## 3. 글에 이미지 추가하기\n\n상대경로를 이용하여 쉽게 이미지를 추가할 수 있습니다. 디렉토리를 생성하고 그 안에 `index.md` 를 추가하여, 글을 추가하는 방법으로 작성해야 이미지 관리가 쉽습니다.\n\n![샘플 이미지 캡션](sample-image.jpg)\n\n이미지는 Lazy Loading 으로 로드되어, 빠른 초기 문서 로딩 속도를 확보할 수 있습니다.\n\n> ⚠ 이미지의 모든 확장자는 소문자여야합니다.\n\n## 4. 태그\n\n![](tag-example.jpg)\n\nFrontmatter 의 태그를 통해 쉽게 문서를 분류하고 검색할 수 있습니다. 여러분의 모든 태그는 `https://siteUrl/tags` 경로에서 확인하고, 검색할 수 있습니다.\n\n## 5. 시리즈\n\n![](series-example.jpg)\n\n여러분이 연관된 여러개의 문서를 작성할 때 시리즈를 사용할 수 있습니다. Frontmatter 에 작성된 시리즈가 같은 문서끼리 묶여 문서 상단에 리스트로 표시됩니다. 시리즈는 일련의 순서가 있는 문서들을 작성할 때 유용하게 사용할 수 있습니다. 시리즈는 문서의 작성 날짜 순서대로 정렬됩니다.\n\n현재 문서는 `gatsby-starter-hoodie 로 블로그 시작하기` 라는 시리즈로 설정되어 있습니다.\n\n[^1]: https://guides.github.com/features/mastering-markdown/\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}