{"componentChunkName":"component---src-templates-post-jsx","path":"/database-transaction-recovery/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"16e09090-cb18-56b9-a597-f8b7b472358e","excerpt":"DB 세션에 대해서 설명해주세요. DB 세션은 WAS나 MySQL Workbench 같은 DB 접근 클라이언트와 DB가 맺어놓은 커넥션을 통해 들어온 쿼리 요청을 실행합니다. 커넥션 하나에 세션 하나가 대응 되며, 트랜잭션 수행 도중에는 세션마다 테이블 조회 결과가 달라질 수 있습니다. Commit에 대해서 설명해주세요. Commit은 등록,수정,삭제 등…","html":"<ul>\n<li>\n<p>DB 세션에 대해서 설명해주세요.</p>\n<p><strong>DB 세션은 WAS나 MySQL Workbench 같은 DB 접근 클라이언트와 DB가 맺어놓은 커넥션을 통해 들어온 쿼리 요청을 실행합니다.</strong></p>\n<p><strong>커넥션 하나에 세션 하나가 대응 되며, 트랜잭션 수행 도중에는 세션마다 테이블 조회 결과가 달라질 수 있습니다.</strong></p>\n</li>\n<li>\n<p>Commit에 대해서 설명해주세요.</p>\n<p><strong>Commit은 등록,수정,삭제 등의 쿼리 수행을 통해서, 임시로 변경된 데이터를 DB에 반영하는 것입니다.</strong></p>\n<p><strong>정상적으로 트랜잭션이 수행된다면 Commit을 통해 트랜잭션 결과를 DB에 반영해야합니다.</strong></p>\n</li>\n<li>\n<p>Rollback에 대해서 설명해주세요.</p>\n<p><strong>Rollback은 등록,수정,삭제 등의 쿼리 수행을 통해서, 임시로 변경된 데이터를 DB에 반영하지 않는 것입니다.</strong></p>\n<p><strong>비정상적으로 트랜잭션이 수행된다면 Rollback을 통해 트랜잭션 결과를 DB에 반영하지 말아야합니다.</strong></p>\n</li>\n<li>\n<p>Auto Commit 설정에 대해서 설명해주세요.</p>\n<p><strong>Auto Commit을 true로 설정하면 쿼리를 하나 하나 실행할때마다 자동으로 Commit이 호출됩니다.</strong></p>\n<p><strong>Auto Commit은 false로 설정하면 직접 수동으로 Commit 또는 Rollback을 호출해야합니다.</strong></p>\n<p><strong>Auto Commit을 false로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있습니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션에 대해 설명해주세요.</p>\n<p><strong>트랜잭션은 DB에서 하나의 논리적인 작업을 처리하기 위한 단위입니다.</strong></p>\n<p><strong>트랜잭션은 정상적으로 수행될 경우 commit이 수행되고,</strong></p>\n<p><strong>비정상적으로 수행될 경우 rollback이 수행됩니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션의 성질 ACID에 대해서 설명해주세요.</p>\n<p><strong>원자성은 트랜잭션에 포함된 작업이 모두 수행되거나 모두 수행되지 않는다는 성질입니다.</strong></p>\n<p><strong>일관성은 트랜잭션을 수행하기 전후 데이터베이스는 항상 일관된 데이터 상태를 유지해야하는 성질입니다.</strong></p>\n<p>격리성<strong>은 어떤 테이블에 대해 수행중인 트랜잭션이 있다면 다른 트랜잭션이 끼어들 수 없다는 성질입니다.</strong></p>\n<p><strong>지속성은 성공적으로 수행한 트랜잭션의 결과는 데이터베이스에 영구적으로 반영되어야 한다는 성질입니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션 격리 수준이 뭘까요?</p>\n<p><strong>트랜잭션간의 격리 수준을 뜻합니다.</strong></p>\n<p><strong>동시에 요청되는 여러 트랜잭션들에 대해 각각 격리성을 완벽하게 보장하려면,</strong></p>\n<p><strong>트랜잭션을 한개씩 순서대로 처리해야합니다. 하지만 이렇게하면 동시 처리 성능이 매우 나빠집니다.</strong></p>\n<p><strong>이런 문제로 인해 ANSI 표준에서는 트랜잭션 격리 수준을 4가지로 나누어 정리했습니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션 격리 수준 READ UNCOMMITTIED에 대해서 설명해주세요.</p>\n<p><strong>커밋하지 않은 변경 데이터를 읽을 수 있는 수준입니다.</strong></p>\n<p><strong>트랜잭션 수행중에 다른 트랜잭션이 변경한 데이터를 조회할 수 있게 되는</strong></p>\n<p><strong>DIRTY READ 현상이 발생합니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션 격리 수준 READ COMMITTED에 대해서 설명해주세요.</p>\n<p><strong>커밋한 변경 데이터를 읽을 수 있는 수준입니다.</strong></p>\n<p><strong>트랜잭션 수행중에 다른 트랜잭션이 변경하고 커밋한 데이터를 조회할 수 있는데,</strong></p>\n<p><strong>반복적으로 같은 데이터를 읽을 수 없는 NON-REPEATABLE READ 현상이 발생합니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션 격리 수준 REPEATABLE READ에 대해서 설명해주세요.</p>\n<p><strong>변경 데이터를 읽을 수 없는 수준입니다.</strong></p>\n<p><strong>커밋한 변경 데이터도 읽을 수 없습니다.</strong></p>\n<p><strong>하지만 트랜잭션 수행중에 다른 트랜잭션이 삽입하고 커밋한 데이터는 조회할 수 있습니다.</strong></p>\n<p><strong>이를 PHANTOM READ라고 합니다.</strong></p>\n</li>\n<li>\n<p>트랜잭션 격리 수준 SERIALIZABLE에 대해서 설명해주세요.</p>\n<p><strong>모든 변경 사항을 읽을 수 없는 수준입니다.</strong></p>\n<p><strong>트랜잭션 수행중에 다른 트랜잭션의 모든 변경 사항을 조회할 수 없습니다.</strong></p>\n<p><strong>완벽한 격리성을 제공하지만 동시성 처리 성능이 매우 떨어집니다.</strong></p>\n</li>\n<li>\n<p>DB 동시성 제어에 대해서 설명해주세요.</p>\n<p><strong>동시에 여러개의 트랜잭션을 수행할때 데이터베이스의 일관성을 파괴하지 않도록 제어하는 것을 뜻합니다.</strong></p>\n<p><strong>트랜잭션 격리 수준 조절과 락을 사용하여 동시성을 제어할 수 있습니다.</strong></p>\n</li>\n<li>\n<p>갱신 손실 문제에 대해 설명해주세요.</p>\n<p><strong>두 개의 트랜잭션이 하나의 데이터를 동시에 변경할때,</strong></p>\n<p><strong>결과적으로 한 트랜잭션의 결과만 반영되는 것을 뜻합니다.</strong></p>\n<p><strong>락을 통해서 갱신 손실 문제를 방지할 수 있습니다.</strong></p>\n</li>\n<li>\n<p>DB 락에 대해서 설명해주세요.</p>\n<p><strong>락은 트랜잭션에서 접근하고 있는 데이터에 다른 트랜잭션이 접근하지 못하도록 잠가두는 것을 뜻합니다.</strong></p>\n<p><strong>어떤 세션이 트랜잭션을 시작한후 데이터를 변경하고 싶다면 우선 락을 획득 해야합니다.</strong></p>\n<p><strong>만약 이미 다른 트랜잭션이 락을 획득하고 데이터를 변경하고 있다면,</strong></p>\n<p><strong>락을 획득하기까지 대기합니다. 이때 특정 대기 시간을 넘어가면 락 타임아웃 오류가 발생합니다.</strong></p>\n</li>\n<li>\n<p>DB 데드락에 대해서 설명해주세요.</p>\n<p><strong>데드락이란 서로 다른 트랜잭션 2개가 같은 데이터에 대한 락을 서로 획득하려고 무한정 대기하는 것을 뜻합니다.</strong></p>\n</li>\n<li>\n<p>DB 회복에 대해서 설명해주세요.</p>\n<p><strong>DB에 장애가 발생했을때 데이터베이스를 일관성 있는 상태로 되돌리는 기능입니다.</strong></p>\n<p><strong>회복은 트랜잭션 단위로 진행됩니다.</strong></p>\n</li>\n<li>\n<p>REDO, UNDO에 대해서 설명해주세요.</p>\n<p><strong>REDO는 커밋 내역이 있는 트랜잭션을 DB에 다시 반영하는 것입니다.</strong></p>\n<p><strong>UNDO는 커밋 내역이 없는 트랜잭션을 DB에서 되돌리는 것을 말합니다.</strong></p>\n</li>\n<li>\n<p>체크포인트 회복 기법에 대해서 설명해주세요.</p>\n<p><strong>일정 시간 단위로 DB와 트랜잭션 로그 파일을 동기화 한다음 동시화 시점을 로그 파일에 기록해두는 기법입니다.</strong></p>\n<p><strong>체크포인트 이후 COMMIT 기록이 있는 트랜잭션의 경우 REDO를 진행하고,</strong></p>\n<p><strong>체크포인트 이후 COMMIT 기록이 없는 트랜잭션의 경우 UNDO를 진행합니다.</strong></p>\n</li>\n<li>\n<p>MySQL InnoDB의 기본 트랜잭션 고립 수준은 뭘까요?</p>\n</li>\n</ul>","frontmatter":{"title":"DB 트랜잭션, 회복","date":"January 29, 2025","update":null,"tags":["Database"],"series":null},"fields":{"slug":"/database-transaction-recovery/","readingTime":{"minutes":9.015}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"9142cd48-5969-5dff-8b0a-1ca7f8164545","fields":{"slug":"/item-05/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"5e51d765-fc56-5fc0-9efb-93e8c323c43c","fields":{"slug":"/item-16/"},"frontmatter":{"title":"public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"b20a27d1-efe1-5df8-8fc6-70b1b621850d","fields":{"slug":"/item-15/"},"frontmatter":{"title":"클래스와 멤버의 접근 권한을 최소화하라"}}},{"node":{"id":"008bff3b-a610-5097-8737-2973f0ce221f","fields":{"slug":"/item-21/"},"frontmatter":{"title":"인터페이스는 구현하는 쪽을 생각해 설계하라"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"6a2593b4-90d6-5f17-a2b7-086a70b26ae1","fields":{"slug":"/database-compare-between-ssd-and-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"78d5ae48-9cb5-5099-8ecb-b3affdd38d6d","fields":{"slug":"/item-32/"},"frontmatter":{"title":"제네릭과 가변인수를 함께 쓸 때는 신중하라"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"16e09090-cb18-56b9-a597-f8b7b472358e","fields":{"slug":"/database-transaction-recovery/"},"frontmatter":{"title":"DB 트랜잭션, 회복"}}},{"node":{"id":"7062e173-15fc-579c-9637-8d4985247b51","fields":{"slug":"/item-34/"},"frontmatter":{"title":"int 상수 대신 열거 타입을 사용하라"}}},{"node":{"id":"8371ee7e-c8e5-5d9e-9d38-b9b2746109f4","fields":{"slug":"/item-41/"},"frontmatter":{"title":"정의하려는 것이 타입이라면 마커 인터페이스를 사용하라"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"Hustle Coder"}}}]},"previous":{"fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}},"next":{"fields":{"slug":"/item-34/"},"frontmatter":{"title":"int 상수 대신 열거 타입을 사용하라"}}},"pageContext":{"id":"16e09090-cb18-56b9-a597-f8b7b472358e","series":null,"previousPostId":"ef88654c-22d3-5af6-b232-ac40429fadd5","nextPostId":"7062e173-15fc-579c-9637-8d4985247b51"}},"staticQueryHashes":[],"slicesMap":{}}