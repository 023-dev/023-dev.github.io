{"componentChunkName":"component---src-templates-post-jsx","path":"/java-vector-hashtable-synchronizedxxx/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"9c443690-789a-5153-a234-67772da4ff2d","excerpt":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX 와  그리고  메서드의 공통점은 모두 한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 와  그리고  메서드의 문제점…","html":"<h1 id=\"Vector와-Hashtable-그리고-CollectionsSynchronizedXXX\" style=\"position:relative;\"><a href=\"#Vector%EC%99%80-Hashtable-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CollectionsSynchronizedXXX\" aria-label=\"Vector와 Hashtable 그리고 CollectionsSynchronizedXXX permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Vector와 Hashtable 그리고 Collections.SynchronizedXXX</h1>\n<p><code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code> 그리고 <code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드의 공통점은 모두 <code class=\"language-text\">Thread-Safe</code>한 컬렉션으로 동기화된 메서드로 구성되어 있다는 것이다.\n<code class=\"language-text\">Thread-Safe</code>한 컬렉션이면 보통 멀티 스레드 환경에서 안전하게 사용할 수 있다고 생각할 수 있지만, 실제로는 성능이 저하되는 문제가 발생할 수 있다.\n그럼 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code> 그리고 <code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드의 문제점에 대해 알아보자.</p>\n<h2 id=\"Vector와-Hashtable-문제점\" style=\"position:relative;\"><a href=\"#Vector%EC%99%80-Hashtable-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"Vector와 Hashtable 문제점 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Vector와 Hashtable 문제점</h2>\n<p><code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>은 모두 레거시한 자바 클래스로, 데이터를 저장하고 관리하는 컬렉션 클래스이다.\n근데 왜 레거시한 자바 컬렉션인지 궁금할 수 있다. 이는 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>이 <code class=\"language-text\">Thread-Safe</code>한 컬렉션으로 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있다.\n이로 인해 두 클래스 모두 메서드 단위에서 동기화를 제공하지만, 이로 인해 앞서 언급했듯이 성능이 저하되는 문제가 발생한다.\n이는 필요한 부분만 동기화를 제공하지 않고, 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제이다.</p>\n<p>내부 구현이 어떻게 되어있는지 그리고 어떠한 상황에서 이러한 문제가 발생하는지 알아보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">ensureCapacityHelper</span><span class=\"token punctuation\">(</span>elementCount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    elementData<span class=\"token punctuation\">[</span>elementCount<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드 <code class=\"language-text\">Vector</code> 클래스의 <code class=\"language-text\">add()</code> 메서드는 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있는 것을 볼 수 있다.\n<code class=\"language-text\">Vector</code> 클래스의 <code class=\"language-text\">add()</code> 메서드는 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있기 때문에 두 스레드가 동시에 <code class=\"language-text\">add()</code> 메서드를 호출하면 한 스레드는 대기하게 된다.\n이로 인해 race condition이 발생하여 성능이 저하되는 문제가 발생한다.</p>\n<p>이러한 문제로 현재의 자바에서는 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code> 대신 <code class=\"language-text\">ArrayList</code>와 <code class=\"language-text\">HashMap</code>을 사용하는 것을 권장하고 있다.\n<code class=\"language-text\">ArrayList</code> 클래스의 <code class=\"language-text\">add()</code> 메서드는 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있지 않기에 두 스레드가 동시에 <code class=\"language-text\">add()</code> 메서드를 호출해도 서로 영향을 주지 않는다.\n그럼 동기화 메서드로 구성된 컬렉션을 사용하고 싶다면 어떻게 해야할까?</p>\n<h2 id=\"CollectionssynchronizedXXX-메서드\" style=\"position:relative;\"><a href=\"#CollectionssynchronizedXXX-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"CollectionssynchronizedXXX 메서드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Collections.synchronizedXXX() 메서드</h2>\n<p><code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드는 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>과 같이 동기화된 메서드로 구성된 컬렉션을 반환한다.\n이 메서드는 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성된 컬렉션을 반환하기 때문에 <code class=\"language-text\">Thread-Safe</code>한 컬렉션을 사용할 수 있다.</p>\n<p>내부 구현이 어떻게 되어있는지 알아보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">synchronizedList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>list <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RandomAccess</span> <span class=\"token operator\">?</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronizedRandomAccessList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronizedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 <code class=\"language-text\">Collections.synchronizedList()</code> 메서드의 내부 구현이다.\n이 메서드는 <code class=\"language-text\">List</code> 인터페이스를 구현한 컬렉션을 매개변수로 받아 <code class=\"language-text\">SynchronizedList</code> 클래스를 반환한다.\n이로 인해 <code class=\"language-text\">ArrayList</code>의 모든 메서드에 대해 동기화를 제공받게 된다.\n그러면 이 메서드를 사용하면 안전할까?\n그렇지는 않다. <code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드는 모든 메서드에 대해 동기화를 제공하기 때문에 과도한 락이 발생하는 문제가 발생한다.\n이 문제 또한 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>의 문제와 같은 문제이다.\n그럼 이러한 문제를 해결하기 위해 어떻게 해야할까?\n이러한 문제로 현재의 자바에서는 <code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드 대신 <code class=\"language-text\">ConcurrentHashMap</code>과 같은 <code class=\"language-text\">Concurrent</code> 패키지의 컬렉션을 사용하는 것을 권장하고 있다.</p>\n<h2 id=\"Concurrent\" style=\"position:relative;\"><a href=\"#Concurrent\" aria-label=\"Concurrent permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Concurrent</h2>\n<p><code class=\"language-text\">Concurrent</code> 패키지는 멀티 스레드 환경에서 안전하게 사용할 수 있는 컬렉션을 제공한다.\n<code class=\"language-text\">ConcurrentHashMap</code>은 <code class=\"language-text\">Hashtable</code>과 같이 <code class=\"language-text\">Thread-Safe</code>한 컬렉션으로 동기화된 메서드로 구성되어 있지만, <code class=\"language-text\">ConcurrentHashMap</code>은 필요한 부분만 동기화를 제공하기 때문에 성능이 향상된다.</p>\n<p>내부 구현이 어떻게 되어있는지 알아보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> onlyIfAbsent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> value <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> hash <span class=\"token operator\">=</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 <code class=\"language-text\">ConcurrentHashMap</code> 클래스의 <code class=\"language-text\">put()</code> 메서드의 일부분이다.\n이 메서드는 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있지만, 필요한 부분만 동기화를 제공하기 때문에 <code class=\"language-text\">Thread-Safe</code>한 컬렉션을 사용하면서 성능이 향상된다.\n자세한 내용은 <a href=\"https://023-dev.github.io/2024-11-22/Java-ConcurrentHashMap-SynchronizedMap\">ConcurrentHashMap vs SynchronizedMap</a>을 참고하자.</p>\n<p>이렇게 주저리주저리 써봤는데 정리하자면 기존 레거시 자바 버전에서는 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>을 사용했지만 해당 컬레션들의 모든 메서드들이 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화된 메서드로 구성되어 있어 과도한 락이 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code> 대신 <code class=\"language-text\">ArrayList</code>와 <code class=\"language-text\">HashMap</code>을 사용하는 것을 권장하고 있다.\n근데 이 부분에서 동기화 메서드가 필요로 해져서 <code class=\"language-text\">Collections.synchronizedXXX()</code> 메서드를 사용해 해당 컬렉션을 동기화된 형태로 래핑할 수 있게 되었다.\n하지만 이 부분에서도 <code class=\"language-text\">Vector</code>와 <code class=\"language-text\">Hashtable</code>과 같은 문제가 발생하여 성능이 저하되는 문제가 발생한다.\n그래서 결과적으로 현재의 자바에서는 <code class=\"language-text\">ArrayList</code>와 <code class=\"language-text\">HashMap</code>을 <code class=\"language-text\">Thread-Safe</code>하게 사용하기 위한 방법으로 <code class=\"language-text\">Concurrent</code> 패키지의 컬렉션을 사용하는 것을 권장하고 있다.</p>","frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX","date":"November 22, 2024","update":null,"tags":["Java"],"series":null},"fields":{"slug":"/java-vector-hashtable-synchronizedxxx/","readingTime":{"minutes":7.49}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"9142cd48-5969-5dff-8b0a-1ca7f8164545","fields":{"slug":"/item-05/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"5e51d765-fc56-5fc0-9efb-93e8c323c43c","fields":{"slug":"/item-16/"},"frontmatter":{"title":"public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"b20a27d1-efe1-5df8-8fc6-70b1b621850d","fields":{"slug":"/item-15/"},"frontmatter":{"title":"클래스와 멤버의 접근 권한을 최소화하라"}}},{"node":{"id":"008bff3b-a610-5097-8737-2973f0ce221f","fields":{"slug":"/item-21/"},"frontmatter":{"title":"인터페이스는 구현하는 쪽을 생각해 설계하라"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"6a2593b4-90d6-5f17-a2b7-086a70b26ae1","fields":{"slug":"/database-compare-between-ssd-and-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 "}}},{"node":{"id":"78d5ae48-9cb5-5099-8ecb-b3affdd38d6d","fields":{"slug":"/item-32/"},"frontmatter":{"title":"제네릭과 가변인수를 함께 쓸 때는 신중하라"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"날 것 그대로에서의 유연함을 얻어 허슬 플레이를 하다"}}}]},"previous":{"fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}},"next":{"fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},"pageContext":{"id":"9c443690-789a-5153-a234-67772da4ff2d","series":null,"previousPostId":"10e407f2-9715-504c-a60f-29a3b4cb67df","nextPostId":"a642a0b6-afce-5363-a262-bccfb0f2ef20"}},"staticQueryHashes":[],"slicesMap":{}}