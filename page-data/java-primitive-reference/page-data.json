{"componentChunkName":"component---src-templates-post-jsx","path":"/java-primitive-reference/","result":{"data":{"site":{"siteMetadata":{"title":"기록도 록이다"}},"markdownRemark":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","excerpt":"기본형(Primitive)과 참조형(Reference) 자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을…","html":"<h1 id=\"기본형Primitive과-참조형Reference\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%ED%98%95Primitive%EA%B3%BC-%EC%B0%B8%EC%A1%B0%ED%98%95Reference\" aria-label=\"기본형Primitive과 참조형Reference permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>기본형(Primitive)과 참조형(Reference)</h1>\n<p>자바의 데이터 타입은 크게 기본형(Primitive)과 참조형(Reference)으로 나눌 수 있다.\n기본형은 정수, 실수, 문자, 논리 등의 값을 저장하는 데이터 타입이고, 참조형은 객체의 주소값을 저장하는 데이터 타입이다.\n기본형과 참조형의 차이점을 이해하고, 데이터 타입을 사용할 때 주의할 점을 살펴보자.</p>\n<h2 id=\"데이터-공유\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0\" aria-label=\"데이터 공유 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>데이터 공유</h2>\n<p>기본형은 하나의 값을 여러 변수에서 절대로 공유할 수 없디.\n하지만, 참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.</p>\n<p>여기서 하나의 값을 공유하거나 공유하지 않는다는 것은 무엇을 의미할까?\n기본형과 참조형의 차이를 이해하기 위해 아래의 코드를 살펴보자.</p>\n<p>먼저 기본형의 경우를 살펴보자.\n기본형은 하나의 값을 여러 변수에서 공유할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code></pre></div>\n<p>우선 기본형 변수 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>는 절대로 같은 값을 공유하지 않는다.\n<code class=\"language-text\">b = a</code>라고 하더라도 <code class=\"language-text\">b</code> 변수는 <code class=\"language-text\">a</code> 변수의 값을 복사하여 가지고 있는다.\n그래서 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 변수는 같은 숫자 값을 가지고 있게되지만, <code class=\"language-text\">a</code>가 가지고 있는 <code class=\"language-text\">10</code>과 <code class=\"language-text\">b</code>가 가지고 있는 <code class=\"language-text\">10</code>은 복사된 완전히 다른 <code class=\"language-text\">10</code>이다.\n메모리 상에서도 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>는 서로 다른 메모리 주소를 가지고 있다.</p>\n<p>이제 참조형의 경우를 살펴보자.\n참조형은 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Person</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Person</span> person2 <span class=\"token operator\">=</span> person1<span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Bob\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Bob</span></code></pre></div>\n<p>위 코드는 <code class=\"language-text\">Person</code> 클래스를 정의하고, <code class=\"language-text\">Person</code> 객체를 생성하여 <code class=\"language-text\">person1</code> 변수에 할당한다.\n그리고 <code class=\"language-text\">person2</code> 변수에 <code class=\"language-text\">person1</code> 변수를 할당한다.\n<code class=\"language-text\">person1</code> 변수의 <code class=\"language-text\">name</code> 필드를 변경한 후, <code class=\"language-text\">person2</code> 변수의 <code class=\"language-text\">name</code> 필드를 출력하면 어떻게 되는지 테스트하는 코드다.\n코드의 결과는 <code class=\"language-text\">Bob</code>이 출력된다.</p>\n<p>참조형 변수들은 같은 참조값을 공유해 같은 인스턴스를 가리킨다.\n따라서 <code class=\"language-text\">person1</code> 변수의 <code class=\"language-text\">name</code> 필드를 변경하면, <code class=\"language-text\">person2</code> 변수도 같은 인스턴스를 가리키고 있기 때문에 <code class=\"language-text\">person2</code> 변수의 <code class=\"language-text\">name</code> 필드도 변경된다.</p>\n<h2 id=\"공유-참조와-사이드-이펙트\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9C%A0-%EC%B0%B8%EC%A1%B0%EC%99%80-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8\" aria-label=\"공유 참조와 사이드 이펙트 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>공유 참조와 사이드 이펙트</h2>\n<p>사이드 이펙트(Side Effect)는 함수나 메소드가 주된 행위 및 작업 외에 추가적인 부수 효과를 일으키는 것을 의미한다.\n앞서 살펴본 참조형 변수의 경우, <code class=\"language-text\">person1</code>의 <code class=\"language-text\">name</code> 필드를 변경하고자 <code class=\"language-text\">person1.name = \"Bob\"</code>를 실행한다.\n하지만 <code class=\"language-text\">person2</code>가 <code class=\"language-text\">person1</code>과 같은 참조값을 가지고 있기 때문에 <code class=\"language-text\">person2</code>의 <code class=\"language-text\">name</code> 필드도 변경된다.\n이렇게 같은 참조값을 공유할 때 발생하는 사이드 이펙트로 인해 디버깅이 어려워지고 코드의 안정성이 저하될 수 있다.</p>\n<h2 id=\"사이드-이펙트-방지\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%EB%B0%A9%EC%A7%80\" aria-label=\"사이드 이펙트 방지 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>사이드 이펙트 방지</h2>\n<p>사이드 이펙트를 방지하기 위해서는 참조형 변수를 공유하지 않도록 해야한다.\n그러면 어떻게 참조형 변수를 공유하지 않도록 할 수 있을까?\n그것은 생각보다 단순하다.\n참조형 변수를 공유하지 않으려면 새로운 인스턴스를 생성하여 참조값을 할당하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Person</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Person</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드는 <code class=\"language-text\">Person</code> 클래스의 인스턴스를 두 개 생성하여 <code class=\"language-text\">person1</code> 변수와 <code class=\"language-text\">person2</code> 변수에 할당한다.\n이제 <code class=\"language-text\">person1</code> 변수와 <code class=\"language-text\">person2</code> 변수는 서로 다른 인스턴스를 가리키고 있기 때문에 <code class=\"language-text\">person1</code> 변수의 필드를 변경하더라도 <code class=\"language-text\">person2</code> 변수의 필드는 변경되지 않는다.</p>\n<p>사실 이러한 사이드 이펙트를 방지하기 위해 불변 객체(Immutable Object)를 사용하는 방법 또한 존재한다.\n불변 객체란 간단히 말해 객체의 상태가 변경되지 않는 객체를 의미한다.\n이러한 불변 객체를 사용하면 객체의 상태가 변경되지 않기 때문에 사이드 이펙트를 방지할 수 있다.\n불변 객체에 대한 자세한 내용은 <a href=\"https://023-dev.github.io/2024-12-23/java-immutable-object\">Immutable Object</a>를 참고하자.</p>","frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)","date":"December 20, 2024","update":null,"tags":["Java"],"series":null},"fields":{"slug":"/java-primitive-reference/","readingTime":{"minutes":5.81}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"2e3f4c03-14e2-53bf-b18b-238b32ede080","fields":{"slug":"/2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"be250c05-5eed-50a2-835c-0f559f6dd229","fields":{"slug":"/effective-java-dependency-injection/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"Hello My World"}}}]},"previous":{"fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}},"next":{"fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},"pageContext":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","series":null,"previousPostId":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","nextPostId":"d4156b41-43d2-511a-90b3-af9d47d4739d"}},"staticQueryHashes":[],"slicesMap":{}}