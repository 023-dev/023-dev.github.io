{"componentChunkName":"component---src-templates-post-jsx","path":"/web-socket/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"fe479149-14a0-5758-ad7d-8ee66f29fa81","excerpt":"주로 인터넷상에서 통신을 할 때는 HTTP를 사용한다. 특히 HTTP/1.1 이하에서는 클라이언트가 서버에게 요청을 보내고, 서버가 그에 응하여 응답을 보내는 식으로 단방향 소통이 이뤄진다. 서버가 클라이언트에게 메시지를 보내는 건 클라이언트의 요청에 응답을 할 때 뿐이다. 일반적인 기능들은 이러한 단방향 방식으로 구현이 가능하지만, 다른 방식이 필요할 …","html":"<p>주로 인터넷상에서 통신을 할 때는 HTTP를 사용한다. 특히 HTTP/1.1 이하에서는 클라이언트가 서버에게 요청을 보내고, 서버가 그에 응하여 응답을 보내는 식으로 단방향 소통이 이뤄진다.</p>\n<p>서버가 클라이언트에게 메시지를 보내는 건 클라이언트의 요청에 응답을 할 때 뿐이다.</p>\n<p>일반적인 기능들은 이러한 단방향 방식으로 구현이 가능하지만, 다른 방식이 필요할 때가 있다.</p>\n<p>채팅 애플리케이션을 생각해보면, 내가 상대방에게 메시지를 보내는 것은 클라이언트에서 서버로 통보하면 되는 것이니 문제 없지만 상대방이 메시지를 보냈을 때, 이를 내 앱에서 감지하는 것은 불가능하다.</p>\n<p>HTTP/1.1 이하에서는 클라이언트의 요청 없이는 서버에서 메시지를 보내지 못하기 떄문이다.</p>\n<p>HTTP로 이 문제를 해결하고자 한다면 Polling이라는 방법이 있긴 하다.</p>\n<p>클라이언트가 주기적으로 서버에 요청을 보내서 상대가 새 챗을 보냈는지 확인하는 방법이다.</p>\n<p>서버는 업데이트가 있으면 있다고, 없으면 없다고 바로 응답을 보낸다.</p>\n<p>이 방법에는 크게 두 가지 문제가 있다.</p>\n<p>첫 번째로, 요청을 보내는 주기만큼의 지연이 발생할 수 있다.</p>\n<p>그로인해, 서버가 갖고 있는 상태의 변화에 즉각적으로 반응하지 못하는 것이다.</p>\n<p>두 번째는 계속해서 불필요한 요청들이 보내진다는 것이다.</p>\n<p>요청의 주기가 짧다면 반응속도는 빨라지겠지만 트래픽의 낭비도 비례하여 더 심해질 것이다.</p>\n<p>이를 개선한 시도로는 Long Polling이 있는데, 이는 서버가 클라이언트의 요청에 바로 응답하지 않고 업데이트가 발생할때까지 기다리는 방법이다.</p>\n<p>그러다 상대방이 챗을 보내거나 타임아웃으로 설정된 시간이 지나면 응답을 보내고, 클라이언트는 다시 요청을 보내서 다음 응답을 기다리는 것이다.</p>\n<p>이 방식을 사용하면 데이터의 업데이트에 반응하는 속도는 빨라지지만 서버의 부담이 커지게 된다.</p>\n<p>서버가 클라이언트로부터 요청을 받을 때 까지 클라이언트와의 연결이 지속되는데, 동시에 여러 클라이언트가 서비스를 사용하면 그 만큼의 연결을 유ㅜ지해야 하므로 부하가 발생하기 때문이다.</p>\n<p>이는 업데이트에 대한 반응이 느려지는 결과로 나타나기까지도 하다.</p>\n<p>HTTP에서의 요청과 응답에 포함되는 헤더 정보의 양도 매 번 부담으로 작용한다.</p>\n<p>때문에 이러한 서비스를 구현하기 위해서는 클라이언트와 서버가 동등하게 메시지를 주고 받을 수 있는, 즉 양방향 통신이 가능한 방식이 필요하다. 그게 바로 WebSocket이다.</p>\n<p>HTTP/1.1이 클라이언트가 편지로 요청을 보내고 서버는 답장만하는 방식이라면, WebSocket은 서로가 자유롭게 대화를 주고받는 전화통화라고 할 수 있다.</p>\n<p>WebSocket 통신은 다음과 같은 방식으로 이뤄진다. 클라이언트에서는 서버에게 WebSocket을 연결하자는 요청을 HTTP를 통해 보낸다. 굳이 비유하자면 전화통화를 하자는 내용의 편지를 보내는 것이다. 서버는 그것이 가능한 경우 이를 수락하는 응답을 역시 HTTP로 보내게 된다. 이 과정을 Handshake라고 한다.</p>\n<p>그렇게 연결이 이뤄지고 나면 그 때부터 클라이언트와 서버는 HTTP가 아닌 WebSocket 프로토콜을 사용하여 소통한다. 여기서 클라이언트와 서버는 자유롭게 서로에게 메시지를 보낼 수 있다.</p>\n<p>WebSocket에서의 통신은 헤더의 크기가 작고 오버헤드가 적기 때문에 HTTP보다 효율적인 통신이 가능하다. 이 전화통화는 한 쪽이 다른 쪽에게 통화를 종료하고자 하는 메시지를 보낼 때까지 지속된다. 한 쪽이 close 프레임을 보내면, 다른 쪽이 이를 확인하고 역시 close 프레임을 응답으로 보냄으로써 연결이 종료되는 것이다.</p>\n<p>만일 클라이언트가 부득이하게 close를 못 보내고 애플리케이션을 꺼버리는 상황이 발생할 수도 있다. 이와 같은 비정상적인 종료를 감지하는 방법들 또한 존재한다. 지정된 시간동안 메시지가 없을 시 확인 패킷을 보내는 방법도 있고 주기적으로 ping, pong 프레임을 주고 받아서 서로의 접속 여부를 확인하는 방법도 있다.</p>\n<p>WebSocket은 하나의 연결을 끝까지 유지하고, 그 과정에서도 적은 자원만 소모하기 때문에 Long Polling만큼 서버에 부담을 주지도 않는다. 이 WebSocket을 사용해서, 실시간으로 서버로부터의 업데이트가 필요한 서비스들을 효율적으로 구축할 수 있는 것이다.</p>\n<p>아까 언급한 Handshake 과정을 좀 더 알아보자면, 클라이언트의 요청에는 헤더에 다음과 같은 내용들이 담긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: <span class=\"token assign-left variable\">dGhlIHNhbXBsZSBub25jZQ</span><span class=\"token operator\">==</span>\nSec-WebSocket-Version: <span class=\"token number\">13</span></code></pre></div>\n<p>헤더는 우편물에 붙은 송장 같은 거라고 보면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Upgrade: websocket\nConnection: Upgrade</code></pre></div>\n<p>이 부분은 혀냊의 HTTP 연결을 WebSocket 프로토콜로 업그레이드하자는 내용이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Sec-WebSocket-Key: <span class=\"token assign-left variable\">dGhlIHNhbXBsZSBub25jZQ</span><span class=\"token operator\">==</span>\nSec-WebSocket-Version: <span class=\"token number\">13</span></code></pre></div>\n<p>Sec-WebSocket-Key에는 클라이언트가 랜덤으로 생성한 값을 Base64로 인코딩한 문자열이 담긴다.</p>\n<p>서버는 이 요청을 받고 나서, GUID라 불리는 정해진 문자열을 그 키에 이어붙인 뒤 SHA-1 해시로 계산하여 다시 Base64로 인코딩한다. 서버는 이 값을 헤더에 담아 클라이언트에게 돌려보내고 클라이언트는 이것이 자기가 보낸 키로부터 생성된 값이 맞는지 확인한다. 모두에게 이미 알려진 공식이기 때문에 서버가 제대로 키를 처리했다는 것을 클라이언트도 확인할 수 있는거다. 이것으로 클라이언트는 이 응답이 자신이 요청을 보낸 상대로부터 온 것임을 확인하고 이 때부터 이 둘은 자유롭게 양방향으로 소통할 수 있는 것이다.</p>\n<aside>\n💡\n<p>그럼 WebSocket은 UDP와 TCP와 어떤 관계일까?</p>\n<p>속한 OSI 7계층이 다르다. TCP와 UDP 소켓은 전송(Transport) 계층인 Layer 4에서, WebSocket은 응용(Application) 계층인 Layer 7에서 동작한다.</p>\n<p>WebSocket은 TCP 소켓을 기반으로 작동한다. 그로인해 데이터의 순서와 신뢰성 또한 보장이 된다.</p>\n<p>이와 같은 장점들 덕분에 WebSocket은 채팅 뿐아니라 주식, 게임, 협업 도구, 위치 추적 등 실시간 양방향 통신이 필요한 수많은 분야에 활용되고 있다.</p>\n</aside>\n<p>하지만 이러한 WebSocket에도 한계 및 극복해야 할 부분들이 있다.</p>\n<p>먼저, 서버의 설계에 따라 구현이 복잡해질 수 있다. 특히 로드 밸런싱이 적용된 서버에서는 이를 위해 고려하고 설정할 부분이 많아진다. WebSocket은 특정 서버와의 지속적인 연결 안에서만 이뤄지기 때문에 한 서버와 웹 소켓 통신을 시작하면 이후로도 계속 그 서버로만 데이터가 전송되도록 설정해야 한다. Nginx, AWS ELB 등 WebSocket을 처리할 수 있는 로드 밸런서를 선택하여 구성하는 등 서비스에 적합한 방법을 찾아 해결해야 한다.</p>\n<p>메시지의 크기가 제한되어 있다는 점도 고려할 부분이다. 브라우저, 서버, 네트워크 환경마다 WebSocket에서의 메시지 크기에 제약을 둘 수 있다. 대용량 데이터의 경우, 분할해서 전송하거나 다른 프로토콜을 사용하는 등의 방법으로 해결할 수 있다.</p>\n<p>그리고 WebSocket의 기본 프로토콜인 WS은 통신이 암호화 되어 있지 않다. 때문에 보안이 중요한 서비스라면 SSL/TLS 인증서를 발급받은 뒤 이를 사용하여 WSS를 설정해야 한다.</p>\n<p>마지막으로, Polling 등의 방식보다는 훨씬 덜하지만 WebSocket도 서버에 부담을 주는 건 마찬가지다.</p>\n<p>많은 사용자들이 동시에 접속해 있을 수록 유지해야 하는 TCP 연결이 많아지고 메시지들이 오가는 빈도가 높다면 네트워크 대역폭과 CPU의 사용량도 증가하게 된다. 때문에, 구현하고자 하는 서비스에 이러한 문제가 발생할 경우 WebSocket이 가장 적절한 선택인지 고려해 볼 필요가 있다.</p>","frontmatter":{"title":"웹 소켓(Web socket)","date":"July 27, 2025","update":null,"tags":["Java","Web Socket"],"series":null},"fields":{"slug":"/web-socket/","readingTime":{"minutes":12.105}}},"seriesList":{"edges":[{"node":{"id":"ebf552bc-59ea-5969-b86b-bad95404ee87","fields":{"slug":"/ssl-protocol/"},"frontmatter":{"title":"SSL Protocol"}}},{"node":{"id":"af6c0192-819a-5110-957c-643bdd4721be","fields":{"slug":"/nginx-config/"},"frontmatter":{"title":"Nginx 설정하기"}}},{"node":{"id":"07aa966e-666d-563f-85c8-b3b4ad26865d","fields":{"slug":"/git-conventions/"},"frontmatter":{"title":"협업을 위한 Git 컨벤션"}}},{"node":{"id":"e4531ca2-2ac9-531b-9164-8b64c75e5a19","fields":{"slug":"/interview/"},"frontmatter":{"title":"면접관 사로잡기"}}},{"node":{"id":"9b20fef2-3067-501e-bf1c-8496cd150398","fields":{"slug":"/spring-data-jpa-paging/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"7fed17e5-3250-5f81-b864-7f719203a651","fields":{"slug":"/database-ssd-faster-than-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"97279d93-b018-5291-a7f8-154ab9af9e06","fields":{"slug":"/database-transaction/"},"frontmatter":{"title":"DBMS는 트랜잭션을 어떻게 관리할까?"}}},{"node":{"id":"556e4443-760f-5c0e-9d3f-56bce92db6bf","fields":{"slug":"/database-isolation-level/"},"frontmatter":{"title":"트랜잭션의 격리 수준(Transaction Isolation Level)"}}},{"node":{"id":"6bb66c2b-026f-566d-84fb-df3ce4dbec95","fields":{"slug":"/boj-17825/"},"frontmatter":{"title":"17825 주사위 윳놀이"}}},{"node":{"id":"0e31350d-6754-56b2-85a5-d739d57c38af","fields":{"slug":"/jscode-study-memoir/"},"frontmatter":{"title":"JSCODE 스터디 되돌아보기"}}},{"node":{"id":"a69e3d86-fa3b-5b23-a46b-27ca07dc31cc","fields":{"slug":"/boj-1325/"},"frontmatter":{"title":"1325 효율적인 해킹"}}},{"node":{"id":"07d0b3a0-20f5-5418-87e3-6e5eff4cbd0a","fields":{"slug":"/boj-1018/"},"frontmatter":{"title":"1018 체스판 다시 칠하기"}}},{"node":{"id":"9dde491d-5904-5c61-84e7-7943094943bd","fields":{"slug":"/boj-1051/"},"frontmatter":{"title":"1051 숫자 정사각형"}}},{"node":{"id":"a563c631-3d22-5595-9063-749fc5553ad3","fields":{"slug":"/boj-2529/"},"frontmatter":{"title":"2529 부등호"}}},{"node":{"id":"b9ebae0f-eb1d-5b1e-890b-1af660585100","fields":{"slug":"/boj-2615/"},"frontmatter":{"title":"2615 오목"}}},{"node":{"id":"c91b8fbb-756d-569e-867a-b441a01f7af8","fields":{"slug":"/boj-15686/"},"frontmatter":{"title":"15686 치킨 배달"}}},{"node":{"id":"c8a562b7-c6eb-5d5f-a167-29ea98d2d2c7","fields":{"slug":"/boj-9663/"},"frontmatter":{"title":"9663 N-Queen"}}},{"node":{"id":"b7249a5d-d62e-511f-a47b-4cae4c5d4a76","fields":{"slug":"/boj-27961/"},"frontmatter":{"title":"27961 고양이는 많을수록 좋다"}}},{"node":{"id":"830ecb3c-ea0c-5b32-932c-b78dea1fd7e6","fields":{"slug":"/prog-42839/"},"frontmatter":{"title":"42839 소수찾기"}}},{"node":{"id":"c14454eb-539e-5270-b82d-a5e74d5846e3","fields":{"slug":"/boj-11399/"},"frontmatter":{"title":"17503 맥주 축제"}}},{"node":{"id":"db022464-1f93-5ca3-b1ef-3ef7a0e53568","fields":{"slug":"/boj-1946/"},"frontmatter":{"title":"1946 신입 사원"}}},{"node":{"id":"442747fb-c36d-5ebf-b571-fc25a484ea56","fields":{"slug":"/boj-19598/"},"frontmatter":{"title":"19598 최소 회의실 개수"}}},{"node":{"id":"d1de5bbb-2949-5108-a4e8-29b57fb29120","fields":{"slug":"/boj-1003/"},"frontmatter":{"title":"1003 피보나치 함수"}}},{"node":{"id":"f66f88d3-87df-5f27-aa94-26a50d7330e8","fields":{"slug":"/boj-2212/"},"frontmatter":{"title":"2212 센서"}}},{"node":{"id":"bdb20dae-34ac-5a09-893c-74ae7b30c8fc","fields":{"slug":"/boj-11053/"},"frontmatter":{"title":"11053 가장 긴 증가하는 부분 수열"}}},{"node":{"id":"0e7377eb-09a1-531d-a44f-08c0014c411f","fields":{"slug":"/boj-9251/"},"frontmatter":{"title":"9251 LCS"}}},{"node":{"id":"9df5e584-f2a1-52e7-99a1-54cfcf2b8d98","fields":{"slug":"/boj-2225/"},"frontmatter":{"title":"2225 합분해"}}},{"node":{"id":"5ed27546-4130-51d0-a15c-fd9346bc5a0a","fields":{"slug":"/boj-1351/"},"frontmatter":{"title":"1351 무한 수열"}}},{"node":{"id":"202eda44-2909-5595-bd82-cb82f45a0ff6","fields":{"slug":"/enablewebmvc-jackson/"},"frontmatter":{"title":"@EnableWebMvc 사용해도 될까?"}}},{"node":{"id":"6d0a4c84-fa22-5a93-956d-8925e17b886f","fields":{"slug":"/annotation-modifying-with-transactional/"},"frontmatter":{"title":"@Query와 @Modifying만 사용하면 될까?"}}},{"node":{"id":"5204b390-54c4-5a3d-898b-8dbe85eeec62","fields":{"slug":"/static-resources-attack/"},"frontmatter":{"title":"디렉토리 스캔 공격은 어떻게 대응해야 할까?"}}},{"node":{"id":"2f361a7b-f132-50c6-a31d-1fb6f6cb18ba","fields":{"slug":"/method-naming/"},"frontmatter":{"title":"Java Method Naming Conventions"}}},{"node":{"id":"f4903cfa-9ebd-5f61-8c70-9f15d1fd5e15","fields":{"slug":"/ec2-cron-alert/"},"frontmatter":{"title":"서버 장애를 대비해 서버 리소스에 대한 Slack Webhook 처리하기"}}},{"node":{"id":"187c27c2-6ef1-560d-8127-7173cc083d5c","fields":{"slug":"/fail2ban-alert/"},"frontmatter":{"title":"Fail2Ban의 상태를 Slack Webhhook 처리하기"}}},{"node":{"id":"9bb120aa-03ff-507f-a287-b07192513173","fields":{"slug":"/2/"},"frontmatter":{"title":"No 'Access-Control-Allow-Origin' header is present on the requested resource"}}},{"node":{"id":"fe089a8a-241a-50b4-a390-8106ba05f4db","fields":{"slug":"/3/"},"frontmatter":{"title":"JSON serialization with Jackson don’t work properly."}}},{"node":{"id":"a6191ffd-2529-5df8-984b-8fda6c70c299","fields":{"slug":"/server-monitoring/"},"frontmatter":{"title":"서버 모니터링에 대한 생각"}}},{"node":{"id":"4a640eb1-312c-5046-a330-010c52c6c644","fields":{"slug":"/bastion-host/"},"frontmatter":{"title":"AWS Bastion Host"}}},{"node":{"id":"96f7894e-d4a9-5bf7-9bb8-830a528eb6ef","fields":{"slug":"/gitactions-connect-private-instance/"},"frontmatter":{"title":"GitHub Actions에서 SSH로 Private 인스턴스에 접근하기"}}},{"node":{"id":"20d53e3c-f47c-5a86-a5ab-6f6b58f0d20d","fields":{"slug":"/gitactions-aws-add-inbound-rule/"},"frontmatter":{"title":"AWS Security Group의 Inbound Rule에 GitHub Actions의 Public IP 추가하기"}}},{"node":{"id":"1c1b69df-adb9-53bc-bc0a-8606822aa0b2","fields":{"slug":"/1/"},"frontmatter":{"title":"301 Moved Permanently"}}},{"node":{"id":"575ef349-72c5-5c06-8530-e2ae7a85f6dc","fields":{"slug":"/1/"},"frontmatter":{"title":"Utility Class에서 생성자를 private으로 선언해야 하는 이유"}}},{"node":{"id":"f7cc2668-fdd8-5081-8d46-4112cbde352b","fields":{"slug":"/id-generator/"},"frontmatter":{"title":"ID를 만드는 방법들"}}},{"node":{"id":"81aed75e-a872-5984-9ec0-e86b482eb8c7","fields":{"slug":"/4/"},"frontmatter":{"title":"Spring에서 Object를 Bean으로 관리하는 이유는 뭘까?"}}},{"node":{"id":"32a2cb86-8f1e-5c8f-9f56-bef33a14fb49","fields":{"slug":"/cookie-session/"},"frontmatter":{"title":"쿠키(Cookie)와 세션(Session)의 차이"}}},{"node":{"id":"7d4b9ff6-50df-50b9-9ffa-626cf0f444df","fields":{"slug":"/uri-url-urn/"},"frontmatter":{"title":"URI, URL, URN의 차이"}}},{"node":{"id":"0b358ad3-9f0a-53d4-9fa7-bfbe38edf138","fields":{"slug":"/not-in-query/"},"frontmatter":{"title":"NOT IN 쿼리를 사용할 때 발생할 수 있는 문제"}}},{"node":{"id":"2a8b8bcd-f005-5fd1-a25c-396b86696c56","fields":{"slug":"/http-https/"},"frontmatter":{"title":"HTTP와 HTTPS의 차이"}}},{"node":{"id":"363816c7-cc18-5b57-acb6-2bf5a9d47d1e","fields":{"slug":"/singleton-pattern/"},"frontmatter":{"title":"싱글턴 패턴(Singleton Pattern)"}}},{"node":{"id":"c5c31b8d-b95d-585a-b7cc-eb943e19a565","fields":{"slug":"/gc-algothms/"},"frontmatter":{"title":"GC 알고리즘(Garbage Collection Algorithms)"}}},{"node":{"id":"fe479149-14a0-5758-ad7d-8ee66f29fa81","fields":{"slug":"/web-socket/"},"frontmatter":{"title":"웹 소켓(Web socket)"}}},{"node":{"id":"1414b62f-0f58-51f0-ae3b-fc32861f1db8","fields":{"slug":"/stomp/"},"frontmatter":{"title":"STOMP"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"focus and hustle"}}}]},"previous":{"fields":{"slug":"/gc-algothms/"},"frontmatter":{"title":"GC 알고리즘(Garbage Collection Algorithms)"}},"next":{"fields":{"slug":"/stomp/"},"frontmatter":{"title":"STOMP"}}},"pageContext":{"id":"fe479149-14a0-5758-ad7d-8ee66f29fa81","series":null,"previousPostId":"c5c31b8d-b95d-585a-b7cc-eb943e19a565","nextPostId":"1414b62f-0f58-51f0-ae3b-fc32861f1db8"}},"staticQueryHashes":[],"slicesMap":{}}