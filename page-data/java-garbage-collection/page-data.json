{"componentChunkName":"component---src-templates-post-jsx","path":"/java-garbage-collection/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","excerpt":"GC(Garbage Collection) **가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와…","html":"<h1 id=\"GCGarbage-Collection\" style=\"position:relative;\"><a href=\"#GCGarbage-Collection\" aria-label=\"GCGarbage Collection permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>GC(Garbage Collection)</h1>\n<hr>\n<p>**가비지 컬렉션(Garbage Collection, GC)**은 자바의 메모리 관리 방식 중 하나로, JVM(자바 가상 머신)의 힙(Heap) 영역에서 더 이상 사용되지 않는 객체(garbage)를 자동으로 식별하고 제거하는 프로세스를 의미한다.\n이는 프로그래머가 직접 메모리를 할당하고 해제해야 했던 C/C++와 달리, 자바에서는 GC가 메모리 관리를 대신 처리해줌으로써 메모리 누수(Memory Leak)를 방지하고 개발자가 로직 구현에만 집중할 수 있도록 돕는다.</p>\n<p>예를 들어, 반복문 내에서 다수의 객체를 생성하고 사용 후 버리는 코드가 있다고 가정할 때, GC는 이러한 객체들을 주기적으로 정리해줘서 메모리를 효율적으로 사용할 수 있게 한다.\nGC의 이러한 자동화는 자바뿐만 아니라 파이썬, 자바스크립트, Go 언어 등 다양한 언어에서도 기본적으로 제공되며, 웹 브라우저와 같은 소프트웨어에서도 GC를 활용해 메모리 관리를 자동화한다.</p>\n<p>그러나 GC에도 단점이 있다.\nGC가 언제 실행될지 명확히 알 수 없기 때문에 메모리 해제를 개발자가 직접 제어하기 어렵고, GC가 실행되는 동안 모든 애플리케이션 스레드가 멈추는 <strong>Stop-The-World(STW)</strong> 현상이 발생한다.\n이로 인해 GC가 지나치게 자주 실행되면 애플리케이션의 성능이 저하될 수 있으며, 실시간 성능이 중요한 시스템에서는 GC의 동작이 치명적일 수 있다.\n예를 들어, 과거의 웹 브라우저인 인터넷 익스플로러는 GC를 너무 자주 실행해 성능 문제를 야기했던 사례가 있다.</p>\n<p>이러한 이유로 GC의 실행을 최소화하고 최적화하는 작업이 중요시하며, 이를 <strong>GC 튜닝</strong>이라고 한다.</p>\n<blockquote>\n<p>GC 튜닝은 어플리케이션의 성능을 유지하면서 효율적으로 메모리를 관리하는 방법을 설계하는 과정으로, 애플리케이션의 성능과 안정성을 보장하기 위해 필수적인 기술 중 하나이다.</p>\n</blockquote>\n<h2 id=\"가비지-컬렉션-대상\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EB%8C%80%EC%83%81\" aria-label=\"가비지 컬렉션 대상 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가비지 컬렉션 대상</h2>\n<p>가비지 컬렉션(Garbage Collection)의 대상은 객체가 더 이상 프로그램에서 참조되지 않는 경우, 즉 도달 불가능(Unreachable)한 상태로 판단된 객체들이다.\n이를 위해 **도달성(Reachability)**이라는 개념이 사용된다. 객체에 참조가 있으면 해당 객체는 Reachable(도달 가능) 상태로 간주되고, 반대로 참조가 없다면 Unreachable(도달 불가능) 상태로 분류되어 가비지 컬렉션의 대상이 된다.</p>\n<p>Reachable 상태의 객체는 현재 사용 중인 객체로, JVM의 Method Area나 Stack Area에서 해당 객체의 메모리 주소를 참조하고 있다.\n반면, Unreachable 상태의 객체는 어떤 변수나 메서드에서도 참조되지 않는 상태로, 더 이상 프로그램에서 사용되지 않는 객체다.\n이러한 Unreachable 객체는 힙(Heap) 영역에서만 존재하며, 가비지 컬렉션에 의해 자동으로 제거된다.</p>\n<div class=\"mermaid\">\ngraph LR\n    subgraph Heap\n        A1[1 Reachable]\n        A2[2 Unreachable]\n        A3[3 Reachable]\n        A4[4 Reachable]\n        A5[5 Reachable]\n    end\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">subgraph Stack\n    B6[6]\n    B7[7]\nend\n\nsubgraph MethodArea\n    C8[8]\nend\n\nB6 --> A1\nB7 --> A5\nA5 --> A4\nC8 --> A3</code></pre></div>\n</div>\n<p>예를 들어, 객체는 주로 힙 영역에서 생성되고, 메서드가 실행되거나 변수가 선언될 때 Method Area나 Stack Area에 객체의 참조 주소를 저장한다.\n하지만 메서드 종료와 같은 특정 이벤트로 인해 참조 변수가 삭제되거나 스코프를 벗어나면, 힙 영역의 해당 객체는 더 이상 참조되지 않게 된다.\n이처럼 도달 불가능한(Unreachable) 상태가 된 객체는 프로그램에서 쓸모없어진 것으로 간주되어 가비지 컬렉터가 주기적으로 수거하여 메모리를 해제한다.</p>\n<p>이 과정은 프로그래머가 명시적으로 메모리를 해제하지 않아도 JVM이 자동으로 메모리를 관리하게 해 주는 장점이 있다.\n하지만, 가비지 컬렉션이 언제 실행될지는 명확히 알 수 없으므로, 이를 고려한 메모리 관리 전략이 필요하다.\nUnreachable 객체를 효율적으로 식별하고 제거하는 것이 가비지 컬렉션의 핵심 역할이다.</p>\n<h2 id=\"가비지-컬렉션-동작-방식\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"가비지 컬렉션 동작 방식 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가비지 컬렉션 동작 방식</h2>\n<p><strong>가비지 컬렉션의 청소 방식</strong>은 Unreachable 객체를 식별하고 제거하는 과정에서 사용하는 알고리즘에 따라 달라진다.\n가장 기본적인 방식은 <strong>Mark and Sweep</strong> 알고리즘으로, 많은 GC에서 기본으로 사용되는 메모리 정리 방법이다.</p>\n<div class=\"mermaid\">\ngraph TD\n    subgraph Mark\n        A1[Object <br> reachable]\n        A2[Object <br> unreachable]\n        A3[Object <br> reachable]\n        A4[Object <br> unreachable]\n        A5[Object <br> reachable]\n    end\n    subgraph Sweep\n        B1[Object <br> reachable]\n        B2[<br>]\n        B3[Object <br> reachable]\n        B4[<br>]\n        B5[Object <br> reachable]\n    end\n    subgraph Compaction\n        C1[Object <br> reachable]\n        C2[Object <br> reachable]\n        C3[Object <br> reachable]\n    end\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Mark --> Sweep\nSweep --> Compaction</code></pre></div>\n</div>\n<p>이 방식은 다음 세 단계로 구성된다:</p>\n<ol>\n<li>\n<p><strong>Mark 과정</strong>: GC는 Root Space(루트 공간)에서 시작해 연결된 객체들을 그래프 형태로 순회하며, 참조되고 있는 객체들을 식별하고 마킹한다. Root Space는 힙 메모리를 참조하는 Method Area, Static 변수, JVM Stack, Native Method Stack 등을 포함한다. 이 과정을 통해 Reachable 객체와 Unreachable 객체를 구분한다.</p>\n</li>\n<li>\n<p><strong>Sweep 과정</strong>: 마킹되지 않은 객체들(Unreachable 객체)을 힙(Heap)에서 제거한다. 이 단계에서는 더 이상 사용되지 않는 메모리를 해제하여 새 객체가 저장될 수 있도록 공간을 확보한다.</p>\n</li>\n<li>\n<p><strong>Compaction 과정</strong>: Sweep 이후에 메모리 조각화(Fragmentation)를 줄이기 위해 남아있는 객체들을 힙의 시작 주소 쪽으로 압축한다. 이를 통해 연속된 메모리 공간을 확보해 새로운 객체를 할당할 때 메모리 할당 실패를 방지한다. 단, 이 과정은 모든 GC에서 수행되는 것은 아니며, 가비지 컬렉터의 종류에 따라 생략되기도 한다.</p>\n</li>\n</ol>\n<p>이 방식은 <strong>루트 공간(Root Space)</strong> 기준으로 객체의 Reachable 상태를 판단하기 때문에 순환 참조와 같은 문제가 있는 객체도 효과적으로 정리할 수 있다.\nRoot Space는 JVM 메모리 구조에서 중요한 요소로, Method Area, Static 변수, JVM Stack, Native Method Stack이 루트 역할을 한다.</p>\n<p>Mark and Sweep 방식은 간단하고 효율적이지만, 모든 객체를 순회하고 처리해야 하므로 수행 시간에 따라 애플리케이션의 성능에 영향을 줄 수 있다.\n또한, GC가 실행되는 동안 애플리케이션이 멈추는 <strong>Stop-The-World(STW)</strong> 현상이 발생할 수 있어 최적화된 GC 전략이 필요하다.\nMark and Sweep 알고리즘은 이런 기본 원리를 바탕으로 다양한 GC 최적화 기술의 기반이 되고 있다.</p>\n<h1 id=\"가비지-컬렉션-동작-과정\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"가비지 컬렉션 동작 과정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가비지 컬렉션 동작 과정</h1>\n<hr>\n<div class=\"mermaid\">\ngraph TB\n    subgraph JVM_Memory [JVM Memory Runtime Data Area]\n        A[Method Area]\n        B[Heap]\n        C[JVM Language Stacks]\n        D[PC Registers]\n        E[Native Method Area]\n    end\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">subgraph Heap_Structure [Heap Structure]\n    F[Eden]\n    G[Survivor 1]\n    H[Survivor 2]\n    I[Old Generation]\n    J[Permanent Generation]\nend\n\nA --> B\nB --> F\nB --> I\nG --> F\nH --> G\nI --> H\nI --> J\n\nF -->|Minor GC| G\nG -->|Minor GC| H\nH -->|Major GC &lt;br> Full GC| I</code></pre></div>\n</div>\n<h2 id=\"Heap-메모리의-구조\" style=\"position:relative;\"><a href=\"#Heap-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"Heap 메모리의 구조 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Heap 메모리의 구조</h2>\n<p><strong>힙(Heap) 메모리의 구조</strong>는 JVM에서 동적으로 생성된 객체와 레퍼런스 데이터를 저장하며, 가비지 컬렉션의 대상이 되는 공간이다.\nJVM의 힙 영역은 객체의 생존 기간과 특성을 기반으로 효율적으로 설계되었으며, 크게 <strong>Young Generation</strong>과 <strong>Old Generation</strong> 두 영역으로 나뉜다. 이러한 설계는 <strong>Weak Generational Hypothesis</strong>에 기반하며, 대부분의 객체는 금방 Unreachable 상태가 되고, 오래된 객체에서 새로운 객체로의 참조는 드물다는 가정을 전제로 한다.</p>\n<h3 id=\"Young-Generation-Young-영역\" style=\"position:relative;\"><a href=\"#Young-Generation-Young-%EC%98%81%EC%97%AD\" aria-label=\"Young Generation Young 영역 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Young Generation (Young 영역)</h3>\n<p><strong>Young 영역</strong>은 새롭게 생성된 객체가 처음 할당되는 공간이다. 대부분의 객체가 이 영역에서 생성되고 금방 Unreachable 상태가 되어 제거되며, 소규모 가비지 컬렉션인 <strong>Minor GC</strong>가 주로 이 영역에서 수행된다.\nYoung 영역은 다음 세 가지로 더 나뉜다:</p>\n<ul>\n<li><strong>Eden</strong>: 새롭게 생성된 객체가 위치하며, 정기적인 Minor GC 수행 후 살아남은 객체가 Survivor 영역으로 이동된다.</li>\n<li><strong>Survivor 0 / Survivor 1</strong>: Eden에서 살아남은 객체가 복사되는 영역으로, 최소 한 번 이상 GC를 통과한 객체들이 이곳에 존재한다. Survivor 0과 Survivor 1은 하나가 항상 비어 있어야 하는 규칙이 있다.</li>\n</ul>\n<h3 id=\"Old-Generation-Old-영역\" style=\"position:relative;\"><a href=\"#Old-Generation-Old-%EC%98%81%EC%97%AD\" aria-label=\"Old Generation Old 영역 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Old Generation (Old 영역)</h3>\n<p><strong>Old 영역</strong>은 Young 영역에서 여러 번의 GC를 거쳐 살아남은 객체가 복사되는 공간이다.\nYoung 영역보다 크며, 오래된 객체들이 위치하기 때문에 가비지 발생률이 상대적으로 낮다.\nOld 영역에서 수행되는 GC는 <strong>Major GC</strong> 또는 <strong>Full GC</strong>로 불리며, Young 영역보다 훨씬 더 큰 메모리를 다룬다.</p>\n<h3 id=\"힙-영역-설계의-효율성\" style=\"position:relative;\"><a href=\"#%ED%9E%99-%EC%98%81%EC%97%AD-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"힙 영역 설계의 효율성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>힙 영역 설계의 효율성</h3>\n<p>Old 영역이 Young 영역보다 크도록 설계된 이유는, Young 영역의 객체 수명이 짧기 때문에 큰 공간을 필요로 하지 않으며, 대형 객체는 Young 영역을 거치지 않고 바로 Old 영역에 할당되기 때문이다.\n또한, Young 영역을 Eden과 두 개의 Survivor 영역으로 나누어 객체의 생존 기간을 면밀히 추적하고, 불필요한 객체를 효율적으로 제거하도록 가비지 컬렉션의 정확도를 높인다.</p>\n<h3 id=\"Permanent-Generation-Java-7-이전과-Metaspace-Java-8-이후\" style=\"position:relative;\"><a href=\"#Permanent-Generation-Java-7-%EC%9D%B4%EC%A0%84%EA%B3%BC-Metaspace-Java-8-%EC%9D%B4%ED%9B%84\" aria-label=\"Permanent Generation Java 7 이전과 Metaspace Java 8 이후 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Permanent Generation (Java 7 이전)과 Metaspace (Java 8 이후)</h3>\n<p>**Permanent Generation(PermGen)**은 클래스 로더에 의해 로드된 클래스와 메서드의 메타정보가 저장되던 공간으로, Java 7까지 힙 영역에 존재했다.\n그러나 Java 8 이후에는 힙 메모리에서 분리되어 <strong>Metaspace</strong>라는 Native Method Stack 영역에 통합되었다.\n이를 통해 PermGen에서 발생하던 메모리 부족 문제를 해결하고, 보다 유연한 메모리 관리를 가능하게 했다.</p>\n<h2 id=\"Minor-GC-과정\" style=\"position:relative;\"><a href=\"#Minor-GC-%EA%B3%BC%EC%A0%95\" aria-label=\"Minor GC 과정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Minor GC 과정</h2>\n<p><strong>Minor GC 과정</strong>은 Young Generation에서 메모리를 효율적으로 관리하기 위해 수행되는 가비지 컬렉션으로, 객체의 생명 주기와 도달 가능성을 기준으로 불필요한 객체를 제거하는 프로세스이다.\nYoung Generation은 Eden 영역과 두 개의 Survivor 영역(Survivor 0, Survivor 1)으로 구성되어 있으며, Minor GC는 주로 Eden 영역에서 발생한다.</p>\n<p>주요 과정은 다음과 같다:</p>\n<ol>\n<li>\n<p><strong>객체 생성 및 Eden 영역 할당</strong>: 새로운 객체는 Young Generation의 Eden 영역에 위치하며, Eden 영역이 가득 차기 전까지 계속 저장된다.</p>\n</li>\n<li>\n<p><strong>Eden 영역 가득참 및 Minor GC 실행</strong>: 객체가 계속 생성되어 Eden 영역이 꽉 차게 되면 Minor GC가 실행된다.</p>\n</li>\n<li>\n<p><strong>Mark 동작</strong>: GC가 Eden 영역에서 Reachable 객체를 탐색하여 마킹한다. Reachable 객체는 참조되고 있는 상태로, 메모리에서 제거되지 않는다.</p>\n</li>\n<li>\n<p><strong>Reachable 객체 Survivor 영역 이동</strong>: Eden 영역에서 살아남은 객체는 하나의 Survivor 영역(예: Survivor 0)으로 이동된다.</p>\n</li>\n<li>\n<p><strong>Unreachable 객체 메모리 해제</strong>: Eden 영역에서 참조되지 않은 Unreachable 객체는 메모리에서 해제(Sweep)된다.</p>\n</li>\n<li>\n<p><strong>객체의 Age 증가</strong>: Survivor 영역에 남아있는 객체들은 <strong>age</strong> 값이 1씩 증가한다. 이 값은 객체가 Survivor 영역에서 살아남은 횟수를 의미하며, <code class=\"language-text\">Object Header</code>에 기록된다. 특정 임계값(예: HotSpot JVM의 기본값 31)에 도달하면 객체는 Old Generation으로 승격(Promotion)된다.</p>\n</li>\n<li>\n<p><strong>다시 Eden 영역 할당</strong>: Eden 영역에 신규 객체가 추가로 생성되어 다시 가득 차게 되면, Minor GC가 반복된다.</p>\n</li>\n<li>\n<p><strong>Survivor 영역 교체</strong>: 마킹된 객체들은 비어있는 다른 Survivor 영역(예: Survivor 1)으로 이동하며, 사용 중인 Survivor 영역은 비워진다.</p>\n</li>\n<li>\n<p><strong>반복적인 Minor GC</strong>: Eden 영역이 반복적으로 가득 차고, 객체들이 Survivor 영역 간 이동하며 age 값이 증가하는 과정을 계속 반복한다.</p>\n</li>\n<li>\n<p><strong>Survivor 영역의 제한 조건</strong>: Survivor 영역 중 하나는 항상 비어 있어야 한다. 두 Survivor 영역이 동시에 사용 중이거나 모두 비어 있다면, 이는 시스템이 비정상적으로 작동하고 있음을 의미한다.</p>\n</li>\n</ol>\n<p>Minor GC는 메모리 공간이 상대적으로 작은 Young Generation에서 수행되기 때문에 짧은 시간 내에 완료될 수 있다.\n하지만 Minor GC의 빈도가 지나치게 높아지면 애플리케이션 성능에 영향을 미칠 수 있으므로, 이를 고려한 메모리 관리 전략이 필요하다.\n이 과정을 통해 메모리를 효율적으로 관리하면서 Old Generation으로의 객체 이동을 최소화한다.</p>\n<h2 id=\"Major-GC-과정\" style=\"position:relative;\"><a href=\"#Major-GC-%EA%B3%BC%EC%A0%95\" aria-label=\"Major GC 과정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Major GC 과정</h2>\n<p><strong>Major GC 과정</strong>은 Old Generation 영역에서 발생하는 가비지 컬렉션으로, 상대적으로 수명이 긴 객체들이 저장된 메모리 공간을 관리하는 역할을 한다. Old Generation에 있는 객체들은 대부분 Young Generation에서 시작되어 Minor GC를 여러 번 통과하며, age 값이 임계값(예: 8)에 도달하면 Promotion 과정을 거쳐 이동된 객체들이다. Major GC는 Old Generation에 더 이상 새로운 객체를 저장할 공간이 부족해질 때 실행되며, Old Generation의 모든 객체를 검사해 참조되지 않은 객체를 제거한다.</p>\n<h3 id=\"Major-GC의-주요-단계\" style=\"position:relative;\"><a href=\"#Major-GC%EC%9D%98-%EC%A3%BC%EC%9A%94-%EB%8B%A8%EA%B3%84\" aria-label=\"Major GC의 주요 단계 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Major GC의 주요 단계</h3>\n<ol>\n<li><strong>객체 Promotion</strong>: Young Generation에서 age 값이 임계값에 도달한 객체들은 Old Generation으로 이동된다.</li>\n<li><strong>Old Generation 메모리 부족</strong>: Old Generation 영역에 객체가 계속 Promotion되면, 결국 메모리가 부족해지는 상황이 발생한다.</li>\n<li><strong>Major GC 발생</strong>: Old Generation이 가득 차게 되면 Major GC가 실행된다. 이 과정에서는 Old Generation 내의 모든 객체를 검사하고, Unreachable 객체를 한꺼번에 제거한다.</li>\n</ol>\n<h3 id=\"Minor-GC와-Major-GC-비교\" style=\"position:relative;\"><a href=\"#Minor-GC%EC%99%80-Major-GC-%EB%B9%84%EA%B5%90\" aria-label=\"Minor GC와 Major GC 비교 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Minor GC와 Major GC 비교</h3>\n<table>\n<thead>\n<tr>\n<th><strong>항목</strong></th>\n<th><strong>Minor GC</strong></th>\n<th><strong>Major GC (Full GC)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>대상 영역</strong></td>\n<td>Young Generation</td>\n<td>Old Generation</td>\n</tr>\n<tr>\n<td><strong>발생 빈도</strong></td>\n<td>빈번하게 발생</td>\n<td>드물게 발생</td>\n</tr>\n<tr>\n<td><strong>처리 속도</strong></td>\n<td>빠르다 (0.5~1초)</td>\n<td>상대적으로 느리다 (10배 이상 소요)</td>\n</tr>\n<tr>\n<td><strong>영향</strong></td>\n<td>애플리케이션 성능에 큰 영향 없음</td>\n<td>Stop-The-World 발생으로 성능 저하</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Major-GC의-특성과-문제점\" style=\"position:relative;\"><a href=\"#Major-GC%EC%9D%98-%ED%8A%B9%EC%84%B1%EA%B3%BC-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"Major GC의 특성과 문제점 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Major GC의 특성과 문제점</h3>\n<p>Major GC는 Old Generation의 메모리를 확보하기 위해 모든 객체를 검사하므로 Minor GC에 비해 처리 시간이 오래 걸린다.\n이 과정에서 애플리케이션의 모든 스레드가 정지하는 <strong>Stop-The-World</strong> 현상이 발생하며, CPU에 부하를 주고 애플리케이션이 일시적으로 멈추거나 느려지는 현상을 유발할 수 있다.\n이로 인해 Major GC는 실시간 성능이 중요한 애플리케이션에서 문제가 될 수 있다.</p>\n<p>현재도 Major GC로 인한 성능 저하를 줄이기 위해 다양한 알고리즘을 활용하여 GC의 처리 시간을 최소화하고, Stop-The-World 현상을 줄이는 방향으로 최적화 작업이 이루어지고 있다.\nJDK에서 제공하는 가비지 컬렉션 알고리즘의 종류와 각 버전에 따른 GC 방식의 변화에 대해 알아보고, 이를 통해 애플리케이션의 성능을 최적화할 수 있는 가비지 컬렉션 설정을 이해해보도록 하자.</p>\n<h1 id=\"JVM의-가비지-컬렉션-알고리즘-종류\" style=\"position:relative;\"><a href=\"#JVM%EC%9D%98-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A2%85%EB%A5%98\" aria-label=\"JVM의 가비지 컬렉션 알고리즘 종류 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>JVM의 가비지 컬렉션 알고리즘 종류</h1>\n<hr>\n<p>자바의 가비지 컬렉션(GC)은 메모리 관리 효율성을 극대화하고 애플리케이션 성능을 유지하기 위해 다양한 알고리즘을 제공하며, 각 알고리즘은 특정한 요구와 환경에 맞게 설계되었다. GC 알고리즘은 JVM 옵션을 통해 상황에 따라 설정할 수 있다. 다음은 주요 GC 알고리즘의 특징과 사용 방법에 대한 정리이다.</p>\n<h2 id=\"Serial-GC\" style=\"position:relative;\"><a href=\"#Serial-GC\" aria-label=\"Serial GC permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Serial GC</h2>\n<p>CPU 코어가 1개인 환경에서 적합하며, 일반적인 서버 환경에서는 잘 사용되지 않음.</p>\n<ul>\n<li>단일 스레드(Single Thread)로 동작하며 가장 단순한 GC.</li>\n<li><strong>Mark-Sweep</strong> 방식으로 Minor GC, <strong>Mark-Sweep-Compact</strong> 방식으로 Major GC 수행.</li>\n<li>Stop-The-World 시간이 가장 길며, 성능이 낮은 환경에서만 사용.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseSerialGC</span> <span class=\"token parameter variable\">-jar</span> Application.java</code></pre></div>\n<h2 id=\"Parallel-GC\" style=\"position:relative;\"><a href=\"#Parallel-GC\" aria-label=\"Parallel GC permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Parallel GC</h2>\n<p>기본적인 멀티 코어 CPU 환경에서 사용.</p>\n<ul>\n<li>Java 8의 기본 GC.</li>\n<li>Minor GC를 멀티 스레드로 처리하지만, Old Generation은 싱글 스레드로 처리.</li>\n<li>Serial GC 대비 Stop-The-World 시간이 줄어듦.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseParallelGC</span> <span class=\"token parameter variable\">-jar</span> Application.java\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:ParallelGCThreads</span><span class=\"token operator\">=</span>N <span class=\"token comment\"># 사용할 스레드 개수 지정</span></code></pre></div>\n<h2 id=\"Parallel-Old-GC\" style=\"position:relative;\"><a href=\"#Parallel-Old-GC\" aria-label=\"Parallel Old GC permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Parallel Old GC</h2>\n<p>멀티 코어 환경에서 Old Generation의 GC 성능이 중요한 경우 사용.</p>\n<ul>\n<li>Parallel GC의 개선 버전.</li>\n<li>Young Generation과 Old Generation 모두 멀티 스레드로 GC 수행.</li>\n<li>Mark-Summary-Compact 방식을 사용하여 효율성 증가.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseParallelOldGC</span> <span class=\"token parameter variable\">-jar</span> Application.java\n<span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:ParallelGCThreads</span><span class=\"token operator\">=</span>N</code></pre></div>\n<h2 id=\"CMS-GC-Concurrent-Mark-Sweep\" style=\"position:relative;\"><a href=\"#CMS-GC-Concurrent-Mark-Sweep\" aria-label=\"CMS GC Concurrent Mark Sweep permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>CMS GC (Concurrent Mark Sweep)</h2>\n<p>실시간 처리가 중요한 애플리케이션에서 사용되었으나 현재는 사용되지 않음.</p>\n<ul>\n<li>애플리케이션 스레드와 GC 스레드가 동시에 실행되어 Stop-The-World 시간을 줄임.</li>\n<li>GC 과정이 복잡하고 CPU 사용량이 높으며, 메모리 파편화 문제가 존재.</li>\n<li>Java 9에서 deprecated, Java 14에서 제거됨.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseConcMarkSweepGC</span> <span class=\"token parameter variable\">-jar</span> Application.java</code></pre></div>\n<h2 id=\"G1-GC-Garbage-First\" style=\"position:relative;\"><a href=\"#G1-GC-Garbage-First\" aria-label=\"G1 GC Garbage First permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>G1 GC (Garbage First)</h2>\n<p>힙 크기가 4GB 이상이며, 실시간 응답성이 중요한 애플리케이션에서 사용.</p>\n<ul>\n<li>CMS GC를 대체하기 위해 JDK 7에서 도입, Java 9부터 기본 GC.</li>\n<li>힙 메모리를 고정된 Young/Old 영역으로 나누지 않고 <strong>Region</strong>이라는 단위로 분할.</li>\n<li>메모리가 많이 사용된 Region을 우선적으로 수집하여 효율성 향상.</li>\n<li>Stop-The-World 시간이 짧고 예측 가능(0.5초).</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseG1GC</span> <span class=\"token parameter variable\">-jar</span> Application.java</code></pre></div>\n<h2 id=\"Shenandoah-GC\" style=\"position:relative;\"><a href=\"#Shenandoah-GC\" aria-label=\"Shenandoah GC permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Shenandoah GC</h2>\n<p>Pause 시간이 중요한 대규모 애플리케이션에서 적합.</p>\n<ul>\n<li>Java 12에서 도입, Red Hat에서 개발.</li>\n<li>강력한 동시성(Concurrency)으로 Stop-The-World 시간을 최소화.</li>\n<li>CMS의 단편화와 G1의 Pause 이슈를 해결한 GC.</li>\n<li>힙 크기에 관계없이 일정한 Pause 시간이 특징.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UseShenandoahGC</span> <span class=\"token parameter variable\">-jar</span> Application.java</code></pre></div>\n<h2 id=\"ZGC-Z-Garbage-Collector\" style=\"position:relative;\"><a href=\"#ZGC-Z-Garbage-Collector\" aria-label=\"ZGC Z Garbage Collector permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>ZGC (Z Garbage Collector)</h2>\n<p>매우 낮은 지연 시간과 대규모 메모리 관리가 필요한 애플리케이션에서 사용.</p>\n<ul>\n<li>Java 15에서 도입.</li>\n<li>대규모 메모리(8MB ~ 16TB)를 처리하며 Stop-The-World 시간이 10ms를 넘지 않음.</li>\n<li>힙 메모리를 <strong>ZPage</strong>라는 동적 크기의 영역으로 관리.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+UnlockExperimentalVMOptions</span> <span class=\"token parameter variable\">-XX:+UseZGC</span> <span class=\"token parameter variable\">-jar</span> Application.java</code></pre></div>\n<h2 id=\"GC-알고리즘-비교-요약\" style=\"position:relative;\"><a href=\"#GC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90-%EC%9A%94%EC%95%BD\" aria-label=\"GC 알고리즘 비교 요약 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>GC 알고리즘 비교 요약</h2>\n<table>\n<thead>\n<tr>\n<th><strong>알고리즘</strong></th>\n<th><strong>특징</strong></th>\n<th><strong>장점</strong></th>\n<th><strong>단점</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Serial GC</td>\n<td>단일 스레드, 가장 단순한 GC</td>\n<td>구현 간단, CPU가 낮은 환경에 적합</td>\n<td>Stop-The-World 시간이 길다</td>\n</tr>\n<tr>\n<td>Parallel GC</td>\n<td>Young 영역 멀티 스레드 처리</td>\n<td>성능 향상, Stop-The-World 감소</td>\n<td>Old Generation은 싱글 스레드 처리</td>\n</tr>\n<tr>\n<td>Parallel Old GC</td>\n<td>Old Generation도 멀티 스레드 처리</td>\n<td>더 나은 성능</td>\n<td>높은 CPU 사용량</td>\n</tr>\n<tr>\n<td>CMS GC</td>\n<td>동시 실행으로 Stop-The-World 최소화</td>\n<td>실시간 처리 적합</td>\n<td>복잡한 과정, 메모리 파편화 문제</td>\n</tr>\n<tr>\n<td>G1 GC</td>\n<td>Region 개념 도입, 메모리 효율성 증가</td>\n<td>낮은 지연 시간</td>\n<td>설정이 복잡할 수 있음</td>\n</tr>\n<tr>\n<td>Shenandoah GC</td>\n<td>매우 짧은 Pause 시간</td>\n<td>힙 크기와 상관없는 일정한 Pause</td>\n<td>최신 JVM에서만 사용 가능</td>\n</tr>\n<tr>\n<td>ZGC</td>\n<td>대규모 메모리와 낮은 지연 시간 처리</td>\n<td>Stop-The-World 시간 10ms 이하</td>\n<td>메모리 사용량이 많을 수 있음</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"GC-모니터링-및-메모리-문제\" style=\"position:relative;\"><a href=\"#GC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AC%B8%EC%A0%9C\" aria-label=\"GC 모니터링 및 메모리 문제 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>GC 모니터링 및 메모리 문제</h1>\n<p>GC는 JVM 메모리를 효율적으로 관리하기 위해 자동으로 수행되지만, 그 과정에서 예상치 못한 문제가 발생할 수 있다.\nGC가 과도하게 실행되면 CPU 사용량이 증가하고 메모리 자원이 부족해져 애플리케이션의 응답 시간이 길어질 수 있다.\n특히, 클라우드 환경이나 대규모 시스템에서는 리소스 관리가 중요한데, 이런 환경에서 GC가 적절히 작동하지 않으면 서비스 장애로 이어질 수 있다.\n이를 방지하기 위해 <strong>jstat</strong>, <strong>VisualVM</strong>, <strong>Prometheus+Grafana</strong> 같은 도구를 활용하여 GC와 메모리 사용 상태를 실시간으로 모니터링해야 한다.\n이를 통해 GC가 애플리케이션에 미치는 영향을 파악하고 적절한 조치를 취할 수 있다.</p>\n<h3 id=\"OutOfMemoryError와-대처-방안\" style=\"position:relative;\"><a href=\"#OutOfMemoryError%EC%99%80-%EB%8C%80%EC%B2%98-%EB%B0%A9%EC%95%88\" aria-label=\"OutOfMemoryError와 대처 방안 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a><strong>OutOfMemoryError와 대처 방안</strong></h3>\n<p>GC를 모니터링하던 중 <strong>OutOfMemoryError</strong>가 발생하는 경우, 이는 힙 메모리의 부족 또는 메모리 누수로 인해 발생할 가능성이 높다.\n이를 해결하려면 먼저 원인을 파악하는 것이 중요하다.\n**힙 덤프(Heap Dump)**를 생성한 뒤, **Eclipse MAT(Memory Analyzer Tool)**이나 <strong>VisualVM</strong> 같은 분석 도구를 활용해 메모리 누수 여부와 객체 참조 상태를 분석한다.</p>\n<ol>\n<li><strong>메모리 누수의 원인 파악</strong>: 메모리 누수가 원인인 경우, 불필요한 객체 참조가 제거되지 않은 코드를 찾아 수정해야 한다. 일반적인 원인으로는 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션에 남아 있는 객체 등이 있다.</li>\n<li><strong>힙 메모리 크기 조정</strong>: 애플리케이션 데이터 처리량이 메모리 크기를 초과하는 경우, JVM 옵션(<code class=\"language-text\">-Xmx</code>, <code class=\"language-text\">-Xms</code>)으로 힙 크기를 늘리고, 적합한 GC 알고리즘(G1 GC, ZGC 등)을 선택해 GC 튜닝을 수행한다.</li>\n<li><strong>추적과 예방</strong>: 애플리케이션 로깅 및 모니터링 체계를 구축해 메모리 사용량 추이를 관찰하고, OutOfMemoryError가 발생하기 전에 문제를 사전에 탐지하도록 한다.</li>\n</ol>\n<h3 id=\"메모리-누수-확인과-방지\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%ED%99%95%EC%9D%B8%EA%B3%BC-%EB%B0%A9%EC%A7%80\" aria-label=\"메모리 누수 확인과 방지 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a><strong>메모리 누수 확인과 방지</strong></h3>\n<p>메모리 누수는 GC가 제거하지 못하는 객체가 메모리를 지속적으로 점유하는 문제로, 힙 메모리를 고갈시킬 수 있다.\n이를 해결하려면 실행 중인 애플리케이션에서 <strong>힙 덤프</strong>를 생성한 후, <strong>객체 그래프</strong>를 분석하여 불필요하게 참조되고 있는 객체를 식별해야 한다.</p>\n<ul>\n<li><strong>분석 도구 활용</strong>: <strong>Eclipse MAT</strong>이나 <strong>VisualVM</strong>을 사용해 객체의 참조 체인을 추적하고 의도치 않게 유지되고 있는 객체를 찾아낸다.</li>\n<li><strong>실시간 모니터링</strong>: <strong>JConsole</strong>, <strong>jstat</strong>, 또는 <strong>APM(Application Performance Monitoring)</strong> 도구를 사용해 메모리 사용량 변화를 실시간으로 모니터링한다. 이를 통해 메모리 사용량이 지속적으로 증가하는 패턴을 확인할 수 있다.</li>\n<li><strong>일반적인 누수 원인 해결</strong>: 캐시 관리 실수, 이벤트 리스너 미해제, 전역 컬렉션 문제 등이 누수의 일반적인 원인이므로, 이러한 요소들을 면밀히 검토하여 코드 문제를 수정한다.</li>\n</ul>\n<blockquote>\n<p>추후 왜 STW(Stop-The-World)가 발생하는지 등에 대한 내용 추가할 예정이다.</p>\n</blockquote>","frontmatter":{"title":"가비지 컬렉션(Garbage Collection)","date":"November 24, 2024","update":null,"tags":["Java"],"series":null},"fields":{"slug":"/java-garbage-collection/","readingTime":{"minutes":30.345}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"9142cd48-5969-5dff-8b0a-1ca7f8164545","fields":{"slug":"/item-05/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"5e51d765-fc56-5fc0-9efb-93e8c323c43c","fields":{"slug":"/item-16/"},"frontmatter":{"title":"public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"b20a27d1-efe1-5df8-8fc6-70b1b621850d","fields":{"slug":"/item-15/"},"frontmatter":{"title":"클래스와 멤버의 접근 권한을 최소화하라"}}},{"node":{"id":"008bff3b-a610-5097-8737-2973f0ce221f","fields":{"slug":"/item-21/"},"frontmatter":{"title":"인터페이스는 구현하는 쪽을 생각해 설계하라"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"6a2593b4-90d6-5f17-a2b7-086a70b26ae1","fields":{"slug":"/database-compare-between-ssd-and-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"78d5ae48-9cb5-5099-8ecb-b3affdd38d6d","fields":{"slug":"/item-32/"},"frontmatter":{"title":"제네릭과 가변인수를 함께 쓸 때는 신중하라"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"날 것 그대로에서의 유연함을 얻어 허슬 플레이를 하다"}}}]},"previous":{"fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}},"next":{"fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},"pageContext":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","series":null,"previousPostId":"01f5976a-4e46-5969-ad10-603a8b529141","nextPostId":"389d424f-8a02-5fdb-8339-76124899e09c"}},"staticQueryHashes":[],"slicesMap":{}}