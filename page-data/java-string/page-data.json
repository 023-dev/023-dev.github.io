{"componentChunkName":"component---src-templates-post-jsx","path":"/java-string/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","excerpt":"String 자바에서 문자를 다루는 대표적인 타입은 와  이렇게 2가지가 있다.\n기본형인 는 문자 하나를 다루는데 사용되고, 를 사용해서 여러 문자 즉 문자열을 다루기 위해선 을 사용해야 한다.\n하지만 이렇게 을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 이라는 클래스를 제공한다. String 내부 구조  클래스는 대략 다음과 같은 구조로 이루…","html":"<h1 id=\"String\" style=\"position:relative;\"><a href=\"#String\" aria-label=\"String permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String</h1>\n<hr>\n<p>자바에서 문자를 다루는 대표적인 타입은 <code class=\"language-text\">char</code>와 <code class=\"language-text\">String</code> 이렇게 2가지가 있다.\n기본형인 <code class=\"language-text\">char</code>는 문자 하나를 다루는데 사용되고, <code class=\"language-text\">char</code>를 사용해서 여러 문자 즉 문자열을 다루기 위해선 <code class=\"language-text\">char[]</code>을 사용해야 한다.\n하지만 이렇게 <code class=\"language-text\">char[]</code>을 사용하면 문자열을 다루는데 불편함이 있어서 자바에서는 <code class=\"language-text\">String</code>이라는 클래스를 제공한다.</p>\n<h2 id=\"String-내부-구조\" style=\"position:relative;\"><a href=\"#String-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0\" aria-label=\"String 내부 구조 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String 내부 구조</h2>\n<p><code class=\"language-text\">String</code> 클래스는 대략 다음과 같은 구조로 이루어져 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span>\n    <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//자바 9이전</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">byte</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//자바 9이후</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> offset<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Default to 0</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클래스이므로 필드와 메소드로 구성되어 있다.</p>\n<h3 id=\"필드속성\" style=\"position:relative;\"><a href=\"#%ED%95%84%EB%93%9C%EC%86%8D%EC%84%B1\" aria-label=\"필드속성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>필드(속성)</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">String</code>은 <code class=\"language-text\">char</code>형 배열을 필드로 가지고 있고, 여기에는 <code class=\"language-text\">String</code>이 가지고 있는 실제 문자열을 저장하는 배열이다.\n이 말의 뜻은 문자 데이터 자체는 <code class=\"language-text\">char</code>형 배열에 저장되어 있고, <code class=\"language-text\">String</code> 객체는 이 배열을 참조하고 있다는 것이다.\n그러면 <code class=\"language-text\">char[]</code>가 불편해서 <code class=\"language-text\">String</code>을 사용하는 거 아닌가? 근데 <code class=\"language-text\">String</code>도 결국 <code class=\"language-text\">char[]</code>를 참조하고 있으니 똑같은 거 아닌가? 라는 의문이 들 수 있다.\n하지만 <code class=\"language-text\">String</code> 클래스는 <code class=\"language-text\">char[]</code>를 참조하고 있지만, 개발자가 직접 다루기 힘든 <code class=\"language-text\">char[]</code>를 내부에 숨겨놓고, <code class=\"language-text\">String</code> 클래스의 메소드를 통해 문자열을 다룰 수 있게 해준다.</p>\n<blockquote>\n<p>참고\n자바 9부터는 <code class=\"language-text\">String</code> 클래스 내부에 <code class=\"language-text\">byte[]</code>를 사용하는 방식으로 변경되었다.\n자바에서 문자 하나를 표현하는데 <code class=\"language-text\">char</code> 타입을 사용하면 <code class=\"language-text\">2byte</code>가 필요하다.\n여기서 영어, 숫자는 보통 <code class=\"language-text\">1byte</code>로 표현하고(정확히는 Latin-1 인코딩의 경우 1byte로 표현 가능),\n그렇지 않은 다른 언어는 <code class=\"language-text\">2byte</code>인 <code class=\"language-text\">UTF-16</code> 인코딩으로 표현해야 한다.\n때문에 <code class=\"language-text\">char</code> 타입을 사용하면 메모리 낭비가 발생할 수 있다.\n그래서 자바 9부터는 <code class=\"language-text\">byte[]</code>를 사용하여 문자열을 저장하고,\n<code class=\"language-text\">String</code> 클래스의 메소드를 통해 <code class=\"language-text\">byte[]</code>를 <code class=\"language-text\">char[]</code>로 변환하여 사용함으로써 메모리를 더 효율적으로 사용할 수 있게 되었다.</p>\n</blockquote>\n<h2 id=\"String은-클래스\" style=\"position:relative;\"><a href=\"#String%EC%9D%80-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"String은 클래스 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String은 클래스</h2>\n<p>자바에서 <code class=\"language-text\">String</code>은 위에 보다시피 클래스로 <code class=\"language-text\">int</code>,<code class=\"language-text\">char</code>와 달리 기본형(Primitive Type) 변수가 아닌 참조형(Reference Type) 변수로 분류 된다.\n참조형은 변수에 실제 값이 아닌 주소값을 가지고 있기에, 원칙적으로 <code class=\"language-text\">+</code>와 같은 연산을 할 수 없다.\n자바에서 <code class=\"language-text\">String</code>은 클래스이지만, 문자열을 다루기 쉽게 하기 위해 <code class=\"language-text\">+</code>연산자를 사용할 수 있게 오버로딩 되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> str1 <span class=\"token operator\">+</span> str2<span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// HelloWorld</span></code></pre></div>\n<p>또한 <code class=\"language-text\">String</code>는 참조형이므로 변수에 문자열을 대입하면 실제 문자열은 메모리의 힙(Heap) 영역에 생성되고, <code class=\"language-text\">String</code> 변수는 이 문자열을 참조하게 된다.</p>\n<h2 id=\"String은-불변Immutable\" style=\"position:relative;\"><a href=\"#String%EC%9D%80-%EB%B6%88%EB%B3%80Immutable\" aria-label=\"String은 불변Immutable permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String은 불변(Immutable)</h2>\n<p>기본적으로 자바에서는 <code class=\"language-text\">String</code>의 값을 변경할 수 없다.</p>\n<p><code class=\"language-text\">String</code>의 내부 구조를 위에서 보여줬듯이 <code class=\"language-text\">char[]</code> 혹은 <code class=\"language-text\">byte[]</code>를 가지고 있지만, 이 배열은 <code class=\"language-text\">final</code>로 선언되어 있어서 한 번 생성되면 변경할 수 없다.</p>\n<p>하지만 <code class=\"language-text\">String</code>의 값을 변경하는 것 처럼 보이는 연산을 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n\nstr <span class=\"token operator\">=</span> str <span class=\"token operator\">+</span> <span class=\"token string\">\" World\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello World</span></code></pre></div>\n<p>위의 코드를 보면 <code class=\"language-text\">str</code> 변수에 <code class=\"language-text\">Hello</code>라는 문자열을 대입하고, <code class=\"language-text\">str</code> 변수에 <code class=\"language-text\">World</code>라는 문자열을 더해서 다시 대입했다.\n이렇게 보면 <code class=\"language-text\">String</code>의 값을 변경한 것 처럼 보이지만, 실제로는 새로운 문자열 데이터 객체를 생성하고, 이를 <code class=\"language-text\">str</code> 변수가 참조하게 된다.</p>\n<p>즉, <code class=\"language-text\">String</code>은 불변(Immutable)하다는 것은 <strong>한 번 생성된 문자열은 변경할 수 없다는 것</strong>을 의미한다.</p>\n<p><code class=\"language-text\">hashCode()</code> 메소드를 이용해 실제로 변수가 가지고 있는 주소값을 찍어보면 알 수 있다.</p>\n<blockquote>\n<p><code class=\"language-text\">hashCode()</code> 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하는 메소드이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 69609650</span>\n\nstr <span class=\"token operator\">=</span> str <span class=\"token operator\">+</span> <span class=\"token string\">\" World\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// -862545276</span></code></pre></div>\n<p>똑같은 변수 str 의 해시코드(주소값)을 출력했음에도 <strong>가지고 있는 값이 바뀜에 따라 아예 주소값이 달라짐</strong>을 알 수 있다.\n즉, <strong>문자열 값 자체는 불변이라 변경할수 없기 때문에 새로운 문자열 데이터 객체를 대입하는 식으로 값을 대체 하기 때문에</strong> 이러한 현상이 생기는 것이다.</p>\n<h3 id=\"왜-불변으로-설계-되었는가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EB%B6%88%EB%B3%80%EC%9C%BC%EB%A1%9C-%EC%84%A4%EA%B3%84-%EB%90%98%EC%97%88%EB%8A%94%EA%B0%80\" aria-label=\"왜 불변으로 설계 되었는가 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>왜 불변으로 설계 되었는가?</h3>\n<p>이처럼 <code class=\"language-text\">String</code>이 불변적인 특성을 가지는 이유는 크게 3가지로 꼽을 수 있다.\n첫번째는 JVM(자바 가싱 머신) 에서는 따로 String Constant Pool 이라는 독립적인 영역을 만들고 문자열들을 Constant 화 하여 다른 변수 혹은 객체들과 공유하게 되는데, 이 과정에서 <strong>데이터 캐싱</strong>이 일어나고 그 만큼 성능적 이득을 취할 수 있기 때문이다.\n두번째는 데이터가 불변(immutable) 하다면 Multi-Thread 환경에서 동기화 문제가 발생하지 않기 때문에 더욱 safe 한 결과를 낼 수 있기 때문이다.\n세번째는 보안(Security) 적인 측면을 들 수 있다.\n예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데,\n만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.</p>\n<h3 id=\"불변인-String-클래스의-단점\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%9D%B8-String-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"불변인 String 클래스의 단점 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>불변인 String 클래스의 단점</h3>\n<p>하지만 불변(Immutable)한 <code class=\"language-text\">String</code> 클래스는 메모리 사용량이 많아지는 단점이 있다.\n불변인 <code class=\"language-text\">String</code> 클래스는 문자열을 변경할 때마다 새로운 문자열 객체를 생성해야 한다는 점이다.\n문자를 변경하는 상황이 자주 발생하는 상황이라면 <code class=\"language-text\">String</code> 객체를 만들고 GC가 빈번히 발생한다.\n결과적으로 CPU와 메모리를 많이 사용하게 되어 성능에 영향을 미칠 수 있다.\n그리고 문자열의 크기가 클수록, 문자열을 더 자주 변경할수록 이러한 단점이 더욱 부각된다.</p>\n<p>이러한 단점을 보완하기 위해 <code class=\"language-text\">StringBuffer</code>와 <code class=\"language-text\">StringBuilder</code> 클래스가 존재한다.\n<code class=\"language-text\">StringBuffer</code>와 <code class=\"language-text\">StringBuilder</code>는 <code class=\"language-text\">String</code>과 달리 가변적인 특성을 가지고 있어 문자열을 변경할 때 새로운 객체를 생성하지 않고 기존 객체를 변경한다.\n이러한 특성 때문에 문자열을 변경하는 작업이 많은 상황에서는 <code class=\"language-text\">StringBuffer</code>와 <code class=\"language-text\">StringBuilder</code>를 사용하는 것이 성능상 이점이 있다.</p>\n<p>자세한 내용은 <a href=\"https://023-dev.github.io/2024-11-05/java-string-stringbuffer-stringbuilder\">자바의 String, StringBuffer, StringBuilder 차이 알아보기</a>를 참고하자.</p>\n<h2 id=\"String의-주소-할당-방식\" style=\"position:relative;\"><a href=\"#String%EC%9D%98-%EC%A3%BC%EC%86%8C-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"String의 주소 할당 방식 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String의 주소 할당 방식</h2>\n<hr>\n<p>String을 통해 문자열을 생성하는 방법은 대표적으로 두가지 방식이 있다.</p>\n<ol>\n<li><code class=\"language-text\">String Literal</code>을 이용한 방식</li>\n<li><code class=\"language-text\">new String(\"\")</code>을 이용한 방식</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// String Literal</span>\n\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new String(\"\")</span></code></pre></div>\n<p>이 둘은 <code class=\"language-text\">\"Hello\"</code>라는 같은 문자열 값을 저장한지만, JVM 메모리 할당에서 차이가 존재한다.</p>\n<h3 id=\"String-Contstant-Pool\" style=\"position:relative;\"><a href=\"#String-Contstant-Pool\" aria-label=\"String Contstant Pool permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String Contstant Pool</h3>\n<p><code class=\"language-text\">String</code>의 주소 할당을 어떠한 방식으로 하는지에 따라 메모리에서 형태가 다르게 된다.</p>\n<p><code class=\"language-text\">String Literal</code>을 변수에 저장하게 되면 이 값은 <code class=\"language-text\">String Constant Pool</code>이라는 영역에 존재하게 되고, <code class=\"language-text\">new</code> 연산자를 통해 <code class=\"language-text\">String</code>을 생성하면 이 값은 <code class=\"language-text\">Heap</code> 영역에 존재하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 코드를 실행하면 문자열 리터럴 값으로 두 변수 <code class=\"language-text\">str1</code>, <code class=\"language-text\">str2</code>가 같은 메모리 주소를 가리킨다.</p>\n<p>그 이유는 <code class=\"language-text\">String</code>이 불변(immutable)하다는 특성 덕분에, 동일한 <code class=\"language-text\">String Literal</code>은 <code class=\"language-text\">String Constant Pool</code>이라는 메모리 영역에서 재사용되어 같은 문자열 가리킨다.</p>\n<p>이러한 이유로 <code class=\"language-text\">str1</code>과 <code class=\"language-text\">str2</code>는 동일한 메모리 주소를 참조하게 된다.</p>\n<p>정리하면, <code class=\"language-text\">String Constant Pool</code>은 동일한 문자열 리터럴을 캐싱하여 불필요한 객체 생성을 줄여 메모리를 사용을 최적화하고 성능을 향상시킨다.\n이러한 이유로 new String() 방식보다 문자열 리터럴 할당이 선호된다.</p>\n<blockquote>\n<p>참고\n풀(Pool)은 자원이 모여있는 곳을 의미한다.\n프로그래밍에서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻한다.\n여러 곳에서 함께 사용할 수 있는 객체를 필요할 때마다 생성하고, 제거하는 것은 비효율적이다.\n대신 이렇게 문자열 리터럴을 <code class=\"language-text\">String Constant Pool</code>에 저장해두고, 필요할 때마다 참조하는 방식으로 메모리를 효율적으로 사용할 수 있다.\n참고로 앞서 언급했듯이 <code class=\"language-text\">String Constant Pool</code>은 <code class=\"language-text\">Heap</code> 영역에 존재한다.\n그리고 <code class=\"language-text\">String Constant Pool</code>에서 문자열을 찾을 때는 해시 알고리즘을 사용하는데,\n이 떄문에 빠른 속도로 원하는 <code class=\"language-text\">String</code> 인스턴스를 찾을 수 있다.</p>\n</blockquote>\n<h2 id=\"String-비교\" style=\"position:relative;\"><a href=\"#String-%EB%B9%84%EA%B5%90\" aria-label=\"String 비교 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String 비교</h2>\n<p><code class=\"language-text\">String</code> 클래스를 비교할 때는 <code class=\"language-text\">==</code> 비교가 아니라 <code class=\"language-text\">equals()</code> 메소드를 사용해야 한다.</p>\n<ul>\n<li>동일성(Idnetity): <code class=\"language-text\">==</code> 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인.</li>\n<li>동등성(Equality): <code class=\"language-text\">equals()</code> 메소드를 사용해서 두 객체의 값이 같은지 확인.</li>\n</ul>\n<p>간단히 정리하자면 <code class=\"language-text\">==</code> 연산자와 <code class=\"language-text\">equals()</code> 메소드의 차이는 <code class=\"language-text\">주소값을 비교하냐</code>, <code class=\"language-text\">대상의 값 자체를 비교하냐</code>의 차이다.\n그래서 <code class=\"language-text\">String Literal</code>의 비교는 <code class=\"language-text\">==</code> 연산자를 사용해도 <code class=\"language-text\">String Constant Pool</code>에서 같은 객체 값을 참조하고 있기 때문에 주소값이 같아 <code class=\"language-text\">true</code>가 반환된다.</p>\n<p>하지만 <code class=\"language-text\">new Stirng(\"\")</code>의 비교는 힙 메모리에서 다른 주소 값을 참조하고 있어서 <code class=\"language-text\">==</code> 연산자를 사용하면 <code class=\"language-text\">false</code>가 반환된다. 따라서 <code class=\"language-text\">new Stirng(\"\")</code>은 주소 값이 아닌 그 안에 값 자체를 비교해야 하고 이 역할을 <code class=\"language-text\">equals()</code> 메소드가 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// String Literal</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new String(\"\")</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// String Literal 비교</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1 <span class=\"token operator\">==</span> str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// new String(\"\") 비교</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3 <span class=\"token operator\">==</span> str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// 리터럴과 객체 문자열 비교</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1 <span class=\"token operator\">==</span> str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<h2 id=\"String의-메소드\" style=\"position:relative;\"><a href=\"#String%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"String의 메소드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>String의 메소드</h2>\n<h3 id=\"문자열-정보-조회\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C\" aria-label=\"문자열 정보 조회 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문자열 정보 조회</h3>\n<ul>\n<li><code class=\"language-text\">length()</code>: 문자열의 길이를 반환한다.</li>\n<li><code class=\"language-text\">charAt(int index)</code>: 문자열의 특정 인덱스에 위치한 문자를 반환한다.</li>\n<li><code class=\"language-text\">isEmpty()</code>: 문자열이 비어있는지 확인한다.(길이가 0인 경우)</li>\n<li><code class=\"language-text\">isBlank()</code>: 문자열이 공백 문자로만 이루어져 있는지 확인한다.(길이가 0인 경우 || 공백(witespace)만 있는 경우), 자바 11부터 지원</li>\n</ul>\n<h3 id=\"문자열-비교\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B9%84%EA%B5%90\" aria-label=\"문자열 비교 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문자열 비교</h3>\n<ul>\n<li><code class=\"language-text\">equals(Object obj)</code>: 문자열이 주어진 객체와 동일한지 비교한다.</li>\n<li><code class=\"language-text\">equalsIgnoreCase(String str)</code>: 대소문자를 무시하고 문자열이 같은지 비교한다.</li>\n<li><code class=\"language-text\">compareTo(String str)</code>: 문자열을 사전 순으로 비교한다.</li>\n<li><code class=\"language-text\">compareToIgnoreCase(String str)</code>: 대소문자를 무시하고 문자열을 사전 순으로 비교한다.</li>\n<li><code class=\"language-text\">startsWith(String prefix)</code>: 문자열이 특정 문자열로 시작하는지 확인한다.</li>\n<li><code class=\"language-text\">endsWith(String suffix)</code>: 문자열이 특정 문자열로 끝나는지 확인한다.</li>\n</ul>\n<h3 id=\"문자열-검색\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89\" aria-label=\"문자열 검색 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문자열 검색</h3>\n<ul>\n<li><code class=\"language-text\">contains(CharSequence s)</code>: 문자열이 특정 문자열을 포함하는지 확인한다.</li>\n<li><code class=\"language-text\">indexOf(String str)</code>: 문자열에서 특정 문자열이 처음으로 등장하는 인덱스를 반환한다.</li>\n<li><code class=\"language-text\">lastIndexOf(String str)</code>: 문자열에서 특정 문자열이 마지막으로 등장하는 인덱스를 반환한다.</li>\n</ul>\n<h3 id=\"문자열-조작-및-변환\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A1%B0%EC%9E%91-%EB%B0%8F-%EB%B3%80%ED%99%98\" aria-label=\"문자열 조작 및 변환 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문자열 조작 및 변환</h3>\n<ul>\n<li><code class=\"language-text\">concat(String str)</code>: 문자열을 연결한다.</li>\n<li><code class=\"language-text\">substring(int beginIndex)</code>: 문자열의 특정 인덱스부터 끝까지의 부분 문자열을 반환한다.</li>\n<li><code class=\"language-text\">replace(CharSequence target, CharSequence replacement)</code>: 문자열에서 특정 문자열을 다른 문자열로 대체한다.</li>\n<li><code class=\"language-text\">replaceAll(String regex, String replacement)</code>: 문자열에서 특정 정규 표현식과 일치하는 문자열을 다른 문자열로 대체한다.</li>\n<li><code class=\"language-text\">replaceFirst(String regex, String replacement)</code>: 문자열에서 특정 정규 표현식과 일치하는 첫 번째 문자열을 다른 문자열로 대체한다.</li>\n<li><code class=\"language-text\">toLowerCase()</code>: 문자열을 소문자로 변환한다.</li>\n<li><code class=\"language-text\">toUpperCase()</code>: 문자열을 대문자로 변환한다.</li>\n<li><code class=\"language-text\">trim()</code>: 문자열의 앞뒤 공백을 제거한다.</li>\n<li><code class=\"language-text\">strip()</code>: 문자열의 앞뒤 공백을 제거한다. 자바 11부터 지원</li>\n</ul>\n<h3 id=\"문자열-분할-및-결합\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B6%84%ED%95%A0-%EB%B0%8F-%EA%B2%B0%ED%95%A9\" aria-label=\"문자열 분할 및 결합 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문자열 분할 및 결합</h3>\n<ul>\n<li><code class=\"language-text\">split(String regex)</code>: 문자열을 특정 정규 표현식을 기준으로 나누어 배열로 반환한다.</li>\n<li><code class=\"language-text\">join(CharSequence delimiter, CharSequence... elements)</code>: 문자열을 결합한다.</li>\n</ul>\n<h3 id=\"기타-유틸리티\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%ED%83%80-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0\" aria-label=\"기타 유틸리티 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>기타 유틸리티</h3>\n<ul>\n<li><code class=\"language-text\">format(String format, Object... args)</code>: 지정된 형식 문자열을 사용하여 문자열을 생성한다.</li>\n<li><code class=\"language-text\">valueOf(Object obj)</code>: 지정된 값을 문자열로 변환한다.</li>\n<li><code class=\"language-text\">toCharArray()</code>: 문자열을 문자 배열로 변환한다.</li>\n<li><code class=\"language-text\">matches(String regex)</code>: 문자열이 특정 정규 표현식과 일치하는지 확인한다.</li>\n</ul>\n<blockquote>\n<p>참고\n<code class=\"language-text\">CharSequence</code>는 <code class=\"language-text\">String</code>, <code class=\"language-text\">StringBuffer</code>, <code class=\"language-text\">StringBuilder</code> 클래스의 부모 인터페이스이다.\n문자열을 처리하는 다양한 클래스를 사용할 때, <code class=\"language-text\">CharSequence</code>를 사용하면 유연하게 문자열을 다룰 수 있다.</p>\n</blockquote>","frontmatter":{"title":"자바 문자열(String)","date":"November 05, 2024","update":null,"tags":["Java"],"series":null},"fields":{"slug":"/java-string/","readingTime":{"minutes":17.625}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"be250c05-5eed-50a2-835c-0f559f6dd229","fields":{"slug":"/effective-java-dependency-injection/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"날 것 그대로에서의 유연함을 얻어 허슬 플레이를 하다"}}}]},"previous":{"fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}},"next":{"fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},"pageContext":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","series":null,"previousPostId":"d9372afe-4014-5507-bcbd-e38e62b29471","nextPostId":"5964f927-8a79-5de0-841b-8fed223ba0f9"}},"staticQueryHashes":[],"slicesMap":{}}