{"componentChunkName":"component---src-templates-post-jsx","path":"/java-concurrenthashmap-synchronizedmap/","result":{"data":{"site":{"siteMetadata":{"title":"023.log"}},"markdownRemark":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","excerpt":"SynchronizedMap와 ConcurrentHashMap 과 은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다. SynchronizedMap 은  메소드를 통해 생성할 수 있…","html":"<h1 id=\"SynchronizedMap와-ConcurrentHashMap\" style=\"position:relative;\"><a href=\"#SynchronizedMap%EC%99%80-ConcurrentHashMap\" aria-label=\"SynchronizedMap와 ConcurrentHashMap permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>SynchronizedMap와 ConcurrentHashMap</h1>\n<p><code class=\"language-text\">SynchronizedMap</code>과 <code class=\"language-text\">ConcurrentHashMap</code>은 둘 다 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n이 글에서는 두 클래스의 차이점을 알아보고, 어떤 상황에서 어떤 클래스를 사용해야 하는지 알아보겠다.</p>\n<h2 id=\"SynchronizedMap\" style=\"position:relative;\"><a href=\"#SynchronizedMap\" aria-label=\"SynchronizedMap permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>SynchronizedMap</h2>\n<p><code class=\"language-text\">SynchronizedMap</code>은 <code class=\"language-text\">Collections.synchronizedMap()</code> 메소드를 통해 생성할 수 있다.\n이 클래스는 내부적으로 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 동기화를 제공한다.\n<code class=\"language-text\">Collections.synchronizedxxx</code>의 초기화 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">synchronizedMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>앞서 생성한 <code class=\"language-text\">HashMap</code>을 <code class=\"language-text\">Collections.synchronizedMap()</code> 메소드에 넘겨주면, 래핑 된 <code class=\"language-text\">SynchronizedMap</code>이 생성된다.\n하지만 이렇게 생성한 <code class=\"language-text\">SynchronizedMap</code>은 단순히 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 객체 레벨의 잠금을 제공하여 동기화를 제공하기 때문에,\nput 및 get 메소드 호출 시 동일한 작업을 수행하기 위해 락을 선점해야 한다.\n이처럼 컬렉션 전체에 대한 락을 사용하면 오버 헤드가 발생하며, 한 스레드가 맵을 수정하는 동안 다른 스레드는 대기해야 하는 과도한 락 문제가 발생할 수 있다.\n또한 이는 성능 저하를 야기할 수 있으며, <code class=\"language-text\">ConcurrentModificationException</code>이 발생할 수 있다.</p>\n<h2 id=\"ConcurrentHashMap\" style=\"position:relative;\"><a href=\"#ConcurrentHashMap\" aria-label=\"ConcurrentHashMap permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>ConcurrentHashMap</h2>\n<p><code class=\"language-text\">ConcurrentHashMap</code>은 <code class=\"language-text\">SynchronizedMap</code>과 달리 락을 사용하여 동기화를 제공하지 않는다.\n이 클래스는 <code class=\"language-text\">synchronized</code> 키워드를 사용하지 않고, 내부적으로 락을 사용하여 동기화를 제공한다.</p>\n<p><code class=\"language-text\">ConcurrentHashMap</code>은 다음과 같이 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">ConcurrentHashMap</code>은 <code class=\"language-text\">SynchronizedMap</code>과 달리 <code class=\"language-text\">synchronized</code> 키워드를 사용하지 않기 때문에, 객체 레벨의 락이 아닌 좀 더 세분화된\n버킷 레벨의 락을 사용하여 동기화를 제공한다.\n여기서 버킷 레벨의 락이란 맵의 각 버킷에 대해 락을 제공하는 것을 의미한다.\n배열, 연결 리스트 그리고 트리 등의 자료구조를 사용하여 버킷을 구성하며, 각 버킷은 독립적으로 락을 가지고 있다.\n보통 해시 충돌이 얼마나 발생하는지에 따라 버킷의 수가 결정되며, 해시 충돌이 많이 발생할수록 버킷의 수가 많아진다.\n또한 자료구조도 해시 충돌을 줄이기 위해 변경되는데 만약 해쉬 충돌이 적으면 배열과 연결 리스트를 사용하고, 해시 충돌이 많으면 Red-Black Tree를 사용한다.\n이를 통해 여러 스레드가 동시에 맵을 수정할 수 있으며, 더 많은 확정성을 지니게 된다.\n기본적으로 <code class=\"language-text\">ConcurrentHashMap</code>은 16개의 버킷을 가지고 있으며, 각 버킷은 독립적으로 락을 가지고 있다.\n이론적으로 봤을 때 16개의 버킷이 있기 때문에 16개의 스레드가 동시에 맵을 수정할 수 있다.\n필요하다면 <code class=\"language-text\">ConcurrentHashMap</code>의 크기를 늘릴 수 있으며, 이는 생성자에 전달할 수 있는 초기 용량을 조정하여 가능하다.</p>\n<h2 id=\"null-허용-여부\" style=\"position:relative;\"><a href=\"#null-%ED%97%88%EC%9A%A9-%EC%97%AC%EB%B6%80\" aria-label=\"null 허용 여부 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>null 허용 여부</h2>\n<p><code class=\"language-text\">SynchronizedMap</code>과 <code class=\"language-text\">ConcurrentHashMap</code>은 null 키와 null 값을 다른 방식으로 처리한다.\n기본적으로 <code class=\"language-text\">SynchronizedMap</code>은 null 키와 null 값을 모두 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> synchronizedMap <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">synchronizedMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsynchronizedMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null 키 허용</span>\nsynchronizedMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null 값 허용</span></code></pre></div>\n<p>하지만, <code class=\"language-text\">ConcurrentHashMap</code>은 null 키와 null 값을 모두 허용하지 않는다.\n따라서 <code class=\"language-text\">ConcurrentHashMap</code>을 사용할 때는 null 키와 null 값을 사용하지 않도록 주의해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> concurrentHashMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconcurrentHashMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null 키 불허</span>\nconcurrentHashMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null 값 불허</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>NullPointerException</span>\n    at java<span class=\"token punctuation\">.</span>base<span class=\"token operator\">/</span><span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span>ConcurrentHashMap</span><span class=\"token punctuation\">.</span><span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">1011</span><span class=\"token punctuation\">)</span>\n    at java<span class=\"token punctuation\">.</span>base<span class=\"token operator\">/</span><span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span>ConcurrentHashMap</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">1006</span><span class=\"token punctuation\">)</span>\n    at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>demo<span class=\"token punctuation\">.</span></span>DemoApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DemoApplication</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>그래도 <code class=\"language-text\">ConcurrentHashMap</code>을 사용하고 싶은데 null 키와 null 값을 사용해야 하는 경우에는,\n<code class=\"language-text\">ConcurrentHashMap</code> 대신 <code class=\"language-text\">ConcurrentHashMap</code>을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"null key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"null value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">SynchronizedMap</code>과 <code class=\"language-text\">ConcurrentHashMap</code>은 멀티 스레드 환경에서 사용할 수 있는 Map 구현체이다.\n하지만 두 클래스는 서로 다른 방식으로 동기화를 제공한다.\n<code class=\"language-text\">SynchronizedMap</code>은 <code class=\"language-text\">synchronized</code> 키워드를 사용하여 객체 레벨의 락을 제공하며, <code class=\"language-text\">ConcurrentHashMap</code>은 버킷 레벨의 락을 사용하여 동기화를 제공한다.\n따라서 <code class=\"language-text\">ConcurrentHashMap</code>이 <code class=\"language-text\">SynchronizedMap</code>보다 더 좋은 성능을 제공한다.\n또한 <code class=\"language-text\">ConcurrentHashMap</code>은 null 키와 null 값을 허용하지 않는다.\n따라서 null 키와 null 값을 사용해야 하는 경우에는 <code class=\"language-text\">ConcurrentHashMap</code>을 사용할 수 없다.\n이러한 경우에는 <code class=\"language-text\">ConcurrentHashMap</code>을 상속받아 null 키와 null 값을 허용하는 클래스를 만들어 사용할 수 있다.</p>","frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap","date":"November 22, 2024","update":null,"tags":["Java"],"series":null},"fields":{"slug":"/java-concurrenthashmap-synchronizedmap/","readingTime":{"minutes":6.28}}},"seriesList":{"edges":[{"node":{"id":"fc065a5d-53ab-5dd6-9dc4-b127396ed80f","fields":{"slug":"/java-lambda-stream/"},"frontmatter":{"title":"자바 람다(Lambda)와 스트림(Stream)"}}},{"node":{"id":"64c66682-ed51-5379-89ee-2f70d12e2b57","fields":{"slug":"/java-exception-error/"},"frontmatter":{"title":"자바 에러(Error)와 예외처리(Exception)"}}},{"node":{"id":"454be74c-98b2-50d6-b615-f4263c00d08c","fields":{"slug":"/java-generic/"},"frontmatter":{"title":"자바 제네릭(Generics)"}}},{"node":{"id":"d9372afe-4014-5507-bcbd-e38e62b29471","fields":{"slug":"/java-systemout-log/"},"frontmatter":{"title":"System.out.println()를 사용한 로깅을 피해야 하는 이유"}}},{"node":{"id":"825cb64a-cf12-5e2e-b87c-df8b6cb230ff","fields":{"slug":"/java-try-catch/"},"frontmatter":{"title":"자바 예외 처리하기(Exception Handling)"}}},{"node":{"id":"5964f927-8a79-5de0-841b-8fed223ba0f9","fields":{"slug":"/java-string-stringbuffer-stringbuilder/"},"frontmatter":{"title":"String과 StringBuffer 그리고 StringBuilder"}}},{"node":{"id":"005e9485-4c2c-5c35-b905-d3ed1b9e798f","fields":{"slug":"/java-reflection/"},"frontmatter":{"title":"자바 리플렉션(Reflection)"}}},{"node":{"id":"7aa8046a-802e-536c-b5f9-e78ad5517c2f","fields":{"slug":"/java-string/"},"frontmatter":{"title":"자바 문자열(String)"}}},{"node":{"id":"133813fe-ca42-5aa4-841f-f6bf4141d1d3","fields":{"slug":"/java-throw-chained-exception/"},"frontmatter":{"title":"throw와 throws 그리고 Chained Exception"}}},{"node":{"id":"098b32ab-5cc8-5f3a-b9ce-06c252ec53e7","fields":{"slug":"/java-thread/"},"frontmatter":{"title":"프로세스(Process)와 스레드(Thread)"}}},{"node":{"id":"4225fe9e-27ba-5b63-b8b6-7093b3c971e7","fields":{"slug":"/java-collection-framework/"},"frontmatter":{"title":"자바 컬렉션 프레임워크(Collection Framework)"}}},{"node":{"id":"ac99cdaa-53ef-5270-b59e-c63ad05b0ba3","fields":{"slug":"/java-atomic/"},"frontmatter":{"title":"멀티 스레드 환경에서 동시성 프로그래밍"}}},{"node":{"id":"990727b3-c221-5882-9668-c35326197a0b","fields":{"slug":"/java-arraylist/"},"frontmatter":{"title":"ArrayList 컬렉션"}}},{"node":{"id":"25229769-0008-5747-b590-dbc1023da764","fields":{"slug":"/java-hashmap/"},"frontmatter":{"title":"HashMap 컬렉션"}}},{"node":{"id":"a5d8aab9-4761-54fb-8033-e3e5428162ee","fields":{"slug":"/java-multi-thread/"},"frontmatter":{"title":"자바 멀티 스레딩"}}},{"node":{"id":"10e407f2-9715-504c-a60f-29a3b4cb67df","fields":{"slug":"/java-cas-aba/"},"frontmatter":{"title":"CAS(Compare-And-Swap)와 ABA 문제"}}},{"node":{"id":"9c443690-789a-5153-a234-67772da4ff2d","fields":{"slug":"/java-vector-hashtable-synchronizedxxx/"},"frontmatter":{"title":"Vector와 Hashtable 그리고 Collections.SynchronizedXXX"}}},{"node":{"id":"a642a0b6-afce-5363-a262-bccfb0f2ef20","fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}}},{"node":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","fields":{"slug":"/java-concurrenthashmap-synchronizedmap/"},"frontmatter":{"title":"SynchronizedMap vs ConcurrentHashMap"}}},{"node":{"id":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7","fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},{"node":{"id":"389d424f-8a02-5fdb-8339-76124899e09c","fields":{"slug":"/java-virtual-machine/"},"frontmatter":{"title":"자바 가상 머신(Java Virtual Machine)"}}},{"node":{"id":"af409114-6f24-5568-8d8c-1553078dd692","fields":{"slug":"/java-object/"},"frontmatter":{"title":"자바 Object 클래스"}}},{"node":{"id":"e956dc3c-ab5a-5788-ab9d-e6932f21b1cd","fields":{"slug":"/java-identity-equality/"},"frontmatter":{"title":"동일성(Identity)와 동등성(Equality)"}}},{"node":{"id":"09fe0da4-1757-5eb6-90d4-18b4ba1d5d9e","fields":{"slug":"/java-primitive-reference/"},"frontmatter":{"title":"기본형(Primitive)과 참조형(Reference)"}}},{"node":{"id":"6df7f449-35cb-5e68-8d5d-80799a314831","fields":{"slug":"/database-phantom-read/"},"frontmatter":{"title":"Phantom Read와 Gap Lock, Next-Key Lock"}}},{"node":{"id":"d4156b41-43d2-511a-90b3-af9d47d4739d","fields":{"slug":"/database-dbms/"},"frontmatter":{"title":"데이터베이스 관리 시스템(DBMS)"}}},{"node":{"id":"39296236-cab8-5f64-9c3a-4216b3db11c5","fields":{"slug":"/java-immutable/"},"frontmatter":{"title":"불변 객체(Immutable Object)"}}},{"node":{"id":"3d4ae372-9791-5064-b476-2d3aca08f12e","fields":{"slug":"/java-string-optimization/"},"frontmatter":{"title":"문자열 최적화(String Optimization)"}}},{"node":{"id":"fa45f65c-d108-57f6-a1c2-e36ed09a23b2","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"title":"래퍼 클래스(Wrapper Class)"}}},{"node":{"id":"535b9757-cd58-551a-bfe8-3657aa82ea9e","fields":{"slug":"/java-class-system/"},"frontmatter":{"title":"자바 Class 클래스와 System 클래스"}}},{"node":{"id":"8d757819-398e-5dd2-89a2-58e6bba8a704","fields":{"slug":"/java-enum/"},"frontmatter":{"title":"자바 열거형 타입(Type-Safe Enum Pattern)"}}},{"node":{"id":"9142cd48-5969-5dff-8b0a-1ca7f8164545","fields":{"slug":"/item-05/"},"frontmatter":{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"7ea4d566-e53f-515a-bd42-7b1298d7d6f9","fields":{"slug":"/database-data-independency/"},"frontmatter":{"title":"데이터 독립성(Data Independence)"}}},{"node":{"id":"a395659b-15d8-5494-b9ab-f10f367bd55c","fields":{"slug":"/database-rdbms/"},"frontmatter":{"title":"관계형 데이터베이스 관리 시스템(RDBMS)"}}},{"node":{"id":"2f78f287-e52a-5403-8b0e-45e8406b20f8","fields":{"slug":"/database-sql/"},"frontmatter":{"title":"SQL(Structured Query Language)"}}},{"node":{"id":"5e51d765-fc56-5fc0-9efb-93e8c323c43c","fields":{"slug":"/item-16/"},"frontmatter":{"title":"public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라"}}},{"node":{"id":"b933390c-7e98-5e83-8e61-6510f9c37a4a","fields":{"slug":"/database-architecture-caching-strategy/"},"frontmatter":{"title":"캐싱 전략(Caching Strategy)"}}},{"node":{"id":"2f2d4165-e533-5227-83dc-c78a353a5843","fields":{"slug":"/database-constraints/"},"frontmatter":{"title":"제약 조건(Constraints)"}}},{"node":{"id":"fb5cb17b-0afd-54ed-9d15-7d39a0a1e6d8","fields":{"slug":"/mysql-delete-truncate-drop/"},"frontmatter":{"title":"MySQL의 DELETE, TRUNCATE, DROP 차이"}}},{"node":{"id":"ddc7aadd-c2b4-537e-86ef-5da0a0f987ce","fields":{"slug":"/mysql-limit-offset/"},"frontmatter":{"title":"MySQL의 Pagination"}}},{"node":{"id":"afdb871b-8a87-545a-b3d3-dcbb36454b18","fields":{"slug":"/boj-2776/"},"frontmatter":{"title":"2776 암기왕"}}},{"node":{"id":"c3de373e-9923-51bb-81bf-7e7b8acb3f9c","fields":{"slug":"/boj-1654/"},"frontmatter":{"title":"1654 랜선 자르기"}}},{"node":{"id":"d79c2dea-56e4-5f4e-ba34-3cb949e9c362","fields":{"slug":"/boj-2512/"},"frontmatter":{"title":"2512 예산"}}},{"node":{"id":"51225c19-1cf3-5058-8943-dc41bc0eac90","fields":{"slug":"/boj-11663/"},"frontmatter":{"title":"11663 선분 위의 점"}}},{"node":{"id":"b20a27d1-efe1-5df8-8fc6-70b1b621850d","fields":{"slug":"/item-15/"},"frontmatter":{"title":"클래스와 멤버의 접근 권한을 최소화하라"}}},{"node":{"id":"008bff3b-a610-5097-8737-2973f0ce221f","fields":{"slug":"/item-21/"},"frontmatter":{"title":"인터페이스는 구현하는 쪽을 생각해 설계하라"}}},{"node":{"id":"c553b71b-99ee-54e4-99c1-28158b54878a","fields":{"slug":"/database-storage-and-random-sequantial-io/"},"frontmatter":{"title":"저장 매체와 랜덤 I/O, 순차 I/O"}}},{"node":{"id":"287deadf-40de-5a3a-9545-342fd478f804","fields":{"slug":"/database-index/"},"frontmatter":{"title":"인덱스(Index)"}}},{"node":{"id":"ff01aabc-69b7-5efa-b11e-9b2c2c6007ff","fields":{"slug":"/database-explain-query-hint/"},"frontmatter":{"title":"실행 계획과 쿼리 최적화"}}},{"node":{"id":"879a45c4-b438-5e30-b986-6a4fbcf179c3","fields":{"slug":"/boj-2805/"},"frontmatter":{"title":"2805 나무 자르기"}}},{"node":{"id":"5172cb65-97e3-52f1-a2ef-51935d94c748","fields":{"slug":"/boj-2343/"},"frontmatter":{"title":"2343 기타 레슨"}}},{"node":{"id":"6a2593b4-90d6-5f17-a2b7-086a70b26ae1","fields":{"slug":"/database-compare-between-ssd-and-hdd/"},"frontmatter":{"title":"SSD를 사용하면 DBMS가 빨라질까?"}}},{"node":{"id":"b8479007-2406-5b98-a027-2437a5c27be6","fields":{"slug":"/boj-2470/"},"frontmatter":{"title":"2470 두 용액"}}},{"node":{"id":"0192b957-d4c7-5ef9-bb0d-bd44452e72ad","fields":{"slug":"/boj-2110/"},"frontmatter":{"title":"2110 공유기 설치"}}},{"node":{"id":"2840da70-822e-5706-bd49-bcef59e88efd","fields":{"slug":"/boj-1260/"},"frontmatter":{"title":"1260 DFS와 BFS"}}},{"node":{"id":"c58dd773-ac71-5951-8381-989f6a01b642","fields":{"slug":"/prog-immigration/"},"frontmatter":{"title":"프로그래머스 입국심사"}}},{"node":{"id":"c37121f6-1974-5663-94a2-f840c17b21cb","fields":{"slug":"/boj-3079/"},"frontmatter":{"title":"3079 입국심사"}}},{"node":{"id":"8f131117-8e43-550c-a9c2-f426134f7559","fields":{"slug":"/boj-1697/"},"frontmatter":{"title":"1697 숨바꼭질"}}},{"node":{"id":"5e43441d-65a2-5400-aa7e-08adda263e4a","fields":{"slug":"/boj-2667/"},"frontmatter":{"title":"2667 단지번호붙이기"}}},{"node":{"id":"5323ab88-9e67-5d24-bb72-ad4c2137a0ea","fields":{"slug":"/datavase-normalization/"},"frontmatter":{"title":"데이터베이스 정규화(Normalization)"}}},{"node":{"id":"78d5ae48-9cb5-5099-8ecb-b3affdd38d6d","fields":{"slug":"/item-32/"},"frontmatter":{"title":"제네릭과 가변인수를 함께 쓸 때는 신중하라"}}},{"node":{"id":"fd4f64da-5d81-5f7a-9375-5118fd1b6c47","fields":{"slug":"/boj-1707/"},"frontmatter":{"title":"1707 이분 그래프"}}},{"node":{"id":"49a050bd-e29b-5ad5-a873-ad7900d76bbc","fields":{"slug":"/boj-2573/"},"frontmatter":{"title":"2573 빙산"}}},{"node":{"id":"7d0e1c93-56d9-556d-8ed7-7920e7470762","fields":{"slug":"/boj-12425/"},"frontmatter":{"title":"12425 윷놀이 (Small)"}}},{"node":{"id":"ef88654c-22d3-5af6-b232-ac40429fadd5","fields":{"slug":"/database-index-sql/"},"frontmatter":{"title":"인덱스만 사용하면 성능이 향상될까?"}}},{"node":{"id":"16e09090-cb18-56b9-a597-f8b7b472358e","fields":{"slug":"/database-transaction-recovery/"},"frontmatter":{"title":"DB 트랜잭션, 회복"}}},{"node":{"id":"7062e173-15fc-579c-9637-8d4985247b51","fields":{"slug":"/item-34/"},"frontmatter":{"title":"int 상수 대신 열거 타입을 사용하라"}}},{"node":{"id":"8371ee7e-c8e5-5d9e-9d38-b9b2746109f4","fields":{"slug":"/item-41/"},"frontmatter":{"title":"정의하려는 것이 타입이라면 마커 인터페이스를 사용하라"}}},{"node":{"id":"dd51ec8d-5b49-5e04-94a6-55568bb010b7","fields":{"slug":"/about/"},"frontmatter":{"title":"Hustle Coder"}}}]},"previous":{"fields":{"slug":"/java-synchroniedlist-copyonwritearraylist/"},"frontmatter":{"title":"SynchronizedList와 CopyOnWriteArrayList의 차이"}},"next":{"fields":{"slug":"/java-garbage-collection/"},"frontmatter":{"title":"가비지 컬렉션(Garbage Collection)"}}},"pageContext":{"id":"01f5976a-4e46-5969-ad10-603a8b529141","series":null,"previousPostId":"a642a0b6-afce-5363-a262-bccfb0f2ef20","nextPostId":"479b1b49-88d0-53dd-b25f-7b05a6d4acd7"}},"staticQueryHashes":[],"slicesMap":{}}